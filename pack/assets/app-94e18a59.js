var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a2;
import { defineAsyncComponent, readonly, ref, reactive, defineComponent, onMounted, computed, h as h$5, inject, resolveComponent, unref, openBlock, createElementBlock, normalizeStyle, createElementVNode, createVNode, createCommentVNode, toRefs, watch, getCurrentScope, onScopeDispose, getCurrentInstance, nextTick, isRef, shallowRef, watchEffect, customRef, onUnmounted, toDisplayString, Fragment, renderList, normalizeClass, createBlock, pushScopeId, popScopeId, createTextVNode, withCtx, withDirectives, vModelText, Transition, onBeforeUnmount, vModelCheckbox, vShow, provide, onUpdated, renderSlot, useSlots, resolveDynamicComponent, onBeforeUpdate, mergeProps, toRef, camelize, capitalize, withModifiers, TransitionGroup, onBeforeMount, render, createApp, shallowReactive, effectScope, toRaw, useCssVars, normalizeProps, guardReactiveProps, Teleport, withScopeId, withKeys, createSSRApp } from "vue";
import katex$1 from "katex";
import { useRouter, useRoute, RouterView, createRouter, START_LOCATION, createWebHistory } from "vue-router";
import * as icons from "@vicons/carbon";
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i3 = links.length - 1; i3 >= 0; i3--) {
        const link2 = links[i3];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err2) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err2;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err2;
    }
  });
};
const pagesData$1 = {
  // path: /timeline/
  "v-01560935": () => __vitePreload(() => import(
    /* webpackChunkName: "v-01560935" */
    "./index.html-d7b3fa74.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /posts/
  "v-e1e3da16": () => __vitePreload(() => import(
    /* webpackChunkName: "v-e1e3da16" */
    "./index.html-7ef429f3.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /friendship-link/
  "v-53355ebb": () => __vitePreload(() => import(
    /* webpackChunkName: "v-53355ebb" */
    "./index.html-652c3680.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /posts/1/
  "v-03d52fd3": () => __vitePreload(() => import(
    /* webpackChunkName: "v-03d52fd3" */
    "./index.html-2f34d830.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /
  "v-8daa1a0e": () => __vitePreload(() => import(
    /* webpackChunkName: "v-8daa1a0e" */
    "./index.html-f8d54bfe.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/
  "v-33291fb2": () => __vitePreload(() => import(
    /* webpackChunkName: "v-33291fb2" */
    "./index.html-ae9564c1.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /blogs/blogtest.html
  "v-71cbb60e": () => __vitePreload(() => import(
    /* webpackChunkName: "v-71cbb60e" */
    "./blogtest.html-2d094e09.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /blogs/shuoshuotest.html
  "v-4cab04d2": () => __vitePreload(() => import(
    /* webpackChunkName: "v-4cab04d2" */
    "./shuoshuotest.html-fabe9378.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/test_album_1/psb.png.html
  "v-926a34b0": () => __vitePreload(() => import(
    /* webpackChunkName: "v-926a34b0" */
    "./psb.png.html-b76aff71.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/test_album_1/
  "v-1f71f6ee": () => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6ee" */
    "./index.html-389fb609.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/test_album_2/
  "v-1f71f6b0": () => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6b0" */
    "./index.html-1f60d8a5.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/tech/flowers.html
  "v-1d051c9f": () => __vitePreload(() => import(
    /* webpackChunkName: "v-1d051c9f" */
    "./flowers.html-ef35759e.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/tech/homebg.html
  "v-dc8a1012": () => __vitePreload(() => import(
    /* webpackChunkName: "v-dc8a1012" */
    "./homebg.html-9b8ad34d.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/test/articletest.html
  "v-06ec5813": () => __vitePreload(() => import(
    /* webpackChunkName: "v-06ec5813" */
    "./articletest.html-e1fc6420.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/test/mdtest.html
  "v-23390c64": () => __vitePreload(() => import(
    /* webpackChunkName: "v-23390c64" */
    "./mdtest.html-85e31ac4.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /404.html
  "v-3706649a": () => __vitePreload(() => import(
    /* webpackChunkName: "v-3706649a" */
    "./404.html-7e543c16.js"
  ), true ? [] : void 0).then(({
    data
  }) => data)
};
const siteData$3 = JSON.parse('{"base":"/","lang":"zh-CN","title":"八桂世界的歌姬","description":"还在调试中","head":[],"locales":{},"pageIdMap":{"albums":{"id":"albums","key":"v-33291fb2","path":"/albums/","title":"画册","frontmatter":{"id":"albums","title":"画册","layout":"Album"}},"blog_1":{"id":"blog_1","key":"v-71cbb60e","path":"/blogs/blogtest.html","title":"音乐播放器测试","frontmatter":{"id":"blog_1","title":"音乐播放器测试","date":"2023-09-08T00:00:00.000Z"}},"blog-2023-09-08_1":{"id":"blog-2023-09-08_1","key":"v-4cab04d2","path":"/blogs/shuoshuotest.html","title":"9月8日","frontmatter":{"id":"blog-2023-09-08_1","title":"9月8日","date":"2023-09-08T00:00:00.000Z"}},"test_album_1:psb.png":{"id":"test_album_1:psb.png","key":"v-926a34b0","path":"/albums/test_album_1/psb.png.html","title":"梯田","frontmatter":{"id":"test_album_1:psb.png","title":"梯田","description":"这是一张梯田的画"}},"test_album_2":{"id":"test_album_2","key":"v-1f71f6b0","path":"/albums/test_album_2/","title":"测试相册2","frontmatter":{"id":"test_album_2","title":"测试相册2","description":"这是对测试相册2的描述","layout":"Album","cover":"MY55-4.png"}},"test_album_1":{"id":"test_album_1","key":"v-1f71f6ee","path":"/albums/test_album_1/","title":"测试相册1","frontmatter":{"id":"test_album_1","title":"测试相册1","description":"这是对测试相册1的描述","layout":"Album","cover":"MY52-2.png"}},"docs_tech_flowers":{"id":"docs_tech_flowers","key":"v-1d051c9f","path":"/docs/tech/flowers.html","title":"前端实现 - 木棉花落","frontmatter":{"id":"docs_tech_flowers","title":"前端实现 - 木棉花落","date":"2023-09-16T00:00:00.000Z"}},"docs_tech_homebg":{"id":"docs_tech_homebg","key":"v-dc8a1012","path":"/docs/tech/homebg.html","title":"前端实现 - 分层背景","frontmatter":{"id":"docs_tech_homebg","title":"前端实现 - 分层背景","date":"2023-09-13T00:00:00.000Z"}},"docs_test_2":{"id":"docs_test_2","key":"v-06ec5813","path":"/docs/test/articletest.html","title":"文章测试","frontmatter":{"id":"docs_test_2","title":"文章测试","date":"2023-09-08T00:00:00.000Z"}},"docs_test_1":{"id":"docs_test_1","key":"v-23390c64","path":"/docs/test/mdtest.html","title":"markdown测试","frontmatter":{"id":"docs_test_1","title":"markdown测试","date":"2023-09-08T16:18:00.000Z"}}}}');
const isArray$1 = Array.isArray;
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
var resolveHeadIdentifier = ([tag, attrs, content]) => {
  if (tag === "meta" && attrs.name) {
    return `${tag}.${attrs.name}`;
  }
  if (["title", "base"].includes(tag)) {
    return tag;
  }
  if (tag === "template" && attrs.id) {
    return `${tag}.${attrs.id}`;
  }
  return JSON.stringify([tag, attrs, content]);
};
var dedupeHead = (head) => {
  const identifierSet = /* @__PURE__ */ new Set();
  const result = [];
  head.forEach((item) => {
    const identifier = resolveHeadIdentifier(item);
    if (!identifierSet.has(identifier)) {
      identifierSet.add(identifier);
      result.push(item);
    }
  });
  return result;
};
var isLinkFtp = (link) => link.startsWith("ftp://");
var isLinkHttp$1 = (link) => /^(https?:)?\/\//.test(link);
var markdownLinkRegexp = /.md((\?|#).*)?$/;
var isLinkExternal = (link, base = "/") => {
  if (isLinkHttp$1(link) || isLinkFtp(link)) {
    return true;
  }
  if (link.startsWith("/") && !link.startsWith(base) && !markdownLinkRegexp.test(link)) {
    return true;
  }
  return false;
};
var isLinkMailto = (link) => /^mailto:/.test(link);
var isLinkTel = (link) => /^tel:/.test(link);
var isPlainObject$1 = (val) => Object.prototype.toString.call(val) === "[object Object]";
var removeEndingSlash = (str) => str[str.length - 1] === "/" ? str.slice(0, -1) : str;
var removeLeadingSlash = (str) => str[0] === "/" ? str.slice(1) : str;
var resolveLocalePath = (locales2, routePath) => {
  const localePaths = Object.keys(locales2).sort((a2, b2) => {
    const levelDelta = b2.split("/").length - a2.split("/").length;
    if (levelDelta !== 0) {
      return levelDelta;
    }
    return b2.length - a2.length;
  });
  for (const localePath of localePaths) {
    if (routePath.startsWith(localePath)) {
      return localePath;
    }
  }
  return "/";
};
const pagesComponents = {
  // path: /timeline/
  "v-01560935": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-01560935" */
    "./index.html-96eed0b5.js"
  ), true ? [] : void 0)),
  // path: /posts/
  "v-e1e3da16": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-e1e3da16" */
    "./index.html-5d909422.js"
  ), true ? [] : void 0)),
  // path: /friendship-link/
  "v-53355ebb": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-53355ebb" */
    "./index.html-4323d8f0.js"
  ), true ? [] : void 0)),
  // path: /posts/1/
  "v-03d52fd3": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-03d52fd3" */
    "./index.html-67034a25.js"
  ), true ? [] : void 0)),
  // path: /
  "v-8daa1a0e": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-8daa1a0e" */
    "./index.html-1d7344b7.js"
  ), true ? [] : void 0)),
  // path: /albums/
  "v-33291fb2": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-33291fb2" */
    "./index.html-ca589da1.js"
  ), true ? [] : void 0)),
  // path: /blogs/blogtest.html
  "v-71cbb60e": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-71cbb60e" */
    "./blogtest.html-6aa3ae2b.js"
  ), true ? [] : void 0)),
  // path: /blogs/shuoshuotest.html
  "v-4cab04d2": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-4cab04d2" */
    "./shuoshuotest.html-1b59256f.js"
  ), true ? [] : void 0)),
  // path: /albums/test_album_1/psb.png.html
  "v-926a34b0": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-926a34b0" */
    "./psb.png.html-e409f01c.js"
  ), true ? [] : void 0)),
  // path: /albums/test_album_1/
  "v-1f71f6ee": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6ee" */
    "./index.html-c9945efd.js"
  ), true ? [] : void 0)),
  // path: /albums/test_album_2/
  "v-1f71f6b0": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6b0" */
    "./index.html-396487c3.js"
  ), true ? [] : void 0)),
  // path: /docs/tech/flowers.html
  "v-1d051c9f": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-1d051c9f" */
    "./flowers.html-d4c5a67e.js"
  ), true ? [] : void 0)),
  // path: /docs/tech/homebg.html
  "v-dc8a1012": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-dc8a1012" */
    "./homebg.html-56707fa3.js"
  ), true ? [] : void 0)),
  // path: /docs/test/articletest.html
  "v-06ec5813": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-06ec5813" */
    "./articletest.html-881d67b9.js"
  ), true ? [] : void 0)),
  // path: /docs/test/mdtest.html
  "v-23390c64": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-23390c64" */
    "./mdtest.html-4739fee8.js"
  ), true ? [] : void 0)),
  // path: /404.html
  "v-3706649a": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-3706649a" */
    "./404.html-18ee1ad7.js"
  ), true ? [] : void 0))
};
var layoutsSymbol = Symbol("");
var pageDataSymbol = Symbol("");
var pageDataEmpty = readonly({
  key: "",
  path: "",
  title: "",
  lang: "",
  frontmatter: {},
  headers: []
});
var usePageData$1 = () => {
  const pageData = inject(pageDataSymbol);
  if (!pageData) {
    throw new Error("pageData() is called without provider.");
  }
  return pageData;
};
var pageFrontmatterSymbol = Symbol("");
var usePageFrontmatter = () => {
  const pageFrontmatter = inject(pageFrontmatterSymbol);
  if (!pageFrontmatter) {
    throw new Error("usePageFrontmatter() is called without provider.");
  }
  return pageFrontmatter;
};
var pageHeadSymbol = Symbol("");
var usePageHead = () => {
  const pageHead = inject(pageHeadSymbol);
  if (!pageHead) {
    throw new Error("usePageHead() is called without provider.");
  }
  return pageHead;
};
var pageHeadTitleSymbol = Symbol("");
var pageLangSymbol = Symbol("");
var usePageLang = () => {
  const pageLang = inject(pageLangSymbol);
  if (!pageLang) {
    throw new Error("usePageLang() is called without provider.");
  }
  return pageLang;
};
var pageLayoutSymbol = Symbol("");
var usePageLayout = () => {
  const pageLayout = inject(pageLayoutSymbol);
  if (!pageLayout) {
    throw new Error("usePageLayout() is called without provider.");
  }
  return pageLayout;
};
var pagesData = ref(pagesData$1);
var routeLocaleSymbol = Symbol("");
var useRouteLocale = () => {
  const routeLocale = inject(routeLocaleSymbol);
  if (!routeLocale) {
    throw new Error("useRouteLocale() is called without provider.");
  }
  return routeLocale;
};
var siteData$2 = ref(siteData$3);
var useSiteData = () => siteData$2;
var siteLocaleDataSymbol = Symbol("");
var useSiteLocaleData = () => {
  const siteLocaleData = inject(siteLocaleDataSymbol);
  if (!siteLocaleData) {
    throw new Error("useSiteLocaleData() is called without provider.");
  }
  return siteLocaleData;
};
var updateHeadSymbol = Symbol("");
var LAYOUT_NAME_DEFAULT = "Layout";
var LAYOUT_NAME_NOT_FOUND = "NotFound";
var resolvers = reactive({
  /**
   * Resolve layouts component map
   */
  resolveLayouts: (clientConfigs2) => clientConfigs2.reduce((prev, item) => ({
    ...prev,
    ...item.layouts
  }), {}),
  /**
   * Resolve page data according to page key
   */
  resolvePageData: async (pageKey) => {
    const pageDataResolver = pagesData.value[pageKey];
    const pageData = await (pageDataResolver == null ? void 0 : pageDataResolver());
    return pageData ?? pageDataEmpty;
  },
  /**
   * Resolve page frontmatter from page data
   */
  resolvePageFrontmatter: (pageData) => pageData.frontmatter,
  /**
   * Merge the head config in frontmatter and site locale
   *
   * Frontmatter should take priority over site locale
   */
  resolvePageHead: (headTitle, frontmatter, siteLocale) => {
    const description2 = isString$1(frontmatter.description) ? frontmatter.description : siteLocale.description;
    const head = [...isArray$1(frontmatter.head) ? frontmatter.head : [], ...siteLocale.head, ["title", {}, headTitle], ["meta", {
      name: "description",
      content: description2
    }]];
    return dedupeHead(head);
  },
  /**
   * Resolve the content of page head title
   *
   * It would be used as the content of the `<title>` tag
   */
  resolvePageHeadTitle: (page, siteLocale) => [page.title, siteLocale.title].filter((item) => !!item).join(" | "),
  /**
   * Resolve page language from page data
   *
   * It would be used as the `lang` attribute of `<html>` tag
   */
  resolvePageLang: (page, siteLocale) => page.lang || siteLocale.lang || "en-US",
  /**
   * Resolve layout component of current page
   */
  resolvePageLayout: (page, layouts2) => {
    let layoutName;
    if (page.path) {
      const frontmatterLayout = page.frontmatter.layout;
      if (isString$1(frontmatterLayout)) {
        layoutName = frontmatterLayout;
      } else {
        layoutName = LAYOUT_NAME_DEFAULT;
      }
    } else {
      layoutName = LAYOUT_NAME_NOT_FOUND;
    }
    return layouts2[layoutName];
  },
  /**
   * Resolve locale path according to route path and locales config
   */
  resolveRouteLocale: (locales2, routePath) => resolveLocalePath(locales2, routePath),
  /**
   * Resolve site data for specific locale
   *
   * It would merge the locales fields to the root fields
   */
  resolveSiteLocaleData: (site, routeLocale) => ({
    ...site,
    ...site.locales[routeLocale]
  })
});
var ClientOnly = defineComponent({
  name: "ClientOnly",
  setup(_2, ctx) {
    const isMounted = ref(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return () => {
      var _a3, _b2;
      return isMounted.value ? (_b2 = (_a3 = ctx.slots).default) == null ? void 0 : _b2.call(_a3) : null;
    };
  }
});
var Content = defineComponent({
  // eslint-disable-next-line vue/no-reserved-component-names
  name: "Content",
  props: {
    pageKey: {
      type: String,
      required: false,
      default: ""
    }
  },
  setup(props) {
    const page = usePageData$1();
    const pageComponent = computed(() => pagesComponents[props.pageKey || page.value.key]);
    return () => pageComponent.value ? (
      // use page component
      h$5(pageComponent.value)
    ) : (
      // fallback content
      h$5("div", "404 Not Found")
    );
  }
});
var defineClientConfig = (clientConfig = {}) => clientConfig;
var withBase = (url) => {
  if (isLinkHttp$1(url))
    return url;
  return `${"/"}${removeLeadingSlash(url)}`;
};
const themeData$1 = JSON.parse('{"home":"/","catalogTitle":"导航","docsDir":"/","series":{"/docs":[{"text":"画改与梦","children":[]},{"text":"技术小记","children":["/docs/tech/flowers","/docs/tech/homebg"]},{"text":"测试页面","children":["/docs/test/mdtest","/docs/test/articletest"],"collapsible":true}]},"navbar":[{"icon":"BlochSphere","text":"首页","link":"/"},{"icon":"Image","text":"画册","link":"/albums"},{"icon":"Book","text":"文章","link":"/docs/test/mdtest"},{"icon":"Idea","text":"随想","link":"/posts"},{"icon":"Forum","text":"说说","link":"/comingSoon"},{"icon":"ChangeCatalog","text":"迭代","link":"/timeline"},{"text":"QQ空间","link":"https://user.qzone.qq.com/841745697/main"}],"colorMode":"dark","primaryColor":"rgb(104, 173, 173)","author":"触虐の羊明","authorAvatar":"/images/avatar.png"}');
const themeData = ref(themeData$1);
const useThemeData = () => themeData;
const themeLocaleDataSymbol = Symbol("");
const useThemeLocaleData$1 = () => {
  const themeLocaleData = inject(themeLocaleDataSymbol);
  if (!themeLocaleData) {
    throw new Error("useThemeLocaleData() is called without provider.");
  }
  return themeLocaleData;
};
const resolveThemeLocaleData = (theme, routeLocale) => {
  const {
    locales: locales2,
    ...baseOptions
  } = theme;
  return {
    ...baseOptions,
    ...locales2 == null ? void 0 : locales2[routeLocale]
  };
};
function useVisible() {
  const themeLocal = useThemeLocaleData$1();
  const bulletin = computed(() => {
    var _a3;
    return (_a3 = themeLocal === null || themeLocal === void 0 ? void 0 : themeLocal.value) === null || _a3 === void 0 ? void 0 : _a3.bulletin;
  });
  const visible = ref(false);
  const bulletinPopoverKey = "__CLOSE_BULLETIN_POPOVER__";
  onMounted(() => {
    var _a3;
    const closeNote = sessionStorage.getItem(bulletinPopoverKey);
    visible.value = closeNote !== "true" && !!((_a3 = bulletin === null || bulletin === void 0 ? void 0 : bulletin.value) === null || _a3 === void 0 ? void 0 : _a3.body);
  });
  const closeBulletinPopover = () => {
    visible.value = false;
    sessionStorage.setItem(bulletinPopoverKey, "true");
  };
  return {
    visible,
    bulletin,
    closeBulletinPopover
  };
}
const nodeHandler = {
  handleImage(node2) {
    return `<img style="${node2.style || ""}" src="${node2.src}" />`;
  },
  handleText(node2) {
    return `<div style="${node2.style || ""}">${node2.content}</div>`;
  },
  handleTitle(node2) {
    return `<h5 style="${node2.style || ""}">${node2.content}</h5>`;
  },
  handleButton(node2) {
    return `<a style="${node2.style || ""}" class="btn" href="${node2.link}">${node2.text}</a>`;
  },
  handleButtongroup(node2) {
    const btnChildren = (node2.children || []).reduce((total, next) => {
      return total += `<a style="${next.style || node2.style || ""}" class="btn" href="${next.link}">${next.text}</a>`;
    }, "");
    return `<div class="btn-group">${btnChildren}</div>`;
  },
  handleHr(node2) {
    return `<hr />`;
  }
};
function useHandleNodes() {
  const themeLocal = useThemeLocaleData$1();
  function handleNode(nodes) {
    if (!Array.isArray(nodes)) {
      let type2 = nodes.type;
      type2 = type2.slice(0, 1).toUpperCase() + type2.slice(1);
      return nodeHandler[`handle${type2}`](nodes);
    } else {
      return nodes.map((node2) => handleNode(node2));
    }
  }
  const bodyNodes = computed(() => {
    var _a3, _b2;
    return handleNode((_b2 = (_a3 = themeLocal === null || themeLocal === void 0 ? void 0 : themeLocal.value) === null || _a3 === void 0 ? void 0 : _a3.bulletin) === null || _b2 === void 0 ? void 0 : _b2.body).join("");
  });
  return {
    bodyNodes,
    handleNode
  };
}
const _hoisted_1$1k = { class: "bulletin-title" };
const _hoisted_2$Z = /* @__PURE__ */ createElementVNode(
  "path",
  {
    d: "M512 34.133333a486.4 486.4 0 1 0 486.4 486.4A486.4 486.4 0 0 0 512 34.133333z m209.4848 632.8064l-55.6032 55.466667-151.517867-151.125333-151.517866 151.1168-55.6032-55.466667 151.517866-151.108267L307.242667 364.714667l55.6032-55.466667 151.517866 151.125333 151.517867-151.1168 55.6032 55.466667-151.517867 151.099733z m0 0",
    "p-id": "4449"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$P = [
  _hoisted_2$Z
];
const _hoisted_4$E = ["innerHTML"];
const _sfc_main$1D = /* @__PURE__ */ defineComponent({
  __name: "Bulletin",
  setup(__props) {
    const { visible, bulletin, closeBulletinPopover } = useVisible();
    const { bodyNodes } = useHandleNodes();
    return (_ctx, _cache) => {
      var _a3, _b2;
      const _component_Xicons = resolveComponent("Xicons");
      return unref(visible) ? (openBlock(), createElementBlock(
        "div",
        {
          key: 0,
          class: "bulletin-wrapper",
          style: normalizeStyle({ width: ((_a3 = unref(bulletin)) == null ? void 0 : _a3.width) || "300px" })
        },
        [
          createElementVNode("div", _hoisted_1$1k, [
            createVNode(_component_Xicons, {
              icon: "VolumeUp",
              "icon-size": "20",
              text: ((_b2 = unref(bulletin)) == null ? void 0 : _b2.title) || "公告",
              color: "#fff",
              "text-size": "16"
            }, null, 8, ["text"]),
            (openBlock(), createElementBlock("svg", {
              class: "btn-close icon",
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeBulletinPopover) && unref(closeBulletinPopover)(...args)),
              t: "1573745677073",
              viewBox: "0 0 1024 1024",
              version: "1.1",
              xmlns: "http://www.w3.org/2000/svg",
              "p-id": "4448",
              width: "22",
              height: "22"
            }, _hoisted_3$P))
          ]),
          createElementVNode("div", {
            class: "bulletin-content",
            innerHTML: unref(bodyNodes)
          }, null, 8, _hoisted_4$E)
        ],
        4
        /* STYLE */
      )) : createCommentVNode("v-if", true);
    };
  }
});
const Bulletin_vue_vue_type_style_index_0_lang = "";
const _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const Bulletin = /* @__PURE__ */ _export_sfc$1(_sfc_main$1D, [["__file", "Bulletin.vue"]]);
const clientConfig0 = defineClientConfig({
  rootComponents: [defineComponent(() => {
    return () => h$5(Bulletin);
  })]
});
function useComment() {
  const themeLocal = useThemeLocaleData$1();
  const solution = computed(() => {
    var _a3;
    switch ((_a3 = themeLocal.value.commentConfig) === null || _a3 === void 0 ? void 0 : _a3.type) {
      case "valine":
        return "valine";
      case "waline":
        return "waline";
      case "giscus":
        return "giscus";
      default:
        return "";
    }
  });
  const options = computed(() => {
    var _a3, _b2;
    return ((_b2 = (_a3 = themeLocal.value) === null || _a3 === void 0 ? void 0 : _a3.commentConfig) === null || _b2 === void 0 ? void 0 : _b2.options) || {};
  });
  return {
    solution,
    options
  };
}
const valine = "";
const Valine = defineComponent({
  name: "Valine",
  props: {
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props) {
    const router = useRouter();
    const {
      options
    } = toRefs(props);
    let valineInstance = null;
    onMounted(async () => {
      const {
        Valine: Valine2
      } = await __vitePreload(() => import("./reco-valine-11644bf6.js"), true ? [] : void 0);
      const initValine = async () => {
        if (valineInstance)
          return;
        const valineOptions = {
          el: "#valine",
          placeholder: "just go go",
          notify: false,
          verify: false,
          avatar: "retro",
          visitor: true,
          recordIP: false,
          path: window.location.pathname,
          ...options.value
        };
        valineInstance = new Valine2(valineOptions);
      };
      initValine();
      watch(() => router.currentRoute.value.path, (toPath) => {
        initValine();
      }, {
        immediate: true,
        deep: true
      });
    });
  },
  render() {
    return h$5("div", {
      class: "reco-valine-wrapper"
    }, h$5("div", {
      id: "valine"
    }));
  }
});
function computedEager(fn, options) {
  var _a3;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options,
    flush: (_a3 = options == null ? void 0 : options.flush) != null ? _a3 : "sync"
  });
  return readonly(result);
}
function computedWithControl(source, fn) {
  let v3 = void 0;
  let track;
  let trigger;
  const dirty = ref(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  watch(source, update, { flush: "sync" });
  const get = typeof fn === "function" ? fn : fn.get;
  const set = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v3 = get();
          dirty.value = false;
        }
        track();
        return v3;
      },
      set(v22) {
        set == null ? void 0 : set(v22);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const toString$1 = Object.prototype.toString;
const isObject$1 = (val) => toString$1.call(val) === "[object Object]";
const noop$1 = () => {
};
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop$1;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop$1;
  };
  const filter2 = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter2;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter2,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function tryOnUnmounted(fn) {
  if (getCurrentInstance())
    onUnmounted(fn);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options;
  if (isRef(optionsOrRef)) {
    options = {
      evaluating: optionsOrRef
    };
  } else {
    options = optionsOrRef || {};
  }
  const {
    lazy = false,
    evaluating = void 0,
    shallow = true,
    onError: onError2 = noop$1
  } = options;
  const started = ref(!lazy);
  const current = shallow ? shallowRef(initialState) : ref(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    if (!started.value)
      return;
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (evaluating)
            evaluating.value = false;
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        current.value = result;
    } catch (e2) {
      onError2(e2);
    } finally {
      if (evaluating && counterAtBeginning === counter)
        evaluating.value = false;
      hasFinished = true;
    }
  });
  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}
function unrefElement(elRef) {
  var _a3;
  const plain = toValue(elRef);
  return (_a3 = plain == null ? void 0 : plain.$el) != null ? _a3 : plain;
}
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop$1;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref(false);
  if (getCurrentInstance()) {
    onMounted(() => {
      isMounted.value = true;
    });
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref(false);
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp) {
    if (!isActive.value || !window2)
      return;
    const delta = timestamp - (previousFrameTimestamp || timestamp);
    fn({ delta, timestamp });
    previousFrameTimestamp = timestamp;
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
const defaults$3 = {
  array: (v3) => JSON.stringify(v3),
  object: (v3) => JSON.stringify(v3),
  set: (v3) => JSON.stringify(Array.from(v3)),
  map: (v3) => JSON.stringify(Object.fromEntries(v3)),
  null: () => ""
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults$3.null;
  if (target instanceof Map)
    return defaults$3.map;
  else if (target instanceof Set)
    return defaults$3.set;
  else if (Array.isArray(target))
    return defaults$3.array;
  else
    return defaults$3.object;
}
function useBase64(target, options) {
  const base64 = ref("");
  const promise2 = ref();
  function execute() {
    if (!isClient)
      return;
    promise2.value = new Promise((resolve, reject) => {
      try {
        const _target = toValue(target);
        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    promise2.value.then((res) => base64.value = res);
    return promise2.value;
  }
  if (isRef(target) || typeof target === "function")
    watch(target, execute, { immediate: true });
  else
    execute();
  return {
    base64,
    promise: promise2,
    execute
  };
}
function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e2) => {
      resolve(e2.target.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global$1))
    _global$1[globalKey] = _global$1[globalKey] || {};
  return _global$1[globalKey];
}
function getSSRHandler(key, fallback2) {
  return handlers[key] || fallback2;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v3) => v3 === "true",
    write: (v3) => String(v3)
  },
  object: {
    read: (v3) => JSON.parse(v3),
    write: (v3) => JSON.stringify(v3)
  },
  number: {
    read: (v3) => Number.parseFloat(v3),
    write: (v3) => String(v3)
  },
  any: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  string: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  map: {
    read: (v3) => new Map(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3.entries()))
  },
  set: {
    read: (v3) => new Set(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3))
  },
  date: {
    read: (v3) => new Date(v3),
    write: (v3) => v3.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a3;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError: onError2 = (e2) => {
    }
  } = options;
  const data = (shallow ? shallowRef : ref)(defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e2) {
      onError2(e2);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults2);
  const type2 = guessSerializerType(rawInit);
  const serializer = (_a3 = options.serializer) != null ? _a3 : StorageSerializers[type2];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    useEventListener(window2, "storage", update);
    useEventListener(window2, customStorageEventName, updateFromCustomEvent);
  }
  update();
  return data;
  function write(v3) {
    try {
      if (v3 == null) {
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v3);
        const oldValue = storage.getItem(key);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          if (window2) {
            window2.dispatchEvent(new CustomEvent(customStorageEventName, {
              detail: {
                key,
                oldValue,
                newValue: serialized,
                storageArea: storage
              }
            }));
          }
        }
      }
    } catch (e2) {
      onError2(e2);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit !== null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value, rawInit);
      else if (type2 === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read(event);
    } catch (e2) {
      onError2(e2);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(
    () => unrefElement(target),
    (el) => {
      cleanup();
      if (isSupported.value && window2 && el) {
        observer = new MutationObserver(callback);
        observer.observe(el, mutationOptions);
      }
    },
    { immediate: true }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
const eventHandlers = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function useFullscreen(target, options = {}) {
  const {
    document: document2 = defaultDocument,
    autoExit = false
  } = options;
  const targetRef = computed(() => {
    var _a3;
    return (_a3 = unrefElement(target)) != null ? _a3 : document2 == null ? void 0 : document2.querySelector("html");
  });
  const isFullscreen = ref(false);
  const requestMethod = computed(() => {
    return [
      "requestFullscreen",
      "webkitRequestFullscreen",
      "webkitEnterFullscreen",
      "webkitEnterFullScreen",
      "webkitRequestFullScreen",
      "mozRequestFullScreen",
      "msRequestFullscreen"
    ].find((m2) => document2 && m2 in document2 || targetRef.value && m2 in targetRef.value);
  });
  const exitMethod = computed(() => {
    return [
      "exitFullscreen",
      "webkitExitFullscreen",
      "webkitExitFullScreen",
      "webkitCancelFullScreen",
      "mozCancelFullScreen",
      "msExitFullscreen"
    ].find((m2) => document2 && m2 in document2 || targetRef.value && m2 in targetRef.value);
  });
  const fullscreenEnabled = computed(() => {
    return [
      "fullScreen",
      "webkitIsFullScreen",
      "webkitDisplayingFullscreen",
      "mozFullScreen",
      "msFullscreenElement"
    ].find((m2) => document2 && m2 in document2 || targetRef.value && m2 in targetRef.value);
  });
  const fullscreenElementMethod = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((m2) => document2 && m2 in document2);
  const isSupported = useSupported(
    () => targetRef.value && document2 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0
  );
  const isCurrentElementFullScreen = () => {
    if (fullscreenElementMethod)
      return (document2 == null ? void 0 : document2[fullscreenElementMethod]) === targetRef.value;
    return false;
  };
  const isElementFullScreen = () => {
    if (fullscreenEnabled.value) {
      if (document2 && document2[fullscreenEnabled.value] != null) {
        return document2[fullscreenEnabled.value];
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {
          return Boolean(target2[fullscreenEnabled.value]);
        }
      }
    }
    return false;
  };
  async function exit() {
    if (!isSupported.value || !isFullscreen.value)
      return;
    if (exitMethod.value) {
      if ((document2 == null ? void 0 : document2[exitMethod.value]) != null) {
        await document2[exitMethod.value]();
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)
          await target2[exitMethod.value]();
      }
    }
    isFullscreen.value = false;
  }
  async function enter() {
    if (!isSupported.value || isFullscreen.value)
      return;
    if (isElementFullScreen())
      await exit();
    const target2 = targetRef.value;
    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
      await target2[requestMethod.value]();
      isFullscreen.value = true;
    }
  }
  async function toggle() {
    await (isFullscreen.value ? exit() : enter());
  }
  const handlerCallback = () => {
    const isElementFullScreenValue = isElementFullScreen();
    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())
      isFullscreen.value = isElementFullScreenValue;
  };
  useEventListener(document2, eventHandlers, handlerCallback, false);
  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);
  if (autoExit)
    tryOnScopeDispose(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}
function useNow(options = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame"
  } = options;
  const now2 = ref(/* @__PURE__ */ new Date());
  const update = () => now2.value = /* @__PURE__ */ new Date();
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });
  if (exposeControls) {
    return {
      now: now2,
      ...controls
    };
  } else {
    return now2;
  }
}
function useScriptTag(src, onLoaded = noop$1, options = {}) {
  const {
    immediate = true,
    manual = false,
    type: type2 = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs = {}
  } = options;
  const scriptTag = ref(null);
  let _promise = null;
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      scriptTag.value = el2;
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type2;
      el.async = async;
      el.src = toValue(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs).forEach(([name2, value]) => el == null ? void 0 : el.setAttribute(name2, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    el.addEventListener("error", (event) => reject(event));
    el.addEventListener("abort", (event) => reject(event));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  };
  const unload = () => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag.value)
      scriptTag.value = null;
    const el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnUnmounted(unload);
  return { scriptTag, load, unload };
}
let _id = 0;
function useStyleTag(css2, options = {}) {
  const isLoaded = ref(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `vueuse_styletag_${++_id}`
  } = options;
  const cssRef = ref(css2);
  let stop = () => {
  };
  const load = () => {
    if (!document2)
      return;
    const el = document2.getElementById(id) || document2.createElement("style");
    if (!el.isConnected) {
      el.id = id;
      if (options.media)
        el.media = options.media;
      document2.head.appendChild(el);
    }
    if (isLoaded.value)
      return;
    stop = watch(
      cssRef,
      (value) => {
        el.textContent = value;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  };
  const unload = () => {
    if (!document2 || !isLoaded.value)
      return;
    stop();
    document2.head.removeChild(document2.getElementById(id));
    isLoaded.value = false;
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnScopeDispose(unload);
  return {
    id,
    css: cssRef,
    unload,
    load,
    isLoaded: readonly(isLoaded)
  };
}
const CloseIcon = ({
  size: size2
}) => h$5("svg", {
  class: "wl-close-icon",
  viewBox: "0 0 1024 1024",
  width: size2,
  height: size2
}, [h$5("path", {
  d: "M697.173 85.333h-369.92c-144.64 0-241.92 101.547-241.92 252.587v348.587c0 150.613 97.28 252.16 241.92 252.16h369.92c144.64 0 241.494-101.547 241.494-252.16V337.92c0-151.04-96.854-252.587-241.494-252.587z",
  fill: "currentColor"
}), h$5("path", {
  d: "m640.683 587.52-75.947-75.861 75.904-75.862a37.29 37.29 0 0 0 0-52.778 37.205 37.205 0 0 0-52.779 0l-75.946 75.818-75.862-75.946a37.419 37.419 0 0 0-52.821 0 37.419 37.419 0 0 0 0 52.821l75.947 75.947-75.776 75.733a37.29 37.29 0 1 0 52.778 52.821l75.776-75.776 75.947 75.947a37.376 37.376 0 0 0 52.779-52.821z",
  fill: "#888"
})]);
const DeleteIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "m341.013 394.667 27.755 393.45h271.83l27.733-393.45h64.106l-28.01 397.952a64 64 0 0 1-63.83 59.498H368.768a64 64 0 0 1-63.83-59.52l-28.053-397.93h64.128zm139.307 19.818v298.667h-64V414.485h64zm117.013 0v298.667h-64V414.485h64zM181.333 288h640v64h-640v-64zm453.483-106.667v64h-256v-64h256z",
  fill: "red"
}));
const EmojiIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z",
  fill: "currentColor"
}));
const ImageIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, [h$5("path", {
  d: "M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z",
  fill: "currentColor"
}), h$5("path", {
  d: "M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z",
  fill: "currentColor"
})]);
const LikeIcon = ({
  active = false
}) => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, [h$5("path", {
  d: `M850.654 323.804c-11.042-25.625-26.862-48.532-46.885-68.225-20.022-19.61-43.258-34.936-69.213-45.73-26.78-11.124-55.124-16.727-84.375-16.727-40.622 0-80.256 11.123-114.698 32.135A214.79 214.79 0 0 0 512 241.819a214.79 214.79 0 0 0-23.483-16.562c-34.442-21.012-74.076-32.135-114.698-32.135-29.25 0-57.595 5.603-84.375 16.727-25.872 10.711-49.19 26.12-69.213 45.73-20.105 19.693-35.843 42.6-46.885 68.225-11.453 26.615-17.303 54.877-17.303 83.963 0 27.439 5.603 56.03 16.727 85.117 9.31 24.307 22.659 49.52 39.715 74.981 27.027 40.293 64.188 82.316 110.33 124.915 76.465 70.615 152.189 119.394 155.402 121.371l19.528 12.525c8.652 5.52 19.776 5.52 28.427 0l19.529-12.525c3.213-2.06 78.854-50.756 155.401-121.371 46.143-42.6 83.304-84.622 110.33-124.915 17.057-25.46 30.487-50.674 39.716-74.981 11.124-29.087 16.727-57.678 16.727-85.117.082-29.086-5.768-57.348-17.221-83.963z${active ? "" : "M512 761.5S218.665 573.55 218.665 407.767c0-83.963 69.461-152.023 155.154-152.023 60.233 0 112.473 33.618 138.181 82.727 25.708-49.109 77.948-82.727 138.18-82.727 85.694 0 155.155 68.06 155.155 152.023C805.335 573.551 512 761.5 512 761.5z"}`,
  fill: active ? "red" : "currentColor"
})]);
const PreviewIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, [h$5("path", {
  d: "M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0",
  fill: "currentColor"
}), h$5("path", {
  d: "M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0",
  fill: "currentColor"
})]);
const MarkdownIcon = () => h$5("svg", {
  width: "16",
  height: "16",
  ariaHidden: "true"
}, h$5("path", {
  d: "M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z",
  fill: "currentColor"
}));
const ReplyIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "M810.667 213.333a64 64 0 0 1 64 64V704a64 64 0 0 1-64 64H478.336l-146.645 96.107a21.333 21.333 0 0 1-33.024-17.856V768h-85.334a64 64 0 0 1-64-64V277.333a64 64 0 0 1 64-64h597.334zm0 64H213.333V704h149.334v63.296L459.243 704h351.424V277.333zm-271.36 213.334v64h-176.64v-64h176.64zm122.026-128v64H362.667v-64h298.666z",
  fill: "currentColor"
}));
const EditIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "M813.039 318.772L480.53 651.278H360.718V531.463L693.227 198.961C697.904 194.284 704.027 192 710.157 192C716.302 192 722.436 194.284 727.114 198.961L813.039 284.88C817.72 289.561 820 295.684 820 301.825C820 307.95 817.72 314.093 813.039 318.772ZM710.172 261.888L420.624 551.431V591.376H460.561L750.109 301.825L710.172 261.888ZM490.517 291.845H240.906V771.09H720.156V521.479C720.156 504.947 733.559 491.529 750.109 491.529C766.653 491.529 780.063 504.947 780.063 521.479V791.059C780.063 813.118 762.18 831 740.125 831H220.937C198.882 831 181 813.118 181 791.059V271.872C181 249.817 198.882 231.935 220.937 231.935H490.517C507.06 231.935 520.47 245.352 520.47 261.888C520.47 278.424 507.06 291.845 490.517 291.845Z",
  fill: "currentColor"
}));
const VerifiedIcon = () => h$5("svg", {
  class: "verified-icon",
  viewBox: "0 0 1024 1024",
  width: "14",
  height: "14"
}, h$5("path", {
  d: "m894.4 461.56-54.4-63.2c-10.4-12-18.8-34.4-18.8-50.4v-68c0-42.4-34.8-77.2-77.2-77.2h-68c-15.6 0-38.4-8.4-50.4-18.8l-63.2-54.4c-27.6-23.6-72.8-23.6-100.8 0l-62.8 54.8c-12 10-34.8 18.4-50.4 18.4h-69.2c-42.4 0-77.2 34.8-77.2 77.2v68.4c0 15.6-8.4 38-18.4 50l-54 63.6c-23.2 27.6-23.2 72.4 0 100l54 63.6c10 12 18.4 34.4 18.4 50v68.4c0 42.4 34.8 77.2 77.2 77.2h69.2c15.6 0 38.4 8.4 50.4 18.8l63.2 54.4c27.6 23.6 72.8 23.6 100.8 0l63.2-54.4c12-10.4 34.4-18.8 50.4-18.8h68c42.4 0 77.2-34.8 77.2-77.2v-68c0-15.6 8.4-38.4 18.8-50.4l54.4-63.2c23.2-27.6 23.2-73.2-.4-100.8zm-216-25.2-193.2 193.2a30 30 0 0 1-42.4 0l-96.8-96.8a30.16 30.16 0 0 1 0-42.4c11.6-11.6 30.8-11.6 42.4 0l75.6 75.6 172-172c11.6-11.6 30.8-11.6 42.4 0 11.6 11.6 11.6 30.8 0 42.4z",
  fill: "#27ae60"
}));
const LoadingIcon = ({
  size: size2 = 100
}) => h$5("svg", {
  width: size2,
  height: size2,
  viewBox: "0 0 100 100",
  preserveAspectRatio: "xMidYMid"
}, h$5("circle", {
  cx: 50,
  cy: 50,
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "4",
  r: "40",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  "stroke-dasharray": "85 30"
}, h$5("animateTransform", {
  attributeName: "transform",
  type: "rotate",
  repeatCount: "indefinite",
  dur: "1s",
  values: "0 50 50;360 50 50",
  keyTimes: "0;1"
})));
const GifIcon = () => h$5("svg", {
  width: 24,
  height: 24,
  fill: "currentcolor",
  viewBox: "0 0 24 24"
}, [h$5("path", {
  style: "transform: translateY(0.5px)",
  d: "M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z"
}), h$5("path", {
  d: "M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z"
})]);
const DefaultUserAvatar = ({
  size: size2 = 100
}) => h$5("svg", {
  width: size2,
  height: size2,
  viewBox: "0 0 1032 1280",
  preserveAspectRatio: "xMidYMid meet"
}, [h$5("g", {
  transform: "translate(0, 1280) scale(0.1, -0.1)",
  fill: "currentcolor",
  stroke: "none"
}, [h$5("path", {
  d: "M4935 12793 c-439 -35 -764 -108 -1140 -255 -848 -333 -1574 -1014 -1964 -1840 -567 -1201 -452 -2603 303 -3690 61 -87 177 -235 271 -344 l34 -40 -106 -120 c-1013 -1138 -1867 -2566 -2183 -3655 -225 -775 -194 -1343 93 -1705 129 -162 320 -303 602 -444 236 -119 240 -120 327 -90 211 72 451 303 658 635 34 55 66 104 70 109 5 4 -21 -81 -56 -190 -68 -209 -224 -730 -224 -748 0 -6 76 -30 170 -54 732 -184 1503 -288 2545 -344 356 -19 1374 -16 1735 5 717 42 1299 107 1825 203 187 34 623 129 632 137 6 7 -126 460 -216 742 -44 137 -79 251 -77 252 1 2 29 -40 62 -93 263 -425 548 -664 814 -681 83 -5 92 -4 166 27 111 46 320 151 401 202 357 222 533 456 607 803 169 793 -298 2136 -1242 3570 -294 447 -595 846 -943 1250 -80 94 -156 179 -168 189 -11 11 -21 23 -21 28 0 5 28 41 63 81 190 219 372 498 511 789 190 394 301 790 348 1238 16 161 16 549 0 710 -124 1192 -786 2224 -1816 2829 -555 327 -1231 506 -1880 499 -89 -1 -179 -3 -201 -5z"
})])]);
const useUserMeta = () => useStorage("WALINE_USER_META", {
  nick: "",
  mail: "",
  link: ""
});
const useEditor = () => useStorage("WALINE_COMMENT_BOX_EDITOR", "");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", {
    value: true
  });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var ReCaptcha = {};
var ReCaptchaLoader$1 = {};
var ReCaptchaInstance$1 = {};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = {
    label: 0,
    sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y3, t2, g2;
  return g2 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
          return t2;
        if (y3 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y3 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
Object.defineProperty(ReCaptchaInstance$1, "__esModule", {
  value: true
});
ReCaptchaInstance$1.ReCaptchaInstance = void 0;
var ReCaptchaInstance = function() {
  function ReCaptchaInstance2(siteKey, recaptchaID, recaptcha) {
    this.siteKey = siteKey;
    this.recaptchaID = recaptchaID;
    this.recaptcha = recaptcha;
    this.styleContainer = null;
  }
  ReCaptchaInstance2.prototype.execute = function(action) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a3) {
        return [2, this.recaptcha.enterprise ? this.recaptcha.enterprise.execute(this.recaptchaID, {
          action
        }) : this.recaptcha.execute(this.recaptchaID, {
          action
        })];
      });
    });
  };
  ReCaptchaInstance2.prototype.getSiteKey = function() {
    return this.siteKey;
  };
  ReCaptchaInstance2.prototype.hideBadge = function() {
    if (this.styleContainer !== null) {
      return;
    }
    this.styleContainer = document.createElement("style");
    this.styleContainer.innerHTML = ".grecaptcha-badge{visibility:hidden !important;}";
    document.head.appendChild(this.styleContainer);
  };
  ReCaptchaInstance2.prototype.showBadge = function() {
    if (this.styleContainer === null) {
      return;
    }
    document.head.removeChild(this.styleContainer);
    this.styleContainer = null;
  };
  return ReCaptchaInstance2;
}();
ReCaptchaInstance$1.ReCaptchaInstance = ReCaptchaInstance;
Object.defineProperty(ReCaptchaLoader$1, "__esModule", {
  value: true
});
ReCaptchaLoader$1.getInstance = ReCaptchaLoader$1.load = void 0;
var ReCaptchaInstance_1 = ReCaptchaInstance$1;
var ELoadingState;
(function(ELoadingState2) {
  ELoadingState2[ELoadingState2["NOT_LOADED"] = 0] = "NOT_LOADED";
  ELoadingState2[ELoadingState2["LOADING"] = 1] = "LOADING";
  ELoadingState2[ELoadingState2["LOADED"] = 2] = "LOADED";
})(ELoadingState || (ELoadingState = {}));
var ReCaptchaLoader = function() {
  function ReCaptchaLoader2() {
  }
  ReCaptchaLoader2.load = function(siteKey, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      return Promise.reject(new Error("This is a library for the browser!"));
    }
    if (ReCaptchaLoader2.getLoadingState() === ELoadingState.LOADED) {
      if (ReCaptchaLoader2.instance.getSiteKey() === siteKey) {
        return Promise.resolve(ReCaptchaLoader2.instance);
      } else {
        return Promise.reject(new Error("reCAPTCHA already loaded with different site key!"));
      }
    }
    if (ReCaptchaLoader2.getLoadingState() === ELoadingState.LOADING) {
      if (siteKey !== ReCaptchaLoader2.instanceSiteKey) {
        return Promise.reject(new Error("reCAPTCHA already loaded with different site key!"));
      }
      return new Promise(function(resolve, reject) {
        ReCaptchaLoader2.successfulLoadingConsumers.push(function(instance) {
          return resolve(instance);
        });
        ReCaptchaLoader2.errorLoadingRunnable.push(function(reason) {
          return reject(reason);
        });
      });
    }
    ReCaptchaLoader2.instanceSiteKey = siteKey;
    ReCaptchaLoader2.setLoadingState(ELoadingState.LOADING);
    var loader = new ReCaptchaLoader2();
    return new Promise(function(resolve, reject) {
      loader.loadScript(siteKey, options.useRecaptchaNet || false, options.useEnterprise || false, options.renderParameters ? options.renderParameters : {}, options.customUrl).then(function() {
        ReCaptchaLoader2.setLoadingState(ELoadingState.LOADED);
        var widgetID = loader.doExplicitRender(grecaptcha, siteKey, options.explicitRenderParameters ? options.explicitRenderParameters : {}, options.useEnterprise || false);
        var instance = new ReCaptchaInstance_1.ReCaptchaInstance(siteKey, widgetID, grecaptcha);
        ReCaptchaLoader2.successfulLoadingConsumers.forEach(function(v3) {
          return v3(instance);
        });
        ReCaptchaLoader2.successfulLoadingConsumers = [];
        if (options.autoHideBadge) {
          instance.hideBadge();
        }
        ReCaptchaLoader2.instance = instance;
        resolve(instance);
      }).catch(function(error) {
        ReCaptchaLoader2.errorLoadingRunnable.forEach(function(v3) {
          return v3(error);
        });
        ReCaptchaLoader2.errorLoadingRunnable = [];
        reject(error);
      });
    });
  };
  ReCaptchaLoader2.getInstance = function() {
    return ReCaptchaLoader2.instance;
  };
  ReCaptchaLoader2.setLoadingState = function(state) {
    ReCaptchaLoader2.loadingState = state;
  };
  ReCaptchaLoader2.getLoadingState = function() {
    if (ReCaptchaLoader2.loadingState === null) {
      return ELoadingState.NOT_LOADED;
    } else {
      return ReCaptchaLoader2.loadingState;
    }
  };
  ReCaptchaLoader2.prototype.loadScript = function(siteKey, useRecaptchaNet, useEnterprise, renderParameters, customUrl) {
    var _this = this;
    if (useRecaptchaNet === void 0) {
      useRecaptchaNet = false;
    }
    if (useEnterprise === void 0) {
      useEnterprise = false;
    }
    if (renderParameters === void 0) {
      renderParameters = {};
    }
    if (customUrl === void 0) {
      customUrl = "";
    }
    var scriptElement = document.createElement("script");
    scriptElement.setAttribute("recaptcha-v3-script", "");
    var scriptBase = "https://www.google.com/recaptcha/api.js";
    if (useRecaptchaNet) {
      if (useEnterprise) {
        scriptBase = "https://recaptcha.net/recaptcha/enterprise.js";
      } else {
        scriptBase = "https://recaptcha.net/recaptcha/api.js";
      }
    }
    if (useEnterprise) {
      scriptBase = "https://www.google.com/recaptcha/enterprise.js";
    }
    if (customUrl) {
      scriptBase = customUrl;
    }
    if (renderParameters.render) {
      renderParameters.render = void 0;
    }
    var parametersQuery = this.buildQueryString(renderParameters);
    scriptElement.src = scriptBase + "?render=explicit" + parametersQuery;
    return new Promise(function(resolve, reject) {
      scriptElement.addEventListener("load", _this.waitForScriptToLoad(function() {
        resolve(scriptElement);
      }, useEnterprise), false);
      scriptElement.onerror = function(error) {
        ReCaptchaLoader2.setLoadingState(ELoadingState.NOT_LOADED);
        reject(error);
      };
      document.head.appendChild(scriptElement);
    });
  };
  ReCaptchaLoader2.prototype.buildQueryString = function(parameters) {
    var parameterKeys = Object.keys(parameters);
    if (parameterKeys.length < 1) {
      return "";
    }
    return "&" + Object.keys(parameters).filter(function(parameterKey) {
      return !!parameters[parameterKey];
    }).map(function(parameterKey) {
      return parameterKey + "=" + parameters[parameterKey];
    }).join("&");
  };
  ReCaptchaLoader2.prototype.waitForScriptToLoad = function(callback, useEnterprise) {
    var _this = this;
    return function() {
      if (window.grecaptcha === void 0) {
        setTimeout(function() {
          _this.waitForScriptToLoad(callback, useEnterprise);
        }, ReCaptchaLoader2.SCRIPT_LOAD_DELAY);
      } else {
        if (useEnterprise) {
          window.grecaptcha.enterprise.ready(function() {
            callback();
          });
        } else {
          window.grecaptcha.ready(function() {
            callback();
          });
        }
      }
    };
  };
  ReCaptchaLoader2.prototype.doExplicitRender = function(grecaptcha2, siteKey, parameters, isEnterprise) {
    var augmentedParameters = {
      sitekey: siteKey,
      badge: parameters.badge,
      size: parameters.size,
      tabindex: parameters.tabindex
    };
    if (parameters.container) {
      if (isEnterprise) {
        return grecaptcha2.enterprise.render(parameters.container, augmentedParameters);
      } else {
        return grecaptcha2.render(parameters.container, augmentedParameters);
      }
    } else {
      if (isEnterprise) {
        return grecaptcha2.enterprise.render(augmentedParameters);
      } else {
        return grecaptcha2.render(augmentedParameters);
      }
    }
  };
  ReCaptchaLoader2.loadingState = null;
  ReCaptchaLoader2.instance = null;
  ReCaptchaLoader2.instanceSiteKey = null;
  ReCaptchaLoader2.successfulLoadingConsumers = [];
  ReCaptchaLoader2.errorLoadingRunnable = [];
  ReCaptchaLoader2.SCRIPT_LOAD_DELAY = 25;
  return ReCaptchaLoader2;
}();
ReCaptchaLoader$1.load = ReCaptchaLoader.load;
ReCaptchaLoader$1.getInstance = ReCaptchaLoader.getInstance;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ReCaptchaInstance = exports.getInstance = exports.load = void 0;
  var ReCaptchaLoader_1 = ReCaptchaLoader$1;
  Object.defineProperty(exports, "load", {
    enumerable: true,
    get: function() {
      return ReCaptchaLoader_1.load;
    }
  });
  Object.defineProperty(exports, "getInstance", {
    enumerable: true,
    get: function() {
      return ReCaptchaLoader_1.getInstance;
    }
  });
  var ReCaptchaInstance_12 = ReCaptchaInstance$1;
  Object.defineProperty(exports, "ReCaptchaInstance", {
    enumerable: true,
    get: function() {
      return ReCaptchaInstance_12.ReCaptchaInstance;
    }
  });
})(ReCaptcha);
const recaptchaStore = {};
const useReCaptcha = (key) => {
  const init = recaptchaStore[key] ?? (recaptchaStore[key] = ReCaptcha.load(key, {
    useRecaptchaNet: true,
    autoHideBadge: true
  }));
  return {
    execute: (action) => init.then((instance) => instance.execute(action))
  };
};
const useTurnstile = (key) => {
  const execute = async (action) => {
    const {
      load
    } = useScriptTag("https://challenges.cloudflare.com/turnstile/v0/api.js", void 0, {
      async: false
    });
    await load();
    const turnstile = window == null ? void 0 : window.turnstile;
    return new Promise((resolve) => {
      turnstile == null ? void 0 : turnstile.ready(() => {
        turnstile == null ? void 0 : turnstile.render(".wl-captcha-container", {
          sitekey: key,
          action,
          size: "compact",
          callback: resolve
        });
      });
    });
  };
  return {
    execute
  };
};
const USER_INFO_KEY = "USER_INFO";
let userInfoStorage = null;
const useUserInfo = () => userInfoStorage ?? (userInfoStorage = useStorage(USER_INFO_KEY, {}));
const ACCESS_TOKEN_KEY = "Access-Token";
let accessTokenStorage = null;
const useAccessToken = () => accessTokenStorage ?? (accessTokenStorage = useStorage(ACCESS_TOKEN_KEY, ref("")));
const decodePath = (path) => {
  try {
    path = decodeURI(path);
  } catch (err2) {
  }
  return path;
};
const removeEndingSplash = (content = "") => content.replace(/\/$/u, "");
const isLinkHttp = (link) => /^(https?:)?\/\//.test(link);
const DEFAULT_LANG = "en-US";
const defaultUploadImage = (file) => new Promise((resolve, reject) => {
  if (file.size > 128 * 1e3)
    return reject(new Error("File too large! File size limit 128KB"));
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onload = () => {
    var _a3;
    return resolve(((_a3 = reader.result) == null ? void 0 : _a3.toString()) || "");
  };
  reader.onerror = reject;
});
const defaultTeXRenderer = (blockMode) => blockMode === true ? '<p class="wl-tex">TeX is not available in preview</p>' : '<span class="wl-tex">TeX is not available in preview</span>';
const getDefaultSearchOptions = (lang) => {
  const fetchGiphy = async (url, params = {}) => fetch(`https://api.giphy.com/v1/gifs/${url}?${new URLSearchParams({
    lang,
    limit: "20",
    rating: "g",
    // eslint-disable-next-line @typescript-eslint/naming-convention
    api_key: "6CIMLkNMMOhRcXPoMCPkFy4Ybk2XUiMp",
    ...params
  }).toString()}`).then((resp) => resp.json()).then(({
    data
  }) => data.map((gif) => ({
    title: gif.title,
    src: gif.images.downsized_medium.url
  })));
  return {
    search: (word) => fetchGiphy("search", {
      q: word,
      offset: "0"
    }),
    default: () => fetchGiphy("trending", {}),
    more: (word, offset2 = 0) => fetchGiphy("search", {
      q: word,
      offset: offset2.toString()
    })
  };
};
const WORD_REGEXP = /[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/;
const LEFT_ANGLE_REGEXP = /</;
const LINE_COMMENT_REGEXP = /(?:^|\s)\/\/(.+?)$/gm;
const BLOCK_COMMENT_REGEXP = /\/\*([\S\s]*?)\*\//gm;
const REGEXP = new RegExp(`(${WORD_REGEXP.source}|${LEFT_ANGLE_REGEXP.source})|((?:${LINE_COMMENT_REGEXP.source})|(?:${BLOCK_COMMENT_REGEXP.source}))`, "gmi");
const COLORS = ["23AC69", "91C132", "F19726", "E8552D", "1AAB8E", "E1147F", "2980C1", "1BA1E6", "9FA0A0", "F19726", "E30B20", "E30B20", "A3338B"];
const cache = {};
const defaultHighlighter = (input) => {
  let index2 = 0;
  return input.replace(REGEXP, (_match, word, comment) => {
    if (comment)
      return `<span style="color: slategray">${comment}</span>`;
    if (word === "<")
      return "&lt;";
    let color;
    if (cache[word])
      color = cache[word];
    else {
      color = COLORS[index2];
      cache[word] = color;
    }
    const out = `<span style="color: #${color}">${word}</span>`;
    index2 = ++index2 % COLORS.length;
    return out;
  });
};
const localeKeys = ["nick", "nickError", "mail", "mailError", "link", "optional", "placeholder", "sofa", "submit", "like", "cancelLike", "reply", "cancelReply", "comment", "refresh", "more", "preview", "emoji", "uploadImage", "seconds", "minutes", "hours", "days", "now", "uploading", "login", "logout", "admin", "sticky", "word", "wordHint", "anonymous", "level0", "level1", "level2", "level3", "level4", "level5", "gif", "gifSearchPlaceholder", "profile", "approved", "waiting", "spam", "unsticky", "oldest", "latest", "hottest", "reactionTitle"];
const generateLocale = (locale) => Object.fromEntries(locale.map((item, index2) => [localeKeys[index2], item]));
const en = generateLocale(["NickName", "NickName cannot be less than 3 bytes.", "E-Mail", "Please confirm your email address.", "Website", "Optional", "Comment here...", "No comment yet.", "Submit", "Like", "Cancel like", "Reply", "Cancel reply", "Comments", "Refresh", "Load More...", "Preview", "Emoji", "Upload Image", "seconds ago", "minutes ago", "hours ago", "days ago", "just now", "Uploading", "Login", "logout", "Admin", "Sticky", "Words", "Please input comments between $0 and $1 words!\n Current word number: $2", "Anonymous", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Search GIF", "Profile", "Approved", "Waiting", "Spam", "Unsticky", "Oldest", "Latest", "Hottest", "What do you think?"]);
const jp = generateLocale(["ニックネーム", "3バイト以上のニックネームをご入力ください.", "メールアドレス", "メールアドレスをご確認ください.", "サイト", "オプション", "ここにコメント", "コメントしましょう~", "提出する", "Like", "Cancel like", "返信する", "キャンセル", "コメント", "更新", "さらに読み込む", "プレビュー", "絵文字", "画像をアップロード", "秒前", "分前", "時間前", "日前", "たっだ今", "アップロード", "ログインする", "ログアウト", "管理者", "トップに置く", "ワード", "コメントは $0 から $1 ワードの間でなければなりません!\n 現在の単語番号: $2", "匿名", "うえにん", "なかにん", "しもおし", "特にしもおし", "かげ", "なぬし", "GIF", "探す GIF", "個人情報", "承認済み", "待っている", "スパム", "べたつかない", "逆順", "正順", "人気順", "どう思いますか？"]);
const ptBR = generateLocale(["Apelido", "Apelido não pode ser menor que 3 bytes.", "E-Mail", "Por favor, confirme seu endereço de e-mail.", "Website", "Opcional", "Comente aqui...", "Nenhum comentário, ainda.", "Enviar", "Like", "Cancel like", "Responder", "Cancelar resposta", "Comentários", "Refrescar", "Carregar Mais...", "Visualizar", "Emoji", "Enviar Imagem", "segundos atrás", "minutos atrás", "horas atrás", "dias atrás", "agora mesmo", "Enviando", "Entrar", "Sair", "Admin", "Sticky", "Palavras", "Favor enviar comentário com $0 a $1 palavras!\n Número de palavras atuais: $2", "Anônimo", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Pesquisar GIF", "informação pessoal", "Aprovado", "Espera", "Spam", "Unsticky", "Mais velho", "Mais recentes", "Mais quente", "O que você acha?"]);
const ru = generateLocale(["Псевдоним", "Никнейм не может быть меньше 3 байт.", "Эл. адрес", "Пожалуйста, подтвердите адрес вашей электронной почты.", "Веб-сайт", "Необязательный", "Комментарий здесь...", "Пока нет комментариев.", "Отправить", "Like", "Cancel like", "Отвечать", "Отменить ответ", "Комментарии", "Обновить", "Загрузи больше...", "Превью", "эмодзи", "Загрузить изображение", "секунд назад", "несколько минут назад", "несколько часов назад", "дней назад", "прямо сейчас", "Загрузка", "Авторизоваться", "Выход из системы", "Админ", "Липкий", "Слова", "Пожалуйста, введите комментарии от $0 до $1 слов!\nНомер текущего слова: $2", "Анонимный", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Поиск GIF", "Персональные данные", "Одобренный", "Ожидающий", "Спам", "Нелипкий", "самый старый", "последний", "самый горячий", "Что вы думаете?"]);
const zhCN = generateLocale(["昵称", "昵称不能少于3个字符", "邮箱", "请填写正确的邮件地址", "网址", "可选", "欢迎评论", "还没有评论哦~ 快来抢一个沙发吧！", "提交", "喜欢", "取消喜欢", "回复", "取消回复", "评论", "刷新", "加载更多...", "预览", "表情", "上传图片", "秒前", "分钟前", "小时前", "天前", "刚刚", "正在上传", "登录", "退出", "博主", "置顶", "字", "评论字数应在 $0 到 $1 字之间！\n当前字数：$2", "匿名", "潜水", "冒泡", "吐槽", "活跃", "话痨", "传说", "表情包", "搜索表情包", "个人资料", "通过", "待审核", "垃圾", "取消置顶", "按最早", "按最新", "按热度", "发表下你的态度吧~"]);
const zhTW = generateLocale(["暱稱", "暱稱不能少於3個字元", "郵箱", "請填寫正確的郵件地址", "網址", "可選", "歡迎留言", "來發留言吧~", "送出", "喜歡", "取消喜歡", "回覆", "取消回覆", "留言", "重整", "載入更多...", "預覽", "表情", "上傳圖片", "秒前", "分鐘前", "小時前", "天前", "剛剛", "正在上傳", "登入", "登出", "管理者", "置頂", "字", "留言字數應在 $0 到 $1 字之間！\n目前字數：$2", "匿名", "潛水", "冒泡", "吐槽", "活躍", "多話", "傳說", "表情包", "搜尋表情包", "個人資料", "通過", "待審核", "垃圾", "取消置頂", "最早", "最新", "熱門", "你認為這篇文章怎麼樣？"]);
const DEFAULT_LOCALES = {
  zh: zhCN,
  "zh-cn": zhCN,
  "zh-CN": zhCN,
  "zh-tw": zhTW,
  "zh-TW": zhTW,
  en,
  "en-US": en,
  "en-us": en,
  jp,
  ja: jp,
  "jp-jp": jp,
  "jp-JP": jp,
  "pt-br": ptBR,
  "pt-BR": ptBR,
  ru,
  "ru-ru": ru,
  "ru-RU": ru
};
const getServerURL = (serverURL) => {
  const result = removeEndingSplash(serverURL);
  return isLinkHttp(result) ? result : `https://${result}`;
};
const getWordLimit = (wordLimit) => Array.isArray(wordLimit) ? wordLimit : wordLimit ? [0, wordLimit] : false;
const fallback = (value, fallback2) => typeof value === "function" ? value : value === false ? false : fallback2;
const getConfig = ({
  // serverURL,
  id,
  path = location.pathname,
  lang = typeof navigator === "undefined" ? "en-US" : navigator.language,
  locale,
  // emoji = DEFAULT_EMOJI,
  // meta = ['nick', 'mail', 'link'],
  // requiredMeta = [],
  dark = false,
  pageSize = 10,
  wordLimit,
  imageUploader,
  highlighter: highlighter2,
  texRenderer: texRenderer2,
  copyright = true,
  login = "enable",
  search: search2,
  // reaction,
  recaptchaV3Key = "",
  turnstileKey = "",
  commentSorting = "latest",
  ...more
}) => ({
  // serverURL: getServerURL(serverURL),
  id: id || decodePath(path),
  locale: {
    ...DEFAULT_LOCALES[lang] || DEFAULT_LOCALES[DEFAULT_LANG],
    ...typeof locale === "object" ? locale : {}
  },
  wordLimit: getWordLimit(wordLimit),
  // meta: getMeta(meta),
  // requiredMeta: getMeta(requiredMeta),
  imageUploader: fallback(imageUploader, defaultUploadImage),
  highlighter: fallback(highlighter2, defaultHighlighter),
  texRenderer: fallback(texRenderer2, defaultTeXRenderer),
  lang: Object.keys(DEFAULT_LOCALES).includes(lang) ? lang : "en-US",
  dark,
  // emoji: typeof emoji === 'boolean' ? (emoji ? DEFAULT_EMOJI : []) : emoji,
  pageSize,
  login,
  copyright,
  search: search2 === false ? false : typeof search2 === "object" ? search2 : getDefaultSearchOptions(lang),
  recaptchaV3Key,
  turnstileKey,
  // reaction: Array.isArray(reaction)
  //   ? reaction
  //   : reaction === true
  //   ? DEFAULT_REACTION
  //   : [],
  commentSorting,
  ...more
});
const style$2 = `{--waline-white:#000;--waline-light-grey:#666;--waline-dark-grey:#999;--waline-color:#888;--waline-bgcolor:#1e1e1e;--waline-bgcolor-light:#272727;--waline-bgcolor-hover: #444;--waline-border-color:#333;--waline-disable-bgcolor:#444;--waline-disable-color:#272727;--waline-bq-color:#272727;--waline-info-bgcolor:#272727;--waline-info-color:#666}`;
const getDarkStyle = (selector) => {
  if (typeof selector === "string") {
    return selector === "auto" ? `@media(prefers-color-scheme:dark){body${style$2}}` : `${selector}${style$2}`;
  }
  return selector === true ? `:root${style$2}` : "";
};
const padWithZeros = (vNumber, width) => {
  let numAsString = vNumber.toString();
  while (numAsString.length < width) {
    numAsString = "0" + numAsString;
  }
  return numAsString;
};
const dateFormat = (date) => {
  const vDay = padWithZeros(date.getDate(), 2);
  const vMonth = padWithZeros(date.getMonth() + 1, 2);
  const vYear = padWithZeros(date.getFullYear(), 2);
  return `${vYear}-${vMonth}-${vDay}`;
};
const getTimeAgo = (date, now2, locale) => {
  if (!date)
    return "";
  const time = typeof date === "string" ? new Date(date.indexOf(" ") !== -1 ? date.replace(/-/g, "/") : date) : date;
  const timePassed = now2.getTime() - time.getTime();
  const days = Math.floor(timePassed / (24 * 3600 * 1e3));
  if (days === 0) {
    const leave1 = timePassed % (24 * 3600 * 1e3);
    const hours = Math.floor(leave1 / (3600 * 1e3));
    if (hours === 0) {
      const leave2 = leave1 % (3600 * 1e3);
      const minutes = Math.floor(leave2 / (60 * 1e3));
      if (minutes === 0) {
        const leave3 = leave2 % (60 * 1e3);
        const seconds = Math.round(leave3 / 1e3);
        return `${seconds} ${locale.seconds}`;
      }
      return `${minutes} ${locale.minutes}`;
    }
    return `${hours} ${locale.hours}`;
  }
  if (days < 0)
    return locale.now;
  if (days < 8)
    return `${days} ${locale.days}`;
  return dateFormat(time);
};
const hasVersion = (url) => Boolean(/@[0-9]+\.[0-9]+\.[0-9]+/.test(url));
const fetchEmoji = (link) => {
  const emojiStore = useStorage("WALINE_EMOJI", {});
  const result = hasVersion(link);
  if (result) {
    const info = emojiStore.value[link];
    if (info)
      return Promise.resolve(info);
  }
  return fetch(`${link}/info.json`).then((resp) => resp.json()).then((emojiInfo) => {
    const info = {
      folder: link,
      ...emojiInfo
    };
    if (result)
      emojiStore.value[link] = info;
    return info;
  });
};
const getLink = (name2, folder = "", prefix = "", type2 = "") => `${folder ? `${folder}/` : ""}${prefix}${name2}${type2 ? `.${type2}` : ""}`;
const getEmojis = (emojis) => Promise.all(emojis.map((emoji2) => typeof emoji2 === "string" ? fetchEmoji(removeEndingSplash(emoji2)) : Promise.resolve(emoji2))).then((emojiInfos) => {
  const emojiConfig = {
    tabs: [],
    map: {}
  };
  emojiInfos.forEach((emojiInfo) => {
    const {
      name: name2,
      folder,
      icon,
      prefix,
      type: type2,
      items
    } = emojiInfo;
    emojiConfig.tabs.push({
      name: name2,
      icon: getLink(icon, folder, prefix, type2),
      items: items.map((item) => {
        const key = `${prefix || ""}${item}`;
        emojiConfig.map[key] = getLink(item, folder, prefix, type2);
        return key;
      })
    });
  });
  return emojiConfig;
});
const isImage = (item) => item.type.includes("image");
const getImageFromDataTransfer = (items) => {
  const image = Array.from(items).find(isImage);
  return image ? image.getAsFile() : null;
};
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults$2 = getDefaults();
function changeDefaults(newDefaults) {
  defaults$2 = newDefaults;
}
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, "g");
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode2) {
  if (encode2) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(html2) {
  return html2.replace(unescapeTest, (_2, n2) => {
    n2 = n2.toLowerCase();
    if (n2 === "colon")
      return ":";
    if (n2.charAt(0) === "#") {
      return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e2) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e2) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
const noopTest = {
  exec: function noopTest2() {
  }
};
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset2, str) => {
    let escaped = false, curr = offset2;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i3 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i3 < cells.length; i3++) {
    cells[i3] = cells[i3].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c2, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c2 && !invert) {
      suffLen++;
    } else if (currChar !== c2 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b2) {
  if (str.indexOf(b2[1]) === -1) {
    return -1;
  }
  const l2 = str.length;
  let level = 0, i3 = 0;
  for (; i3 < l2; i3++) {
    if (str[i3] === "\\") {
      i3++;
    } else if (str[i3] === b2[0]) {
      level++;
    } else if (str[i3] === b2[1]) {
      level--;
      if (level < 0) {
        return i3;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token2 = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer.inlineTokens(text2)
    };
    lexer.state.inLink = false;
    return token2;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node2) => {
    const matchIndentInNode = node2.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node2;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node2.slice(indentToCode.length);
    }
    return node2;
  }).join("\n");
}
class Tokenizer {
  constructor(options) {
    this.options = options || defaults$2;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i3, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t2) => " ".repeat(3 * t2.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l2 = list.items.length;
      for (i3 = 0; i3 < l2; i3++) {
        this.lexer.state.top = false;
        list.items[i3].tokens = this.lexer.blockTokens(list.items[i3].text, []);
        if (!list.loose) {
          const spacers = list.items[i3].tokens.filter((t2) => t2.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t2) => /\n.*\n/.test(t2.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i3 = 0; i3 < l2; i3++) {
          list.items[i3].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token2 = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token2.type = "paragraph";
        token2.text = text2;
        token2.tokens = this.lexer.inline(text2);
      }
      return token2;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c2) => {
          return {
            text: c2
          };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l2 = item.align.length;
        let i3, j2, k2, row;
        for (i3 = 0; i3 < l2; i3++) {
          if (/^ *-+: *$/.test(item.align[i3])) {
            item.align[i3] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i3])) {
            item.align[i3] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i3])) {
            item.align[i3] = "left";
          } else {
            item.align[i3] = null;
          }
        }
        l2 = item.rows.length;
        for (i3 = 0; i3 < l2; i3++) {
          item.rows[i3] = splitCells(item.rows[i3], item.header.length).map((c2) => {
            return {
              text: c2
            };
          });
        }
        l2 = item.header.length;
        for (j2 = 0; j2 < l2; j2++) {
          item.header[j2].tokens = this.lexer.inline(item.header[j2].text);
        }
        l2 = item.rows.length;
        for (j2 = 0; j2 < l2; j2++) {
          row = item.rows[j2];
          for (k2 = 0; k2 < row.length; k2++) {
            row[k2].tokens = this.lexer.inline(row[k2].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [{
          type: "text",
          raw: text2,
          text: text2
        }]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [{
          type: "text",
          raw: text2,
          text: text2
        }]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = {
  ...block
};
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = {
  ...inline
};
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text2) {
  return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text2) {
  let out = "", i3, ch;
  const l2 = text2.length;
  for (i3 = 0; i3 < l2; i3++) {
    ch = text2.charCodeAt(i3);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options || defaults$2;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_2, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token2, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token2 = extTokenizer.call({
          lexer: this
        }, src, tokens)) {
          src = src.substring(token2.raw.length);
          tokens.push(token2);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token2 = this.tokenizer.space(src)) {
        src = src.substring(token2.raw.length);
        if (token2.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.code(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.fences(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.heading(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.hr(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.blockquote(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.list(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.html(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.def(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token2.tag]) {
          this.tokens.links[token2.tag] = {
            href: token2.href,
            title: token2.title
          };
        }
        continue;
      }
      if (token2 = this.tokenizer.table(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.lheading(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({
            lexer: this
          }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token2 = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token2.raw.length);
        continue;
      }
      if (token2 = this.tokenizer.text(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({
      src,
      tokens
    });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token2, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token2 = extTokenizer.call({
          lexer: this
        }, src, tokens)) {
          src = src.substring(token2.raw.length);
          tokens.push(token2);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token2 = this.tokenizer.escape(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.tag(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token2.type === "text" && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.link(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token2.type === "text" && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.codespan(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.br(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.del(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (!this.state.inLink && (token2 = this.tokenizer.url(src, mangle))) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({
            lexer: this
          }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token2 = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token2.raw.length);
        if (token2.raw.slice(-1) !== "_") {
          prevChar = token2.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
class Renderer {
  constructor(options) {
    this.options = options || defaults$2;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html2) {
    return html2;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text2, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text2}</h${level}>
`;
    }
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type2 = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type2 + startatt + ">\n" + body + "</" + type2 + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text2) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type2 = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type2} align="${flags.align}">` : `<${type2}>`;
    return tag + content + `</${type2}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text2) {
    return `<em>${text2}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text2) {
    return `<del>${text2}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text2) {
    return text2;
  }
}
class TextRenderer {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
}
class Parser {
  constructor(options) {
    this.options = options || defaults$2;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new Parser(options);
    return parser.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i3, j2, k2, l2, l3, row, cell, header, body, token2, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l4 = tokens.length;
    for (i3 = 0; i3 < l4; i3++) {
      token2 = tokens[i3];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
        ret = this.options.extensions.renderers[token2.type].call({
          parser: this
        }, token2);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token2.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token2.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(this.parseInline(token2.tokens), token2.depth, unescape$1(this.parseInline(token2.tokens, this.textRenderer)), this.slugger);
          continue;
        }
        case "code": {
          out += this.renderer.code(token2.text, token2.lang, token2.escaped);
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token2.header.length;
          for (j2 = 0; j2 < l2; j2++) {
            cell += this.renderer.tablecell(this.parseInline(token2.header[j2].tokens), {
              header: true,
              align: token2.align[j2]
            });
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token2.rows.length;
          for (j2 = 0; j2 < l2; j2++) {
            row = token2.rows[j2];
            cell = "";
            l3 = row.length;
            for (k2 = 0; k2 < l3; k2++) {
              cell += this.renderer.tablecell(this.parseInline(row[k2].tokens), {
                header: false,
                align: token2.align[k2]
              });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token2.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token2.ordered;
          start = token2.start;
          loose = token2.loose;
          l2 = token2.items.length;
          body = "";
          for (j2 = 0; j2 < l2; j2++) {
            item = token2.items[j2];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token2.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token2.tokens));
          continue;
        }
        case "text": {
          body = token2.tokens ? this.parseInline(token2.tokens) : token2.text;
          while (i3 + 1 < l4 && tokens[i3 + 1].type === "text") {
            token2 = tokens[++i3];
            body += "\n" + (token2.tokens ? this.parseInline(token2.tokens) : token2.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token2.type + '" type was not found.';
          if (this.options.silent) {
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i3, token2, ret;
    const l2 = tokens.length;
    for (i3 = 0; i3 < l2; i3++) {
      token2 = tokens[i3];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
        ret = this.options.extensions.renderers[token2.type].call({
          parser: this
        }, token2);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token2.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token2.type) {
        case "escape": {
          out += renderer.text(token2.text);
          break;
        }
        case "html": {
          out += renderer.html(token2.text);
          break;
        }
        case "link": {
          out += renderer.link(token2.href, token2.title, this.parseInline(token2.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token2.href, token2.title, token2.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token2.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token2.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token2.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token2.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token2.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token2.type + '" type was not found.';
          if (this.options.silent) {
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
class Hooks {
  constructor(options) {
    this.options = options || defaults$2;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
}
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess"]));
function onError(silent, async, callback) {
  return (e2) => {
    e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e2);
    }
    if (callback) {
      callback(e2);
      return;
    }
    throw e2;
  };
}
function parseMarkdown$1(lexer, parser) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = {
      ...opt
    };
    opt = {
      ...marked.defaults,
      ...origOpt
    };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer(src, opt);
      } catch (e2) {
        return throwError(e2);
      }
      const done = function(err2) {
        let out;
        if (!err2) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e2) {
            err2 = e2;
          }
        }
        opt.highlight = highlight;
        return err2 ? throwError(err2) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token2) {
        if (token2.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token2.text, token2.lang, function(err2, code) {
              if (err2) {
                return done(err2);
              }
              if (code != null && code !== token2.text) {
                token2.text = code;
                token2.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html2 = parser(tokens, opt);
      if (opt.hooks) {
        html2 = opt.hooks.postprocess(html2);
      }
      return html2;
    } catch (e2) {
      return throwError(e2);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown$1(Lexer.lex, Parser.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = {
    ...marked.defaults,
    ...opt
  };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults$2;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || {
    renderers: {},
    childTokens: {}
  };
  args.forEach((pack) => {
    const opts = {
      ...pack
    };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token2) {
        let values = [];
        values.push(pack.walkTokens.call(this, token2));
        if (walkTokens) {
          values = values.concat(walkTokens.call(this, token2));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values = [];
  for (const token2 of tokens) {
    values = values.concat(callback.call(marked, token2));
    switch (token2.type) {
      case "table": {
        for (const cell of token2.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token2.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values = values.concat(marked.walkTokens(token2.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token2.type]) {
          marked.defaults.extensions.childTokens[token2.type].forEach(function(childTokens) {
            values = values.concat(marked.walkTokens(token2[childTokens], callback));
          });
        } else if (token2.tokens) {
          values = values.concat(marked.walkTokens(token2.tokens, callback));
        }
      }
    }
  }
  return values;
};
marked.parseInline = parseMarkdown$1(Lexer.lexInline, Parser.parseInline);
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser.parse;
Lexer.lex;
var prismCore = { exports: {} };
(function(module) {
  var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _2 = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self2.Prism && _self2.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function encode2(tokens) {
          if (tokens instanceof Token) {
            return new Token(tokens.type, encode2(tokens.content), tokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(encode2);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(o2) {
          return Object.prototype.toString.call(o2).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", {
              value: ++uniqueId
            });
          }
          return obj["__id"];
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o2, visited) {
          visited = visited || {};
          var clone2;
          var id;
          switch (_2.util.type(o2)) {
            case "Object":
              id = _2.util.objId(o2);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = /** @type {Record<string, any>} */
              {};
              visited[id] = clone2;
              for (var key in o2) {
                if (o2.hasOwnProperty(key)) {
                  clone2[key] = deepClone(o2[key], visited);
                }
              }
              return (
                /** @type {any} */
                clone2
              );
            case "Array":
              id = _2.util.objId(o2);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = [];
              visited[id] = clone2;
              o2.forEach(function(v3, i3) {
                clone2[i3] = deepClone(v3, visited);
              });
              return (
                /** @type {any} */
                clone2
              );
            default:
              return o2;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(element) {
          while (element) {
            var m2 = lang.exec(element.className);
            if (m2) {
              return m2[1].toLowerCase();
            }
            element = element.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(element, language) {
          element.className = element.className.replace(RegExp(lang, "gi"), "");
          element.classList.add("language-" + language);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document === "undefined") {
            return null;
          }
          if ("currentScript" in document && 1 < 2) {
            return (
              /** @type {any} */
              document.currentScript
            );
          }
          try {
            throw new Error();
          } catch (err2) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err2.stack) || [])[1];
            if (src) {
              var scripts2 = document.getElementsByTagName("script");
              for (var i3 in scripts2) {
                if (scripts2[i3].src == src) {
                  return scripts2[i3];
                }
              }
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(element, className, defaultActivation) {
          var no = "no-" + className;
          while (element) {
            var classList2 = element.classList;
            if (classList2.contains(className)) {
              return true;
            }
            if (classList2.contains(no)) {
              return false;
            }
            element = element.parentElement;
          }
          return !!defaultActivation;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(id, redef) {
          var lang2 = _2.util.clone(_2.languages[id]);
          for (var key in redef) {
            lang2[key] = redef[key];
          }
          return lang2;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(inside, before, insert, root) {
          root = root || /** @type {any} */
          _2.languages;
          var grammar = root[inside];
          var ret = {};
          for (var token2 in grammar) {
            if (grammar.hasOwnProperty(token2)) {
              if (token2 == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token2)) {
                ret[token2] = grammar[token2];
              }
            }
          }
          var old = root[inside];
          root[inside] = ret;
          _2.languages.DFS(_2.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o2, callback, type2, visited) {
          visited = visited || {};
          var objId = _2.util.objId;
          for (var i3 in o2) {
            if (o2.hasOwnProperty(i3)) {
              callback.call(o2, i3, o2[i3], type2 || i3);
              var property = o2[i3];
              var propertyType = _2.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i3, visited);
              }
            }
          }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(async, callback) {
        _2.highlightAllUnder(document, async, callback);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _2.hooks.run("before-highlightall", env);
        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
        _2.hooks.run("before-all-elements-highlight", env);
        for (var i3 = 0, element; element = env.elements[i3++]; ) {
          _2.highlightElement(element, async === true, env.callback);
        }
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(element, async, callback) {
        var language = _2.util.getLanguage(element);
        var grammar = _2.languages[language];
        _2.util.setLanguage(element, language);
        var parent = element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre") {
          _2.util.setLanguage(parent, language);
        }
        var code = element.textContent;
        var env = {
          element,
          language,
          grammar,
          code
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;
          _2.hooks.run("before-insert", env);
          env.element.innerHTML = env.highlightedCode;
          _2.hooks.run("after-highlight", env);
          _2.hooks.run("complete", env);
          callback && callback.call(env.element);
        }
        _2.hooks.run("before-sanity-check", env);
        parent = env.element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
          parent.setAttribute("tabindex", "0");
        }
        if (!env.code) {
          _2.hooks.run("complete", env);
          callback && callback.call(env.element);
          return;
        }
        _2.hooks.run("before-highlight", env);
        if (!env.grammar) {
          insertHighlightedCode(_2.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_2.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          };
          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else {
          insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
        }
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(text2, grammar, language) {
        var env = {
          code: text2,
          grammar,
          language
        };
        _2.hooks.run("before-tokenize", env);
        if (!env.grammar) {
          throw new Error('The language "' + env.language + '" has no grammar.');
        }
        env.tokens = _2.tokenize(env.code, env.grammar);
        _2.hooks.run("after-tokenize", env);
        return Token.stringify(_2.util.encode(env.tokens), env.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(text2, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token2 in rest) {
            grammar[token2] = rest[token2];
          }
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text2);
        matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
        return toArray2(tokenList);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(name2, callback) {
          var hooks = _2.hooks.all;
          hooks[name2] = hooks[name2] || [];
          hooks[name2].push(callback);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(name2, env) {
          var callbacks = _2.hooks.all[name2];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i3 = 0, callback; callback = callbacks[i3++]; ) {
            callback(env);
          }
        }
      },
      Token
    };
    _self2.Prism = _2;
    function Token(type2, content, alias, matchedStr) {
      this.type = type2;
      this.content = content;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify(o2, language) {
      if (typeof o2 == "string") {
        return o2;
      }
      if (Array.isArray(o2)) {
        var s2 = "";
        o2.forEach(function(e2) {
          s2 += stringify(e2, language);
        });
        return s2;
      }
      var env = {
        type: o2.type,
        content: stringify(o2.content, language),
        tag: "span",
        classes: ["token", o2.type],
        attributes: {},
        language
      };
      var aliases = o2.alias;
      if (aliases) {
        if (Array.isArray(aliases)) {
          Array.prototype.push.apply(env.classes, aliases);
        } else {
          env.classes.push(aliases);
        }
      }
      _2.hooks.run("wrap", env);
      var attributes = "";
      for (var name2 in env.attributes) {
        attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
      }
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text2, lookbehind) {
      pattern.lastIndex = pos;
      var match = pattern.exec(text2);
      if (match && lookbehind && match[1]) {
        var lookbehindLength = match[1].length;
        match.index += lookbehindLength;
        match[0] = match[0].slice(lookbehindLength);
      }
      return match;
    }
    function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
      for (var token2 in grammar) {
        if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
          continue;
        }
        var patterns = grammar[token2];
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        for (var j2 = 0; j2 < patterns.length; ++j2) {
          if (rematch && rematch.cause == token2 + "," + j2) {
            return;
          }
          var patternObj = patterns[j2];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
          }
          var pattern = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }
            var str = currentNode.value;
            if (tokenList.length > text2.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            var removeCount = 1;
            var match;
            if (greedy) {
              match = matchPattern(pattern, pos, text2, lookbehind);
              if (!match || match.index >= text2.length) {
                break;
              }
              var from = match.index;
              var to = match.index + match[0].length;
              var p2 = pos;
              p2 += currentNode.value.length;
              while (from >= p2) {
                currentNode = currentNode.next;
                p2 += currentNode.value.length;
              }
              p2 -= currentNode.value.length;
              pos = p2;
              if (currentNode.value instanceof Token) {
                continue;
              }
              for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                removeCount++;
                p2 += k2.value.length;
              }
              removeCount--;
              str = text2.slice(pos, p2);
              match.index -= pos;
            } else {
              match = matchPattern(pattern, 0, str, lookbehind);
              if (!match) {
                continue;
              }
            }
            var from = match.index;
            var matchStr = match[0];
            var before = str.slice(0, from);
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after) {
              addAfter(tokenList, currentNode, after);
            }
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token2 + "," + j2,
                reach
              };
              matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
              if (rematch && nestedRematch.reach > rematch.reach) {
                rematch.reach = nestedRematch.reach;
              }
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = {
        value: null,
        prev: null,
        next: null
      };
      var tail = {
        value: null,
        prev: head,
        next: null
      };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list, node2, value) {
      var next = node2.next;
      var newNode = {
        value,
        prev: node2,
        next
      };
      node2.next = newNode;
      next.prev = newNode;
      list.length++;
      return newNode;
    }
    function removeRange(list, node2, count) {
      var next = node2.next;
      for (var i3 = 0; i3 < count && next !== list.tail; i3++) {
        next = next.next;
      }
      node2.next = next;
      next.prev = node2;
      list.length -= i3;
    }
    function toArray2(list) {
      var array = [];
      var node2 = list.head.next;
      while (node2 !== list.tail) {
        array.push(node2.value);
        node2 = node2.next;
      }
      return array;
    }
    if (!_self2.document) {
      if (!_self2.addEventListener) {
        return _2;
      }
      if (!_2.disableWorkerMessageHandler) {
        _self2.addEventListener("message", function(evt) {
          var message = JSON.parse(evt.data);
          var lang2 = message.language;
          var code = message.code;
          var immediateClose = message.immediateClose;
          _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
          if (immediateClose) {
            _self2.close();
          }
        }, false);
      }
      return _2;
    }
    var script = _2.util.currentScript();
    if (script) {
      _2.filename = script.src;
      if (script.hasAttribute("data-manual")) {
        _2.manual = true;
      }
    }
    function highlightAutomaticallyCallback() {
      if (!_2.manual) {
        _2.highlightAll();
      }
    }
    if (!_2.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }
    return _2;
  }(_self);
  if (module.exports) {
    module.exports = Prism2;
  }
  if (typeof commonjsGlobal !== "undefined") {
    commonjsGlobal.Prism = Prism2;
  }
})(prismCore);
var prismCoreExports = prismCore.exports;
const Prism$1 = /* @__PURE__ */ getDefaultExportFromCjs(prismCoreExports);
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: "keyword"
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        "code-block": {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        "code-language": {
          pattern: /^(```).+/,
          lookbehind: true
        },
        "punctuation": /```/
      }
    }],
    "title": [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: "important",
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: "important",
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token2 !== inside) {
        Prism2.languages.markdown[token2].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i3 = 0, l2 = tokens.length; i3 < l2; i3++) {
        var token2 = tokens[i3];
        if (token2.type !== "code") {
          walkTokens(token2.content);
          continue;
        }
        var codeLang = token2.content[1];
        var codeBlock = token2.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i3 = 0, l2 = env.classes.length; i3 < l2; i3++) {
      var cls = env.classes[i3];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html2) {
    var text2 = html2.replace(tagPattern, "");
    text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code) {
      code = code.toLowerCase();
      if (code[0] === "#") {
        var value;
        if (code[1] === "x") {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        }
        return m2;
      }
    });
    return text2;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, Prism.languages.c["string"]],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: "function"
      }],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
        return modName;
      }) + ")"),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
(function(Prism2) {
  function replace(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
      return "(?:" + replacements[+index2] + ")";
    });
  }
  function re2(pattern, replacements, flags) {
    return RegExp(replace(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i3 = 0; i3 < depthLog2; i3++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
  var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [{
      pattern: re2(/(^|[^$\\])<<0>>/.source, [verbatimString]),
      lookbehind: true,
      greedy: true
    }, {
      pattern: re2(/(^|[^@$\\])<<0>>/.source, [regularString]),
      lookbehind: true,
      greedy: true
    }],
    "class-name": [{
      // Using static
      // using static System.Math;
      pattern: re2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (type)
      // using Project = PC.MyCompany.Project;
      pattern: re2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (alias)
      // using Project = PC.MyCompany.Project;
      pattern: re2(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
      lookbehind: true
    }, {
      // Type declarations
      // class Foo<A, B>
      // interface Foo<out A, B>
      pattern: re2(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Single catch exception declaration
      // catch(Foo)
      // (things like catch(Foo e) is covered by variable declaration)
      pattern: re2(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Name of the type parameter of generic constraints
      // where Foo : class
      pattern: re2(/(\bwhere\s+)<<0>>/.source, [name2]),
      lookbehind: true
    }, {
      // Casts and checks via as and is.
      // as Foo<A>, is Bar<B>
      // (things like if(a is Foo b) is covered by variable declaration)
      pattern: re2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Variable, field and parameter declaration
      // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
      pattern: re2(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
      inside: typeInside
    }],
    "keyword": keywords,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re2(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re2(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re2(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re2(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re2(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re2(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re2(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [typeDeclarationKeywords, genericName, name2, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re2(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re2(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re2(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [{
      pattern: re2(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(mInterpolation, mInterpolationRound)
    }, {
      pattern: re2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(sInterpolation, sInterpolationRound)
    }],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [className, {
      // variables, parameters, and constructor references
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
      lookbehind: true,
      inside: className.inside
    }, {
      // class names based on keyword
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
      lookbehind: true,
      inside: className.inside
    }],
    "keyword": keywords,
    "function": [Prism2.languages.clike.function, {
      pattern: /(::\s*)[a-z_]\w*/,
      lookbehind: true
    }],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [{
      pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
      lookbehind: true,
      inside: {
        "namespace": className.inside.namespace,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }, {
      pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
      lookbehind: true,
      alias: "static",
      inside: {
        "namespace": className.inside.namespace,
        "static": /\b\w+$/,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }],
    "namespace": {
      pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
        return keywords.source;
      })),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  Prism2.languages.ruby = Prism2.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism2.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism2.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism2.languages.ruby.function;
  var percentExpression = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [{
      pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }, {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [{
      pattern: RegExp(/(^|[^:]):/.source + symbolName),
      lookbehind: true,
      greedy: true
    }, {
      pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
      lookbehind: true,
      greedy: true
    }],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism2.languages.insertBefore("ruby", "string", {
    "string-literal": [{
      pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?/
          }
        },
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?'|'$/
          }
        },
        "string": /[\s\S]+/
      }
    }],
    "command-literal": [{
      pattern: RegExp(/%x/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }, {
      pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }]
  });
  delete Prism2.languages.ruby.string;
  Prism2.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism2.languages.rb = Prism2.languages.ruby;
})(Prism);
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i3 = 0; i3 < 2; i3++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [{
      pattern: RegExp(/(^|[^\\])/.source + multilineComment),
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [{
      pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
      lookbehind: true,
      alias: "namespace"
    }, {
      pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
      lookbehind: true,
      alias: "namespace",
      inside: {
        "punctuation": /::/
      }
    }],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: true
          }, /^\$\(\(/],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
  var inside = insideString.variable[1].inside;
  for (var i3 = 0; i3 < toBeCopied.length; i3++) {
    inside[toBeCopied[i3]] = Prism2.languages.bash[toBeCopied[i3]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
Prism.languages.cmake = {
  "comment": /#.*/,
  "string": {
    pattern: /"(?:[^\\"]|\\.)*"/,
    greedy: true,
    inside: {
      "interpolation": {
        pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
        inside: {
          "punctuation": /\$\{|\}/,
          "variable": /\w+/
        }
      }
    }
  },
  "variable": /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_NAME|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE))\b/,
  "property": /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
  "keyword": /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
  "boolean": /\b(?:FALSE|OFF|ON|TRUE)\b/,
  "namespace": /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
  "operator": /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
  "inserted": {
    pattern: /\b\w+::\w+\b/,
    alias: "class-name"
  },
  "number": /\b\d+(?:\.\d+)*\b/,
  "function": /\b[a-z_]\w*(?=\s*\()\b/i,
  "punctuation": /[()>}]|\$[<{]/
};
(function(Prism2) {
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+)/,
    lookbehind: true
  };
  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  var inside = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    "url": {
      pattern: /\burl\((["']?).*?\1\)/i,
      greedy: true
    },
    "string": {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    "interpolation": null,
    // See below
    "func": null,
    // See below
    "important": /\B!(?:important|optional)\b/i,
    "keyword": {
      pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
      lookbehind: true
    },
    "hexcode": /#[\da-f]{3,6}/i,
    "color": [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        "unit": unit,
        "number": number,
        "function": /[\w-]+(?=\()/,
        "punctuation": /[(),]/
      }
    }],
    "entity": /\\[\da-f]{1,8}/i,
    "unit": unit,
    "boolean": /\b(?:false|true)\b/,
    "operator": [
      // We want non-word chars around "-" because it is
      // accepted in property names.
      /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
    ],
    "number": number,
    "punctuation": /[{}()\[\];:,]/
  };
  inside["interpolation"] = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: "variable",
    inside: {
      "delimiter": {
        pattern: /^\{|\}$/,
        alias: "punctuation"
      },
      rest: inside
    }
  };
  inside["func"] = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: {
      "function": /^[^(]+/,
      rest: inside
    }
  };
  Prism2.languages.stylus = {
    "atrule-declaration": {
      pattern: /(^[ \t]*)@.+/m,
      lookbehind: true,
      inside: {
        "atrule": /^@[\w-]+/,
        rest: inside
      }
    },
    "variable-declaration": {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
      lookbehind: true,
      inside: {
        "variable": /^\S+/,
        rest: inside
      }
    },
    "statement": {
      pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
      lookbehind: true,
      inside: {
        "keyword": /^\S+/,
        rest: inside
      }
    },
    // A property/value pair cannot end with a comma or a brace
    // It cannot have indented content unless it ended with a semicolon
    "property-declaration": {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
      lookbehind: true,
      inside: {
        "property": {
          pattern: /^[^\s:]+/,
          inside: {
            "interpolation": inside.interpolation
          }
        },
        rest: inside
      }
    },
    // A selector can contain parentheses only as part of a pseudo-element
    // It can span multiple lines.
    // It must end with a comma or an accolade or have indented content.
    "selector": {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
      lookbehind: true,
      inside: {
        "interpolation": inside.interpolation,
        "comment": inside.comment,
        "punctuation": /[{},]/
      }
    },
    "func": inside.func,
    "string": inside.string,
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true,
      greedy: true
    },
    "interpolation": inside.interpolation,
    "punctuation": /[{}()\[\];:.]/
  };
})(Prism);
(function(Prism2) {
  var powershell = Prism2.languages.powershell = {
    "comment": [{
      pattern: /(^|[^`])<#[\s\S]*?#>/,
      lookbehind: true
    }, {
      pattern: /(^|[^`])#.*/,
      lookbehind: true
    }],
    "string": [{
      pattern: /"(?:`[\s\S]|[^`"])*"/,
      greedy: true,
      inside: null
      // see below
    }, {
      pattern: /'(?:[^']|'')*'/,
      greedy: true
    }],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    "boolean": /\$(?:false|true)\b/i,
    "variable": /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    "function": [/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i, /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    "operator": {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    "punctuation": /[|{}[\];(),.]/
  };
  powershell.string[0].inside = {
    "function": {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: powershell
    },
    "boolean": powershell.boolean,
    "variable": powershell.variable
  };
})(Prism);
(function(Prism2) {
  var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
  var insideEqu = {
    "equation-command": {
      pattern: funcPattern,
      alias: "regex"
    }
  };
  Prism2.languages.latex = {
    "comment": /%.*/,
    // the verbatim environment prints whitespace to the document
    "cdata": {
      pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true
    },
    /*
     * equations can be between $$ $$ or $ $ or \( \) or \[ \]
     * (all are multiline)
     */
    "equation": [{
      pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
      inside: insideEqu,
      alias: "string"
    }, {
      pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true,
      inside: insideEqu,
      alias: "string"
    }],
    /*
     * arguments which are keywords or references are highlighted
     * as keywords
     */
    "keyword": {
      pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true
    },
    "url": {
      pattern: /(\\url\{)[^}]+(?=\})/,
      lookbehind: true
    },
    /*
     * section or chapter headlines are highlighted as bold so that
     * they stand out more
     */
    "headline": {
      pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true,
      alias: "class-name"
    },
    "function": {
      pattern: funcPattern,
      alias: "selector"
    },
    "punctuation": /[[\]{}&]/
  };
  Prism2.languages.tex = Prism2.languages.latex;
  Prism2.languages.context = Prism2.languages.latex;
})(Prism);
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
  Prism2.languages.nginx = {
    "comment": {
      pattern: /(^|[\s{};])#.*/,
      lookbehind: true,
      greedy: true
    },
    "directive": {
      pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: {
        "string": {
          pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
          lookbehind: true,
          greedy: true,
          inside: {
            "escape": {
              pattern: /\\["'\\nrt]/,
              alias: "entity"
            },
            "variable": variable
          }
        },
        "comment": {
          pattern: /(\s)#.*/,
          lookbehind: true,
          greedy: true
        },
        "keyword": {
          pattern: /^\S+/,
          greedy: true
        },
        // other patterns
        "boolean": {
          pattern: /(\s)(?:off|on)(?!\S)/,
          lookbehind: true
        },
        "number": {
          pattern: /(\s)\d+[a-z]*(?!\S)/i,
          lookbehind: true
        },
        "variable": variable
      }
    },
    "punctuation": /[{};]/
  };
})(Prism);
Prism.languages.vim = {
  "string": /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
  "comment": /".*/,
  "function": /\b\w+(?=\()/,
  "keyword": /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
  "builtin": /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
  "number": /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
  "operator": /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
  "punctuation": /[{}[\](),;:]/
};
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  var PLUGIN_NAME = "line-numbers";
  var NEW_LINE_EXP = /\n(?!$)/g;
  var config = Prism.plugins.lineNumbers = {
    /**
     * Get node for provided line number
     *
     * @param {Element} element pre element
     * @param {number} number line number
     * @returns {Element|undefined}
     */
    getLine: function(element, number) {
      if (element.tagName !== "PRE" || !element.classList.contains(PLUGIN_NAME)) {
        return;
      }
      var lineNumberRows = element.querySelector(".line-numbers-rows");
      if (!lineNumberRows) {
        return;
      }
      var lineNumberStart = parseInt(element.getAttribute("data-start"), 10) || 1;
      var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);
      if (number < lineNumberStart) {
        number = lineNumberStart;
      }
      if (number > lineNumberEnd) {
        number = lineNumberEnd;
      }
      var lineIndex = number - lineNumberStart;
      return lineNumberRows.children[lineIndex];
    },
    /**
     * Resizes the line numbers of the given element.
     *
     * This function will not add line numbers. It will only resize existing ones.
     *
     * @param {HTMLElement} element A `<pre>` element with line numbers.
     * @returns {void}
     */
    resize: function(element) {
      resizeElements([element]);
    },
    /**
     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
     * the current viewport.
     *
     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
     *
     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
     *
     * @type {boolean}
     */
    assumeViewportIndependence: true
  };
  function resizeElements(elements) {
    elements = elements.filter(function(e2) {
      var codeStyles = getStyles(e2);
      var whiteSpace = codeStyles["white-space"];
      return whiteSpace === "pre-wrap" || whiteSpace === "pre-line";
    });
    if (elements.length == 0) {
      return;
    }
    var infos = elements.map(function(element) {
      var codeElement = element.querySelector("code");
      var lineNumbersWrapper = element.querySelector(".line-numbers-rows");
      if (!codeElement || !lineNumbersWrapper) {
        return void 0;
      }
      var lineNumberSizer = element.querySelector(".line-numbers-sizer");
      var codeLines = codeElement.textContent.split(NEW_LINE_EXP);
      if (!lineNumberSizer) {
        lineNumberSizer = document.createElement("span");
        lineNumberSizer.className = "line-numbers-sizer";
        codeElement.appendChild(lineNumberSizer);
      }
      lineNumberSizer.innerHTML = "0";
      lineNumberSizer.style.display = "block";
      var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
      lineNumberSizer.innerHTML = "";
      return {
        element,
        lines: codeLines,
        lineHeights: [],
        oneLinerHeight,
        sizer: lineNumberSizer
      };
    }).filter(Boolean);
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var lines = info.lines;
      var lineHeights = info.lineHeights;
      var oneLinerHeight = info.oneLinerHeight;
      lineHeights[lines.length - 1] = void 0;
      lines.forEach(function(line, index2) {
        if (line && line.length > 1) {
          var e2 = lineNumberSizer.appendChild(document.createElement("span"));
          e2.style.display = "block";
          e2.textContent = line;
        } else {
          lineHeights[index2] = oneLinerHeight;
        }
      });
    });
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var lineHeights = info.lineHeights;
      var childIndex = 0;
      for (var i3 = 0; i3 < lineHeights.length; i3++) {
        if (lineHeights[i3] === void 0) {
          lineHeights[i3] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
        }
      }
    });
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var wrapper = info.element.querySelector(".line-numbers-rows");
      lineNumberSizer.style.display = "none";
      lineNumberSizer.innerHTML = "";
      info.lineHeights.forEach(function(height, lineNumber) {
        wrapper.children[lineNumber].style.height = height + "px";
      });
    });
  }
  function getStyles(element) {
    if (!element) {
      return null;
    }
    return window.getComputedStyle ? getComputedStyle(element) : element.currentStyle || null;
  }
  var lastWidth = void 0;
  window.addEventListener("resize", function() {
    if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
      return;
    }
    lastWidth = window.innerWidth;
    resizeElements(Array.prototype.slice.call(document.querySelectorAll("pre." + PLUGIN_NAME)));
  });
  Prism.hooks.add("complete", function(env) {
    if (!env.code) {
      return;
    }
    var code = (
      /** @type {Element} */
      env.element
    );
    var pre = (
      /** @type {HTMLElement} */
      code.parentNode
    );
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (code.querySelector(".line-numbers-rows")) {
      return;
    }
    if (!Prism.util.isActive(code, PLUGIN_NAME)) {
      return;
    }
    code.classList.remove(PLUGIN_NAME);
    pre.classList.add(PLUGIN_NAME);
    var match = env.code.match(NEW_LINE_EXP);
    var linesNum = match ? match.length + 1 : 1;
    var lineNumbersWrapper;
    var lines = new Array(linesNum + 1).join("<span></span>");
    lineNumbersWrapper = document.createElement("span");
    lineNumbersWrapper.setAttribute("aria-hidden", "true");
    lineNumbersWrapper.className = "line-numbers-rows";
    lineNumbersWrapper.innerHTML = lines;
    if (pre.hasAttribute("data-start")) {
      pre.style.counterReset = "linenumber " + (parseInt(pre.getAttribute("data-start"), 10) - 1);
    }
    env.element.appendChild(lineNumbersWrapper);
    resizeElements([pre]);
    Prism.hooks.run("line-numbers", env);
  });
  Prism.hooks.add("line-numbers", function(env) {
    env.plugins = env.plugins || {};
    env.plugins.lineNumbers = true;
  });
})();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  var callbacks = [];
  var map = {};
  var noop2 = function() {
  };
  Prism.plugins.toolbar = {};
  var registerButton = Prism.plugins.toolbar.registerButton = function(key, opts) {
    var callback;
    if (typeof opts === "function") {
      callback = opts;
    } else {
      callback = function(env) {
        var element;
        if (typeof opts.onClick === "function") {
          element = document.createElement("button");
          element.type = "button";
          element.addEventListener("click", function() {
            opts.onClick.call(this, env);
          });
        } else if (typeof opts.url === "string") {
          element = document.createElement("a");
          element.href = opts.url;
        } else {
          element = document.createElement("span");
        }
        if (opts.className) {
          element.classList.add(opts.className);
        }
        element.textContent = opts.text;
        return element;
      };
    }
    if (key in map) {
      return;
    }
    callbacks.push(map[key] = callback);
  };
  function getOrder(element) {
    while (element) {
      var order = element.getAttribute("data-toolbar-order");
      if (order != null) {
        order = order.trim();
        if (order.length) {
          return order.split(/\s*,\s*/g);
        } else {
          return [];
        }
      }
      element = element.parentElement;
    }
  }
  var hook = Prism.plugins.toolbar.hook = function(env) {
    var pre = env.element.parentNode;
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (pre.parentNode.classList.contains("code-toolbar")) {
      return;
    }
    var wrapper = document.createElement("div");
    wrapper.classList.add("code-toolbar");
    pre.parentNode.insertBefore(wrapper, pre);
    wrapper.appendChild(pre);
    var toolbar = document.createElement("div");
    toolbar.classList.add("toolbar");
    var elementCallbacks = callbacks;
    var order = getOrder(env.element);
    if (order) {
      elementCallbacks = order.map(function(key) {
        return map[key] || noop2;
      });
    }
    elementCallbacks.forEach(function(callback) {
      var element = callback(env);
      if (!element) {
        return;
      }
      var item = document.createElement("div");
      item.classList.add("toolbar-item");
      item.appendChild(element);
      toolbar.appendChild(item);
    });
    wrapper.appendChild(toolbar);
  };
  registerButton("label", function(env) {
    var pre = env.element.parentNode;
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (!pre.hasAttribute("data-label")) {
      return;
    }
    var element;
    var template;
    var text2 = pre.getAttribute("data-label");
    try {
      template = document.querySelector("template#" + text2);
    } catch (e2) {
    }
    if (template) {
      element = template.content;
    } else {
      if (pre.hasAttribute("data-url")) {
        element = document.createElement("a");
        element.href = pre.getAttribute("data-url");
      } else {
        element = document.createElement("span");
      }
      element.textContent = text2;
    }
    return element;
  });
  Prism.hooks.add("complete", hook);
})();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Prism.plugins.toolbar) {
    return;
  }
  function registerClipboard(element, copyInfo) {
    element.addEventListener("click", function() {
      copyTextToClipboard(copyInfo);
    });
  }
  function fallbackCopyTextToClipboard(copyInfo) {
    var textArea = document.createElement("textarea");
    textArea.value = copyInfo.getText();
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      var successful = document.execCommand("copy");
      setTimeout(function() {
        if (successful) {
          copyInfo.success();
        } else {
          copyInfo.error();
        }
      }, 1);
    } catch (err2) {
      setTimeout(function() {
        copyInfo.error(err2);
      }, 1);
    }
    document.body.removeChild(textArea);
  }
  function copyTextToClipboard(copyInfo) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(copyInfo.getText()).then(copyInfo.success, function() {
        fallbackCopyTextToClipboard(copyInfo);
      });
    } else {
      fallbackCopyTextToClipboard(copyInfo);
    }
  }
  function selectElementText(element) {
    window.getSelection().selectAllChildren(element);
  }
  function getSettings(startElement) {
    var settings = {
      "copy": "Copy",
      "copy-error": "Press Ctrl+C to copy",
      "copy-success": "Copied!",
      "copy-timeout": 5e3
    };
    var prefix = "data-prismjs-";
    for (var key in settings) {
      var attr = prefix + key;
      var element = startElement;
      while (element && !element.hasAttribute(attr)) {
        element = element.parentElement;
      }
      if (element) {
        settings[key] = element.getAttribute(attr);
      }
    }
    return settings;
  }
  Prism.plugins.toolbar.registerButton("copy-to-clipboard", function(env) {
    var element = env.element;
    var settings = getSettings(element);
    var linkCopy = document.createElement("button");
    linkCopy.className = "copy-to-clipboard-button";
    linkCopy.setAttribute("type", "button");
    var linkSpan = document.createElement("span");
    linkCopy.appendChild(linkSpan);
    setState("copy");
    registerClipboard(linkCopy, {
      getText: function() {
        return element.textContent;
      },
      success: function() {
        setState("copy-success");
        resetText();
      },
      error: function() {
        setState("copy-error");
        setTimeout(function() {
          selectElementText(element);
        }, 1);
        resetText();
      }
    });
    return linkCopy;
    function resetText() {
      setTimeout(function() {
        setState("copy");
      }, settings["copy-timeout"]);
    }
    function setState(state) {
      linkSpan.textContent = settings[state];
      linkCopy.setAttribute("data-copy-state", state);
    }
  });
})();
/*! @license DOMPurify 3.0.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.5/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf: getPrototypeOf$1,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array, transformCaseFunc) {
  var _transformCaseFunc;
  transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l2 = array.length;
  while (l2--) {
    let element = array[l2];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    newObject[property] = value;
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$1(object);
  }
  function fallbackValue(element) {
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
const svg$2 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = () => typeof window === "undefined" ? null : window;
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    return null;
  }
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.0.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  const originalDocument = window2.document;
  const currentScript = originalDocument.currentScript;
  let {
    document: document2
  } = window2;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element2,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = {};
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg$2, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let PARSER_MEDIA_TYPE;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [...text]);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  const ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  const ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, {
      element: node2
    });
    try {
      node2.parentNode.removeChild(node2);
    } catch (_2) {
      node2.remove();
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, node2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node2.getAttributeNode(name2),
        from: node2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node2
      });
    }
    node2.removeAttribute(name2);
    if (name2 === "is" && !ALLOWED_ATTR[name2]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node2);
        } catch (_2) {
        }
      } else {
        try {
          node2.setAttribute(name2, "");
        } catch (_2) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc;
    let leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_2) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  const _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(object) {
    return typeof Node2 === "object" ? object instanceof Node2 : object && typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  const _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i3 = childCount - 1; i3 >= 0; --i3) {
            parentNode.insertBefore(cloneNode(childNodes[i3], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR2, " ");
      content = stringReplace(content, ERB_EXPR2, " ");
      content = stringReplace(content, TMPLIT_EXPR2, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      )
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, "")))
      ;
    else if (value) {
      return false;
    } else
      ;
    return true;
  };
  const _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    let attr;
    let value;
    let lcName;
    let l2;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr = attributes[l2];
      const {
        name: name2,
        namespaceURI
      } = attr;
      value = name2 === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name2);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR2, " ");
        value = stringReplace(value, ERB_EXPR2, " ");
        value = stringReplace(value, TMPLIT_EXPR2, " ");
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode;
    const shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body;
    let importedNode;
    let currentNode;
    let returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR2, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
const inlineMathStart = /\$.*?\$/;
const inlineMathReg = /^\$(.*?)\$/;
const blockMathReg = /^(?:\s{0,3})\$\$((?:[^\n]|\n[^\n])+?)\n{0,1}\$\$/;
const markedTeXExtensions = (texRenderer2) => {
  const blockMathExtension = {
    name: "blockMath",
    level: "block",
    tokenizer(src) {
      const cap = blockMathReg.exec(src);
      if (cap !== null) {
        return {
          type: "html",
          raw: cap[0],
          text: texRenderer2(true, cap[1])
        };
      }
      return void 0;
    }
  };
  const inlineMathExtension = {
    name: "inlineMath",
    level: "inline",
    start(src) {
      const idx = src.search(inlineMathStart);
      return idx !== -1 ? idx : src.length;
    },
    tokenizer(src) {
      const cap = inlineMathReg.exec(src);
      if (cap !== null) {
        return {
          type: "html",
          raw: cap[0],
          text: texRenderer2(false, cap[1])
        };
      }
      return void 0;
    }
  };
  return [blockMathExtension, inlineMathExtension];
};
const parseEmoji = (text2 = "", emojiMap = {}) => text2.replace(/:(.+?):/g, (placeholder, key) => emojiMap[key] ? `<img class="wl-emoji" src="${emojiMap[key]}" alt="${key}">` : placeholder);
const texRenderer = (blockMode, tex) => {
  return katex$1.renderToString(tex, {
    throwOnError: false,
    displayMode: blockMode
  });
};
const highlighter = (code, lang) => {
  lang = Prism$1.languages[lang] ? lang : "plaintext";
  return Prism$1.highlight(code, Prism$1.languages[lang] ?? "plaintext", lang);
};
const parseMarkdown = (content, opts) => {
  const {
    emojiMap = false,
    highlight: enHl = true,
    texRender: enTex = true
  } = opts ?? {};
  marked.setOptions({
    highlight: enHl ? highlighter : void 0,
    breaks: true,
    smartLists: true,
    smartypants: true
  });
  if (enTex) {
    const extensions = markedTeXExtensions(texRenderer);
    marked.use({
      extensions
    });
  }
  if (emojiMap) {
    content = parseEmoji(content, emojiMap);
  }
  content = marked.parse(content);
  content = purify.sanitize(content);
  return content;
};
const getQuery = (element) => element.dataset.path || element.getAttribute("id");
const getWords = (content) => (
  // \u00C0-\u024F are Latin Supplement letters, maybe used in language like french
  // \u0400-\u04FF are Cyrillic letters, used in russian
  content.match(/[\w\d\s,.\u00C0-\u024F\u0400-\u04FF]+/giu)
);
const getChinese = (content) => content.match(/[\u4E00-\u9FD5]/gu);
const getWordNumber = (content) => {
  var _a3, _b2;
  return (((_a3 = getWords(content)) == null ? void 0 : _a3.reduce((accumulator, word) => accumulator + (word.trim() === "" ? 0 : word.trim().split(/\s+/u).length), 0)) || 0) + (((_b2 = getChinese(content)) == null ? void 0 : _b2.length) || 0);
};
const userAgent = async () => {
  if (!navigator) {
    return "";
  }
  const {
    userAgentData
  } = navigator;
  let ua = navigator.userAgent;
  if (!userAgentData || userAgentData.platform !== "Windows") {
    return ua;
  }
  const {
    platformVersion
  } = await userAgentData.getHighEntropyValues(["platformVersion"]);
  if (!platformVersion) {
    return ua;
  }
  const isWindows11Later = parseInt(platformVersion.split(".")[0]) >= 13;
  if (isWindows11Later) {
    ua = ua.replace("Windows NT 10.0", "Windows NT 11.0");
  }
  return ua;
};
const emoji = ref({
  tabs: [],
  map: {}
});
const emojiOrgs = ref(["https://unpkg.com/@waline/emojis@1.2.0/bmoji", "https://unpkg.com/@waline/emojis@1.2.0/bilibili", "https://unpkg.com/@waline/emojis@1.2.0/qq", "https://unpkg.com/@waline/emojis@1.2.0/weibo"]);
watch(emojiOrgs, (newOrgs) => getEmojis(newOrgs).then((config) => {
  emoji.value = config;
}), {
  immediate: true
});
const useEmoji = () => emoji;
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const {
  toString
} = Object.prototype;
const {
  getPrototypeOf
} = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const {
  isArray
} = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, {
  allOwnKeys = false
} = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i3;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i3 = 0, l2 = obj.length; i3 < l2; i3++) {
      fn.call(null, obj[i3], i3, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i3 = 0; i3 < len; i3++) {
      key = keys[i3];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i3 = keys.length;
  let _key;
  while (i3-- > 0) {
    _key = keys[i3];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const {
    caseless
  } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    arguments[i3] && forEach(arguments[i3], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, {
  allOwnKeys
} = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, {
    allOwnKeys
  });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i3;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i3 = props.length;
    while (i3-- > 0) {
      prop = props[i3];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i3 = thing.length;
  if (!isNumber(i3))
    return null;
  const arr = new Array(i3);
  while (i3-- > 0) {
    arr[i3] = thing[i3];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m2, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
const hasOwnProperty = (({
  hasOwnProperty: hasOwnProperty2
}) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const {
    length
  } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack2 = new Array(10);
  const visit = (source, i3) => {
    if (isObject(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack2[i3] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i3 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack2[i3] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
  value: true
});
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token2, i3) {
    token2 = removeBrackets(token2);
    return !dots && i3 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack2.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value);
    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack2.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i3;
  const len = keys.length;
  let key;
  for (i3 = 0; i3 < len; i3++) {
    key = keys[i3];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: platform.isNode ? "http" : "xhr",
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(isFileList2 ? {
          "files[]": data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i3;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i3 = line.indexOf(":");
    key = line.substring(0, i3).trim().toLowerCase();
    val = line.substring(i3 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i3 = keys.length;
    let deleted = false;
    while (i3--) {
      const key = keys[i3];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.reduceDescriptors(AxiosHeaders.prototype, ({
  value
}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError("Request failed with status code " + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain2, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain2)) {
          cookie.push("domain=" + domain2);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i3 = tail;
    let bytesCount = 0;
    while (i3 !== head) {
      bytesCount += bytes[i3++];
      i3 = i3 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err2) {
        reject(err2);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(fullPath);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", {
        value
      });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", {
      value
    });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const {
      length
    } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i3 = 0; i3 < length; i3++) {
      nameOrAdapter = adapters2[i3];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`, "ERR_NOT_SUPPORT");
      }
      throw new Error(utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({
        caseless
      }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.5.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i3) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i3 < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError.ERR_DEPRECATED);
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i3 = keys.length;
  while (i3-- > 0) {
    const opt = keys[i3];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const {
      transitional: transitional2,
      paramsSerializer,
      headers
    } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils.merge(headers.common, headers[config.method]);
    headers && utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i3 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i3 < len) {
        promise2 = promise2.then(chain[i3++], chain[i3++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i3 = 0;
    while (i3 < len) {
      const onFulfilled = requestInterceptorChain[i3++];
      const onRejected = requestInterceptorChain[i3++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i3 = 0;
    len = responseInterceptorChain.length;
    while (i3 < len) {
      promise2 = promise2.then(responseInterceptorChain[i3++], responseInterceptorChain[i3++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i3 = token2._listeners.length;
      while (i3-- > 0) {
        token2._listeners[i3](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, {
    allOwnKeys: true
  });
  utils.extend(instance, context, null, {
    allOwnKeys: true
  });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
const token = useAccessToken();
const userInfo = useUserInfo();
function Api(serverURL) {
  this.serverURL = getServerURL(serverURL);
  this.req = axios$1.create({
    baseURL: this.serverURL,
    headers: {
      Authorization: token.value ? `Bearer ${token.value}` : null
    }
  });
  this.req.interceptors.request.use(function(config) {
    config.headers.Authorization = token.value ? `Bearer ${token.value}` : null;
    return config;
  }, function(error) {
    return Promise.reject(error.request);
  });
  this.req.interceptors.response.use(function(resp) {
    var _a3;
    const curToken = token.value;
    const {
      authorization: auth
    } = resp.headers;
    const respToken = ((_a3 = auth == null ? void 0 : auth.match(/^Bearer (.*)/)) == null ? void 0 : _a3[1]) ?? null;
    if (respToken !== null && (!curToken || curToken !== respToken)) {
      token.value = respToken;
    }
    return resp.data;
  }, function(error) {
    if (error.response.status === 401) {
      token.value = "";
      userInfo.value = {};
      window.dispatchEvent(new Event("autologout"));
    }
    return Promise.reject(error.response);
  });
}
Api.prototype.getCommitsInfo = function(repo, page, pageSize) {
  return this.req.post("/git/commits", {
    repo,
    page,
    pageSize
  });
};
__vitePreload(() => import("./oss-e31c7595.js"), true ? [] : void 0);
__vitePreload(() => import("./captcha-dd695a5b.js"), true ? [] : void 0);
__vitePreload(() => import("./user-319f8e57.js"), true ? [] : void 0);
__vitePreload(() => import("./article-92bb7239.js"), true ? [] : void 0);
__vitePreload(() => import("./comment-b958d3df.js"), true ? [] : void 0);
const serverApi = new Api("https://www.lancree.xyz/api");
const getAbsolutePos = (element) => {
  if (!element) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  let {
    offsetLeft: x2,
    offsetTop: y3
  } = element;
  let p2 = element.offsetParent;
  const {
    offsetWidth: width,
    offsetHeight: height
  } = element;
  while (p2) {
    x2 += p2.offsetLeft;
    y3 += p2.offsetTop;
    p2 = p2.offsetParent;
  }
  return {
    x: x2,
    y: y3,
    width,
    height
  };
};
function inViewport(el) {
  if (!el || false)
    return false;
  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
  const {
    y: offsetTop,
    height
  } = getAbsolutePos(el);
  const offsetBottom = offsetTop + height;
  const scrollTop = document.documentElement.scrollTop;
  const top = offsetTop - scrollTop, bottom = offsetBottom - scrollTop;
  return top <= viewPortHeight && bottom >= 0;
}
const throttle$1 = (func, wait = 500) => {
  let timer;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      func.apply(func, args);
      timer = null;
    }, wait);
  };
};
const throttleGet = (func, wait = 500) => {
  let prom = null;
  let next = null;
  return (...args) => {
    next = args;
    if (prom) {
      return prom;
    } else {
      return prom = new Promise((res) => setTimeout(() => {
        const t2 = next;
        next = null;
        prom = null;
        res(func.apply(func, t2));
      }, wait));
    }
  };
};
function randFloat(p1 = 0, p2 = 100) {
  let max2, min2;
  if (typeof p1 === "number") {
    [max2, min2] = [p2, p1];
  } else {
    [max2, min2] = [p1.max, p1.min];
  }
  return Math.random() * (max2 - min2) + min2;
}
function randInt(p1 = 0, p2 = 100) {
  if (typeof p1 === "number") {
    return Math.floor(randFloat(p1, p2));
  } else {
    return Math.floor(randFloat(p1));
  }
}
function randElem(array) {
  return array[Math.floor(Math.random() * array.length)];
}
function inRange(val, p1 = -Infinity, p2 = Infinity) {
  let max2, min2;
  if (typeof p1 === "number") {
    [max2, min2] = [p2, p1];
  } else {
    [max2, min2] = [p1.max, p1.min];
  }
  return val >= min2 && val <= max2;
}
const isMobile = (window2) => {
  if (!window2) {
    return null;
  }
  const {
    userAgent: userAgent2
  } = window2.navigator;
  return /Android|webOS|iPhone|iPod|BlackBerry/i.test(userAgent2);
};
const bedURL = "/upload";
const imageReq = axios$1.create({
  // baseURL: "https://www.imagehub.cc"
  baseURL: bedURL
});
const imageUpload = async (file, filename) => {
  const uploadUrl = "/";
  const form = new FormData();
  form.append("source", file, filename);
  form.append("nsfw", "0");
  form.append("format", "txt");
  const headers = {
    "X-API-Key": "chv_gs0d_58903bb19f9ecfdd4b20ff3be5bfdf6f28630a7d838c8c5b6af4a0e8a4a9a42b16988d62d780c10d7d3ff526cc6bef282f8d2042335ea850e57253ba73000263"
  };
  const res = await imageReq.request({
    method: "post",
    url: uploadUrl,
    data: form,
    headers
  });
  return res.data;
};
const region = "oss-cn-wulanchabu";
const bucket = "lancree-blog-pics";
const OSS_BUCKET_HOST = `${bucket}.${region}.aliyuncs.com`;
const ossGetNameByUrl = (url) => {
  var _a3;
  return ((_a3 = url.match(new RegExp(`^https?://${OSS_BUCKET_HOST}/(.*)$`))) == null ? void 0 : _a3[1]) ?? null;
};
const getFileExtension = (filename, withdot = true) => {
  var _a3;
  return ((_a3 = filename.match(withdot ? /\.[^.]+$/ : /[^.]+$/)) == null ? void 0 : _a3[0]) ?? "";
};
const parseHTMLText = (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
function passTo(val, dest, step = 1) {
  if (dest < val) {
    val = Math.max(val - step, dest);
  } else if (dest > val) {
    val = Math.min(val + step, dest);
  }
  return val;
}
const signMap = {};
const proxy$1 = new Proxy(signMap, {
  get(target, url) {
    if (!url) {
      return ref(void 0);
    }
    const now2 = Date.now() / 1e3;
    let signUrlRef = target[url];
    if (!signUrlRef || !signUrlRef.value || signUrlRef.value.expires <= now2) {
      const expires = 1800;
      const name2 = ossGetNameByUrl(url);
      if (name2 === null) {
        throw "Url Error: Not OSS Bucket url" + url;
      }
      if (!signUrlRef)
        target[url] = signUrlRef = ref({
          url: "",
          expires: now2
        });
      serverApi.getObjectSignUrl(name2, expires).then((res) => {
        const signUrl = {
          url: res.data.url,
          expires: res.data.expire
        };
        signUrlRef.value = signUrl;
      });
    }
    return signUrlRef;
  },
  set() {
    throw "Can not manually SET this proxy.";
  },
  deleteProperty() {
    throw "Can not manually DELETE this proxy.";
  }
});
const useSignUrl = () => proxy$1;
const blobUrlMap = {};
const imgExts = ["png", "jpg", "jpeg", "png", "bmp", "tiff", "gif", "svg", "webp"];
const proxy = new Proxy(blobUrlMap, {
  get(target, url) {
    if (!url) {
      return ref(void 0);
    }
    const ext = getFileExtension(url, false);
    if (!imgExts.includes(ext)) {
      return ref("");
    }
    let urlRef = target[url];
    if (!urlRef || urlRef.value === void 0) {
      const name2 = ossGetNameByUrl(url);
      if (name2 === null) {
        const rf = computedAsync(async () => {
          const buffer = await fetch(url).then((res) => res.arrayBuffer());
          if (!buffer.byteLength) {
            delete target[url];
            return "";
          }
          const blob = new Blob([buffer]);
          const blobUrl = URL.createObjectURL(blob);
          return blobUrl;
        });
        urlRef = rf;
      } else {
        const rf = computedAsync(async () => {
          const buffer = await serverApi.getObjectSignUrl(url, 60).then((res) => fetch(res.data.url)).then((res) => res.arrayBuffer());
          if (!buffer.byteLength) {
            delete target[url];
            return "";
          }
          const blob = new Blob([buffer], {
            type: "image/" + ext
          });
          const blobUrl = URL.createObjectURL(blob);
          return blobUrl;
        });
        urlRef = rf;
      }
      if (!target[url]) {
        target[url] = urlRef;
      }
    }
    return urlRef;
  },
  set(target, url, value) {
    if (!url) {
      return false;
    }
    if (typeof value === "string" || typeof value === "function") {
      if (typeof value === "function") {
        value = value();
      }
      let urlRef = target[url];
      if (!urlRef) {
        target[url] = ref(value);
      } else
        urlRef.value = value;
    } else {
      target[url] = value;
    }
    return true;
  },
  deleteProperty(target, url) {
    return delete target[url];
  }
});
const useImageCache = () => proxy;
const initImgCache = () => {
  document.querySelectorAll("img[image-cache]").forEach((el) => {
    let src = el.getAttribute("data-source");
    if (src === null)
      return;
    watch(proxy[src], (val) => {
      el.setAttribute("src", val);
    });
  });
};
const siteData$1 = useSiteData();
const pageMap = computed(() => siteData$1.value.pageIdMap);
const usePageMap = () => pageMap;
const ARTICLE_ID_KEY = Symbol("articleId");
const ARTICLE_INFO_KEY = Symbol("articleInfo");
const _hoisted_1$1j = {
  key: 0,
  class: "wl-reaction"
};
const _hoisted_2$Y = ["textContent"];
const _hoisted_3$O = {
  class: "wl-reaction-list"
};
const _hoisted_4$D = ["onClick"];
const _hoisted_5$s = ["src", "alt"];
const _hoisted_6$n = ["textContent"];
const _hoisted_7$g = ["textContent"];
const _hoisted_8$d = ["textContent"];
const _sfc_main$1C = /* @__PURE__ */ defineComponent({
  __name: "ArticleReaction",
  setup(__props, {
    expose: __expose
  }) {
    __expose();
    const config = inject("config");
    const articleId = inject(ARTICLE_ID_KEY);
    const articleInfo = inject(ARTICLE_INFO_KEY);
    const api = inject("api");
    const msg = inject("msg");
    const token2 = useAccessToken();
    const userInfo2 = useUserInfo();
    const trends = computed(() => (articleInfo == null ? void 0 : articleInfo.value.trends) ?? {});
    const isLogin = computed(() => !!token2.value);
    const votingIndex = ref(-1);
    const locale = computed(() => config.value.locale);
    const reactionsInfo = ref([
      // ["//unpkg.com/@waline/emojis/tieba/tieba_agree.png", "点赞", "good"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_look_down.png", "好逗", "funny"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png", "哇塞", "amazing"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png", "期待", "hopeful"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_awkward.png", "摸摸", "pitiful"],
      ["(ง •̀ω•́)ง✧⃛", "点赞", "good"],
      ["╰(๑´ㅂ`๑)╯", "好逗", "funny"],
      ["∑(ʘдʘ)!!", "哇塞", "amazing"],
      ["(☆▽☆)", "期待", "hopeful"],
      ["ଘ(੭•ω•)੭( )", "摸摸", "pitiful"]
    ].map((e2) => ({
      icon: e2[0],
      desc: e2[1],
      field: e2[2]
    })));
    const active = computed(() => reactionsInfo.value.map(({
      field
    }) => {
      var _a3;
      return ((_a3 = trends.value[field]) == null ? void 0 : _a3.includes(userInfo2.value.id)) ?? false;
    }));
    let abort;
    const vote = async (index2) => {
      if (!isLogin.value) {
        msg({
          type: "warn",
          text: "登录后才能表态哦(ノ｀Д)ノ~"
        });
        return;
      }
      if (votingIndex.value === -1) {
        const userId = userInfo2.value.id;
        const field = reactionsInfo.value[index2].field;
        const ids = trends.value[field];
        const hasTrend = (ids == null ? void 0 : ids.includes(userId)) ?? false;
        votingIndex.value = index2;
        try {
          await api.toggleArticleTrend(articleId.value, userId, index2, !hasTrend);
          if (hasTrend) {
            trends.value[field].splice(ids.indexOf(userId, 1));
          } else {
            trends.value[field] ? trends.value[field].push(userId) : trends.value[field] = reactive([userId]);
          }
        } catch {
        }
        votingIndex.value = -1;
      }
    };
    onUnmounted(() => abort == null ? void 0 : abort());
    return (_ctx, _cache) => {
      return reactionsInfo.value.length ? (openBlock(), createElementBlock("div", _hoisted_1$1j, [createElementVNode("div", {
        class: "wl-reaction-title",
        textContent: toDisplayString(locale.value.reactionTitle)
      }, null, 8, _hoisted_2$Y), createElementVNode("ul", _hoisted_3$O, [(openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(reactionsInfo.value, ({
          icon,
          field,
          desc
        }, index2) => {
          var _a3;
          return openBlock(), createElementBlock("li", {
            key: index2,
            class: normalizeClass(["wl-reaction-item", {
              active: active.value[index2]
            }]),
            onClick: ($event) => vote(index2)
          }, [createElementVNode(
            "div",
            {
              class: normalizeClass(["wl-reaction-img", {
                "kaomoji-mode": !unref(isLinkHttp)(icon)
              }])
            },
            [unref(isLinkHttp)(icon) ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: icon,
              alt: desc
            }, null, 8, _hoisted_5$s)) : (openBlock(), createElementBlock("span", {
              key: 1,
              class: "kaomoji-text",
              textContent: toDisplayString(icon)
            }, null, 8, _hoisted_6$n)), votingIndex.value === index2 ? (openBlock(), createBlock(unref(LoadingIcon), {
              key: 2,
              class: "wl-reaction-loading"
            })) : (openBlock(), createElementBlock("div", {
              key: 3,
              class: "wl-reaction-votes",
              textContent: toDisplayString(((_a3 = trends.value[field]) == null ? void 0 : _a3.length) || 0)
            }, null, 8, _hoisted_7$g))],
            2
            /* CLASS */
          ), createElementVNode("div", {
            class: "wl-reaction-text",
            textContent: toDisplayString(desc)
          }, null, 8, _hoisted_8$d)], 10, _hoisted_4$D);
        }),
        128
        /* KEYED_FRAGMENT */
      ))])])) : createCommentVNode("v-if", true);
    };
  }
});
const ArticleReaction_vue_vue_type_style_index_0_lang = "";
const Reaction = /* @__PURE__ */ _export_sfc$1(_sfc_main$1C, [["__file", "ArticleReaction.vue"]]);
var e$5 = /* @__PURE__ */ new Map();
function t$5(t2) {
  var o2 = e$5.get(t2);
  o2 && o2.destroy();
}
function o$5(t2) {
  var o2 = e$5.get(t2);
  o2 && o2.update();
}
var r$7 = null;
"undefined" == typeof window ? ((r$7 = function(e2) {
  return e2;
}).destroy = function(e2) {
  return e2;
}, r$7.update = function(e2) {
  return e2;
}) : ((r$7 = function(t2, o2) {
  return t2 && Array.prototype.forEach.call(t2.length ? t2 : [t2], function(t3) {
    return function(t4) {
      if (t4 && t4.nodeName && "TEXTAREA" === t4.nodeName && !e$5.has(t4)) {
        var o3, r2 = null, n2 = window.getComputedStyle(t4), i3 = (o3 = t4.value, function() {
          a2({
            testForHeightReduction: "" === o3 || !t4.value.startsWith(o3),
            restoreTextAlign: null
          }), o3 = t4.value;
        }), l2 = (function(o4) {
          t4.removeEventListener("autosize:destroy", l2), t4.removeEventListener("autosize:update", s2), t4.removeEventListener("input", i3), window.removeEventListener("resize", s2), Object.keys(o4).forEach(function(e2) {
            return t4.style[e2] = o4[e2];
          }), e$5.delete(t4);
        }).bind(t4, {
          height: t4.style.height,
          resize: t4.style.resize,
          textAlign: t4.style.textAlign,
          overflowY: t4.style.overflowY,
          overflowX: t4.style.overflowX,
          wordWrap: t4.style.wordWrap
        });
        t4.addEventListener("autosize:destroy", l2), t4.addEventListener("autosize:update", s2), t4.addEventListener("input", i3), window.addEventListener("resize", s2), t4.style.overflowX = "hidden", t4.style.wordWrap = "break-word", e$5.set(t4, {
          destroy: l2,
          update: s2
        }), s2();
      }
      function a2(e2) {
        var o4, i4, l3 = e2.restoreTextAlign, s3 = void 0 === l3 ? null : l3, d2 = e2.testForHeightReduction, u3 = void 0 === d2 || d2, c2 = n2.overflowY;
        if (0 !== t4.scrollHeight && ("vertical" === n2.resize ? t4.style.resize = "none" : "both" === n2.resize && (t4.style.resize = "horizontal"), u3 && (o4 = function(e3) {
          for (var t5 = []; e3 && e3.parentNode && e3.parentNode instanceof Element; )
            e3.parentNode.scrollTop && t5.push([e3.parentNode, e3.parentNode.scrollTop]), e3 = e3.parentNode;
          return function() {
            return t5.forEach(function(e4) {
              var t6 = e4[0], o5 = e4[1];
              t6.style.scrollBehavior = "auto", t6.scrollTop = o5, t6.style.scrollBehavior = null;
            });
          };
        }(t4), t4.style.height = ""), i4 = "content-box" === n2.boxSizing ? t4.scrollHeight - (parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom)) : t4.scrollHeight + parseFloat(n2.borderTopWidth) + parseFloat(n2.borderBottomWidth), "none" !== n2.maxHeight && i4 > parseFloat(n2.maxHeight) ? ("hidden" === n2.overflowY && (t4.style.overflow = "scroll"), i4 = parseFloat(n2.maxHeight)) : "hidden" !== n2.overflowY && (t4.style.overflow = "hidden"), t4.style.height = i4 + "px", s3 && (t4.style.textAlign = s3), o4 && o4(), r2 !== i4 && (t4.dispatchEvent(new Event("autosize:resized", {
          bubbles: true
        })), r2 = i4), c2 !== n2.overflow && !s3)) {
          var v3 = n2.textAlign;
          "hidden" === n2.overflow && (t4.style.textAlign = "start" === v3 ? "end" : "start"), a2({
            restoreTextAlign: v3,
            testForHeightReduction: true
          });
        }
      }
      function s2() {
        a2({
          testForHeightReduction: true,
          restoreTextAlign: null
        });
      }
    }(t3);
  }), t2;
}).destroy = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], t$5), e2;
}, r$7.update = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], o$5), e2;
});
var n$7 = r$7;
const publicKey = "-----BEGIN RSA Public Key-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzoqS0WWXcXSt1dRIwMyz\nkRf7nO3I90yKRVcft+UB9UXRBR+JA/mQMFM1ITiPYcgCRfRpzRObX9WL7Ic4KRTk\nqppa7zsAnkuDbLhQdaK6AE4uyjaYu2Rf6iS8B2gkUjdi3mNM/CDQw2t2Nh0omkcI\n1ynUnpEb/G4oXMR6dSc9E7m3G9Ky/i5kBufPJj92Lx7jxN5qBzEa4aYfG1Y7uT2r\nf4QueinHeMSq659v83kIQxc6Hq9QQpwfq6W/g3oMBQOxER+jpBZyR7pmb/HH/6SL\nE96EagKSqwhReqB3TP72/Wkr1IAf3lmjyV/CNUJhqvMYvuYLr5EJhHRL678vfzV2\nawIDAQAB\n-----END RSA Public Key-----\n";
const Captcha_vue_vue_type_style_index_0_scoped_a5a46ca8_lang = "";
const _sfc_main$1B = {
  name: "GoCaptcha",
  props: {
    value: Boolean,
    width: {
      type: String,
      default: "300px"
    },
    height: {
      type: String,
      default: "240px"
    },
    calcPosType: {
      type: String,
      default: "dom",
      validator: (value) => ["dom", "screen"].includes(value)
    },
    maxDot: {
      type: Number,
      default: 5
      // validator: value => value > 10
    },
    imageBase64: String,
    thumbBase64: String
  },
  data() {
    return {
      dots: [],
      imageBase64Code: "",
      thumbBase64Code: ""
    };
  },
  watch: {
    value() {
      this.dots = [];
      this.imageBase64Code = "";
      this.thumbBase64Code = "";
    },
    imageBase64(val) {
      this.dots = [];
      this.imageBase64Code = val;
    },
    thumbBase64(val) {
      this.dots = [];
      this.thumbBase64Code = val;
    }
  },
  computed: {
    style() {
      return `width:${this.width}; height:${this.height};`;
    }
  },
  methods: {
    /**
     * @Description: 处理关闭事件
     */
    handleCloseEvent() {
      this.$emit("close");
      this.dots = [];
      this.imageBase64Code = "";
      this.thumbBase64Code = "";
    },
    /**
     * @Description: 处理刷新事件
     */
    handleRefreshEvent() {
      this.dots = [];
      this.$emit("refresh");
    },
    /**
     * @Description: 处理确认事件
     */
    handleConfirmEvent() {
      this.$emit("confirm", this.dots);
    },
    /**
     * @Description: 处理dot
     * @param ev
     */
    handleClickPos(ev) {
      if (this.dots.length >= this.maxDot) {
        return;
      }
      const e2 = ev || window.event;
      e2.preventDefault();
      const dom = e2.currentTarget;
      const {
        domX,
        domY
      } = this.getDomXY(dom);
      let mouseX = navigator.appName === "Netscape" ? e2.pageX : e2.x + document.body.offsetTop;
      let mouseY = navigator.appName === "Netscape" ? e2.pageY : e2.y + document.body.offsetTop;
      if (this.calcPosType === "screen") {
        mouseX = navigator.appName === "Netscape" ? e2.clientX : e2.x;
        mouseY = navigator.appName === "Netscape" ? e2.clientY : e2.y;
      }
      const xPos = mouseX - domX;
      const yPos = mouseY - domY;
      const xp = parseInt(xPos.toString());
      const yp = parseInt(yPos.toString());
      this.dots.push({
        x: xp - 11,
        y: yp - 11,
        index: this.dots.length + 1
      });
      return false;
    },
    /**
     * @Description: 找到元素的屏幕位置
     * @param el
     */
    calcLocationLeft(el) {
      let tmp = el.offsetLeft;
      let val = el.offsetParent;
      while (val != null) {
        tmp += val.offsetLeft;
        val = val.offsetParent;
      }
      return tmp;
    },
    /**
     * @Description: 找到元素的屏幕位置
     * @param el
     */
    calcLocationTop(el) {
      let tmp = el.offsetTop;
      let val = el.offsetParent;
      while (val != null) {
        tmp += val.offsetTop;
        val = val.offsetParent;
      }
      return tmp;
    },
    /**
     * @Description: 找到元素的屏幕位置
     * @param dom
     */
    getDomXY(dom) {
      let x2 = 0;
      let y3 = 0;
      if (dom.getBoundingClientRect) {
        let box = dom.getBoundingClientRect();
        let D2 = document.documentElement;
        x2 = box.left + Math.max(D2.scrollLeft, document.body.scrollLeft) - D2.clientLeft;
        y3 = box.top + Math.max(D2.scrollTop, document.body.scrollTop) - D2.clientTop;
      } else {
        while (dom !== document.body) {
          x2 += dom.offsetLeft;
          y3 += dom.offsetTop;
          dom = dom.offsetParent;
        }
      }
      return {
        domX: x2,
        domY: y3
      };
    }
  }
};
const _withScopeId$8 = (n2) => (pushScopeId("data-v-a5a46ca8"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1i = {
  class: "wg-cap-wrap"
};
const _hoisted_2$X = {
  class: "wg-cap-wrap__header"
};
const _hoisted_3$N = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode(
  "span",
  null,
  [/* @__PURE__ */ createTextVNode("请在下图"), /* @__PURE__ */ createElementVNode("em", null, "依次"), /* @__PURE__ */ createTextVNode("点击：")],
  -1
  /* HOISTED */
));
const _hoisted_4$C = ["src"];
const _hoisted_5$r = ["src"];
const _hoisted_6$m = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode(
  "img",
  {
    class: "wg-cap-wrap__loading",
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBzdHlsZT0ibWFyZ2luOiBhdXRvOyBiYWNrZ3JvdW5kOiByZ2JhKDI0MSwgMjQyLCAyNDMsIDApOyBkaXNwbGF5OiBibG9jazsgc2hhcGUtcmVuZGVyaW5nOiBhdXRvOyIgd2lkdGg9IjY0cHgiIGhlaWdodD0iNjRweCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIj4KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjM2LjgxMDEiIHI9IjEzIiBmaWxsPSIjM2U3Y2ZmIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImN5IiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgY2FsY01vZGU9InNwbGluZSIga2V5U3BsaW5lcz0iMC40NSAwIDAuOSAwLjU1OzAgMC40NSAwLjU1IDAuOSIga2V5VGltZXM9IjA7MC41OzEiIHZhbHVlcz0iMjM7Nzc7MjMiPjwvYW5pbWF0ZT4KICA8L2NpcmNsZT4KPC9zdmc+",
    alt: "正在加载中..."
  },
  null,
  -1
  /* HOISTED */
));
const _hoisted_7$f = {
  class: "wg-cap-wrap__footer"
};
const _hoisted_8$c = {
  class: "wg-cap-wrap__ico"
};
const _hoisted_9$a = {
  class: "wg-cap-wrap__btn"
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1i, [createElementVNode("div", _hoisted_2$X, [_hoisted_3$N, $data.thumbBase64Code ? (openBlock(), createElementBlock("img", {
    key: 0,
    class: "wg-cap-wrap__thumb",
    src: $data.thumbBase64Code,
    alt: " "
  }, null, 8, _hoisted_4$C)) : createCommentVNode("v-if", true)]), createElementVNode(
    "div",
    {
      class: "wg-cap-wrap__body",
      style: normalizeStyle($options.style)
    },
    [$data.imageBase64Code ? (openBlock(), createElementBlock("img", {
      key: 0,
      class: "wg-cap-wrap__picture",
      src: $data.imageBase64Code,
      alt: " ",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.handleClickPos($event))
    }, null, 8, _hoisted_5$r)) : createCommentVNode("v-if", true), _hoisted_6$m, (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList($data.dots, (dot, key) => {
        return openBlock(), createElementBlock(
          "div",
          {
            key,
            class: "wg-cap-wrap__dot",
            style: normalizeStyle(`top: ${dot.y}px; left:${dot.x}px;`)
          },
          [createElementVNode(
            "span",
            null,
            toDisplayString(dot.index),
            1
            /* TEXT */
          )],
          4
          /* STYLE */
        );
      }),
      128
      /* KEYED_FRAGMENT */
    ))],
    4
    /* STYLE */
  ), createElementVNode("div", _hoisted_7$f, [createElementVNode("div", _hoisted_8$c, [createElementVNode("img", {
    onClick: _cache[1] || (_cache[1] = (...args) => $options.handleCloseEvent && $options.handleCloseEvent(...args)),
    src: "data:image/svg+xml;base64,PHN2ZyB0PSIxNjI2NjE0NDM5NDIzIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9Ijg2NzUiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNNTEyIDIzLjI3MjcyN2MyNjkuOTE3MDkxIDAgNDg4LjcyNzI3MyAyMTguODEwMTgyIDQ4OC43MjcyNzMgNDg4LjcyNzI3M2E0ODYuNjMyNzI3IDQ4Ni42MzI3MjcgMCAwIDEtODQuOTQ1NDU1IDI3NS40MDk0NTUgNDYuNTQ1NDU1IDQ2LjU0NTQ1NSAwIDAgMS03Ni44NDY1NDUtNTIuNTI2NTQ2QTM5My41NDE4MTggMzkzLjU0MTgxOCAwIDAgMCA5MDcuNjM2MzY0IDUxMmMwLTIxOC41MDc2MzYtMTc3LjEyODcyNy0zOTUuNjM2MzY0LTM5NS42MzYzNjQtMzk1LjYzNjM2NFMxMTYuMzYzNjM2IDI5My40OTIzNjQgMTE2LjM2MzYzNiA1MTJzMTc3LjEyODcyNyAzOTUuNjM2MzY0IDM5NS42MzYzNjQgMzk1LjYzNjM2NGEzOTUuMTcwOTA5IDM5NS4xNzA5MDkgMCAwIDAgMTI1LjQ0LTIwLjI5MzgxOSA0Ni41NDU0NTUgNDYuNTQ1NDU1IDAgMCAxIDI5LjQ4NjU0NSA4OC4yOTY3MjhBNDg4LjI2MTgxOCA0ODguMjYxODE4IDAgMCAxIDUxMiAxMDAwLjcyNzI3M0MyNDIuMDgyOTA5IDEwMDAuNzI3MjczIDIzLjI3MjcyNyA3ODEuOTE3MDkxIDIzLjI3MjcyNyA1MTJTMjQyLjA4MjkwOSAyMy4yNzI3MjcgNTEyIDIzLjI3MjcyN3ogbS0xMTUuMiAzMDcuNzEyTDUxMiA0NDYuMTM4MTgybDExNS4yLTExNS4yYTQ2LjU0NTQ1NSA0Ni41NDU0NTUgMCAxIDEgNjUuODE1MjczIDY1Ljg2MTgxOEw1NzcuODYxODE4IDUxMmwxMTUuMiAxMTUuMmE0Ni41NDU0NTUgNDYuNTQ1NDU1IDAgMSAxLTY1Ljg2MTgxOCA2NS44MTUyNzNMNTEyIDU3Ny44NjE4MThsLTExNS4yIDExNS4yYTQ2LjU0NTQ1NSA0Ni41NDU0NTUgMCAxIDEtNjUuODE1MjczLTY1Ljg2MTgxOEw0NDYuMTM4MTgyIDUxMmwtMTE1LjItMTE1LjJhNDYuNTQ1NDU1IDQ2LjU0NTQ1NSAwIDEgMSA2NS44NjE4MTgtNjUuODE1MjczeiIgcC1pZD0iODY3NiIgZmlsbD0iIzcwNzA3MCI+PC9wYXRoPjwvc3ZnPg==",
    alt: "关闭"
  }), createElementVNode("img", {
    onClick: _cache[2] || (_cache[2] = (...args) => $options.handleRefreshEvent && $options.handleRefreshEvent(...args)),
    src: "data:image/svg+xml;base64,PHN2ZyB0PSIxNjI2NjE0NDk5NjM4IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEzNjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMTg3LjQ1NiA0MjUuMDI0YTMzNiAzMzYgMCAwIDAgMzY4LjM4NCA0MjAuMjI0IDQ4IDQ4IDAgMCAxIDEyLjU0NCA5NS4xNjggNDMyIDQzMiAwIDAgMS00NzMuNjY0LTU0MC4xNmwtNTcuMjgtMTUuMzZhMTIuOCAxMi44IDAgMCAxLTYuMjcyLTIwLjkyOGwxNTkuMTY4LTE3OS40NTZhMTIuOCAxMi44IDAgMCAxIDIyLjE0NCA1Ljg4OGw0OC4wNjQgMjM1LjA3MmExMi44IDEyLjggMCAwIDEtMTUuODA4IDE0LjkxMmwtNTcuMjgtMTUuMzZ6TTgzNi40OCA1OTkuMDRhMzM2IDMzNiAwIDAgMC0zNjguMzg0LTQyMC4yMjQgNDggNDggMCAxIDEtMTIuNTQ0LTk1LjE2OCA0MzIgNDMyIDAgMCAxIDQ3My42NjQgNTQwLjE2bDU3LjI4IDE1LjM2YTEyLjggMTIuOCAwIDAgMSA2LjI3MiAyMC45MjhsLTE1OS4xNjggMTc5LjQ1NmExMi44IDEyLjggMCAwIDEtMjIuMTQ0LTUuODg4bC00OC4wNjQtMjM1LjA3MmExMi44IDEyLjggMCAwIDEgMTUuODA4LTE0LjkxMmw1Ny4yOCAxNS4zNnoiIGZpbGw9IiM3MDcwNzAiIHAtaWQ9IjEzNjEiPjwvcGF0aD48L3N2Zz4=",
    alt: "刷新"
  })]), createElementVNode("div", _hoisted_9$a, [createElementVNode("button", {
    onClick: _cache[3] || (_cache[3] = (...args) => $options.handleConfirmEvent && $options.handleConfirmEvent(...args))
  }, "确认")])])]);
}
const GoCaptcha = /* @__PURE__ */ _export_sfc$1(_sfc_main$1B, [["render", _sfc_render$P], ["__scopeId", "data-v-a5a46ca8"], ["__file", "Captcha.vue"]]);
const CaptchaBtn_vue_vue_type_style_index_0_scoped_b53be06d_lang = "";
const _sfc_main$1A = {
  name: "GoCaptchaBtn",
  components: {
    GoCaptcha
  },
  props: {
    captStatus: {
      type: String,
      default: "default",
      validator: (value) => ["default", "check", "error", "over", "success"].includes(value)
    },
    width: String,
    height: String,
    maxDot: {
      type: Number,
      default: 5
    },
    imageBase64: String,
    thumbBase64: String
  },
  data() {
    return {
      popoverVisible: false
      // captStatus: 'default'
    };
  },
  watch: {
    popoverVisible(val) {
      if (val) {
        this.$emit("refresh");
      }
    },
    captStatus(val) {
      if (val === "over" || val === "success") {
        this.popoverVisible = false;
      }
    }
  },
  emits: ["confirm", "refresh"],
  computed: {
    style() {
      return `width:${this.width}; height:${this.height};`;
    },
    activeClass() {
      let activeClass = this.captStatus;
      return `wg-cap-active__${activeClass}`;
    }
  },
  methods: {
    handleBtnEvent() {
      setTimeout(() => {
        this.popoverVisible = true;
      }, 0);
    },
    handleRefreshEvent() {
      this.$emit("refresh");
    },
    handleConfirmEvent(data) {
      this.$emit("confirm", data);
    },
    handleCloseEvent() {
      this.popoverVisible = false;
    }
  }
};
const _withScopeId$7 = (n2) => (pushScopeId("data-v-b53be06d"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1h = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico wg-cap-btn__verify"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSLlm77lsYJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDIwMCAyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDIwMCAyMDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojM0U3Q0ZGO30KCS5zdDF7ZmlsbDojRkZGRkZGO30KPC9zdHlsZT4KPGNpcmNsZSBjbGFzcz0ic3QwIiBjeD0iMTAwIiBjeT0iMTAwIiByPSI5Ni4zIi8+CjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDAuOCw2NC40bC0zOS42LTExLjloLTIuNEw1OS4yLDY0LjRjLTEuNiwwLjgtMi44LDIuNC0yLjgsNHYyNC4xYzAsMjUuMywxNS44LDQ1LjksNDIuMyw1NC42CgljMC40LDAsMC44LDAuNCwxLjIsMC40YzAuNCwwLDAuOCwwLDEuMi0wLjRjMjYuNS04LjcsNDIuMy0yOC45LDQyLjMtNTQuNlY2OC4zQzE0My41LDY2LjgsMTQyLjMsNjUuMiwxNDAuOCw2NC40eiIvPgo8L3N2Zz4K"
  })]), /* @__PURE__ */ createElementVNode("span", {
    class: "wg-cap-btn__text"
  }, "点击按键进行人机验证")],
  -1
  /* HOISTED */
));
const _hoisted_2$W = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PHN2ZyB0PSIxNjI3MDU1NTg2NTk0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEyMTEiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMTIwLjI1OTQ1NiA1MTIuMDAxMDIzbS0xMTcuOTIzNzYgMGExMTUuMjM4IDExNS4yMzggMCAxIDAgMjM1Ljg0NzUxOSAwIDExNS4yMzggMTE1LjIzOCAwIDEgMC0yMzUuODQ3NTE5IDBaIiBwLWlkPSIxMjEyIiBmaWxsPSIjZmZhMDAwIj48L3BhdGg+PHBhdGggZD0iTTUxMS45OTk0ODggNTEyLjAwMTAyM20tMTE3LjkyMTcxMyAwYTExNS4yMzYgMTE1LjIzNiAwIDEgMCAyMzUuODQzNDI2IDAgMTE1LjIzNiAxMTUuMjM2IDAgMSAwLTIzNS44NDM0MjYgMFoiIHAtaWQ9IjEyMTMiIGZpbGw9IiNmZmEwMDAiPjwvcGF0aD48cGF0aCBkPSJNOTAzLjczOTUyMSA1MTIuMDAxMDIzbS0xMTcuOTIzNzYgMGExMTUuMjM4IDExNS4yMzggMCAxIDAgMjM1Ljg0NzUxOSAwIDExNS4yMzggMTE1LjIzOCAwIDEgMC0yMzUuODQ3NTE5IDBaIiBwLWlkPSIxMjE0IiBmaWxsPSIjZmZhMDAwIj48L3BhdGg+PC9zdmc+",
    alt: ""
  })]), /* @__PURE__ */ createElementVNode("span", {
    class: "wg-cap-btn__text"
  }, "正在进行人机验证...")],
  -1
  /* HOISTED */
));
const _hoisted_3$M = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDAgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDAgMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0VENDYzMDt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xODQsMjYuNkwxMDIuNCwyLjFoLTQuOUwxNiwyNi42Yy0zLjMsMS42LTUuNyw0LjktNS43LDguMnY0OS44YzAsNTIuMiwzMi42LDk0LjcsODcuMywxMTIuNgoJYzAuOCwwLDEuNiwwLjgsMi40LDAuOHMxLjYsMCwyLjQtMC44YzU0LjctMTgsODcuMy01OS42LDg3LjMtMTEyLjZWMzQuN0MxODkuOCwzMS41LDE4Ny4zLDI4LjIsMTg0LDI2LjZ6IE0xMzQuNSwxMjMuMQoJYzMuMSwzLjEsMy4xLDguMiwwLDExLjNjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zcy00LjEtMC44LTUuNy0yLjNMMTAwLDExMS4zbC0yMy4xLDIzLjFjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zCgljLTIsMC00LjEtMC44LTUuNy0yLjNjLTMuMS0zLjEtMy4xLTguMiwwLTExLjNMODguNywxMDBMNjUuNSw3Ni45Yy0zLjEtMy4xLTMuMS04LjIsMC0xMS4zYzMuMS0zLjEsOC4yLTMuMSwxMS4zLDBMMTAwLDg4LjcKCWwyMy4xLTIzLjFjMy4xLTMuMSw4LjItMy4xLDExLjMsMGMzLjEsMy4xLDMuMSw4LjIsMCwxMS4zTDExMS4zLDEwMEwxMzQuNSwxMjMuMXoiLz4KPC9zdmc+Cg==",
    alt: "失败"
  })]), /* @__PURE__ */ createElementVNode("span", null, [/* @__PURE__ */ createTextVNode("人机验证失败 "), /* @__PURE__ */ createElementVNode("em", null, "点击重试")])],
  -1
  /* HOISTED */
));
const _hoisted_4$B = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDAgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDAgMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0VENDYzMDt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xODQsMjYuNkwxMDIuNCwyLjFoLTQuOUwxNiwyNi42Yy0zLjMsMS42LTUuNyw0LjktNS43LDguMnY0OS44YzAsNTIuMiwzMi42LDk0LjcsODcuMywxMTIuNgoJYzAuOCwwLDEuNiwwLjgsMi40LDAuOHMxLjYsMCwyLjQtMC44YzU0LjctMTgsODcuMy01OS42LDg3LjMtMTEyLjZWMzQuN0MxODkuOCwzMS41LDE4Ny4zLDI4LjIsMTg0LDI2LjZ6IE0xMzQuNSwxMjMuMQoJYzMuMSwzLjEsMy4xLDguMiwwLDExLjNjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zcy00LjEtMC44LTUuNy0yLjNMMTAwLDExMS4zbC0yMy4xLDIzLjFjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zCgljLTIsMC00LjEtMC44LTUuNy0yLjNjLTMuMS0zLjEtMy4xLTguMiwwLTExLjNMODguNywxMDBMNjUuNSw3Ni45Yy0zLjEtMy4xLTMuMS04LjIsMC0xMS4zYzMuMS0zLjEsOC4yLTMuMSwxMS4zLDBMMTAwLDg4LjcKCWwyMy4xLTIzLjFjMy4xLTMuMSw4LjItMy4xLDExLjMsMGMzLjEsMy4xLDMuMSw4LjIsMCwxMS4zTDExMS4zLDEwMEwxMzQuNSwxMjMuMXoiLz4KPC9zdmc+Cg==",
    alt: "失败"
  })]), /* @__PURE__ */ createElementVNode("span", null, [/* @__PURE__ */ createTextVNode("点击次数过多 "), /* @__PURE__ */ createElementVNode("em", null, "点击重试")])],
  -1
  /* HOISTED */
));
const _hoisted_5$q = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    onClick: () => false,
    class: "wg-cap-state__success"
  },
  [/* @__PURE__ */ createCommentVNode(" 验证成功状态 "), /* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-state__inner"
  }, [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDAgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDAgMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6IzVFQUEyRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xODMuMywyNy4yTDEwMi40LDIuOWgtNC45TDE2LjcsMjcuMkMxMy40LDI4LjgsMTEsMzIsMTEsMzUuM3Y0OS40YzAsNTEuOCwzMi40LDkzLjksODYuNiwxMTEuNwoJYzAuOCwwLDEuNiwwLjgsMi40LDAuOGMwLjgsMCwxLjYsMCwyLjQtMC44YzU0LjItMTcuOCw4Ni42LTU5LjEsODYuNi0xMTEuN1YzNS4zQzE4OSwzMiwxODYuNiwyOC44LDE4My4zLDI3LjJ6IE0xNDYuMSw4MS40CglsLTQ4LjUsNDguNWMtMS42LDEuNi0zLjIsMi40LTUuNywyLjRjLTIuNCwwLTQtMC44LTUuNy0yLjRMNjIsMTA1LjdjLTMuMi0zLjItMy4yLTguMSwwLTExLjNjMy4yLTMuMiw4LjEtMy4yLDExLjMsMGwxOC42LDE4LjYKCWw0Mi45LTQyLjljMy4yLTMuMiw4LjEtMy4yLDExLjMsMEMxNDkuNCw3My4zLDE0OS40LDc4LjIsMTQ2LjEsODEuNEwxNDYuMSw4MS40eiIvPgo8L3N2Zz4K",
    alt: "成功"
  })]), /* @__PURE__ */ createElementVNode("span", null, "人机验证已通过")])],
  -1
  /* HOISTED */
));
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_go_captcha = resolveComponent("go-captcha");
  const _component_v_dropdown = resolveComponent("v-dropdown");
  return openBlock(), createElementBlock(
    "div",
    {
      class: "wg-cap-btn",
      style: normalizeStyle($options.style)
    },
    [createElementVNode(
      "div",
      {
        class: normalizeClass(["wg-cap-btn__inner", $options.activeClass])
      },
      [createCommentVNode(" wg-cap-active__default wg-cap-active__error wg-cap-active__over wg-cap-active__success "), createVNode(_component_v_dropdown, {
        triggers: ["click"],
        shown: $data.popoverVisible,
        placement: "top"
      }, {
        popper: withCtx(() => [createVNode(_component_go_captcha, {
          modelValue: $data.popoverVisible,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.popoverVisible = $event),
          width: "300px",
          height: "240px",
          "max-dot": $props.maxDot,
          "image-base64": $props.imageBase64,
          "thumb-base64": $props.thumbBase64,
          onClose: $options.handleCloseEvent,
          onRefresh: $options.handleRefreshEvent,
          onConfirm: $options.handleConfirmEvent
        }, null, 8, ["modelValue", "max-dot", "image-base64", "thumb-base64", "onClose", "onRefresh", "onConfirm"])]),
        default: withCtx(() => [createElementVNode("div", {
          onClick: _cache[1] || (_cache[1] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__default"
        }, [createCommentVNode(" 初始状态 "), _hoisted_1$1h]), createElementVNode("div", {
          onClick: _cache[2] || (_cache[2] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__check"
        }, [createCommentVNode(" 验证状态 "), _hoisted_2$W]), createElementVNode("div", {
          onClick: _cache[3] || (_cache[3] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__error"
        }, [createCommentVNode(" 验证失败状态 "), _hoisted_3$M]), createElementVNode("div", {
          onClick: _cache[4] || (_cache[4] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__over"
        }, [createCommentVNode(" 验证次数过多状态 "), _hoisted_4$B]), _hoisted_5$q]),
        _: 1
        /* STABLE */
      }, 8, ["shown"])],
      2
      /* CLASS */
    )],
    4
    /* STYLE */
  );
}
const GoCaptchaBtn = /* @__PURE__ */ _export_sfc$1(_sfc_main$1A, [["render", _sfc_render$O], ["__scopeId", "data-v-b53be06d"], ["__file", "CaptchaBtn.vue"]]);
const _sfc_main$1z = {
  components: {
    GoCaptchaBtn
    // GoCaptchaBtnDialog
  },
  data() {
    return {
      // 验证码数据
      captBase64: "",
      captThumbBase64: "",
      captKey: "",
      captStatus: "default",
      captExpires: 0,
      captAutoRefreshCount: 0
    };
  },
  mounted() {
    this.init();
  },
  emits: {
    over(data) {
      return true;
    }
  },
  methods: {
    init() {
      this.captStatus = "default";
      this.captAutoRefreshCount = 0;
    },
    /**
     * 处理请求验证码
     */
    handleRequestCaptCode() {
      this.captBase64 = "";
      this.captThumbBase64 = "";
      this.captKey = "";
      this.$api.getCaptcha().then((resp) => {
        const {
          data = {}
        } = resp;
        this.captBase64 = data["image_base64"] || "";
        this.captThumbBase64 = data["thumb_base64"] || "";
        this.captKey = data["captcha_key"] || "";
      }).catch((err2) => {
        this.$msg({
          text: `获取人机验证数据失败`,
          type: "warn"
        });
      });
      this.captStatus = "check";
    },
    /**
     * 处理验证码校验请求
     * @param {{ x: number, y: number }[]} dots
     */
    handleConfirm(dots) {
      if ((dots.length ?? 0) <= 0) {
        this.$msg({
          text: `请进行人机验证再操作ヾ(。￣□￣)ﾂ゜゜゜`,
          type: "info"
        });
        this.$emit("over", false);
        return;
      }
      const dotArr = dots.map((dot) => [dot.x, dot.y]).flat();
      const dotArrStr = dotArr.join(",");
      this.$api.validateCaptcha(this.captKey, dotArrStr).then((resp) => {
        this.$msg({
          text: `人机验证成功Ψ(￣∀￣)Ψ`,
          type: "success"
        });
        this.captStatus = "success";
        this.captAutoRefreshCount = 0;
        this.$emit("over", {
          dots: dotArrStr,
          key: this.captKey
        });
      }).catch((err2) => {
        this.$msg({
          text: `人机验证失败|(*′口\`): ${err2.data.what}`,
          type: "warn"
        });
        if (this.captAutoRefreshCount > 5) {
          this.captAutoRefreshCount = 0;
          this.captStatus = "over";
          return;
        }
        this.handleRequestCaptCode();
        this.captAutoRefreshCount += 1;
        this.captStatus = "error";
        this.$emit("over", false);
      });
    }
  }
};
const Index_vue_vue_type_style_index_0_scoped_34e3e3f3_lang = "";
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_go_captcha_btn = resolveComponent("go-captcha-btn");
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [createVNode(_component_go_captcha_btn, {
      class: "go-captcha-btn",
      width: "100%",
      height: "100%",
      captStatus: $data.captStatus,
      "image-base64": $data.captBase64,
      "thumb-base64": $data.captThumbBase64,
      onConfirm: $options.handleConfirm,
      onRefresh: $options.handleRequestCaptCode
    }, null, 8, ["captStatus", "image-base64", "thumb-base64", "onConfirm", "onRefresh"]), createCommentVNode("   弹窗方式   "), createCommentVNode(' <go-captcha-btn-dialog\r\n    class="go-captcha-btn"\r\n    v-model="captStatus"\r\n    width="100%"\r\n    height="50px"\r\n    :image-base64="captBase64"\r\n    :thumb-base64="captThumbBase64"\r\n    @confirm="handleConfirm"\r\n    @refresh="handleRequestCaptCode"\r\n  /> ')],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const Captcha = /* @__PURE__ */ _export_sfc$1(_sfc_main$1z, [["render", _sfc_render$N], ["__scopeId", "data-v-34e3e3f3"], ["__file", "Index.vue"]]);
const _sfc_main$1y = {
  components: {
    CaptchaBtn: Captcha
  },
  props: {
    crypt: {
      required: true,
      type: Object
    }
  },
  setup() {
    const userInfo2 = useUserInfo();
    const username = ref("");
    const password = ref("");
    const ua = ref("");
    const {
      base64
    } = useBase64(password);
    const pswdBase64 = computed(() => base64.value.slice("data:text/plain;base64,".length));
    userAgent().then((res) => ua.value = res);
    const captcha = ref(false);
    return {
      userInfo: userInfo2,
      username,
      password,
      ua,
      pswdBase64,
      captcha
    };
  },
  emits: {
    show(open = true) {
      return typeof open === "boolean";
    },
    toggle(tabName) {
      return true;
    },
    login() {
      return true;
    }
  },
  methods: {
    init() {
      this.captcha = false;
      this.$refs.captchaRef.init();
    },
    login() {
      if (!this.username || !this.password) {
        return;
      }
      if (!this.captcha) {
        this.$msg({
          type: "warn",
          text: "请先进行人机验证ψ(╰_╯)"
        });
        return;
      }
      const usernameEn = encodeURIComponent(this.crypt.encrypt(this.username));
      const passwordEn = encodeURIComponent(this.crypt.encrypt(this.pswdBase64));
      const uaEn = encodeURIComponent(this.crypt.encrypt(this.ua));
      this.captcha.remove = true;
      this.$api.login(usernameEn, passwordEn, uaEn, this.captcha).then((res) => {
        this.$api.getUserInfo(res.data.id).then((res2) => {
          this.userInfo = res2.data;
          this.$msg({
            type: "success",
            text: "登录成功ヾ(･ω･`｡)~"
          });
          this.$emit("login");
          this.$emit("show", false);
        }).catch((err2) => {
          var _a3;
          this.$msg({
            type: "error",
            text: "获取用户信息失败ヽ(°◇° )ノ: " + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
          });
          this.init();
        });
      }).catch((err2) => {
        var _a3;
        if (err2.status == 404 || err2.status == 403) {
          this.$msg({
            type: "error",
            text: err2.data.what
          });
        } else {
          this.$msg({
            type: "error",
            text: "登录失败ヽ(≧□≦)ノ: " + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
          });
        }
        this.init();
      });
    }
  }
};
const Login_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$1g = {
  class: "login-form"
};
const _hoisted_2$V = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "邮箱",
  -1
  /* HOISTED */
);
const _hoisted_3$L = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "密码",
  -1
  /* HOISTED */
);
const _hoisted_4$A = {
  class: "btn-row"
};
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CaptchaBtn = resolveComponent("CaptchaBtn");
  return openBlock(), createElementBlock("div", _hoisted_1$1g, [_hoisted_2$V, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "text",
      class: "form-input-login",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.username = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.username]])]), _hoisted_3$L, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "password",
      class: "form-input-login",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.password = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.password]])]), createElementVNode("div", null, [createVNode(
    _component_CaptchaBtn,
    {
      ref: "captchaRef",
      onOver: _cache[2] || (_cache[2] = ($event) => $setup.captcha = $event)
    },
    null,
    512
    /* NEED_PATCH */
  )]), createElementVNode("div", _hoisted_4$A, [createElementVNode("button", {
    class: "btn text",
    onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("toggle", "regis"))
  }, " 注册 "), createElementVNode("button", {
    class: "btn",
    onClick: _cache[4] || (_cache[4] = (...args) => $options.login && $options.login(...args))
  }, " 登录 ")])]);
}
const Login = /* @__PURE__ */ _export_sfc$1(_sfc_main$1y, [["render", _sfc_render$M], ["__file", "Login.vue"]]);
const _sfc_main$1x = {
  components: {
    CaptchaBtn: Captcha
  },
  props: {
    crypt: {
      required: true,
      type: Object
    }
  },
  setup() {
    const email = ref("");
    const nickname = ref("");
    const password = ref("");
    const confpswd = ref("");
    const pswdEqual = computed(() => password.value === confpswd.value);
    const captcha = ref(false);
    return {
      email,
      nickname,
      password,
      confpswd,
      pswdEqual,
      captcha
    };
  },
  emits: {
    show(open = true) {
      return typeof open === "boolean";
    },
    toggle(tabName) {
      return true;
    }
  },
  methods: {
    init() {
      this.captcha = false;
      this.$refs.captchaRef.init();
    },
    register() {
      if (!this.pswdEqual) {
        this.$msg({
          type: "error",
          text: "两次密码输入不一致ヘ(_ _ヘ)"
        });
        return;
      }
      if ([this.email, this.password, this.confpswd].some((e2) => !e2.length)) {
        this.$msg({
          type: "error",
          text: "必填信息为空ヘ(_ _ヘ)"
        });
        return;
      }
      if (!this.captcha) {
        this.$msg({
          type: "info",
          text: "请先进行人机验证ψ(╰_╯)"
        });
        return;
      }
      const emailEn = encodeURIComponent(this.crypt.encrypt(this.email));
      const passwordEn = encodeURIComponent(this.crypt.encrypt(this.password));
      this.$api.regis(this.nickname, emailEn, passwordEn, this.captcha).then(() => {
        this.$msg({
          type: "success",
          text: "注册成功(〃'▽'〃)"
        });
        this.$emit("toggle", "login");
      }).catch((err2) => {
        var _a3;
        this.$msg({
          type: "error",
          text: "注册失败ヽ(≧□≦)ノ: " + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
        });
        this.init();
      });
    }
  }
};
const Regis_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$1f = {
  class: "regis-form"
};
const _hoisted_2$U = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  [/* @__PURE__ */ createTextVNode("注册邮箱"), /* @__PURE__ */ createElementVNode("span", {
    class: "required-mark"
  })],
  -1
  /* HOISTED */
);
const _hoisted_3$K = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "昵称",
  -1
  /* HOISTED */
);
const _hoisted_4$z = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  [/* @__PURE__ */ createTextVNode("密码"), /* @__PURE__ */ createElementVNode("span", {
    class: "required-mark"
  })],
  -1
  /* HOISTED */
);
const _hoisted_5$p = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  [/* @__PURE__ */ createTextVNode("确认密码"), /* @__PURE__ */ createElementVNode("span", {
    class: "required-mark"
  })],
  -1
  /* HOISTED */
);
const _hoisted_6$l = {
  class: "btn-row"
};
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CaptchaBtn = resolveComponent("CaptchaBtn");
  return openBlock(), createElementBlock("div", _hoisted_1$1f, [_hoisted_2$U, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "text",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.email = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.email]])]), _hoisted_3$K, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "text",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.nickname = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.nickname]])]), _hoisted_4$z, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "password",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.password = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.password]])]), _hoisted_5$p, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "password",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.confpswd = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.confpswd]])]), createElementVNode("div", null, [createVNode(
    _component_CaptchaBtn,
    {
      ref: "captchaRef",
      onOver: _cache[4] || (_cache[4] = ($event) => $setup.captcha = $event)
    },
    null,
    512
    /* NEED_PATCH */
  )]), createElementVNode("div", _hoisted_6$l, [createElementVNode("button", {
    class: "btn text",
    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("toggle", "login"))
  }, " 登录 "), createElementVNode("button", {
    class: "btn",
    onClick: _cache[6] || (_cache[6] = (...args) => $options.register && $options.register(...args))
  }, " 注册 ")])]);
}
const Regis = /* @__PURE__ */ _export_sfc$1(_sfc_main$1x, [["render", _sfc_render$L], ["__file", "Regis.vue"]]);
const _sfc_main$1w = defineComponent({
  components: {
    Login,
    Regis
  },
  setup() {
    const showDialog = ref(false);
    const curTab = ref("login");
    const crypt = ref(null);
    __vitePreload(() => import("./index-f6db4958.js"), true ? [] : void 0).then(({
      default: JSEncrypt
    }) => {
      crypt.value = new JSEncrypt();
      crypt.value.setPublicKey(publicKey);
    });
    return {
      curTab,
      crypt,
      showDialog
    };
  },
  emits: {
    close(cls) {
      return typeof cls === "boolean";
    },
    login() {
      return true;
    }
  },
  methods: {
    show(open = true) {
      this.showDialog = open;
      this.$emit("close", !open);
    },
    toggle(tabName) {
      this.curTab = tabName;
    }
  }
});
const Index_vue_vue_type_style_index_0_scoped_47ac1abb_lang = "";
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Login = resolveComponent("Login");
  const _component_Regis = resolveComponent("Regis");
  const _component_GDialog = resolveComponent("GDialog");
  return openBlock(), createBlock(_component_GDialog, {
    modelValue: _ctx.showDialog,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.showDialog = $event),
    "max-width": 400
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "dialog"
    }, {
      default: withCtx(() => [_ctx.curTab === "login" ? (openBlock(), createBlock(_component_Login, {
        key: 0,
        crypt: _ctx.crypt,
        onShow: _ctx.show,
        onToggle: _ctx.toggle,
        onLogin: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("login"))
      }, null, 8, ["crypt", "onShow", "onToggle"])) : _ctx.curTab === "regis" ? (openBlock(), createBlock(_component_Regis, {
        key: 1,
        crypt: _ctx.crypt,
        onShow: _ctx.show,
        onToggle: _ctx.toggle
      }, null, 8, ["crypt", "onShow", "onToggle"])) : createCommentVNode("v-if", true)]),
      _: 1
      /* STABLE */
    })]),
    _: 1
    /* STABLE */
  }, 8, ["modelValue"]);
}
const Index = /* @__PURE__ */ _export_sfc$1(_sfc_main$1w, [["render", _sfc_render$K], ["__scopeId", "data-v-47ac1abb"], ["__file", "Index.vue"]]);
const _hoisted_1$1e = {
  key: 0,
  class: "wl-tab-wrapper"
};
const _hoisted_2$T = ["title", "onClick"];
const _hoisted_3$J = ["src", "alt"];
const _hoisted_4$y = {
  key: 0,
  class: "wl-tabs"
};
const _hoisted_5$o = ["onClick"];
const _hoisted_6$k = ["src", "alt", "title"];
const _sfc_main$1v = /* @__PURE__ */ defineComponent({
  __name: "EmojiPopup",
  props: {
    emoji: {},
    showEmoji: {
      type: Boolean
    }
  },
  emits: ["insert"],
  setup(__props) {
    const emojiTabIndex = ref(0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.emoji.tabs, (emojiItem, index2) => {
            return openBlock(), createElementBlock(
              Fragment,
              {
                key: emojiItem.name
              },
              [index2 === emojiTabIndex.value ? (openBlock(), createElementBlock("div", _hoisted_1$1e, [(openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(emojiItem.items, (key) => {
                  return openBlock(), createElementBlock("button", {
                    key,
                    type: "button",
                    title: key,
                    onClick: ($event) => _ctx.$emit("insert", `:${key}:`)
                  }, [_ctx.showEmoji ? (openBlock(), createElementBlock("img", {
                    key: 0,
                    class: "wl-emoji",
                    src: _ctx.emoji.map[key],
                    alt: key,
                    loading: "lazy",
                    referrerPolicy: "no-referrer"
                  }, null, 8, _hoisted_3$J)) : createCommentVNode("v-if", true)], 8, _hoisted_2$T);
                }),
                128
                /* KEYED_FRAGMENT */
              ))])) : createCommentVNode("v-if", true)],
              64
              /* STABLE_FRAGMENT */
            );
          }),
          128
          /* KEYED_FRAGMENT */
        )), _ctx.emoji.tabs.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_4$y, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.emoji.tabs, (emojiItem, index2) => {
            return openBlock(), createElementBlock("button", {
              key: emojiItem.name,
              type: "button",
              class: normalizeClass(["wl-tab", {
                active: emojiTabIndex.value === index2
              }]),
              onClick: ($event) => emojiTabIndex.value = index2
            }, [createElementVNode("img", {
              class: "wl-emoji",
              src: emojiItem.icon,
              alt: emojiItem.name,
              title: emojiItem.name,
              loading: "lazy",
              referrerPolicy: "no-referrer"
            }, null, 8, _hoisted_6$k)], 10, _hoisted_5$o);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])) : createCommentVNode("v-if", true)],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});
const EmojiPopup = /* @__PURE__ */ _export_sfc$1(_sfc_main$1v, [["__file", "EmojiPopup.vue"]]);
const _hoisted_1$1d = ["data-index"];
const _hoisted_2$S = ["src", "title", "onClick"];
const _sfc_main$1u = /* @__PURE__ */ defineComponent({
  __name: "ImageWall",
  props: {
    items: {
      default: () => []
    },
    columnWidth: {
      default: 300
    },
    gap: {
      default: 0
    }
  },
  emits: ["insert"],
  setup(__props, {
    expose: __expose
  }) {
    const props = __props;
    __expose();
    let resizeObserver = null;
    const wall = ref(null);
    const state = ref({});
    const columns = ref([]);
    const getColumnCount = () => {
      const count = Math.floor((wall.value.getBoundingClientRect().width + props.gap) / (props.columnWidth + props.gap));
      return count > 0 ? count : 1;
    };
    const createColumns = (count) => new Array(count).fill(null).map(() => []);
    const fillColumns = async (itemIndex) => {
      var _a3;
      if (itemIndex >= props.items.length)
        return;
      await nextTick();
      const columnDivs = Array.from(((_a3 = wall.value) == null ? void 0 : _a3.children) || []);
      const target = columnDivs.reduce((prev, curr) => curr.getBoundingClientRect().height < prev.getBoundingClientRect().height ? curr : prev);
      columns.value[Number(target.dataset.index)].push(itemIndex);
      await fillColumns(itemIndex + 1);
    };
    const redraw = async (force = false) => {
      if (columns.value.length === getColumnCount() && !force)
        return;
      columns.value = createColumns(getColumnCount());
      const scrollY = window.scrollY;
      await fillColumns(0);
      window.scrollTo({
        top: scrollY
      });
    };
    const imageLoad = (e2) => {
      state.value[e2.target.src] = true;
    };
    onMounted(() => {
      void redraw(true);
      resizeObserver = new ResizeObserver(() => {
        void redraw();
      });
      resizeObserver.observe(wall.value);
      watch(() => [props.items], () => {
        state.value = {};
        void redraw(true);
      });
      watch(() => [props.columnWidth, props.gap], () => {
        void redraw();
      });
    });
    onBeforeUnmount(() => resizeObserver.unobserve(wall.value));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          ref_key: "wall",
          ref: wall,
          class: "wl-gallery",
          style: normalizeStyle({
            gap: `${_ctx.gap}px`
          })
        },
        [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(columns.value, (column, columnIndex) => {
            return openBlock(), createElementBlock("div", {
              key: columnIndex,
              class: "wl-gallery-column",
              "data-index": columnIndex,
              style: normalizeStyle({
                gap: `${_ctx.gap}px`
              })
            }, [(openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(column, (itemIndex) => {
                return openBlock(), createElementBlock(
                  Fragment,
                  {
                    key: itemIndex
                  },
                  [createCommentVNode(" eslint-disable vue/no-static-inline-styles "), !state.value[_ctx.items[itemIndex].src] ? (openBlock(), createBlock(unref(LoadingIcon), {
                    key: 0,
                    size: 36,
                    style: {
                      "margin": "20px auto"
                    }
                  })) : createCommentVNode("v-if", true), createCommentVNode(" eslint-enable vue/no-static-inline-styles "), createElementVNode("img", {
                    class: "wl-gallery-item",
                    src: _ctx.items[itemIndex].src,
                    title: _ctx.items[itemIndex].title,
                    loading: "lazy",
                    onLoad: imageLoad,
                    onClick: ($event) => _ctx.$emit("insert", `![](${_ctx.items[itemIndex].src})`)
                  }, null, 40, _hoisted_2$S)],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))], 12, _hoisted_1$1d);
          }),
          128
          /* KEYED_FRAGMENT */
        ))],
        4
        /* STYLE */
      );
    };
  }
});
const ImageWall = /* @__PURE__ */ _export_sfc$1(_sfc_main$1u, [["__file", "ImageWall.vue"]]);
const _hoisted_1$1c = ["placeholder"];
const _hoisted_2$R = {
  key: 1,
  class: "wl-loading"
};
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  __name: "GifPopup",
  props: {
    showGif: {
      type: Boolean
    }
  },
  emits: ["insert"],
  setup(__props, {
    emit
  }) {
    const props = __props;
    const isImageListEnd = ref(false);
    const gifSearchInputRef = ref(null);
    const config = inject("config");
    const locale = computed(() => config.value.locale);
    const searchResults = reactive({
      loading: true,
      list: []
    });
    const onImageWallScroll = async (event) => {
      var _a3;
      const {
        scrollTop,
        clientHeight,
        scrollHeight
      } = event.target;
      const percent = (clientHeight + scrollTop) / scrollHeight;
      const searchOptions = config.value.search;
      const keyword = ((_a3 = gifSearchInputRef.value) == null ? void 0 : _a3.value) || "";
      if (percent < 0.9 || searchResults.loading || isImageListEnd.value)
        return;
      searchResults.loading = true;
      const searchResult = searchOptions.more && searchResults.list.length ? await searchOptions.more(keyword, searchResults.list.length) : await searchOptions.search(keyword);
      if (searchResult.length)
        searchResults.list = [...searchResults.list, ...searchOptions.more && searchResults.list.length ? await searchOptions.more(keyword, searchResults.list.length) : await searchOptions.search(keyword)];
      else
        isImageListEnd.value = true;
      searchResults.loading = false;
      setTimeout(() => {
        event.target.scrollTop = scrollTop;
      }, 50);
    };
    const onGifSearch = useDebounceFn((event) => {
      searchResults.list = [];
      isImageListEnd.value = false;
      void onImageWallScroll(event);
    }, 300);
    onMounted(() => {
      const {
        showGif
      } = toRefs(props);
      watch(showGif, async (showGif2) => {
        if (!showGif2)
          return;
        const searchOptions = config.value.search;
        if (gifSearchInputRef.value)
          gifSearchInputRef.value.value = "";
        searchResults.loading = true;
        searchResults.list = searchOptions.default ? await searchOptions.default() : await searchOptions.search("");
        searchResults.loading = false;
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [createElementVNode("input", {
          ref_key: "gifSearchInputRef",
          ref: gifSearchInputRef,
          type: "text",
          placeholder: locale.value.gifSearchPlaceholder,
          onInput: _cache[0] || (_cache[0] = //@ts-ignore
          (...args) => unref(onGifSearch) && unref(onGifSearch)(...args))
        }, null, 40, _hoisted_1$1c), searchResults.list.length ? (openBlock(), createBlock(ImageWall, {
          key: 0,
          items: searchResults.list,
          "column-width": 200,
          gap: 6,
          onInsert: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("insert", $event)),
          onScroll: onImageWallScroll
        }, null, 8, ["items"])) : createCommentVNode("v-if", true), searchResults.loading ? (openBlock(), createElementBlock("div", _hoisted_2$R, [createVNode(unref(LoadingIcon), {
          size: 30
        })])) : createCommentVNode("v-if", true)],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});
const GifPopup = /* @__PURE__ */ _export_sfc$1(_sfc_main$1t, [["__file", "GifPopup.vue"]]);
const _withScopeId$6 = (n2) => (pushScopeId("data-v-fec613ec"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1b = {
  class: "wl-preview"
};
const _hoisted_2$Q = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode(
  "hr",
  null,
  null,
  -1
  /* HOISTED */
));
const _hoisted_3$I = {
  class: "head"
};
const _hoisted_4$x = {
  class: "title"
};
const _hoisted_5$n = {
  for: "show-html",
  class: "toggle-show-html"
};
const _hoisted_6$j = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode(
  "span",
  null,
  "源码",
  -1
  /* HOISTED */
));
const _hoisted_7$e = ["innerHTML"];
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  __name: "Preview",
  props: {
    showPreview: {
      type: Boolean
    }
  },
  setup(__props) {
    const config = inject("config");
    const emoji2 = useEmoji();
    const editor = useEditor();
    const previewText = ref("");
    const showHTML = ref(false);
    const locale = computed(() => config.value.locale);
    onMounted(() => {
      watch([editor, showHTML], ([value, html2]) => {
        const parsed = parseMarkdown(value, {
          emojiMap: emoji2.value.map
        });
        previewText.value = html2 ? parseMarkdown("```html\n" + parsed + "\n```") : parsed;
      });
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock(
        "div",
        _hoisted_1$1b,
        [_hoisted_2$Q, createElementVNode("div", _hoisted_3$I, [createElementVNode(
          "div",
          _hoisted_4$x,
          toDisplayString(locale.value.preview),
          1
          /* TEXT */
        ), createElementVNode("label", _hoisted_5$n, [withDirectives(createElementVNode(
          "input",
          {
            name: "show-html",
            type: "checkbox",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showHTML.value = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [[vModelCheckbox, showHTML.value]]), _hoisted_6$j])]), createCommentVNode(" eslint-disable-next-line vue/no-v-html "), createElementVNode("div", {
          class: "wl-content",
          innerHTML: previewText.value
        }, null, 8, _hoisted_7$e)],
        512
        /* NEED_PATCH */
      )), [[vShow, _ctx.showPreview]]);
    };
  }
});
const Preview_vue_vue_type_style_index_0_scoped_fec613ec_lang = "";
const Preview = /* @__PURE__ */ _export_sfc$1(_sfc_main$1s, [["__scopeId", "data-v-fec613ec"], ["__file", "Preview.vue"]]);
const _hoisted_1$1a = {
  class: "wl-footer"
};
const _hoisted_2$P = {
  class: "wl-actions"
};
const _hoisted_3$H = {
  href: "https://guides.github.com/features/mastering-markdown/",
  title: "Markdown Guide",
  "aria-label": "Markdown is supported",
  class: "wl-action",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_4$w = ["title"];
const _hoisted_5$m = ["title"];
const _hoisted_6$i = ["title"];
const _hoisted_7$d = ["title"];
const _hoisted_8$b = {
  class: "wl-info"
};
const _hoisted_9$9 = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wl-captcha-container"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_10$8 = {
  class: "wl-text-number"
};
const _hoisted_11$7 = {
  key: 0
};
const _hoisted_12$4 = ["textContent"];
const _hoisted_13$4 = ["textContent"];
const _hoisted_14$3 = ["disabled"];
const _sfc_main$1r = /* @__PURE__ */ defineComponent({
  __name: "Footer",
  props: {
    wordNumber: {},
    wordLimit: {},
    uploadImage: {
      type: Function
    },
    isLogin: {
      type: Boolean
    },
    isSubmitting: {
      type: Boolean
    },
    isWordNumberLegal: {
      type: Boolean
    }
  },
  emits: ["insert", "change", "login", "submit"],
  setup(__props) {
    const props = __props;
    const emoji2 = inject("emoji");
    const showPreview = ref(false);
    const showEmoji = ref(false);
    const showGif = ref(false);
    const emojiButtonRef = ref(null);
    const emojiPopupRef = ref(null);
    const gifButtonRef = ref(null);
    const gifPopupRef = ref(null);
    const imageUploadRef = ref(null);
    const loginRef = ref(null);
    const config = inject("config");
    const canUploadImage = computed(() => config.value.imageUploader !== false);
    const locale = computed(() => config.value.locale);
    const popupHandler = (event) => {
      var _a3, _b2, _c, _d;
      if (!((_a3 = emojiButtonRef.value) == null ? void 0 : _a3.contains(event.target)) && !((_b2 = emojiPopupRef.value) == null ? void 0 : _b2.contains(event.target)))
        showEmoji.value = false;
      if (!((_c = gifButtonRef.value) == null ? void 0 : _c.contains(event.target)) && !((_d = gifPopupRef.value) == null ? void 0 : _d.contains(event.target)))
        showGif.value = false;
    };
    const onLogin = (event) => {
      event.preventDefault();
      loginRef.value.show(true);
    };
    const onImageUpload = () => {
      const inputElement = imageUploadRef.value;
      if (inputElement.files && canUploadImage.value)
        void props.uploadImage(inputElement.files[0]).then(() => {
          inputElement.value = "";
        });
    };
    onMounted(() => {
      document.body.addEventListener("click", popupHandler);
    }), onUnmounted(() => {
      document.body.removeEventListener("click", popupHandler);
    });
    return (_ctx, _cache) => {
      const _component_ClientOnly = resolveComponent("ClientOnly");
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [createVNode(Preview, {
          "show-preview": showPreview.value
        }, null, 8, ["show-preview"]), createElementVNode("div", _hoisted_1$1a, [createElementVNode("div", _hoisted_2$P, [createElementVNode("a", _hoisted_3$H, [createVNode(unref(MarkdownIcon))]), withDirectives(createElementVNode("button", {
          ref_key: "emojiButtonRef",
          ref: emojiButtonRef,
          type: "button",
          class: normalizeClass(["wl-action", {
            active: showEmoji.value
          }]),
          title: locale.value.emoji,
          onClick: _cache[0] || (_cache[0] = ($event) => showEmoji.value = !showEmoji.value)
        }, [createVNode(unref(EmojiIcon))], 10, _hoisted_4$w), [[vShow, unref(emoji2).tabs.length]]), unref(config).search ? (openBlock(), createElementBlock("button", {
          key: 0,
          ref_key: "gifButtonRef",
          ref: gifButtonRef,
          type: "button",
          class: normalizeClass(["wl-action", {
            active: showGif.value
          }]),
          title: locale.value.gif,
          onClick: _cache[1] || (_cache[1] = ($event) => showGif.value = !showGif.value)
        }, [createVNode(unref(GifIcon))], 10, _hoisted_5$m)) : createCommentVNode("v-if", true), createElementVNode(
          "input",
          {
            id: "wl-image-upload",
            ref_key: "imageUploadRef",
            ref: imageUploadRef,
            class: "upload",
            type: "file",
            accept: ".png,.jpg,.jpeg,.webp,.bmp,.gif",
            onChange: onImageUpload
          },
          null,
          544
          /* HYDRATE_EVENTS, NEED_PATCH */
        ), canUploadImage.value ? (openBlock(), createElementBlock("label", {
          key: 1,
          for: "wl-image-upload",
          class: "wl-action",
          title: locale.value.uploadImage
        }, [createVNode(unref(ImageIcon))], 8, _hoisted_6$i)) : createCommentVNode("v-if", true), createElementVNode("button", {
          type: "button",
          class: normalizeClass(["wl-action", {
            active: showPreview.value
          }]),
          title: locale.value.preview,
          onClick: _cache[2] || (_cache[2] = ($event) => showPreview.value = !showPreview.value)
        }, [createVNode(unref(PreviewIcon))], 10, _hoisted_7$d)]), createElementVNode("div", _hoisted_8$b, [_hoisted_9$9, createElementVNode("div", _hoisted_10$8, [createTextVNode(
          toDisplayString(_ctx.wordNumber) + " ",
          1
          /* TEXT */
        ), unref(config).wordLimit ? (openBlock(), createElementBlock("span", _hoisted_11$7, [createTextVNode("  /  "), createElementVNode("span", {
          class: normalizeClass({
            illegal: !_ctx.isWordNumberLegal
          }),
          textContent: toDisplayString(_ctx.wordLimit)
        }, null, 10, _hoisted_12$4)])) : createCommentVNode("v-if", true), createTextVNode(
          "  " + toDisplayString(locale.value.word),
          1
          /* TEXT */
        )]), unref(config).login !== "disable" && !_ctx.isLogin ? (openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          class: "wl-btn",
          onClick: onLogin,
          textContent: toDisplayString(locale.value.login)
        }, null, 8, _hoisted_13$4)) : createCommentVNode("v-if", true), unref(config).login !== "force" || _ctx.isLogin ? (openBlock(), createElementBlock("button", {
          key: 1,
          type: "submit",
          class: "primary wl-btn",
          title: "Cmd|Ctrl + Enter",
          disabled: _ctx.isSubmitting,
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("submit"))
        }, [_ctx.isSubmitting ? (openBlock(), createBlock(unref(LoadingIcon), {
          key: 0,
          size: 16
        })) : (openBlock(), createElementBlock(
          Fragment,
          {
            key: 1
          },
          [createTextVNode(
            toDisplayString(locale.value.submit),
            1
            /* TEXT */
          )],
          64
          /* STABLE_FRAGMENT */
        ))], 8, _hoisted_14$3)) : createCommentVNode("v-if", true)]), createElementVNode(
          "div",
          {
            ref_key: "gifPopupRef",
            ref: gifPopupRef,
            class: normalizeClass(["wl-gif-popup", {
              display: showGif.value
            }])
          },
          [createVNode(GifPopup, {
            "show-gif": showGif.value,
            onInsert: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("insert", $event))
          }, null, 8, ["show-gif"])],
          2
          /* CLASS */
        ), createElementVNode(
          "div",
          {
            ref_key: "emojiPopupRef",
            ref: emojiPopupRef,
            class: normalizeClass(["wl-emoji-popup", {
              display: showEmoji.value
            }])
          },
          [createVNode(EmojiPopup, {
            emoji: unref(emoji2),
            "show-emoji": showEmoji.value,
            onInsert: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("insert", $event))
          }, null, 8, ["emoji", "show-emoji"])],
          2
          /* CLASS */
        ), createVNode(_component_ClientOnly, null, {
          default: withCtx(() => [createVNode(
            unref(Index),
            {
              ref_key: "loginRef",
              ref: loginRef,
              onLogin: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("login"))
            },
            null,
            512
            /* NEED_PATCH */
          )]),
          _: 1
          /* STABLE */
        })])],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});
const Footer$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1r, [["__file", "Footer.vue"]]);
const _sfc_main$1q = defineComponent({
  setup() {
    const userInfo2 = useUserInfo();
    const showDialog = ref(false);
    const avatarUrl = ref(userInfo2.value.avatar ?? "");
    const oldAvatarUrl = ref(userInfo2.value.avatar ?? "");
    const nickname = ref(userInfo2.value.nickname ?? "");
    const imageValid = ref(false);
    const imageCache = useImageCache();
    const getImageViewUrl = throttleGet((url) => imageCache[url], 3e3);
    const viewAvatarUrl = computedAsync(async () => {
      const res = await getImageViewUrl(avatarUrl.value);
      return res.value;
    });
    return {
      userInfo: userInfo2,
      showDialog,
      avatarUrl,
      oldAvatarUrl,
      nickname,
      imageValid,
      imageCache,
      viewAvatarUrl
    };
  },
  watch: {
    showDialog(show) {
      if (show) {
        this.avatarUrl = this.userInfo.avatar ?? "";
        this.oldAvatarUrl = this.userInfo.avatar ?? "";
        this.nickname = this.userInfo.nickname ?? "";
      }
    },
    userInfo(newInfo) {
      this.avatarUrl = newInfo.avatar ?? "";
      this.nickname = newInfo.nickname ?? "";
    }
  },
  methods: {
    show(open = true) {
      this.showDialog = open;
    },
    onUpload() {
      const inputElement = this.$refs.avatarUploadRef;
      if (this.userInfo.id && inputElement.files) {
        const file = inputElement.files[0];
        const suf = getFileExtension(file.name);
        const filename = `avatar/avatar_${this.userInfo.id}_${Date.now().toString(36)}${suf}`;
        this.$api.putObject(this.userInfo.id, filename, file).then((res) => {
          this.$msg({
            type: "success",
            text: "头像上传成功"
          });
          this.avatarUrl = res.data.url;
        }).catch((err2) => {
          this.$msg({
            type: "error",
            text: "头像上传失败: " + err2.message
          });
        });
      }
    },
    async onModify() {
      let succ = true;
      if (this.avatarUrl !== this.userInfo.avatar) {
        succ && (succ = await this.modify("avatar", this.avatarUrl, () => this.userInfo.avatar = this.avatarUrl));
      }
      if (this.nickname !== this.userInfo.nickname) {
        succ && (succ = await this.modify("nickname", this.nickname, () => this.userInfo.nickname = this.nickname));
      }
      if (succ)
        this.show(false);
    },
    async modify(field, value, cb) {
      var _a3;
      try {
        await this.$api.modifyUserInfo(this.userInfo.id, field, value);
        this.oldAvatarUrl = this.avatarUrl;
        cb();
        return true;
      } catch (err2) {
        this.$msg({
          type: "error",
          text: `修改${{
            avatar: "头像",
            nickname: "昵称"
          }[field]}失败: ` + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
        });
        return false;
      }
    }
  }
});
const LoginInfoDialog_vue_vue_type_style_index_0_scoped_8e20da87_lang = "";
const _withScopeId$5 = (n2) => (pushScopeId("data-v-8e20da87"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$19 = {
  class: "form"
};
const _hoisted_2$O = {
  class: "form-avatar-preview"
};
const _hoisted_3$G = ["src"];
const _hoisted_4$v = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "头像",
  -1
  /* HOISTED */
));
const _hoisted_5$l = {
  class: "form-row"
};
const _hoisted_6$h = {
  class: "btn input-right",
  for: "avatarUpload"
};
const _hoisted_7$c = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "昵称",
  -1
  /* HOISTED */
));
const _hoisted_8$a = {
  class: "btn-row"
};
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  const _component_GDialog = resolveComponent("GDialog");
  return openBlock(), createBlock(_component_GDialog, {
    modelValue: _ctx.showDialog,
    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.showDialog = $event),
    "max-width": 400
  }, {
    default: withCtx(() => [createElementVNode("div", _hoisted_1$19, [withDirectives(createElementVNode(
      "div",
      _hoisted_2$O,
      [createElementVNode("img", {
        class: "form-img",
        src: _ctx.viewAvatarUrl,
        onLoad: _cache[0] || (_cache[0] = ($event) => _ctx.imageValid = true),
        onError: _cache[1] || (_cache[1] = ($event) => _ctx.imageValid = false)
      }, null, 40, _hoisted_3$G)],
      512
      /* NEED_PATCH */
    ), [[vShow, _ctx.imageValid]]), _hoisted_4$v, createElementVNode("div", _hoisted_5$l, [withDirectives(createElementVNode(
      "input",
      {
        class: "form-input with-btn",
        type: "text",
        placeholder: "输入头像图片地址..",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.avatarUrl = $event)
      },
      null,
      512
      /* NEED_PATCH */
    ), [[vModelText, _ctx.avatarUrl]]), createElementVNode("label", _hoisted_6$h, [createVNode(_component_xicons, {
      icon: "Upload"
    }, {
      default: withCtx(() => [createTextVNode("上传")]),
      _: 1
      /* STABLE */
    })]), withDirectives(createElementVNode(
      "input",
      {
        id: "avatarUpload",
        name: "avatarUpload",
        ref: "avatarUploadRef",
        type: "file",
        accept: ".png,.jpg,.jpeg,.webp,.bmp,.gif",
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.onUpload && _ctx.onUpload(...args))
      },
      null,
      544
      /* HYDRATE_EVENTS, NEED_PATCH */
    ), [[vShow, false]]), createCommentVNode(' <button class="" @click="onUpload"></button> ')]), _hoisted_7$c, createElementVNode("div", null, [withDirectives(createElementVNode(
      "input",
      {
        type: "text",
        placeholder: "输入昵称..",
        class: "form-input",
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.nickname = $event)
      },
      null,
      512
      /* NEED_PATCH */
    ), [[vModelText, _ctx.nickname]])]), createElementVNode("div", _hoisted_8$a, [createElementVNode("button", {
      class: "btn",
      onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onModify && _ctx.onModify(...args))
    }, " 提交 ")])])]),
    _: 1
    /* STABLE */
  }, 8, ["modelValue"]);
}
const LoginInfoDialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$1q, [["render", _sfc_render$J], ["__scopeId", "data-v-8e20da87"], ["__file", "LoginInfoDialog.vue"]]);
const _hoisted_1$18 = {
  key: 0,
  class: "wl-login-info"
};
const _hoisted_2$N = {
  class: "wl-avatar"
};
const _hoisted_3$F = ["title"];
const _hoisted_4$u = ["src"];
const _hoisted_5$k = {
  key: 1,
  class: "no-indent wl-avatar-alttext"
};
const _hoisted_6$g = ["textContent"];
const _sfc_main$1p = /* @__PURE__ */ defineComponent({
  __name: "LoginInfo",
  props: {
    isLogin: {
      type: Boolean
    },
    cmtEdit: {}
  },
  emits: ["logout"],
  setup(__props, {
    emit
  }) {
    const config = inject("config");
    const token2 = useAccessToken();
    const userInfo2 = useUserInfo();
    const imageCache = useImageCache();
    const dialogRef = ref(null);
    const locale = computed(() => config.value.locale);
    const userDisplayName = computed(() => userInfo2.value.nickname || userInfo2.value.id);
    const viewAvatarUrl = imageCache[userInfo2.value.avatar];
    const onLogout = () => {
      token2.value = "";
      userInfo2.value = {};
      emit("logout");
    };
    const onProfile = (event) => {
      event.preventDefault();
      dialogRef.value.show();
    };
    return (_ctx, _cache) => {
      var _a3;
      return unref(config).login !== "disable" && _ctx.isLogin && !((_a3 = _ctx.cmtEdit) == null ? void 0 : _a3.id) ? (openBlock(), createElementBlock("div", _hoisted_1$18, [createElementVNode("div", _hoisted_2$N, [createElementVNode("button", {
        type: "submit",
        class: "wl-logout-btn",
        title: locale.value.logout,
        onClick: onLogout
      }, [createVNode(unref(CloseIcon), {
        size: 14
      })], 8, _hoisted_3$F), createElementVNode("a", {
        href: "#",
        class: "wl-login-nick",
        "aria-label": "Profile",
        title: "点击修改头像",
        onClick: onProfile
      }, [unref(userInfo2).avatar ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: unref(viewAvatarUrl),
        alt: "avatar"
      }, null, 8, _hoisted_4$u)) : (openBlock(), createElementBlock("p", _hoisted_5$k, "暂无头像"))])]), createElementVNode("a", {
        href: "#",
        class: "wl-login-nick",
        "aria-label": "Profile",
        title: "点击修改头像",
        onClick: onProfile,
        textContent: toDisplayString(userDisplayName.value)
      }, null, 8, _hoisted_6$g), createVNode(
        LoginInfoDialog,
        {
          ref_key: "dialogRef",
          ref: dialogRef
        },
        null,
        512
        /* NEED_PATCH */
      )])) : createCommentVNode("v-if", true);
    };
  }
});
const LoginInfo_vue_vue_type_style_index_0_scoped_4659fbd4_lang = "";
const LoginInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$1p, [["__scopeId", "data-v-4659fbd4"], ["__file", "LoginInfo.vue"]]);
const _hoisted_1$17 = {
  class: "wl-comment"
};
const _hoisted_2$M = {
  class: "wl-panel"
};
const _hoisted_3$E = ["placeholder"];
const _hoisted_4$t = ["title"];
const _sfc_main$1o = /* @__PURE__ */ defineComponent({
  __name: "Index",
  props: {
    cmtEdit: {
      default: null
    },
    rootId: {
      default: ""
    },
    replyId: {
      default: ""
    },
    replyUserId: {},
    replyUser: {
      default: ""
    }
  },
  emits: ["log", "cancelEdit", "cancelReply", "submit"],
  setup(__props, {
    expose: __expose,
    emit
  }) {
    const props = __props;
    __expose();
    const articleId = inject("articleId");
    const config = inject("config");
    const api = inject("api");
    inject("emoji");
    const msg = inject("msg");
    const editor = useEditor();
    const userMeta = useUserMeta();
    const userInfo2 = useUserInfo();
    const token2 = useAccessToken();
    ref({});
    const editorRef = ref(null);
    const footerRef = ref(null);
    const wordNumber = ref(0);
    const wordLimit = ref(0);
    const isWordNumberLegal = ref(false);
    const content = ref("");
    const isSubmitting = ref(false);
    const isLogin = computed(() => Boolean(token2.value));
    const locale = computed(() => config.value.locale);
    const canUploadImage = computed(() => config.value.imageUploader !== false);
    const insert = (content2) => {
      const textArea = editorRef.value;
      const startPosition = textArea.selectionStart;
      const endPosition = textArea.selectionEnd || 0;
      const scrollTop = textArea.scrollTop;
      editor.value = textArea.value.substring(0, startPosition) + content2 + textArea.value.substring(endPosition, textArea.value.length);
      textArea.focus();
      textArea.selectionStart = startPosition + content2.length;
      textArea.selectionEnd = startPosition + content2.length;
      textArea.scrollTop = scrollTop;
    };
    const onKeyDown = (event) => {
      const key = event.key;
      if ((event.ctrlKey || event.metaKey) && key === "Enter")
        void submitComment();
    };
    const uploadImage = (file) => {
      const uploadText = `![${config.value.locale.uploading} ${file.name}]()`;
      insert(uploadText);
      isSubmitting.value = true;
      const suf = getFileExtension(file.name);
      const uploadFilename = "image_" + Date.now().toString(36) + suf;
      return Promise.resolve().then(() => imageUpload(file, uploadFilename)).then((url) => {
        editor.value = editor.value.replace(uploadText, `\r
![${file.name}](${url})`);
      }).catch((err2) => {
        msg({
          type: "error",
          text: "图片" + uploadFilename + "上传失败: " + err2.message
        });
        editor.value = editor.value.replace(uploadText, `![上传失败 ${file.name}]()`);
      }).then(() => {
        isSubmitting.value = false;
      });
    };
    const onDrop = (event) => {
      var _a3;
      if ((_a3 = event.dataTransfer) == null ? void 0 : _a3.items) {
        const file = getImageFromDataTransfer(event.dataTransfer.items);
        if (file && canUploadImage.value) {
          void uploadImage(file);
          event.preventDefault();
        }
      }
    };
    const onPaste = (event) => {
      if (event.clipboardData) {
        const file = getImageFromDataTransfer(event.clipboardData.items);
        if (file && canUploadImage.value)
          void uploadImage(file);
      }
    };
    const onClose = () => {
      if (props.replyId) {
        emit("cancelReply");
      } else {
        emit("cancelEdit");
      }
    };
    const submitComment = async () => {
      var _a3, _b2, _c;
      const {
        login,
        wordLimit: wordLimit2,
        // requiredMeta,
        recaptchaV3Key,
        turnstileKey
      } = config.value;
      const cmt = {
        id: articleId.value,
        userId: userMeta.value.nick,
        content: content.value,
        meta: {
          userAgent: await userAgent()
        }
        // email: userMeta.value.mail,
        // link: userMeta.value.link,
        // ua,
      };
      if (token2.value) {
        cmt.userId = userInfo2.value.id;
      } else {
        if (login === "force")
          return;
        if (!cmt.userId)
          cmt.userId = locale.value.anonymous;
      }
      if (!cmt.content) {
        (_a3 = editorRef.value) == null ? void 0 : _a3.focus();
        return;
      }
      if (!isWordNumberLegal.value)
        return alert(locale.value.wordHint.replace("$0", wordLimit2[0].toString()).replace("$1", wordLimit2[1].toString()).replace("$2", wordNumber.value.toString()));
      cmt.content = purify.sanitize(cmt.content);
      cmt.content = encodeURIComponent(cmt.content);
      if (props.replyId && props.rootId) {
        cmt.replyTo = props.replyId;
        cmt.replyUserId = props.replyUserId;
        cmt.replyRoot = props.rootId;
      }
      isSubmitting.value = true;
      try {
        if (recaptchaV3Key)
          cmt.recaptchaV3 = await useReCaptcha(recaptchaV3Key).execute("social");
        if (turnstileKey)
          cmt.turnstile = await useTurnstile(turnstileKey).execute("social");
        const resp = await (props.cmtEdit ? api.editComment(articleId.value, props.cmtEdit.id, cmt.replyRoot ?? props.cmtEdit.id, cmt.content) : api.addComment(articleId.value, userInfo2.value.id, cmt.content, cmt.meta, cmt.replyTo, cmt.replyUserId, cmt.replyRoot));
        const newCmt = props.cmtEdit ? {
          ...props.cmtEdit,
          content: content.value
        } : {
          ...resp.data,
          user: userInfo2.value
        };
        emit("submit", newCmt, !props.cmtEdit);
        isSubmitting.value = false;
        editor.value = "";
        if (props.replyId)
          emit("cancelReply");
        if ((_b2 = props.cmtEdit) == null ? void 0 : _b2.id)
          emit("cancelEdit");
      } catch (err2) {
        isSubmitting.value = false;
        alert(((_c = err2.data) == null ? void 0 : _c.what) || err2.status);
      }
    };
    watch(userInfo2, () => emit("log"));
    watch([config, wordNumber], ([config2, wordNumber2]) => {
      const {
        wordLimit: limit
      } = config2;
      if (limit) {
        if (wordNumber2 < limit[0] && limit[0] !== 0) {
          wordLimit.value = limit[0];
          isWordNumberLegal.value = false;
        } else if (wordNumber2 > limit[1]) {
          wordLimit.value = limit[1];
          isWordNumberLegal.value = false;
        } else {
          wordLimit.value = limit[1];
          isWordNumberLegal.value = true;
        }
      } else {
        wordLimit.value = 0;
        isWordNumberLegal.value = true;
      }
    }, {
      immediate: true
    });
    onMounted(() => {
      var _a3;
      if ((_a3 = props.cmtEdit) == null ? void 0 : _a3.id) {
        editor.value = decodeURIComponent(props.cmtEdit.content);
      }
      watch(() => editor.value, (value) => {
        content.value = value;
        wordNumber.value = getWordNumber(value);
        if (value)
          n$7(editorRef.value);
        else
          n$7.destroy(editorRef.value);
      }, {
        immediate: true
      });
    });
    onUnmounted(() => {
    });
    return (_ctx, _cache) => {
      var _a3;
      return openBlock(), createElementBlock("div", _hoisted_1$17, [createCommentVNode(" 左侧头像昵称信息栏（仅添加评论显示） "), createVNode(LoginInfo, {
        "is-login": isLogin.value,
        "cmt-edit": _ctx.cmtEdit,
        onLogout: _cache[0] || (_cache[0] = () => {
        })
      }, null, 8, ["is-login", "cmt-edit"]), createCommentVNode(" 评论编辑框 "), createElementVNode("div", _hoisted_2$M, [createCommentVNode(' <div v-if="config.login !== \'force\' && config.meta.length && !isLogin" class="wl-header"\r\n        :class="`item${config.meta.length}`">\r\n        <div v-for="kind in config.meta" :key="kind" class="wl-header-item">\r\n          <label :for="`wl-${kind}`" v-text="locale[kind] +\r\n            (config.requiredMeta.includes(kind) || !config.requiredMeta.length\r\n              ? \'\'\r\n              : `(${locale.optional})`)\r\n            " />\r\n\r\n          <input :id="`wl-${kind}`" :ref="(element) => {\r\n              if (element) inputRefs[kind] = element as HTMLInputElement;\r\n            }\r\n            " v-model="userMeta[kind]" class="wl-input" :class="`wl-${kind}`" :name="kind"\r\n            :type="kind === \'mail\' ? \'email\' : \'text\'" />\r\n        </div>\r\n      </div> '), withDirectives(createElementVNode("textarea", {
        id: "wl-edit",
        ref_key: "editorRef",
        ref: editorRef,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(editor) ? editor.value = $event : null),
        class: "wl-editor",
        placeholder: _ctx.replyUser ? `回复 @${_ctx.replyUser}:` : locale.value.placeholder,
        onKeydown: onKeyDown,
        onDrop,
        onPaste
      }, null, 40, _hoisted_3$E), [[vModelText, unref(editor)]]), createVNode(Footer$1, {
        ref_key: "footerRef",
        ref: footerRef,
        "word-number": wordNumber.value,
        "word-limit": wordLimit.value,
        "upload-image": uploadImage,
        "is-submitting": isSubmitting.value,
        "is-login": isLogin.value,
        "is-word-number-legal": isWordNumberLegal.value,
        onInsert: _cache[2] || (_cache[2] = ($event) => insert($event)),
        onLogin: _cache[3] || (_cache[3] = () => {
        }),
        onSubmit: submitComment
      }, null, 8, ["word-number", "word-limit", "is-submitting", "is-login", "is-word-number-legal"])]), _ctx.replyId || ((_a3 = _ctx.cmtEdit) == null ? void 0 : _a3.id) ? (openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: "wl-close",
        title: locale.value.cancelReply,
        onClick: onClose
      }, [createVNode(unref(CloseIcon), {
        size: 24
      })], 8, _hoisted_4$t)) : createCommentVNode("v-if", true)]);
    };
  }
});
const CommentBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$1o, [["__file", "Index.vue"]]);
const _hoisted_1$16 = ["id"];
const _hoisted_2$L = {
  class: "wl-user",
  "aria-hidden": "true"
};
const _hoisted_3$D = ["src"];
const _hoisted_4$s = {
  class: "wl-head"
};
const _hoisted_5$j = {
  class: "wl-nick"
};
const _hoisted_6$f = ["href"];
const _hoisted_7$b = {
  key: 1,
  class: "wl-nick-text"
};
const _hoisted_8$9 = ["textContent"];
const _hoisted_9$8 = ["textContent"];
const _hoisted_10$7 = ["textContent"];
const _hoisted_11$6 = ["textContent"];
const _hoisted_12$3 = ["textContent"];
const _hoisted_13$3 = ["data-value", "textContent"];
const _hoisted_14$2 = {
  class: "wl-comment-actions"
};
const _hoisted_15$1 = ["title"];
const _hoisted_16$1 = ["title"];
const _hoisted_17 = ["textContent"];
const _hoisted_18 = ["title"];
const _hoisted_19 = ["textContent"];
const _hoisted_20 = {
  class: "wl-meta",
  "aria-hidden": "true"
};
const _hoisted_21 = ["data-value", "textContent"];
const _hoisted_22 = ["data-value", "textContent"];
const _hoisted_23 = {
  key: 0,
  class: "wl-reply-name"
};
const _hoisted_24 = {
  key: 1,
  class: "wl-waiting-text"
};
const _hoisted_25 = ["innerHTML"];
const _hoisted_26 = {
  key: 3,
  class: "wl-admin-actions"
};
const _hoisted_27 = {
  class: "wl-comment-status"
};
const _hoisted_28 = ["disabled", "onClick", "textContent"];
const _hoisted_29 = {
  key: 5,
  class: "wl-quote"
};
const _sfc_main$1n = /* @__PURE__ */ defineComponent({
  __name: "CommentCard",
  props: {
    comment: {},
    replyCmt: {},
    rootCmt: {},
    cmtEdit: {
      default: null
    },
    cmtReply: {
      default: null
    }
  },
  emits: ["log", "submit", "delete", "edit", "like", "status", "sticky", "reply"],
  setup(__props) {
    var _a3;
    const props = __props;
    inject("articleId");
    const config = inject("config");
    const emoji2 = inject("emoji");
    const commentStatus = ["approved", "waiting", "spam"];
    const {
      comment
    } = toRefs(props);
    const now2 = useNow();
    const token2 = useAccessToken();
    const userInfo2 = useUserInfo();
    const imageCache = useImageCache();
    const locale = computed(() => config.value.locale);
    const link = computed(() => {
      const {
        user
      } = comment.value;
      if (!user)
        return "";
      const link2 = user.meta.link;
      return link2 ? isLinkHttp(link2) ? link2 : `https://${link2}` : "";
    });
    const isLogin = computed(() => !!token2.value);
    const isLiked = computed(() => {
      var _a4, _b2;
      return !!((_b2 = (_a4 = comment.value.meta) == null ? void 0 : _a4.likes) == null ? void 0 : _b2.includes(userInfo2.value.id));
    });
    const time = computed(() => getTimeAgo(new Date(comment.value.time), now2.value, locale.value));
    const viewAvatarUrl = imageCache[(_a3 = comment.value.user) == null ? void 0 : _a3.avatar];
    const contentHTML = computed(() => {
      const {
        content
      } = comment.value;
      const deContent = decodeURIComponent(content);
      return parseMarkdown(deContent, {
        emojiMap: emoji2.value.map
      });
    });
    const replyDisplayname = computed(() => {
      if (!props.replyCmt && props.comment.replyTo !== props.comment.replyRoot) {
        return "(已删除)";
      }
      const {
        replyCmt
      } = props;
      if (!replyCmt || !replyCmt.user) {
        return null;
      }
      const {
        user
      } = replyCmt;
      return user.nickname || user.id || replyCmt.userId;
    });
    const displayName = computed(() => {
      const {
        user
      } = comment.value;
      return (user == null ? void 0 : user.nickname) || (user == null ? void 0 : user.id) || comment.value.userId;
    });
    const displayAddr = computed(() => {
      const {
        meta
      } = comment.value;
      let [country, region2, city] = (meta.addr ?? "||").split("|");
      let m2 = (region2 == null ? void 0 : region2.match(/(.*)[省市]/)) ?? null;
      if (m2 == null ? void 0 : m2[1]) {
        region2 = m2[1];
      }
      region2 = {
        "广西壮族自治区": "广西",
        "新疆维吾尔自治区": "新疆",
        "西藏自治区": "西藏",
        "宁夏回族自治区": "宁夏",
        "内蒙古自治区": "内蒙古",
        "香港特别行政区": "香港",
        "澳门特别行政区": "澳门"
      }[region2] ?? region2;
      m2 = (city == null ? void 0 : city.match(/(.*)市/)) ?? null;
      if (m2 == null ? void 0 : m2[1]) {
        city = m2[1];
      }
      return country !== "中国" ? country === region2 ? country : country + (region2 ?? "") : region2 === city ? region2 : region2 + (city ?? "");
    });
    const isAdmin = computed(() => userInfo2.value.type === "administrator");
    const isOwner = computed(() => props.comment.userId && userInfo2.value.id === props.comment.userId);
    const isReplyingCurrent = computed(() => {
      var _a4;
      return props.comment.id === ((_a4 = props.cmtReply) == null ? void 0 : _a4.id);
    });
    const isEditingCurrent = computed(() => {
      var _a4;
      return props.comment.id === ((_a4 = props.cmtEdit) == null ? void 0 : _a4.id);
    });
    return (_ctx, _cache) => {
      var _a4, _b2, _c, _d, _e2, _f;
      const _component_CommentCard = resolveComponent("CommentCard", true);
      return openBlock(), createElementBlock("div", {
        id: unref(comment).id,
        class: "wl-card-item"
      }, [createElementVNode("div", _hoisted_2$L, [((_a4 = unref(comment).user) == null ? void 0 : _a4.avatar) ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: unref(viewAvatarUrl)
      }, null, 8, _hoisted_3$D)) : (openBlock(), createBlock(unref(DefaultUserAvatar), {
        key: 1,
        size: 35,
        style: {
          opacity: 0.6
        }
      })), ((_b2 = unref(comment).user) == null ? void 0 : _b2.type) ? (openBlock(), createBlock(unref(VerifiedIcon), {
        key: 2
      })) : createCommentVNode("v-if", true)]), createElementVNode(
        "div",
        {
          class: normalizeClass(["wl-card", {
            "wl-waiting": unref(comment).status === "waiting"
          }])
        },
        [createElementVNode("div", _hoisted_4$s, [createCommentVNode(" 评论者显示名字(昵称/ID) "), createElementVNode("span", _hoisted_5$j, [link.value ? (openBlock(), createElementBlock("a", {
          key: 0,
          class: "wl-nick-text",
          href: link.value,
          target: "_blank",
          rel: "nofollow noopener noreferrer"
        }, toDisplayString(displayName.value), 9, _hoisted_6$f)) : (openBlock(), createElementBlock(
          "span",
          _hoisted_7$b,
          toDisplayString(displayName.value),
          1
          /* TEXT */
        )), createVNode(unref(VerifiedIcon), {
          class: "sm-hidden"
        })]), createCommentVNode(" 评论者用户类型 "), ((_c = unref(comment).user) == null ? void 0 : _c.type) === "administrator" ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-badge",
          textContent: toDisplayString(locale.value.admin)
        }, null, 8, _hoisted_8$9)) : createCommentVNode("v-if", true), createCommentVNode(" 评论者用户标签 "), (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(comment).meta.labels, (label) => {
            return openBlock(), createElementBlock("span", {
              class: "wl-badge",
              textContent: toDisplayString(label)
            }, null, 8, _hoisted_9$8);
          }),
          256
          /* UNKEYED_FRAGMENT */
        )), createCommentVNode(" 评论置顶标签 "), unref(comment).meta.sticky ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "wl-badge",
          textContent: toDisplayString(locale.value.sticky)
        }, null, 8, _hoisted_10$7)) : createCommentVNode("v-if", true), createCommentVNode(" 评论者等级 "), unref(comment).level !== void 0 && unref(comment).level >= 0 ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(`wl-badge level${unref(comment).level}`),
          textContent: toDisplayString(locale.value[`level${unref(comment).level}`] || `Level ${unref(comment).level}`)
        }, null, 10, _hoisted_11$6)) : createCommentVNode("v-if", true), createCommentVNode(" 评论时间 "), createElementVNode("span", {
          class: "wl-time",
          textContent: toDisplayString(time.value)
        }, null, 8, _hoisted_12$3), createCommentVNode(" 评论者IP所在地 "), unref(comment).meta.addr ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: "wl-addr",
          "data-value": unref(comment).meta.addr,
          textContent: toDisplayString(displayAddr.value)
        }, null, 8, _hoisted_13$3)) : createCommentVNode("v-if", true), createCommentVNode(" 右上角操作按钮 "), createElementVNode("div", _hoisted_14$2, [createCommentVNode(" 编辑评论按钮 "), isAdmin.value || isOwner.value ? (openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          class: normalizeClass(["wl-edit", {
            active: isEditingCurrent.value
          }]),
          title: isEditingCurrent.value ? "取消编辑" : locale.value.reply,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("edit", isEditingCurrent.value ? null : unref(comment)))
        }, [createVNode(unref(EditIcon))], 10, _hoisted_15$1)) : createCommentVNode("v-if", true), createCommentVNode(" 删除评论按钮 "), isAdmin.value || isOwner.value ? (openBlock(), createElementBlock("button", {
          key: 1,
          type: "button",
          class: "wl-delete",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("delete", unref(comment)))
        }, [createVNode(unref(DeleteIcon))])) : createCommentVNode("v-if", true), createCommentVNode(" 点赞评论按钮 "), createElementVNode("button", {
          type: "button",
          class: normalizeClass(["wl-like", {
            "wl-disable-btn": !isLogin.value
          }]),
          title: isLiked.value ? locale.value.cancelLike : locale.value.like,
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("like", unref(comment)))
        }, [createVNode(unref(LikeIcon), {
          active: isLiked.value
        }, null, 8, ["active"]), unref(comment).meta.likes && unref(comment).meta.likes.length ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-actions-count",
          textContent: toDisplayString(unref(comment).meta.likes.length)
        }, null, 8, _hoisted_17)) : createCommentVNode("v-if", true)], 10, _hoisted_16$1), createCommentVNode(" 回复评论按钮 "), createElementVNode("button", {
          type: "button",
          class: normalizeClass(["wl-reply", {
            active: isReplyingCurrent.value,
            "wl-disable-btn": !isLogin.value
          }]),
          title: isReplyingCurrent.value ? locale.value.cancelReply : locale.value.reply,
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("reply", isReplyingCurrent.value ? null : unref(comment)))
        }, [createVNode(unref(ReplyIcon)), unref(comment).replies && unref(comment).replies.length ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-actions-count",
          textContent: toDisplayString(unref(comment).replies.length)
        }, null, 8, _hoisted_19)) : createCommentVNode("v-if", true)], 10, _hoisted_18)])]), createCommentVNode(" 评论附加属性 "), createElementVNode("div", _hoisted_20, [createCommentVNode(" 评论者浏览器 "), unref(comment).meta.browser ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-browser",
          "data-value": unref(comment).meta.browser,
          textContent: toDisplayString(unref(comment).meta.browser.split("/")[0])
        }, null, 8, _hoisted_21)) : createCommentVNode("v-if", true), createCommentVNode(" 评论者操作系统 "), unref(comment).meta.os ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "wl-os",
          "data-value": unref(comment).meta.os,
          textContent: toDisplayString(unref(comment).meta.os.split("/")[0])
        }, null, 8, _hoisted_22)) : createCommentVNode("v-if", true)]), replyDisplayname.value ? (openBlock(), createElementBlock(
          "div",
          _hoisted_23,
          "回复 @" + toDisplayString(replyDisplayname.value) + ":",
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true), createCommentVNode(" 评论内容 "), createCommentVNode(" eslint-disable vue/no-v-html "), !isEditingCurrent.value && !(isAdmin.value || isOwner.value) && unref(comment).status === "waiting" ? (openBlock(), createElementBlock("div", _hoisted_24, " 评论审核中.. ")) : !isEditingCurrent.value ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: "wl-content",
          innerHTML: contentHTML.value
        }, null, 8, _hoisted_25)) : createCommentVNode("v-if", true), createCommentVNode(" 评论管理员操作 "), createCommentVNode(" eslint-enable vue/no-v-html "), isAdmin.value && !isEditingCurrent.value ? (openBlock(), createElementBlock("div", _hoisted_26, [createCommentVNode(" 评论审核状态 "), createElementVNode("span", _hoisted_27, [(openBlock(), createElementBlock(
          Fragment,
          null,
          renderList(commentStatus, (status) => {
            return createElementVNode("button", {
              key: status,
              type: "submit",
              class: normalizeClass(`wl-btn wl-${status}`),
              disabled: unref(comment).status === status,
              onClick: ($event) => _ctx.$emit("status", {
                status,
                comment: unref(comment)
              }),
              textContent: toDisplayString(locale.value[status])
            }, null, 10, _hoisted_28);
          }),
          64
          /* STABLE_FRAGMENT */
        ))]), createCommentVNode(" 评论置顶按钮 "), isAdmin.value && !unref(comment).replyRoot ? (openBlock(), createElementBlock(
          "button",
          {
            key: 0,
            type: "submit",
            class: "wl-btn wl-sticky",
            onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("sticky", unref(comment)))
          },
          toDisplayString(unref(comment).meta.sticky ? locale.value.unsticky : locale.value.sticky),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true), isReplyingCurrent.value || isEditingCurrent.value ? (openBlock(), createElementBlock(
          "div",
          {
            key: 4,
            class: normalizeClass({
              "wl-reply-wrapper": isReplyingCurrent.value,
              "wl-edit-wrapper": isEditingCurrent.value
            })
          },
          [createVNode(unref(CommentBox), {
            "cmt-edit": _ctx.cmtEdit,
            "reply-id": (_d = _ctx.cmtReply) == null ? void 0 : _d.id,
            "reply-user-id": (_e2 = _ctx.cmtReply) == null ? void 0 : _e2.userId,
            "reply-user": displayName.value,
            "root-id": _ctx.rootCmt.id,
            onLog: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("log")),
            onCancelReply: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("reply", null)),
            onCancelEdit: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("edit", null)),
            onSubmit: _cache[8] || (_cache[8] = (cmt, add) => _ctx.$emit("submit", cmt, add))
          }, null, 8, ["cmt-edit", "reply-id", "reply-user-id", "reply-user", "root-id"])],
          2
          /* CLASS */
        )) : createCommentVNode("v-if", true), createCommentVNode(" 评论回复 "), ((_f = unref(comment).replies) == null ? void 0 : _f.length) ? (openBlock(), createElementBlock("div", _hoisted_29, [createCommentVNode(" FIXME: This is a upstream bug "), createCommentVNode(" eslint-disable-next-line vue/no-undef-components "), (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(comment).replies, (child) => {
            var _a5;
            return openBlock(), createBlock(_component_CommentCard, {
              key: child.id,
              comment: child,
              "reply-cmt": (_a5 = unref(comment).replies) == null ? void 0 : _a5.find((r2) => r2.id === child.replyTo),
              "root-cmt": unref(comment),
              "cmt-edit": _ctx.cmtEdit,
              "cmt-reply": _ctx.cmtReply,
              onLog: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("log")),
              onDelete: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("delete", $event)),
              onEdit: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("edit", $event)),
              onLike: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("like", $event)),
              onReply: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("reply", $event)),
              onStatus: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("status", $event)),
              onSticky: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("sticky", $event)),
              onSubmit: _cache[16] || (_cache[16] = (cmt, add) => _ctx.$emit("submit", cmt, add))
            }, null, 8, ["comment", "reply-cmt", "root-cmt", "cmt-edit", "cmt-reply"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])) : createCommentVNode("v-if", true)],
        2
        /* CLASS */
      )], 8, _hoisted_1$16);
    };
  }
});
const CommentCard_vue_vue_type_style_index_0_lang = "";
const CommentCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$1n, [["__file", "CommentCard.vue"]]);
const _hoisted_1$15 = {
  class: "wl-meta-head"
};
const _hoisted_2$K = {
  key: 0,
  class: "wl-count"
};
const _hoisted_3$C = ["textContent"];
const _hoisted_4$r = {
  class: "wl-reply-count"
};
const _hoisted_5$i = ["textContent"];
const _hoisted_6$e = {
  class: "wl-sort"
};
const _hoisted_7$a = ["onClick"];
const _hoisted_8$8 = {
  class: "wl-cards"
};
const _hoisted_9$7 = {
  key: 1,
  class: "wl-operation"
};
const _hoisted_10$6 = ["textContent"];
const _hoisted_11$5 = {
  key: 0,
  class: "wl-loading"
};
const _hoisted_12$2 = ["textContent"];
const _hoisted_13$2 = {
  class: "wl-operation"
};
const _hoisted_14$1 = ["textContent"];
const _hoisted_15 = {
  key: 3,
  class: "wl-power"
};
const _hoisted_16 = /* @__PURE__ */ createElementVNode(
  "a",
  {
    href: "https://github.com/walinejs/waline",
    target: "_blank",
    rel: "noopener noreferrer"
  },
  " Waline ",
  -1
  /* HOISTED */
);
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  __name: "WalineComment",
  setup(__props) {
    const sortKeyMap = {
      latest: "time_desc",
      oldest: "time_asc",
      hottest: "hot_desc"
    };
    const sortingMethods = Object.keys(sortKeyMap);
    const config = inject("config");
    const articleId = inject("articleId");
    const api = inject("api");
    const userInfo2 = useUserInfo();
    const status = ref("loading");
    const count = ref({
      root: 0,
      total: 0
    });
    const page = ref(1);
    const totalPages = ref(0);
    const walineRef = ref(null);
    const commentSortingRef = ref(config.value.commentSorting);
    const data = ref([]);
    const cmtReply = ref(null);
    const cmtEdit = ref(null);
    const darkmodeStyle = computed(() => getDarkStyle(config.value.dark));
    useStyleTag(darkmodeStyle, {
      id: "waline-darkmode"
    });
    const i18n = computed(() => config.value.locale);
    let abort;
    const getCommentData = (pageNumber) => {
      const {
        pageSize
      } = config.value;
      const controller = new AbortController();
      status.value = "loading";
      abort == null ? void 0 : abort();
      api.getComments(articleId.value, sortKeyMap[commentSortingRef.value], pageNumber, pageSize).then((resp) => {
        status.value = "success";
        if (resp.data) {
          data.value.push(...resp.data);
          page.value = pageNumber;
        }
        if (resp.meta) {
          count.value = resp.meta;
          totalPages.value = Math.ceil(count.value.root / pageSize);
        } else {
          count.value = {
            root: 0,
            total: 0
          };
        }
      }).catch((err2) => {
        if (err2.name !== "AbortError") {
          status.value = "error";
        }
      });
      abort = controller.abort.bind(controller);
    };
    const loadMore = () => getCommentData(page.value + 1);
    const refresh = () => {
      count.value = {
        root: 0,
        total: 0
      };
      data.value = [];
      getCommentData(1);
    };
    const onSortByChange = (item) => {
      if (commentSortingRef.value !== item) {
        commentSortingRef.value = item;
        refresh();
      }
    };
    const onReply = (comment) => {
      cmtReply.value = comment;
    };
    const onEdit = (comment) => {
      cmtEdit.value = comment;
    };
    const onSubmit = (comment, isAdd) => {
      if (isAdd) {
        if (comment.replyTo) {
          const rootIdx = data.value.findIndex(({
            id
          }) => id === comment.replyRoot);
          const rootCmt = data.value[rootIdx];
          if (!rootCmt)
            return;
          if (!Array.isArray(rootCmt.replies))
            rootCmt.replies = [];
          rootCmt.replies.push(comment);
          data.value[rootIdx] = rootCmt;
          count.value = {
            root: count.value.root,
            total: count.value.total + 1
          };
        } else {
          data.value = [comment, ...data.value];
          count.value = {
            root: count.value.root + 1,
            total: count.value.total + 1
          };
        }
      } else {
        const rootIdx = data.value.findIndex(({
          id
        }) => id === (comment.replyRoot || comment.id));
        const rootCmt = data.value[rootIdx];
        if (!rootCmt)
          return;
        if (comment.replyTo) {
          const replyCmt = rootCmt.replies.find(({
            id
          }) => id === comment.id);
          if (!replyCmt)
            return;
          replyCmt.content = comment.content;
          data.value[rootIdx] = rootCmt;
        } else {
          rootCmt.content = comment.content;
        }
        data.value[rootIdx] = rootCmt;
      }
    };
    const onStatusChange = async ({
      comment,
      status: status2
    }) => {
      if (comment.status === status2)
        return;
      try {
        await api.updateComment(articleId.value, comment.id, comment.userId, comment.replyRoot, "status", status2);
        comment.status = status2;
      } catch {
      }
    };
    const onSticky = async (comment) => {
      if (comment.replyRoot)
        return;
      try {
        await api.updateComment(articleId.value, comment.id, comment.userId, comment.replyRoot, "sticky", !comment.meta.sticky);
        comment.meta.sticky = !comment.meta.sticky;
      } catch {
      }
    };
    const onDelete = async ({
      id: commentId,
      userId,
      replyRoot = commentId
    }) => {
      if (!confirm("确定要删除评论?"))
        return;
      try {
        await api.deleteComment(articleId.value, userId, commentId, replyRoot);
        if (commentId === replyRoot) {
          data.value = data.value.filter((item) => item.id !== commentId);
        } else {
          const index2 = data.value.findIndex((it2) => it2.id === replyRoot);
          if (index2 >= 0) {
            const item = data.value[index2];
            item.replies = item.replies.filter((reply) => reply.id !== commentId);
            data.value[index2] = item;
          }
        }
      } catch {
      }
    };
    const onLike = async (comment) => {
      var _a3, _b2;
      const hasLiked = !!((_a3 = comment.meta.likes) == null ? void 0 : _a3.includes(userInfo2.value.id));
      try {
        await api.updateComment(articleId.value, comment.id, comment.userId, comment.replyRoot, hasLiked ? "likes$pull" : "likes$add", userInfo2.value.id);
        if (!hasLiked) {
          comment.meta.likes = (comment.meta.likes || []).concat(userInfo2.value.id);
        } else {
          comment.meta.likes = (_b2 = comment.meta.likes) == null ? void 0 : _b2.filter((userId) => userId !== userInfo2.value.id);
        }
      } catch {
      }
    };
    onMounted(() => {
      watch(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        () => [config.value.id, articleId],
        () => refresh(),
        {
          immediate: true
        }
      );
    });
    onUnmounted(() => abort == null ? void 0 : abort());
    return (_ctx, _cache) => {
      var _a3, _b2;
      return openBlock(), createElementBlock(
        "div",
        {
          ref_key: "walineRef",
          ref: walineRef,
          "data-waline": ""
        },
        [createVNode(Reaction), !cmtReply.value && !cmtEdit.value ? (openBlock(), createBlock(unref(CommentBox), {
          key: 0,
          "article-id": unref(articleId),
          onLog: refresh,
          onSubmit
        }, null, 8, ["article-id"])) : createCommentVNode("v-if", true), createElementVNode("div", _hoisted_1$15, [count.value ? (openBlock(), createElementBlock("div", _hoisted_2$K, [((_a3 = count.value) == null ? void 0 : _a3.root) !== void 0 ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-num",
          textContent: toDisplayString(count.value.root)
        }, null, 8, _hoisted_3$C)) : createCommentVNode("v-if", true), createTextVNode(
          " " + toDisplayString(i18n.value.comment) + " ",
          1
          /* TEXT */
        ), createElementVNode("span", _hoisted_4$r, [((_b2 = count.value) == null ? void 0 : _b2.total) !== void 0 ? (openBlock(), createElementBlock("span", {
          key: 0,
          textContent: toDisplayString(count.value.total)
        }, null, 8, _hoisted_5$i)) : createCommentVNode("v-if", true), createTextVNode(" 回复 ")])])) : createCommentVNode("v-if", true), createElementVNode("ul", _hoisted_6$e, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(sortingMethods), (item) => {
            return openBlock(), createElementBlock("li", {
              key: item,
              class: normalizeClass({
                active: item === commentSortingRef.value
              }),
              onClick: ($event) => onSortByChange(item)
            }, toDisplayString(i18n.value[item]), 11, _hoisted_7$a);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])]), createElementVNode("div", _hoisted_8$8, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(data.value, (comment) => {
            return openBlock(), createBlock(CommentCard, {
              key: comment.id,
              "root-cmt": comment,
              comment,
              "cmt-reply": cmtReply.value,
              "cmt-edit": cmtEdit.value,
              onLog: refresh,
              onReply,
              onEdit,
              onSubmit,
              onStatus: onStatusChange,
              onDelete,
              onSticky,
              onLike
            }, null, 8, ["root-cmt", "comment", "cmt-reply", "cmt-edit"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))]), status.value === "error" ? (openBlock(), createElementBlock("div", _hoisted_9$7, [createElementVNode("button", {
          type: "button",
          class: "wl-btn",
          onClick: refresh,
          textContent: toDisplayString(i18n.value.refresh)
        }, null, 8, _hoisted_10$6)])) : (openBlock(), createElementBlock(
          Fragment,
          {
            key: 2
          },
          [status.value === "loading" ? (openBlock(), createElementBlock("div", _hoisted_11$5, [createVNode(unref(LoadingIcon), {
            size: 30
          })])) : !data.value.length ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "wl-empty",
            textContent: toDisplayString(i18n.value.sofa)
          }, null, 8, _hoisted_12$2)) : page.value < totalPages.value ? (openBlock(), createElementBlock(
            Fragment,
            {
              key: 2
            },
            [createCommentVNode(" Load more button "), createElementVNode("div", _hoisted_13$2, [createElementVNode("button", {
              type: "button",
              class: "wl-btn",
              onClick: loadMore,
              textContent: toDisplayString(i18n.value.more)
            }, null, 8, _hoisted_14$1)])],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)],
          64
          /* STABLE_FRAGMENT */
        )), createCommentVNode(" Copyright Information "), unref(config).copyright ? (openBlock(), createElementBlock("div", _hoisted_15, [createTextVNode(" Based on & Powered by "), _hoisted_16, createCommentVNode(" v{{ version }} ")])) : createCommentVNode("v-if", true)],
        512
        /* NEED_PATCH */
      );
    };
  }
});
const WalineComment_vue_vue_type_style_index_0_lang = "";
const WalineComment = /* @__PURE__ */ _export_sfc$1(_sfc_main$1m, [["__file", "WalineComment.vue"]]);
const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  __name: "WalineGlobal",
  props: [
    "id",
    "path",
    "meta",
    "requiredMeta",
    "dark",
    "commentSorting",
    "lang",
    "locale",
    "pageSize",
    "wordLimit",
    // 'emoji',
    "login",
    // 'highlighter',
    // 'texRenderer',
    "imageUploader",
    "search",
    "copyright",
    "recaptchaV3Key",
    "turnstileKey"
    // 'reaction',
  ],
  setup(__props) {
    const props = __props;
    const {
      proxy: proxy2
    } = getCurrentInstance();
    const config = computed(() => getConfig(props));
    const pageData = usePageData$1();
    const articleId = computed(() => config.value.id || props.id || props.path);
    const emoji2 = useEmoji();
    onMounted(() => {
    });
    provide("config", config);
    provide("pageData", pageData);
    provide("articleId", articleId);
    provide("emoji", emoji2);
    provide("api", proxy2 == null ? void 0 : proxy2.$api);
    provide("msg", proxy2 == null ? void 0 : proxy2.$msg);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(WalineComment);
    };
  }
});
const WalineGlobal_vue_vue_type_style_index_0_lang = "";
const Waline$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1l, [["__file", "WalineGlobal.vue"]]);
const index$2 = "";
const waline = "";
const Waline = defineComponent({
  name: "Waline",
  props: {
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props) {
    const {
      options
    } = toRefs(props);
    const lang = usePageLang();
    const pageData = usePageData$1();
    const walineOption = computed(() => {
      var _a3;
      return {
        lang: lang.value || "zh-CN",
        dark: 'html[class="dark"]',
        path: withBase((_a3 = pageData.value) === null || _a3 === void 0 ? void 0 : _a3.path),
        ...options.value,
        pageview: false
      };
    });
    return () => h$5("div", {
      class: "reco-waline-wrapper"
    }, h$5(Waline$1, walineOption.value));
  }
});
const d$7 = ["id", "host", "repo", "repoid", "category", "categoryid", "mapping", "term", "strict", "reactionsenabled", "emitmetadata", "inputposition", "theme", "lang", "loading"], l$4 = /* @__PURE__ */ defineComponent({
  __name: "Giscus",
  props: {
    id: {},
    host: {},
    repo: {},
    repoId: {},
    category: {},
    categoryId: {},
    mapping: {},
    term: {},
    theme: {},
    strict: {},
    reactionsEnabled: {},
    emitMetadata: {},
    inputPosition: {},
    lang: {},
    loading: {}
  },
  setup(s2) {
    const t2 = ref(false);
    return onMounted(() => {
      t2.value = true, __vitePreload(() => import("./giscus-2a044aea-fc9a54a1.js"), true ? [] : void 0);
    }), (e2, m2) => t2.value ? (openBlock(), createElementBlock("giscus-widget", {
      key: 0,
      id: e2.id,
      host: e2.host,
      repo: e2.repo,
      repoid: e2.repoId,
      category: e2.category,
      categoryid: e2.categoryId,
      mapping: e2.mapping,
      term: e2.term,
      strict: e2.strict,
      reactionsenabled: e2.reactionsEnabled,
      emitmetadata: e2.emitMetadata,
      inputposition: e2.inputPosition,
      theme: e2.theme,
      lang: e2.lang,
      loading: e2.loading
    }, null, 8, d$7)) : createCommentVNode("", true);
  }
});
const giscus = "";
const giscusTheme = "";
const giscusThemeDark = "";
const Giscus = defineComponent({
  name: "Giscus",
  props: {
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props) {
    const {
      options
    } = toRefs(props);
    const lang = usePageLang();
    const theme = ref("light_tritanopia");
    onMounted(async () => {
      const fn = function() {
        var _a3;
        const dark = (_a3 = document.documentElement.classList) === null || _a3 === void 0 ? void 0 : _a3.contains("dark");
        {
          const baseUrl = window.location.protocol + "//" + window.location.host;
          theme.value = baseUrl + `/assets/giscus-theme${dark ? "-dark" : ""}.css`;
        }
      };
      const mutationObserver = new MutationObserver(fn);
      mutationObserver.observe(document.documentElement, {
        attributes: true
      });
      fn();
    });
    const giscusOption = computed(() => ({
      lang: lang.value || "zh-CN",
      host: "https://giscus.app",
      theme: theme.value,
      ...options.value
    }));
    return () => h$5("div", {
      class: "reco-giscus-wrapper"
    }, h$5(l$4, giscusOption.value));
  }
});
const Comments = defineComponent({
  name: "RecoComments",
  components: {
    Valine,
    Waline,
    Giscus
  },
  props: {
    hideComments: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const {
      solution,
      options
    } = useComment();
    const {
      hideComments
    } = toRefs(props);
    let componentName;
    switch (solution.value) {
      case "valine":
        componentName = Valine;
        break;
      case "waline":
        componentName = Waline;
        break;
      case "giscus":
        componentName = Giscus;
        break;
      default:
        componentName = "";
        break;
    }
    return () => {
      if (componentName) {
        if (hideComments.value) {
          if (solution.value === "valine") {
            return h$5(componentName, {
              options: options.value,
              style: "display: none"
            });
          }
          return null;
        }
        return h$5(componentName, {
          options: options.value
        });
      }
      return null;
    };
  }
});
const ValineViews = defineComponent({
  name: "ValineViews",
  props: {
    idVal: String,
    numStyle: {
      type: Object,
      default: () => ({})
    },
    flagTitle: {
      type: String,
      default: "Your Article Title"
    }
  },
  setup(props) {
    const siteLocal = useSiteLocaleData();
    const route = useRoute();
    const {
      idVal,
      numStyle,
      flagTitle
    } = toRefs(props);
    const getIdVal = (path) => {
      return siteLocal.value.base.slice(0, siteLocal.value.base.length - 1) + path;
    };
    return () => h$5("span", {
      "id": getIdVal(idVal.value || route.path),
      "class": "leancloud-visitors",
      "data-flag-title": flagTitle.value
    }, h$5("a", {
      class: "leancloud-visitors-count",
      style: numStyle.value
    }));
  }
});
const renderVisitorCount = (counts, countElements) => {
  countElements.forEach((element, index2) => {
    element.innerText = counts[index2].toString();
  });
};
const pageviewCount = ({
  serverURL,
  api = serverApi,
  path = window.location.pathname,
  id = usePageFrontmatter().value.id || path,
  selector = ".waline-pageview-count",
  update = true,
  lang = navigator.language
}) => {
  const controller = new AbortController();
  const elements = Array.from(
    // pageview selectors
    document.querySelectorAll(selector)
  );
  const filter2 = (element) => {
    const query = getQuery(element);
    return query !== null && path !== query;
  };
  if (update) {
    const normalElements = elements.filter((element) => !filter2(element));
    api.getArticleInfo(id).then((resp) => {
      api.addPageView(id);
      renderVisitorCount(new Array(normalElements.length).fill(resp.data.pageView + 1), normalElements);
    });
  }
  return controller.abort.bind(controller);
};
const WalineViews$1 = defineComponent({
  name: "WalineViews",
  props: {
    path: String
  },
  setup(props) {
    const {
      path
    } = toRefs(props);
    const {
      options
    } = useComment();
    const route = useRoute();
    const viewFn = function() {
      pageviewCount({
        serverURL: options.value.serverURL,
        path: path.value,
        selector: `[data-path="${path.value}"]`,
        update: route.path === path.value
      });
    };
    onMounted(() => {
      viewFn();
    });
    onUpdated(() => {
      viewFn();
    });
    return () => h$5("span", {
      "class": "waline-pageview-count",
      "data-path": path.value
    });
  }
});
function applyClientEnhance$1({
  app
}) {
  app.component("Comments", (props) => h$5(Comments, {
    ...props
  }));
  app.component("ValineViews", (props) => h$5(ValineViews, {
    ...props
  }));
  app.component("WalineViews", (props) => h$5(WalineViews$1, {
    ...props
  }));
}
const clientConfig1 = defineClientConfig({
  enhance(...args) {
    applyClientEnhance$1(...args);
  }
});
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a3;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a3 = global.perf_hooks) === null || _a3 === void 0 ? void 0 : _a3.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id in plugin2.settings) {
        const item = plugin2.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy2 = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy: proxy2
    });
    if (proxy2)
      setupFn(proxy2.proxiedTarget);
  }
}
const clientConfig2 = defineClientConfig({
  enhance({
    app
  }) {
    const themeData2 = useThemeData();
    const routeLocale = app._context.provides[routeLocaleSymbol];
    const themeLocaleData = computed(() => resolveThemeLocaleData(themeData2.value, routeLocale.value));
    app.provide(themeLocaleDataSymbol, themeLocaleData);
    Object.defineProperties(app.config.globalProperties, {
      $theme: {
        get() {
          return themeData2.value;
        }
      },
      $themeLocale: {
        get() {
          return themeLocaleData.value;
        }
      }
    });
    {
      setupDevtoolsPlugin({
        // fix recursive reference
        app,
        id: "org.vuejs.vuepress.plugin-theme-data",
        label: "VuePress Theme Data Plugin",
        packageName: "@vuepress/plugin-theme-data",
        homepage: "https://v2.vuepress.vuejs.org",
        logo: "https://v2.vuepress.vuejs.org/images/hero.png",
        componentStateTypes: ["VuePress"]
      }, (api) => {
        api.on.inspectComponent((payload) => {
          payload.instanceData.state.push({
            type: "VuePress",
            key: "themeData",
            editable: false,
            value: themeData2.value
          }, {
            type: "VuePress",
            key: "themeLocaleData",
            editable: false,
            value: themeLocaleData.value
          });
        });
      });
    }
  }
});
const isFocusingTextControl = (target) => {
  if (!(target instanceof Element)) {
    return false;
  }
  return document.activeElement === target && (["TEXTAREA", "SELECT", "INPUT"].includes(target.tagName) || target.hasAttribute("contenteditable"));
};
const isKeyMatched = (event, hotKeys2) => hotKeys2.some((item) => {
  if (isString$1(item)) {
    return item === event.key;
  }
  const {
    key,
    ctrl = false,
    shift: shift2 = false,
    alt = false
  } = item;
  return key === event.key && ctrl === event.ctrlKey && shift2 === event.shiftKey && alt === event.altKey;
});
const nonASCIIRegExp = /[^\x00-\x7F]/;
const splitWords = (str) => str.split(/\s+/g).map((str2) => str2.trim()).filter((str2) => !!str2);
const escapeRegExp = (str) => str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
const isQueryMatched = (query, toMatch) => {
  const toMatchStr = toMatch.join(" ");
  const words = splitWords(query);
  if (nonASCIIRegExp.test(query)) {
    return words.some((word) => toMatchStr.toLowerCase().indexOf(word) > -1);
  }
  const hasTrailingSpace = query.endsWith(" ");
  const searchRegex = new RegExp(words.map((word, index2) => {
    if (words.length === index2 + 1 && !hasTrailingSpace) {
      return `(?=.*\\b${escapeRegExp(word)})`;
    }
    return `(?=.*\\b${escapeRegExp(word)}\\b)`;
  }).join("") + ".+", "gi");
  return searchRegex.test(toMatchStr);
};
const useHotKeys = ({
  input,
  hotKeys: hotKeys2
}) => {
  if (hotKeys2.value.length === 0)
    return;
  const onKeydown = (event) => {
    if (!input.value)
      return;
    if (
      // key matches
      isKeyMatched(event, hotKeys2.value) && // event does not come from the search box itself or
      // user isn't focusing (and thus perhaps typing in) a text control
      !isFocusingTextControl(event.target)
    ) {
      event.preventDefault();
      input.value.focus();
    }
  };
  onMounted(() => {
    document.addEventListener("keydown", onKeydown);
  });
  onBeforeUnmount(() => {
    document.removeEventListener("keydown", onKeydown);
  });
};
const searchIndex$1 = [{
  "title": "",
  "headers": [],
  "path": "/timeline/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/posts/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/friendship-link/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/posts/1/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [{
    "level": 2,
    "title": "Hello world.",
    "slug": "hello-world",
    "link": "#hello-world",
    "children": []
  }],
  "path": "/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "画册",
  "headers": [],
  "path": "/albums/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "音乐播放器测试",
  "headers": [],
  "path": "/blogs/blogtest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "9月8日",
  "headers": [],
  "path": "/blogs/shuoshuotest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "梯田",
  "headers": [],
  "path": "/albums/test_album_1/psb.png.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "测试相册1",
  "headers": [],
  "path": "/albums/test_album_1/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "测试相册2",
  "headers": [],
  "path": "/albums/test_album_2/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "前端实现 - 木棉花落",
  "headers": [{
    "level": 2,
    "title": "Flowers.vue 绘制花瓣飞舞",
    "slug": "flowers-vue-绘制花瓣飞舞",
    "link": "#flowers-vue-绘制花瓣飞舞",
    "children": [{
      "level": 3,
      "title": "脚本实现",
      "slug": "脚本实现",
      "link": "#脚本实现",
      "children": []
    }]
  }, {
    "level": 2,
    "title": "WindBase.vue 随机风力产生",
    "slug": "windbase-vue-随机风力产生",
    "link": "#windbase-vue-随机风力产生",
    "children": []
  }],
  "path": "/docs/tech/flowers.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "前端实现 - 分层背景",
  "headers": [{
    "level": 2,
    "title": "CSS",
    "slug": "css",
    "link": "#css",
    "children": [{
      "level": 3,
      "title": "天空层",
      "slug": "天空层",
      "link": "#天空层",
      "children": []
    }, {
      "level": 3,
      "title": "远景和近景层",
      "slug": "远景和近景层",
      "link": "#远景和近景层",
      "children": []
    }]
  }, {
    "level": 2,
    "title": "脚本",
    "slug": "脚本",
    "link": "#脚本",
    "children": []
  }],
  "path": "/docs/tech/homebg.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "文章测试",
  "headers": [],
  "path": "/docs/test/articletest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "markdown测试",
  "headers": [{
    "level": 3,
    "title": "导航到这里",
    "slug": "导航到这里",
    "link": "#导航到这里",
    "children": []
  }],
  "path": "/docs/test/mdtest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/404.html",
  "pathLocale": "/",
  "extraFields": []
}];
const searchIndex = ref(searchIndex$1);
const useSearchIndex = () => searchIndex;
const useSearchSuggestions = ({
  searchIndex: searchIndex2,
  routeLocale,
  query,
  maxSuggestions: maxSuggestions2
}) => {
  const localeSearchIndex = computed(() => searchIndex2.value.filter((item) => item.pathLocale === routeLocale.value));
  return computed(() => {
    const searchStr = query.value.trim().toLowerCase();
    if (!searchStr)
      return [];
    const suggestions = [];
    const matchPageHeader = (searchIndexItem, header) => {
      if (isQueryMatched(searchStr, [header.title])) {
        suggestions.push({
          link: `${searchIndexItem.path}#${header.slug}`,
          title: searchIndexItem.title,
          header: header.title
        });
      }
      for (const child of header.children) {
        if (suggestions.length >= maxSuggestions2.value) {
          return;
        }
        matchPageHeader(searchIndexItem, child);
      }
    };
    for (const searchIndexItem of localeSearchIndex.value) {
      if (suggestions.length >= maxSuggestions2.value) {
        break;
      }
      if (isQueryMatched(searchStr, [searchIndexItem.title, ...searchIndexItem.extraFields])) {
        suggestions.push({
          link: searchIndexItem.path,
          title: searchIndexItem.title
        });
        continue;
      }
      for (const header of searchIndexItem.headers) {
        if (suggestions.length >= maxSuggestions2.value) {
          break;
        }
        matchPageHeader(searchIndexItem, header);
      }
    }
    return suggestions;
  });
};
const useSuggestionsFocus = (suggestions) => {
  const focusIndex = ref(0);
  const focusNext = () => {
    if (focusIndex.value < suggestions.value.length - 1) {
      focusIndex.value += 1;
    } else {
      focusIndex.value = 0;
    }
  };
  const focusPrev = () => {
    if (focusIndex.value > 0) {
      focusIndex.value -= 1;
    } else {
      focusIndex.value = suggestions.value.length - 1;
    }
  };
  return {
    focusIndex,
    focusNext,
    focusPrev
  };
};
const SearchBox = defineComponent({
  name: "SearchBox",
  props: {
    locales: {
      type: Object,
      required: false,
      default: () => ({})
    },
    hotKeys: {
      type: Array,
      required: false,
      default: () => []
    },
    maxSuggestions: {
      type: Number,
      required: false,
      default: 5
    }
  },
  setup(props) {
    const {
      locales: locales2,
      hotKeys: hotKeys2,
      maxSuggestions: maxSuggestions2
    } = toRefs(props);
    const router = useRouter();
    const routeLocale = useRouteLocale();
    const searchIndex2 = useSearchIndex();
    const input = ref(null);
    const isActive = ref(false);
    const query = ref("");
    const locale = computed(() => locales2.value[routeLocale.value] ?? {});
    const suggestions = useSearchSuggestions({
      searchIndex: searchIndex2,
      routeLocale,
      query,
      maxSuggestions: maxSuggestions2
    });
    const {
      focusIndex,
      focusNext,
      focusPrev
    } = useSuggestionsFocus(suggestions);
    useHotKeys({
      input,
      hotKeys: hotKeys2
    });
    const showSuggestions = computed(() => isActive.value && !!suggestions.value.length);
    const onArrowUp = () => {
      if (!showSuggestions.value) {
        return;
      }
      focusPrev();
    };
    const onArrowDown = () => {
      if (!showSuggestions.value) {
        return;
      }
      focusNext();
    };
    const goTo = (index2) => {
      if (!showSuggestions.value) {
        return;
      }
      const suggestion = suggestions.value[index2];
      if (!suggestion) {
        return;
      }
      router.push(suggestion.link).then(() => {
        query.value = "";
        focusIndex.value = 0;
      });
    };
    return () => h$5("form", {
      class: "search-box",
      role: "search"
    }, [h$5("input", {
      ref: input,
      type: "search",
      placeholder: locale.value.placeholder,
      autocomplete: "off",
      spellcheck: false,
      value: query.value,
      onFocus: () => isActive.value = true,
      onBlur: () => isActive.value = false,
      onInput: (event) => query.value = event.target.value,
      onKeydown: (event) => {
        switch (event.key) {
          case "ArrowUp": {
            onArrowUp();
            break;
          }
          case "ArrowDown": {
            onArrowDown();
            break;
          }
          case "Enter": {
            event.preventDefault();
            goTo(focusIndex.value);
            break;
          }
        }
      }
    }), showSuggestions.value && h$5("ul", {
      class: "suggestions",
      onMouseleave: () => focusIndex.value = -1
    }, suggestions.value.map(({
      link,
      title,
      header
    }, index2) => h$5("li", {
      class: ["suggestion", {
        focus: focusIndex.value === index2
      }],
      onMouseenter: () => focusIndex.value = index2,
      onMousedown: () => goTo(index2)
    }, h$5("a", {
      href: link,
      onClick: (event) => event.preventDefault()
    }, [h$5("span", {
      class: "page-title"
    }, title), header && h$5("span", {
      class: "page-header"
    }, `> ${header}`)]))))]);
  }
});
const vars$3 = "";
const search = "";
const locales$1 = {};
const hotKeys = [{ "key": "s", "ctrl": true }];
const maxSuggestions = 5;
const clientConfig3 = defineClientConfig({
  enhance({
    app
  }) {
    app.component("SearchBox", (props) => h$5(SearchBox, {
      locales: locales$1,
      hotKeys,
      maxSuggestions,
      ...props
    }));
  }
});
/**
 * NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT
 */
const nprogress$1 = {
  settings: {
    minimum: 0.08,
    easing: "ease",
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    barSelector: '[role="bar"]',
    parent: "body",
    template: '<div class="bar" role="bar"></div>'
  },
  status: null,
  set: (n2) => {
    const started = nprogress$1.isStarted();
    n2 = clamp$1(n2, nprogress$1.settings.minimum, 1);
    nprogress$1.status = n2 === 1 ? null : n2;
    const progress = nprogress$1.render(!started);
    const bar = progress.querySelector(nprogress$1.settings.barSelector);
    const speed = nprogress$1.settings.speed;
    const ease = nprogress$1.settings.easing;
    progress.offsetWidth;
    queue((next) => {
      css(bar, {
        transform: "translate3d(" + toBarPerc(n2) + "%,0,0)",
        transition: "all " + speed + "ms " + ease
      });
      if (n2 === 1) {
        css(progress, {
          transition: "none",
          opacity: "1"
        });
        progress.offsetWidth;
        setTimeout(function() {
          css(progress, {
            transition: "all " + speed + "ms linear",
            opacity: "0"
          });
          setTimeout(function() {
            nprogress$1.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(() => next(), speed);
      }
    });
    return nprogress$1;
  },
  isStarted: () => typeof nprogress$1.status === "number",
  start: () => {
    if (!nprogress$1.status)
      nprogress$1.set(0);
    const work = () => {
      setTimeout(() => {
        if (!nprogress$1.status)
          return;
        nprogress$1.trickle();
        work();
      }, nprogress$1.settings.trickleSpeed);
    };
    if (nprogress$1.settings.trickle)
      work();
    return nprogress$1;
  },
  done: (force) => {
    if (!force && !nprogress$1.status)
      return nprogress$1;
    return nprogress$1.inc(0.3 + 0.5 * Math.random()).set(1);
  },
  inc: (amount) => {
    let n2 = nprogress$1.status;
    if (!n2) {
      return nprogress$1.start();
    }
    if (typeof amount !== "number") {
      amount = (1 - n2) * clamp$1(Math.random() * n2, 0.1, 0.95);
    }
    n2 = clamp$1(n2 + amount, 0, 0.994);
    return nprogress$1.set(n2);
  },
  trickle: () => nprogress$1.inc(Math.random() * nprogress$1.settings.trickleRate),
  render: (fromStart) => {
    if (nprogress$1.isRendered()) {
      return document.getElementById("nprogress");
    }
    addClass(document.documentElement, "nprogress-busy");
    const progress = document.createElement("div");
    progress.id = "nprogress";
    progress.innerHTML = nprogress$1.settings.template;
    const bar = progress.querySelector(nprogress$1.settings.barSelector);
    const perc = fromStart ? "-100" : toBarPerc(nprogress$1.status || 0);
    const parent = document.querySelector(nprogress$1.settings.parent);
    css(bar, {
      transition: "all 0 linear",
      transform: "translate3d(" + perc + "%,0,0)"
    });
    if (parent !== document.body) {
      addClass(parent, "nprogress-custom-parent");
    }
    parent == null ? void 0 : parent.appendChild(progress);
    return progress;
  },
  remove: () => {
    removeClass(document.documentElement, "nprogress-busy");
    removeClass(document.querySelector(nprogress$1.settings.parent), "nprogress-custom-parent");
    const progress = document.getElementById("nprogress");
    progress && removeElement(progress);
  },
  isRendered: () => !!document.getElementById("nprogress")
};
const clamp$1 = (n2, min2, max2) => {
  if (n2 < min2)
    return min2;
  if (n2 > max2)
    return max2;
  return n2;
};
const toBarPerc = (n2) => (-1 + n2) * 100;
const queue = function() {
  const pending = [];
  function next() {
    const fn = pending.shift();
    if (fn) {
      fn(next);
    }
  }
  return function(fn) {
    pending.push(fn);
    if (pending.length === 1)
      next();
  };
}();
const css = function() {
  const cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  const cssProps = {};
  function camelCase(string) {
    return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
      return letter.toUpperCase();
    });
  }
  function getVendorProp(name2) {
    const style2 = document.body.style;
    if (name2 in style2)
      return name2;
    let i3 = cssPrefixes.length;
    const capName = name2.charAt(0).toUpperCase() + name2.slice(1);
    let vendorName;
    while (i3--) {
      vendorName = cssPrefixes[i3] + capName;
      if (vendorName in style2)
        return vendorName;
    }
    return name2;
  }
  function getStyleProp(name2) {
    name2 = camelCase(name2);
    return cssProps[name2] ?? (cssProps[name2] = getVendorProp(name2));
  }
  function applyCss(element, prop, value) {
    prop = getStyleProp(prop);
    element.style[prop] = value;
  }
  return function(element, properties) {
    for (const prop in properties) {
      const value = properties[prop];
      if (value !== void 0 && Object.prototype.hasOwnProperty.call(properties, prop))
        applyCss(element, prop, value);
    }
  };
}();
const hasClass = (element, name2) => {
  const list = typeof element === "string" ? element : classList(element);
  return list.indexOf(" " + name2 + " ") >= 0;
};
const addClass = (element, name2) => {
  const oldList = classList(element);
  const newList = oldList + name2;
  if (hasClass(oldList, name2))
    return;
  element.className = newList.substring(1);
};
const removeClass = (element, name2) => {
  const oldList = classList(element);
  if (!hasClass(element, name2))
    return;
  const newList = oldList.replace(" " + name2 + " ", " ");
  element.className = newList.substring(1, newList.length - 1);
};
const classList = (element) => {
  return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
};
const removeElement = (element) => {
  element && element.parentNode && element.parentNode.removeChild(element);
};
const vars$2 = "";
const nprogress = "";
const useNprogress = () => {
  onMounted(() => {
    const router = useRouter();
    const loadedPages = /* @__PURE__ */ new Set();
    loadedPages.add(router.currentRoute.value.path);
    router.beforeEach((to) => {
      if (!loadedPages.has(to.path)) {
        nprogress$1.start();
      }
    });
    router.afterEach((to) => {
      loadedPages.add(to.path);
      nprogress$1.done();
    });
  });
};
const clientConfig4 = defineClientConfig({
  setup() {
    useNprogress();
  }
});
function r$6(r2, e2, n2) {
  var i3, t2, o2;
  void 0 === e2 && (e2 = 50), void 0 === n2 && (n2 = {});
  var a2 = null != (i3 = n2.isImmediate) && i3, u3 = null != (t2 = n2.callback) && t2, c2 = n2.maxWait, v3 = Date.now(), l2 = [];
  function f2() {
    if (void 0 !== c2) {
      var r3 = Date.now() - v3;
      if (r3 + e2 >= c2)
        return c2 - r3;
    }
    return e2;
  }
  var d2 = function() {
    var e3 = [].slice.call(arguments), n3 = this;
    return new Promise(function(i4, t3) {
      var c3 = a2 && void 0 === o2;
      if (void 0 !== o2 && clearTimeout(o2), o2 = setTimeout(function() {
        if (o2 = void 0, v3 = Date.now(), !a2) {
          var i5 = r2.apply(n3, e3);
          u3 && u3(i5), l2.forEach(function(r3) {
            return (0, r3.resolve)(i5);
          }), l2 = [];
        }
      }, f2()), c3) {
        var d3 = r2.apply(n3, e3);
        return u3 && u3(d3), i4(d3);
      }
      l2.push({
        resolve: i4,
        reject: t3
      });
    });
  };
  return d2.cancel = function(r3) {
    void 0 !== o2 && clearTimeout(o2), l2.forEach(function(e3) {
      return (0, e3.reject)(r3);
    }), l2 = [];
  }, d2;
}
const useActiveHeaderLinks = ({
  headerLinkSelector: headerLinkSelector2,
  headerAnchorSelector: headerAnchorSelector2,
  delay: delay2,
  offset: offset2 = 5
}) => {
  const router = useRouter();
  const setActiveRouteHash = () => {
    var _a3, _b2;
    const scrollTop = Math.max(window.scrollY, document.documentElement.scrollTop, document.body.scrollTop);
    const isAtPageTop = Math.abs(scrollTop - 0) < offset2;
    if (isAtPageTop) {
      updateHash(router, "");
      return;
    }
    const scrollBottom = window.innerHeight + scrollTop;
    const scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
    const isAtPageBottom = Math.abs(scrollHeight - scrollBottom) < offset2;
    const headerLinks = Array.from(document.querySelectorAll(headerLinkSelector2));
    const headerAnchors = Array.from(document.querySelectorAll(headerAnchorSelector2));
    const existedHeaderAnchors = headerAnchors.filter((anchor) => headerLinks.some((link) => link.hash === anchor.hash));
    for (let i3 = 0; i3 < existedHeaderAnchors.length; i3++) {
      const anchor = existedHeaderAnchors[i3];
      const nextAnchor = existedHeaderAnchors[i3 + 1];
      const hasPassedCurrentAnchor = scrollTop >= (((_a3 = anchor.parentElement) == null ? void 0 : _a3.offsetTop) ?? 0) - offset2;
      const hasNotPassedNextAnchor = !nextAnchor || scrollTop < (((_b2 = nextAnchor.parentElement) == null ? void 0 : _b2.offsetTop) ?? 0) - offset2;
      const isActive = hasPassedCurrentAnchor && hasNotPassedNextAnchor;
      if (!isActive)
        continue;
      const routeHash = decodeURIComponent(router.currentRoute.value.hash);
      const anchorHash = decodeURIComponent(anchor.hash);
      if (routeHash === anchorHash)
        return;
      if (isAtPageBottom) {
        for (let j2 = i3 + 1; j2 < existedHeaderAnchors.length; j2++) {
          if (routeHash === decodeURIComponent(existedHeaderAnchors[j2].hash)) {
            return;
          }
        }
      }
      updateHash(router, anchorHash);
      return;
    }
  };
  const onScroll = r$6(setActiveRouteHash, delay2);
  onMounted(() => {
    window.addEventListener("scroll", onScroll);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("scroll", onScroll);
  });
};
const updateHash = async (router, hash2) => {
  const {
    scrollBehavior
  } = router.options;
  router.options.scrollBehavior = void 0;
  await router.replace({
    query: router.currentRoute.value.query,
    hash: hash2
  }).finally(() => router.options.scrollBehavior = scrollBehavior);
};
const headerLinkSelector = "a.page-catalog-item";
const headerAnchorSelector = ".header-anchor";
const delay = 200;
const offset$1 = 5;
const clientConfig5 = defineClientConfig({
  setup() {
    useActiveHeaderLinks({
      headerLinkSelector,
      headerAnchorSelector,
      delay,
      offset: offset$1
    });
  }
});
const vars$1 = "";
const externalLinkIcon = "";
const svg = h$5("svg", {
  "class": "external-link-icon",
  "xmlns": "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  "focusable": "false",
  "x": "0px",
  "y": "0px",
  "viewBox": "0 0 100 100",
  "width": "15",
  "height": "15"
}, [h$5("path", {
  fill: "currentColor",
  d: "M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
}), h$5("polygon", {
  fill: "currentColor",
  points: "45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
})]);
const ExternalLinkIcon = defineComponent({
  name: "ExternalLinkIcon",
  props: {
    locales: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  setup(props) {
    const routeLocale = useRouteLocale();
    const locale = computed(() => props.locales[routeLocale.value] ?? {
      openInNewWindow: "open in new window"
    });
    return () => h$5("span", [svg, h$5("span", {
      class: "external-link-icon-sr-only"
    }, locale.value.openInNewWindow)]);
  }
});
const locales = {};
const clientConfig6 = defineClientConfig({
  enhance({
    app
  }) {
    app.component("ExternalLinkIcon", h$5(ExternalLinkIcon, {
      locales
    }));
  }
});
const clientConfig7 = {
  enhance: ({
    app
  }) => {
  }
};
const clientConfig8 = {
  enhance: ({
    app
  }) => {
  }
};
const getScrollTop = () => window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
const scrollToTop = () => window.scrollTo({
  top: 0,
  behavior: "smooth"
});
const vars = "";
const backToTop = "";
const BackToTop = defineComponent({
  name: "BackToTop",
  setup() {
    const scrollTop = ref(0);
    const show = computed(() => scrollTop.value > 300);
    const onScroll = r$6(() => {
      scrollTop.value = getScrollTop();
    }, 100);
    onMounted(() => {
      scrollTop.value = getScrollTop();
      window.addEventListener("scroll", () => onScroll());
    });
    const backToTopEl = h$5("div", {
      class: "back-to-top",
      onClick: scrollToTop
    });
    return () => h$5(Transition, {
      name: "back-to-top"
    }, () => show.value ? backToTopEl : null);
  }
});
const clientConfig9 = defineClientConfig({
  rootComponents: [BackToTop]
});
function useInitCopyBtn() {
  const codeNodes = ref([]);
  const addCopyBtnToCodeNode = () => {
    codeNodes.value.forEach((node2) => {
      node2.style.position = "relative";
      const btn = document.createElement("span");
      btn.className = "code-copy-btn";
      btn.style.position = "absolute";
      btn.style.zIndex = "20";
      btn.style.top = "4px";
      btn.style.right = "10px";
      btn.style.display = "none";
      btn.style.padding = "0 10px 0 10px";
      btn.style.borderRadius = "4px";
      btn.style.cursor = "pointer";
      btn.innerHTML = '<span class="copied">copied</span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="8" width="12" height="12" rx="2"></rect><path d="M16 8V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2"></path></g></svg>';
      const icon = btn.querySelector("svg");
      icon.style.width = "20px";
      icon.style.verticalAlign = "middle";
      const copied = btn.querySelector(".copied");
      copied.style.verticalAlign = "middle";
      copied.style.fontSize = "12px";
      copied.style.display = "none";
      copied.style.marginRight = "4px";
      handleElement(btn);
      node2.appendChild(btn);
      node2.addEventListener("mouseenter", () => {
        btn.style.display = "block";
      });
      node2.addEventListener("mouseleave", () => {
        btn.style.display = "none";
      });
    });
  };
  const initCopyBtn = () => {
    const nodes = document.querySelectorAll('div[class*="language-"]');
    codeNodes.value = nodes;
    addCopyBtnToCodeNode();
  };
  return {
    codeNodes,
    initCopyBtn
  };
}
async function copyToClipboard(text2) {
  try {
    return navigator.clipboard.writeText(text2);
  } catch (_a3) {
    const element = document.createElement("textarea");
    const previouslyFocusedElement = document.activeElement;
    element.value = text2;
    element.setAttribute("readonly", "");
    element.style.contain = "strict";
    element.style.position = "absolute";
    element.style.left = "-9999px";
    element.style.fontSize = "12pt";
    const selection = document.getSelection();
    const originalRange = selection ? selection.rangeCount > 0 && selection.getRangeAt(0) : null;
    document.body.appendChild(element);
    element.select();
    element.selectionStart = 0;
    element.selectionEnd = text2.length;
    document.execCommand("copy");
    document.body.removeChild(element);
    if (originalRange) {
      selection.removeAllRanges();
      selection.addRange(originalRange);
    }
    if (previouslyFocusedElement) {
      previouslyFocusedElement.focus();
    }
  }
}
function handleElement(el) {
  el.addEventListener("click", () => {
    const parent = el.parentElement;
    if (!parent) {
      return;
    }
    const isShell = parent.classList.contains("language-sh") || parent.classList.contains("language-bash");
    let {
      innerText: text2 = ""
    } = parent;
    if (isShell) {
      text2 = text2.replace(/^ *\$ /gm, "");
    }
    copyToClipboard(text2).then(() => {
      const copied = el.querySelector(".copied");
      copied.style.display = "inline-block";
      setTimeout(() => {
        copied.style.display = "none";
      }, 3e3);
    });
  });
}
async function applyClientSetup$2() {
  const {
    initCopyBtn
  } = useInitCopyBtn();
  onMounted(() => {
    setTimeout(() => {
      initCopyBtn();
    }, 500);
  });
}
const clientConfig10 = defineClientConfig({
  setup() {
    applyClientSetup$2();
  }
});
const resolveRepoType = (repo) => {
  if (!isLinkHttp$1(repo) || /github\.com/.test(repo))
    return "GitHub";
  if (/bitbucket\.org/.test(repo))
    return "Bitbucket";
  if (/gitlab\.com/.test(repo))
    return "GitLab";
  if (/gitee\.com/.test(repo))
    return "Gitee";
  return null;
};
const editLinkPatterns = {
  GitHub: ":repo/edit/:branch/:path",
  GitLab: ":repo/-/edit/:branch/:path",
  Gitee: ":repo/edit/:branch/:path",
  Bitbucket: ":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"
};
const resolveEditLink = ({
  docsRepo,
  docsBranch,
  docsDir,
  filePathRelative,
  editLinkPattern
}) => {
  const repoType = resolveRepoType(docsRepo);
  let pattern;
  if (editLinkPattern) {
    pattern = editLinkPattern;
  } else if (repoType !== null) {
    pattern = editLinkPatterns[repoType];
  }
  if (!pattern)
    return null;
  return pattern.replace(/:repo/, isLinkHttp$1(docsRepo) ? docsRepo : `https://github.com/${docsRepo}`).replace(/:branch/, docsBranch).replace(/:path/, removeLeadingSlash(`${removeEndingSlash(docsDir)}/${filePathRelative}`));
};
function createOneColor() {
  const tagColorArr = ["#e15b64", "#f47e60", "#f8b26a", "#abbd81", "#849b87", "#e15b64", "#f47e60", "#f8b26a", "#f26d6d", "#67cc86", "#fb9b5f", "#3498db"];
  const index2 = Math.floor(Math.random() * tagColorArr.length);
  return tagColorArr[index2];
}
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  __name: "Badge",
  props: {
    type: {
      type: String,
      required: false,
      default: "tip"
    },
    text: {
      type: String,
      required: false,
      default: ""
    },
    vertical: {
      type: String,
      required: false,
      default: "top"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "span",
        {
          class: normalizeClass(["badge", __props.type]),
          style: normalizeStyle({
            verticalAlign: __props.vertical
          })
        },
        [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(
              toDisplayString(__props.text),
              1
              /* TEXT */
            )
          ])
        ],
        6
        /* CLASS, STYLE */
      );
    };
  }
});
const Badge_vue_vue_type_style_index_0_lang = "";
const Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$1k, [["__file", "Badge.vue"]]);
const _hoisted_1$14 = {
  key: 1,
  class: "xicon-container"
};
const _sfc_main$1j = /* @__PURE__ */ defineComponent({
  __name: "Xicons",
  props: {
    icon: {
      type: String,
      default: ""
    },
    iconPosition: {
      type: String,
      default: "left"
    },
    iconSize: {
      type: [String, Number],
      default: 18
    },
    color: {
      type: String,
      default: "inherit"
    },
    text: {
      type: String,
      default: ""
    },
    textSize: {
      type: [String, Number],
      default: "14"
    },
    link: {
      type: String,
      default: "javascript:void(0)"
    },
    target: {
      type: String,
      default: "_self"
    }
  },
  emits: ["click"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const slots = useSlots();
    const { icon, iconSize, color, textSize } = toRefs(props);
    const iconStyle = computed(() => {
      const style2 = {
        width: `${iconSize.value}px`,
        height: `${iconSize.value}px`,
        fontSize: `${iconSize.value}px`,
        color: color.value
      };
      return style2;
    });
    const textStyle = computed(() => {
      return { color: color.value, fontSize: `${textSize.value}px` };
    });
    const handleClick = () => {
      if (props.link) {
        window.open(props.link, props.target);
      }
      emits("click");
    };
    return (_ctx, _cache) => {
      return __props.link !== "javascript:void(0)" || (__props.text || unref(slots).default) ? (openBlock(), createElementBlock(
        "span",
        {
          key: 0,
          class: normalizeClass(["xicon-container", __props.iconPosition]),
          onClick: handleClick
        },
        [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            (openBlock(), createBlock(resolveDynamicComponent(icons[unref(icon)]), {
              class: "xicon-icon",
              style: normalizeStyle(iconStyle.value)
            }, null, 8, ["style"]))
          ]),
          __props.text || unref(slots).default ? (openBlock(), createElementBlock(
            "span",
            {
              key: 0,
              class: "xicon-content",
              style: normalizeStyle(textStyle.value)
            },
            [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(
                  toDisplayString(__props.text),
                  1
                  /* TEXT */
                )
              ])
            ],
            4
            /* STYLE */
          )) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : (openBlock(), createElementBlock("span", _hoisted_1$14, [
        (openBlock(), createBlock(resolveDynamicComponent(icons[unref(icon)]), {
          style: normalizeStyle(iconStyle.value),
          onClick: _cache[0] || (_cache[0] = ($event) => emits("click"))
        }, null, 8, ["style"]))
      ]));
    };
  }
});
const Xicons_vue_vue_type_style_index_0_lang = "";
const Xicons = /* @__PURE__ */ _export_sfc$1(_sfc_main$1j, [["__file", "Xicons.vue"]]);
const _sfc_main$1i = defineComponent({
  name: "CodeGroup",
  setup(_2, { slots }) {
    const activeIndex = ref(-1);
    const tabRefs = ref([]);
    onBeforeUpdate(() => {
      tabRefs.value = [];
    });
    const activateNext = (i3 = activeIndex.value) => {
      if (i3 < tabRefs.value.length - 1) {
        activeIndex.value = i3 + 1;
      } else {
        activeIndex.value = 0;
      }
      tabRefs.value[activeIndex.value].focus();
    };
    const activatePrev = (i3 = activeIndex.value) => {
      if (i3 > 0) {
        activeIndex.value = i3 - 1;
      } else {
        activeIndex.value = tabRefs.value.length - 1;
      }
      tabRefs.value[activeIndex.value].focus();
    };
    const keyboardHandler = (event, i3) => {
      if (event.key === " " || event.key === "Enter") {
        event.preventDefault();
        activeIndex.value = i3;
      } else if (event.key === "ArrowRight") {
        event.preventDefault();
        activateNext(i3);
      } else if (event.key === "ArrowLeft") {
        event.preventDefault();
        activatePrev(i3);
      }
    };
    return () => {
      var _a3;
      const items = (((_a3 = slots.default) == null ? void 0 : _a3.call(slots)) || []).filter((vnode) => vnode.type.name === "CodeGroupItem").map((vnode) => {
        if (vnode.props === null) {
          vnode.props = {};
        }
        return vnode;
      });
      if (items.length === 0) {
        return null;
      }
      if (activeIndex.value < 0 || activeIndex.value > items.length - 1) {
        activeIndex.value = items.findIndex(
          (vnode) => vnode.props.active === "" || vnode.props.active === true
        );
        if (activeIndex.value === -1) {
          activeIndex.value = 0;
        }
      } else {
        items.forEach((vnode, i3) => {
          vnode.props.active = i3 === activeIndex.value;
        });
      }
      return h$5("div", { class: "code-group" }, [
        h$5(
          "div",
          { class: "code-group__nav" },
          h$5(
            "ul",
            { class: "code-group__ul" },
            items.map((vnode, i3) => {
              const isActive = i3 === activeIndex.value;
              return h$5(
                "li",
                { class: "code-group__li" },
                h$5(
                  "button",
                  {
                    ref: (element) => {
                      if (element) {
                        tabRefs.value[i3] = element;
                      }
                    },
                    class: {
                      "code-group__nav-tab": true,
                      "code-group__nav-tab-active": isActive
                    },
                    ariaPressed: isActive,
                    ariaExpanded: isActive,
                    onClick: () => activeIndex.value = i3,
                    onKeydown: (e2) => keyboardHandler(e2, i3)
                  },
                  h$5(
                    Xicons,
                    {
                      icon: "Code",
                      text: vnode.props.title
                    }
                  )
                )
              );
            })
          )
        ),
        items
      ]);
    };
  }
});
const CodeGroup_vue_vue_type_style_index_0_lang = "";
const CodeGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$1i, [["__file", "CodeGroup.vue"]]);
const _sfc_main$1h = {};
const _hoisted_1$13 = { class: "magic-card" };
const _hoisted_2$J = /* @__PURE__ */ createElementVNode(
  "span",
  { class: "magic-card__bg" },
  null,
  -1
  /* HOISTED */
);
function _sfc_render$I(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$13, [
    _hoisted_2$J,
    renderSlot(_ctx.$slots, "default")
  ]);
}
const MagicCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$1h, [["render", _sfc_render$I], ["__file", "MagicCard.vue"]]);
const _hoisted_1$12 = { class: "vue-preview-container" };
const _hoisted_2$I = {
  key: 0,
  class: "preview-container"
};
const _sfc_main$1g = /* @__PURE__ */ defineComponent({
  __name: "VuePreview",
  props: ["component"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$12, [
        __props.component !== "undefined" ? (openBlock(), createElementBlock("div", _hoisted_2$I, [
          (openBlock(), createBlock(resolveDynamicComponent(__props.component)))
        ])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
const VuePreview_vue_vue_type_style_index_0_lang = "";
const VuePreview = /* @__PURE__ */ _export_sfc$1(_sfc_main$1g, [["__file", "VuePreview.vue"]]);
const _hoisted_1$11 = ["aria-selected"];
const __default__$3 = defineComponent({
  name: "CodeGroupItem"
});
const _sfc_main$1f = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: {
    title: {
      type: String,
      required: true
    },
    active: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["code-group-item", { "code-group-item__active": __props.active }]),
        "aria-selected": __props.active
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 10, _hoisted_1$11);
    };
  }
});
const CodeGroupItem_vue_vue_type_style_index_0_lang = "";
const CodeGroupItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1f, [["__file", "CodeGroupItem.vue"]]);
const GlobalComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Badge,
  CodeGroup,
  CodeGroupItem,
  MagicCard,
  VuePreview,
  Xicons
}, Symbol.toStringTag, { value: "Module" }));
function registerGlobalComponents(app) {
  Object.keys(GlobalComponents).forEach((key) => {
    app.component(key, GlobalComponents[key]);
  });
}
function resolveSearchComponent(app) {
  app.component("NavbarSearch", () => {
    const SearchComponent = app.component("Docsearch") || app.component("SearchBox");
    return SearchComponent ? h$5(SearchComponent) : null;
  });
}
const throttle = (func, wait = 500) => {
  let timer;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      func.apply(func, args);
      timer = null;
    }, wait);
  };
};
class MouseMove {
  constructor() {
    this.cards = [];
  }
  init() {
    this.getCardNodes();
    this.initMouseMoveObserver();
  }
  initMouseMoveObserver() {
    window.removeEventListener("mousemove", () => {
    });
    window.addEventListener("mousemove", throttle((event) => {
      const x2 = event.pageX;
      const y3 = event.pageY;
      this._setMouseLocationToCard(x2, y3);
    }, 50));
  }
  getCardNodes() {
    const cards = document.querySelectorAll(".magic-card");
    this.cards = cards;
    cards.forEach((card) => {
      card.setAttribute("data-x", card.offsetLeft);
      card.setAttribute("data-y", card.offsetTop);
      card.setAttribute("data-width", card.clientWidth);
      card.setAttribute("data-height", card.clientHeight);
    });
  }
  _setMouseLocationToCard(mouseX, mouseY) {
    this.cards.forEach((card) => {
      const {
        x: cardX,
        y: cardY,
        width,
        height
      } = card.dataset;
      const x2 = Math.floor(mouseX - cardX);
      const y3 = Math.floor(mouseY - cardY);
      card.style.setProperty("--x", `${x2}px`);
      card.style.setProperty("--y", `${y3}px`);
    });
  }
}
const mouseMove = new MouseMove();
function useMagicCard() {
  const initMagicCard = () => {
    mouseMove.init();
  };
  return {
    initMagicCard
  };
}
ref(false);
const useMobileMenus = () => {
  const isOpenMobileMenus = ref(false);
  const toggleMobileMenus = (to) => {
    isOpenMobileMenus.value = typeof to === "boolean" ? to : !isOpenMobileMenus.value;
  };
  return {
    isOpenMobileMenus,
    toggleMobileMenus
  };
};
const useResolveRouteWithRedirect = (...args) => {
  const router = useRouter();
  const route = router.resolve(...args);
  const lastMatched = route.matched[route.matched.length - 1];
  if (!(lastMatched === null || lastMatched === void 0 ? void 0 : lastMatched.redirect)) {
    return route;
  }
  const {
    redirect
  } = lastMatched;
  const resolvedRedirect = isFunction$1(redirect) ? redirect(route) : redirect;
  const resolvedRedirectObj = isString$1(resolvedRedirect) ? {
    path: resolvedRedirect
  } : resolvedRedirect;
  return useResolveRouteWithRedirect({
    hash: route.hash,
    query: route.query,
    params: route.params,
    ...resolvedRedirectObj
  });
};
const useNavLink = (item) => {
  const resolved = useResolveRouteWithRedirect(item);
  return {
    text: resolved.meta.title || item,
    link: resolved.name === "404" ? item : resolved.fullPath
  };
};
const catalogSymbol = Symbol("catalog");
const usePageCatalog = () => {
  const catalog = inject(catalogSymbol);
  if (!catalog) {
    throw new Error("usePageCatalog() is called without provider.");
  }
  return catalog;
};
function resolveCatalog() {
  const page = usePageData$1();
  return headersToCatalog(page.value.headers);
}
const headerToCatalogItem = (header) => ({
  text: header.title,
  link: `#${header.slug}`,
  level: header.level,
  children: headersToCatalog(header.children)
});
const headersToCatalog = (headers) => headers.map((header) => headerToCatalogItem(header));
const direction = ref("");
function useScrollDirection() {
  let startY = 0, endY = 0;
  onMounted(() => {
    window.addEventListener("touchstart", (e2) => {
      const touch = e2.touches[0];
      startY = Number(touch.pageY);
    });
    window.addEventListener("touchmove", throttle((e2) => {
      const touch = e2.touches[0];
      endY = touch.pageY;
      if (endY - startY < 0) {
        direction.value = "top";
      } else if (endY - startY > 0) {
        direction.value = "bottom";
      } else {
        direction.value = "";
      }
      startY = endY;
    }, 300));
  });
  return {
    direction
  };
}
let promise = null;
let promiseResolve = null;
const scrollPromise = {
  wait: () => promise,
  pending: () => {
    promise = new Promise((resolve) => promiseResolve = resolve);
  },
  resolve: () => {
    promiseResolve === null || promiseResolve === void 0 ? void 0 : promiseResolve();
    promise = null;
    promiseResolve = null;
  }
};
const useScrollPromise = () => scrollPromise;
const useSeriesData = () => {
  const isOpenSeries = ref(false);
  const frontmatter = usePageFrontmatter();
  const seriesItems = useSeriesItems();
  const catalog = usePageCatalog();
  const isShowSeries = computed(() => seriesItems.value.length > 0 && isOpenSeries);
  const isShowCatalog = computed(() => catalog.value.length > 0 && frontmatter.value.home !== true);
  const toggleSeries = (to) => {
    isOpenSeries.value = typeof to === "boolean" ? to : !isOpenSeries.value;
    document.body.style.overflowY = isOpenSeries.value ? "hidden" : "auto";
  };
  return {
    isOpenSeries,
    isShowSeries,
    isShowCatalog,
    toggleSeries
  };
};
const categoryPaginationPostsSymbol = Symbol("categoryPaginationPostsSymbol");
const categorySummarySymbol = Symbol("categorySummarySymbol");
const postsSymbol = Symbol("postsSymbol");
const seriesSymbol = Symbol("seriesSymbol");
function usePageData() {
  const categorySummary = inject(categorySummarySymbol, null) || {};
  const posts = inject(postsSymbol, null) || [];
  const series = inject(seriesSymbol, null) || {};
  const categoryPaginationPosts = inject(categoryPaginationPostsSymbol, null) || {};
  if (!postsSymbol) {
    throw new Error("useSiteLocaleData() is called without provider.");
  }
  const {
    currentRoute
  } = useRouter();
  const categoryPosts = computed(() => {
    return categoryPaginationPosts[currentRoute.value.path] || {};
  });
  return {
    categoryPosts,
    categorySummary,
    posts,
    series
  };
}
const seriesItemsSymbol = Symbol("seriesItems");
const useSeriesItems = () => {
  const seriesItems = inject(seriesItemsSymbol);
  if (!seriesItems) {
    throw new Error("useSeriesItems() is called without provider.");
  }
  return seriesItems;
};
const resolveSeriesItems = (frontmatter, themeLocal, series) => {
  var _a3;
  const {
    series: autoSeries
  } = usePageData();
  let seriesConfig = (_a3 = themeLocal.series) !== null && _a3 !== void 0 ? _a3 : {};
  seriesConfig = {
    ...autoSeries,
    ...seriesConfig
  };
  if (frontmatter.home) {
    return [];
  }
  if (isPlainObject$1(seriesConfig)) {
    return resolveMultiSeriesItems(seriesConfig);
  }
  return [];
};
const resolveArraySeriesItems = (seriesConfig) => {
  const handleChildItem = (item) => {
    let childItem;
    if (isString$1(item)) {
      childItem = useNavLink(item);
    } else {
      childItem = item;
    }
    return childItem;
  };
  return seriesConfig.map((item) => {
    if (isString$1(item)) {
      return useNavLink(item);
    }
    return {
      ...item,
      children: item.children.map(handleChildItem)
    };
  });
};
const resolveMultiSeriesItems = (seriesConfig) => {
  var _a3;
  const route = useRoute();
  const seriesPath = resolveLocalePath(seriesConfig, decodeURIComponent(route.path));
  const matchedSeriesConfig = (_a3 = seriesConfig[seriesPath]) !== null && _a3 !== void 0 ? _a3 : [];
  return resolveArraySeriesItems(matchedSeriesConfig);
};
const isLetterOrNumberReg = (str) => {
  return /^[0-9a-zA-Z]+$/.test(str);
};
const isAllChineseStr = (str) => {
  return /^[\u4E00-\u9FA5]+$/.test(str);
};
const splitStringByNumber = (str, sortByNumericalSize = false) => {
  let strArr = [];
  const REG_STRING_NUMBER_PARTS = /\d+|\D+/g;
  const arr = str.match(REG_STRING_NUMBER_PARTS);
  for (let i3 = 0; i3 < arr.length; i3++) {
    const splitStr = arr[i3];
    if (isNaN(splitStr)) {
      strArr = strArr.concat(splitStr.split(""));
    } else {
      if (!sortByNumericalSize) {
        strArr = strArr.concat(splitStr.split(""));
      } else {
        strArr.push(splitStr);
      }
    }
  }
  return strArr;
};
const compare = (a2, b2, sortByNumericalSize = true) => {
  if (isLetterOrNumberReg(a2) && isLetterOrNumberReg(b2)) {
    return a2.localeCompare(b2, "zh-Hans-CN", {
      numeric: true
    });
  }
  if (isAllChineseStr(a2) && isAllChineseStr(b2)) {
    return a2.localeCompare(b2, "zh-Hans-CN", {
      numeric: true
    });
  }
  const arrA = splitStringByNumber(a2, sortByNumericalSize);
  const arrB = splitStringByNumber(b2, sortByNumericalSize);
  let result = 0;
  const length = Math.min(arrA.length, arrB.length);
  for (let i3 = 0; i3 < length; i3++) {
    const charA = arrA[i3];
    const charB = arrB[i3];
    if (!isAllChineseStr(charA) && isAllChineseStr(charB)) {
      return -1;
    }
    if (isAllChineseStr(charA) && !isAllChineseStr(charB)) {
      return 1;
    }
    if (isAllChineseStr(charA) && isAllChineseStr(charB)) {
      result = charA.localeCompare(charB, "zh-Hans-CN");
    } else {
      result = charA.localeCompare(charB, "zh-Hans-CN", {
        numeric: true
      });
    }
    if (result !== 0) {
      return result;
    }
  }
  if (arrA.length > arrB.length)
    return 1;
  if (arrA.length < arrB.length)
    return -1;
  return 0;
};
function sortSeries(arr) {
  const a2 = arr.sort((a3, b2) => {
    if (a3.children)
      sortSeries(a3.children);
    if (b2.children)
      sortSeries(b2.children);
    return compare(a3.text, b2.text, true);
  });
  return a2;
}
function useSortSeries() {
  return {
    sortSeries
  };
}
const useThemeLocaleData = () => useThemeLocaleData$1();
function applyClientSetup$1() {
  const themeLocal = useThemeLocaleData();
  usePageData();
  const frontmatter = usePageFrontmatter();
  const seriesItems = computed(() => resolveSeriesItems(frontmatter.value, themeLocal.value));
  provide(seriesItemsSymbol, seriesItems);
  const catalog = computed(() => resolveCatalog());
  provide(catalogSymbol, catalog);
}
const index$1 = "";
const index = "";
function applyClientEnhance({
  app
}) {
  registerGlobalComponents(app);
  resolveSearchComponent(app);
}
/*!
 * md5-es
 * https://github.com/logotype/es-crypto.git
 *
 * Copyright 2017 Victor Norgren
 * Released under the MIT license
 */
class MD5 {
  hash(string) {
    return MD5.hex(MD5.md51(string));
  }
  static md5cycle(x2, k2) {
    let a2 = x2[0], b2 = x2[1], c2 = x2[2], d2 = x2[3];
    a2 = MD5.ff(a2, b2, c2, d2, k2[0], 7, -680876936);
    d2 = MD5.ff(d2, a2, b2, c2, k2[1], 12, -389564586);
    c2 = MD5.ff(c2, d2, a2, b2, k2[2], 17, 606105819);
    b2 = MD5.ff(b2, c2, d2, a2, k2[3], 22, -1044525330);
    a2 = MD5.ff(a2, b2, c2, d2, k2[4], 7, -176418897);
    d2 = MD5.ff(d2, a2, b2, c2, k2[5], 12, 1200080426);
    c2 = MD5.ff(c2, d2, a2, b2, k2[6], 17, -1473231341);
    b2 = MD5.ff(b2, c2, d2, a2, k2[7], 22, -45705983);
    a2 = MD5.ff(a2, b2, c2, d2, k2[8], 7, 1770035416);
    d2 = MD5.ff(d2, a2, b2, c2, k2[9], 12, -1958414417);
    c2 = MD5.ff(c2, d2, a2, b2, k2[10], 17, -42063);
    b2 = MD5.ff(b2, c2, d2, a2, k2[11], 22, -1990404162);
    a2 = MD5.ff(a2, b2, c2, d2, k2[12], 7, 1804603682);
    d2 = MD5.ff(d2, a2, b2, c2, k2[13], 12, -40341101);
    c2 = MD5.ff(c2, d2, a2, b2, k2[14], 17, -1502002290);
    b2 = MD5.ff(b2, c2, d2, a2, k2[15], 22, 1236535329);
    a2 = MD5.gg(a2, b2, c2, d2, k2[1], 5, -165796510);
    d2 = MD5.gg(d2, a2, b2, c2, k2[6], 9, -1069501632);
    c2 = MD5.gg(c2, d2, a2, b2, k2[11], 14, 643717713);
    b2 = MD5.gg(b2, c2, d2, a2, k2[0], 20, -373897302);
    a2 = MD5.gg(a2, b2, c2, d2, k2[5], 5, -701558691);
    d2 = MD5.gg(d2, a2, b2, c2, k2[10], 9, 38016083);
    c2 = MD5.gg(c2, d2, a2, b2, k2[15], 14, -660478335);
    b2 = MD5.gg(b2, c2, d2, a2, k2[4], 20, -405537848);
    a2 = MD5.gg(a2, b2, c2, d2, k2[9], 5, 568446438);
    d2 = MD5.gg(d2, a2, b2, c2, k2[14], 9, -1019803690);
    c2 = MD5.gg(c2, d2, a2, b2, k2[3], 14, -187363961);
    b2 = MD5.gg(b2, c2, d2, a2, k2[8], 20, 1163531501);
    a2 = MD5.gg(a2, b2, c2, d2, k2[13], 5, -1444681467);
    d2 = MD5.gg(d2, a2, b2, c2, k2[2], 9, -51403784);
    c2 = MD5.gg(c2, d2, a2, b2, k2[7], 14, 1735328473);
    b2 = MD5.gg(b2, c2, d2, a2, k2[12], 20, -1926607734);
    a2 = MD5.hh(a2, b2, c2, d2, k2[5], 4, -378558);
    d2 = MD5.hh(d2, a2, b2, c2, k2[8], 11, -2022574463);
    c2 = MD5.hh(c2, d2, a2, b2, k2[11], 16, 1839030562);
    b2 = MD5.hh(b2, c2, d2, a2, k2[14], 23, -35309556);
    a2 = MD5.hh(a2, b2, c2, d2, k2[1], 4, -1530992060);
    d2 = MD5.hh(d2, a2, b2, c2, k2[4], 11, 1272893353);
    c2 = MD5.hh(c2, d2, a2, b2, k2[7], 16, -155497632);
    b2 = MD5.hh(b2, c2, d2, a2, k2[10], 23, -1094730640);
    a2 = MD5.hh(a2, b2, c2, d2, k2[13], 4, 681279174);
    d2 = MD5.hh(d2, a2, b2, c2, k2[0], 11, -358537222);
    c2 = MD5.hh(c2, d2, a2, b2, k2[3], 16, -722521979);
    b2 = MD5.hh(b2, c2, d2, a2, k2[6], 23, 76029189);
    a2 = MD5.hh(a2, b2, c2, d2, k2[9], 4, -640364487);
    d2 = MD5.hh(d2, a2, b2, c2, k2[12], 11, -421815835);
    c2 = MD5.hh(c2, d2, a2, b2, k2[15], 16, 530742520);
    b2 = MD5.hh(b2, c2, d2, a2, k2[2], 23, -995338651);
    a2 = MD5.ii(a2, b2, c2, d2, k2[0], 6, -198630844);
    d2 = MD5.ii(d2, a2, b2, c2, k2[7], 10, 1126891415);
    c2 = MD5.ii(c2, d2, a2, b2, k2[14], 15, -1416354905);
    b2 = MD5.ii(b2, c2, d2, a2, k2[5], 21, -57434055);
    a2 = MD5.ii(a2, b2, c2, d2, k2[12], 6, 1700485571);
    d2 = MD5.ii(d2, a2, b2, c2, k2[3], 10, -1894986606);
    c2 = MD5.ii(c2, d2, a2, b2, k2[10], 15, -1051523);
    b2 = MD5.ii(b2, c2, d2, a2, k2[1], 21, -2054922799);
    a2 = MD5.ii(a2, b2, c2, d2, k2[8], 6, 1873313359);
    d2 = MD5.ii(d2, a2, b2, c2, k2[15], 10, -30611744);
    c2 = MD5.ii(c2, d2, a2, b2, k2[6], 15, -1560198380);
    b2 = MD5.ii(b2, c2, d2, a2, k2[13], 21, 1309151649);
    a2 = MD5.ii(a2, b2, c2, d2, k2[4], 6, -145523070);
    d2 = MD5.ii(d2, a2, b2, c2, k2[11], 10, -1120210379);
    c2 = MD5.ii(c2, d2, a2, b2, k2[2], 15, 718787259);
    b2 = MD5.ii(b2, c2, d2, a2, k2[9], 21, -343485551);
    x2[0] = a2 + x2[0] & 4294967295;
    x2[1] = b2 + x2[1] & 4294967295;
    x2[2] = c2 + x2[2] & 4294967295;
    x2[3] = d2 + x2[3] & 4294967295;
  }
  static cmn(q2, a2, b2, x2, s2, t2) {
    a2 = (a2 + q2 & 4294967295) + (x2 + t2 & 4294967295) & 4294967295;
    return (a2 << s2 | a2 >>> 32 - s2) + b2 & 4294967295;
  }
  static ff(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
  }
  static gg(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
  }
  static hh(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
  }
  static ii(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
  }
  static md51(s2) {
    const n2 = s2.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let o2 = 0, i3 = 64;
    for (i3; i3 <= n2; i3 += 64) {
      MD5.md5cycle(state, MD5.md5blk(s2.substring(i3 - 64, i3)));
    }
    s2 = s2.substring(i3 - 64);
    i3 = 0;
    o2 = s2.length;
    for (i3; i3 < o2; i3++) {
      tail[i3 >> 2] |= s2.charCodeAt(i3) << (i3 % 4 << 3);
    }
    tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
    if (i3 > 55) {
      MD5.md5cycle(state, tail);
      for (i3 = 0; i3 < 16; i3++) {
        tail[i3] = 0;
      }
    }
    tail[14] = n2 * 8;
    MD5.md5cycle(state, tail);
    return state;
  }
  static md5blk(s2) {
    const md5blks = [];
    let i3 = 0;
    for (i3; i3 < 64; i3 += 4) {
      md5blks[i3 >> 2] = s2.charCodeAt(i3) + (s2.charCodeAt(i3 + 1) << 8) + (s2.charCodeAt(i3 + 2) << 16) + (s2.charCodeAt(i3 + 3) << 24);
    }
    return md5blks;
  }
  static rhex(n2) {
    let s2 = "";
    s2 += MD5.hexArray[n2 >> 4 & 15] + MD5.hexArray[n2 >> 0 & 15];
    s2 += MD5.hexArray[n2 >> 12 & 15] + MD5.hexArray[n2 >> 8 & 15];
    s2 += MD5.hexArray[n2 >> 20 & 15] + MD5.hexArray[n2 >> 16 & 15];
    s2 += MD5.hexArray[n2 >> 28 & 15] + MD5.hexArray[n2 >> 24 & 15];
    return s2;
  }
  static hex(x2) {
    const length = x2.length;
    let i3 = 0;
    for (i3; i3 < length; i3++) {
      x2[i3] = MD5.rhex(x2[i3]);
    }
    return x2.join("");
  }
}
MD5.hexArray = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
const md5 = new MD5().hash;
const convertToPinyin = (sourceStr = "") => {
  let targetStr = "";
  const cnReg = /[\u4e00-\u9fa5]/;
  targetStr = sourceStr.split("").reduce((total, next, index2) => {
    if (cnReg.test(next)) {
      const searchResult = searchPinYin(next, PinYin);
      return total += searchResult ? searchResult : "";
    }
    return total += next;
  }, "");
  return targetStr;
};
const searchPinYin = (str, data) => {
  for (const key in data) {
    if (data.hasOwnProperty(key) && data[key].indexOf(str) !== -1) {
      return key;
    }
  }
  return "";
};
const PinYin = {
  a: "啊阿锕",
  ai: "埃挨哎唉哀皑癌蔼矮艾碍爱隘诶捱嗳嗌嫒瑷暧砹锿霭",
  an: "鞍氨安俺按暗岸胺案谙埯揞犴庵桉铵鹌顸黯",
  ang: "肮昂盎",
  ao: "凹敖熬翱袄傲奥懊澳坳拗嗷噢岙廒遨媪骜聱螯鏊鳌鏖",
  ba: "芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸茇菝萆捭岜灞杷钯粑鲅魃",
  bai: "白柏百摆佰败拜稗薜掰鞴",
  ban: "斑班搬扳般颁板版扮拌伴瓣半办绊阪坂豳钣瘢癍舨",
  bang: "邦帮梆榜膀绑棒磅蚌镑傍谤蒡螃",
  bao: "苞胞包褒雹保堡饱宝抱报暴豹鲍爆勹葆宀孢煲鸨褓趵龅",
  bo: "剥薄玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳亳蕃啵饽檗擘礴钹鹁簸跛",
  bei: "杯碑悲卑北辈背贝钡倍狈备惫焙被孛陂邶埤蓓呗怫悖碚鹎褙鐾",
  ben: "奔苯本笨畚坌锛",
  beng: "崩绷甭泵蹦迸唪嘣甏",
  bi: "逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛匕仳俾芘荜荸吡哔狴庳愎滗濞弼妣婢嬖璧贲畀铋秕裨筚箅篦舭襞跸髀",
  bian: "鞭边编贬扁便变卞辨辩辫遍匾弁苄忭汴缏煸砭碥稹窆蝙笾鳊",
  biao: "标彪膘表婊骠飑飙飚灬镖镳瘭裱鳔",
  bie: "鳖憋别瘪蹩鳘",
  bin: "彬斌濒滨宾摈傧浜缤玢殡膑镔髌鬓",
  bing: "兵冰柄丙秉饼炳病并禀邴摒绠枋槟燹",
  bu: "捕卜哺补埠不布步簿部怖拊卟逋瓿晡钚醭",
  ca: "擦嚓礤",
  cai: "猜裁材才财睬踩采彩菜蔡",
  can: "餐参蚕残惭惨灿骖璨粲黪",
  cang: "苍舱仓沧藏伧",
  cao: "操糙槽曹草艹嘈漕螬艚",
  ce: "厕策侧册测刂帻恻",
  ceng: "层蹭噌",
  cha: "插叉茬茶查碴搽察岔差诧猹馇汊姹杈楂槎檫钗锸镲衩",
  chai: "拆柴豺侪茈瘥虿龇",
  chan: "搀掺蝉馋谗缠铲产阐颤冁谄谶蒇廛忏潺澶孱羼婵嬗骣觇禅镡裣蟾躔",
  chang: "昌猖场尝常长偿肠厂敞畅唱倡伥鬯苌菖徜怅惝阊娼嫦昶氅鲳",
  chao: "超抄钞朝嘲潮巢吵炒怊绉晁耖",
  che: "车扯撤掣彻澈坼屮砗",
  chen: "郴臣辰尘晨忱沉陈趁衬称谌抻嗔宸琛榇肜胂碜龀",
  cheng: "撑城橙成呈乘程惩澄诚承逞骋秤埕嵊徵浈枨柽樘晟塍瞠铖裎蛏酲",
  chi: "吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽傺墀芪茌搋叱哧啻嗤彳饬沲媸敕胝眙眵鸱瘛褫蚩螭笞篪豉踅踟魑",
  chong: "充冲虫崇宠茺忡憧铳艟",
  chou: "抽酬畴踌稠愁筹仇绸瞅丑俦圳帱惆溴妯瘳雠鲋",
  chu: "臭初出橱厨躇锄雏滁除楚础储矗搐触处亍刍憷绌杵楮樗蜍蹰黜",
  chuan: "揣川穿椽传船喘串掾舛惴遄巛氚钏镩舡",
  chuang: "疮窗幢床闯创怆",
  chui: "吹炊捶锤垂陲棰槌",
  chun: "春椿醇唇淳纯蠢促莼沌肫朐鹑蝽",
  chuo: "戳绰蔟辶辍镞踔龊",
  ci: "疵茨磁雌辞慈瓷词此刺赐次荠呲嵯鹚螅糍趑",
  cong: "聪葱囱匆从丛偬苁淙骢琮璁枞",
  cu: "凑粗醋簇猝殂蹙",
  cuan: "蹿篡窜汆撺昕爨",
  cui: "摧崔催脆瘁粹淬翠萃悴璀榱隹",
  cun: "村存寸磋忖皴",
  cuo: "撮搓措挫错厝脞锉矬痤鹾蹉躜",
  da: "搭达答瘩打大耷哒嗒怛妲疸褡笪靼鞑",
  dai: "呆歹傣戴带殆代贷袋待逮怠埭甙呔岱迨逯骀绐玳黛",
  dan: "耽担丹单郸掸胆旦氮但惮淡诞弹蛋亻儋卩萏啖澹檐殚赕眈瘅聃箪",
  dang: "当挡党荡档谠凼菪宕砀铛裆",
  dao: "刀捣蹈倒岛祷导到稻悼道盗叨啁忉洮氘焘忑纛",
  de: "德得的锝",
  deng: "蹬灯登等瞪凳邓噔嶝戥磴镫簦",
  di: "堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔氐籴诋谛邸坻莜荻嘀娣柢棣觌砥碲睇镝羝骶",
  dian: "颠掂滇碘点典靛垫电佃甸店惦奠淀殿丶阽坫埝巅玷癜癫簟踮",
  diao: "碉叼雕凋刁掉吊钓调轺铞蜩粜貂",
  die: "跌爹碟蝶迭谍叠佚垤堞揲喋渫轶牒瓞褶耋蹀鲽鳎",
  ding: "丁盯叮钉顶鼎锭定订丢仃啶玎腚碇町铤疔耵酊",
  dong: "东冬董懂动栋侗恫冻洞垌咚岽峒夂氡胨胴硐鸫",
  dou: "兜抖斗陡豆逗痘蔸钭窦窬蚪篼酡",
  du: "都督毒犊独读堵睹赌杜镀肚度渡妒芏嘟渎椟橐牍蠹笃髑黩",
  duan: "端短锻段断缎彖椴煅簖",
  dui: "堆兑队对怼憝碓",
  dun: "墩吨蹲敦顿囤钝盾遁炖砘礅盹镦趸",
  duo: "掇哆多夺垛躲朵跺舵剁惰堕咄哚缍柁铎裰踱",
  e: "蛾峨鹅俄额讹娥恶厄扼遏鄂饿噩谔垩垭苊莪萼呃愕屙婀轭曷腭硪锇锷鹗颚鳄",
  en: "恩蒽摁唔嗯",
  er: "而儿耳尔饵洱二贰迩珥铒鸸鲕",
  fa: "发罚筏伐乏阀法珐垡砝",
  fan: "藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛蘩幡犭梵攵燔畈蹯",
  fang: "坊芳方肪房防妨仿访纺放匚邡彷钫舫鲂",
  fei: "菲非啡飞肥匪诽吠肺废沸费芾狒悱淝妃绋绯榧腓斐扉祓砩镄痱蜚篚翡霏鲱",
  fen: "芬酚吩氛分纷坟焚汾粉奋份忿愤粪偾瀵棼愍鲼鼢",
  feng: "丰封枫蜂峰锋风疯烽逢冯缝讽奉凤俸酆葑沣砜",
  fu: "佛否夫敷肤孵扶拂辐幅氟符伏俘服浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐匐凫郛芙苻茯莩菔呋幞滏艴孚驸绂桴赙黻黼罘稃馥虍蚨蜉蝠蝮麸趺跗鳆",
  ga: "噶嘎蛤尬呷尕尜旮钆",
  gai: "该改概钙盖溉丐陔垓戤赅胲",
  gan: "干甘杆柑竿肝赶感秆敢赣坩苷尴擀泔淦澉绀橄旰矸疳酐",
  gang: "冈刚钢缸肛纲岗港戆罡颃筻",
  gong: "杠工攻功恭龚供躬公宫弓巩汞拱贡共蕻廾咣珙肱蚣蛩觥",
  gao: "篙皋高膏羔糕搞镐稿告睾诰郜蒿藁缟槔槁杲锆",
  ge: "哥歌搁戈鸽胳疙割革葛格阁隔铬个各鬲仡哿塥嗝纥搿膈硌铪镉袼颌虼舸骼髂",
  gei: "给",
  gen: "根跟亘茛哏艮",
  geng: "耕更庚羹埂耿梗哽赓鲠",
  gou: "钩勾沟苟狗垢构购够佝诟岣遘媾缑觏彀鸲笱篝鞲",
  gu: "辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇嘏诂菰哌崮汩梏轱牯牿胍臌毂瞽罟钴锢瓠鸪鹄痼蛄酤觚鲴骰鹘",
  gua: "刮瓜剐寡挂褂卦诖呱栝鸹",
  guai: "乖拐怪哙",
  guan: "棺关官冠观管馆罐惯灌贯倌莞掼涫盥鹳鳏",
  guang: "光广逛犷桄胱疒",
  gui: "瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽匦刿庋宄妫桧炅晷皈簋鲑鳜",
  gun: "辊滚棍丨衮绲磙鲧",
  guo: "锅郭国果裹过馘蠃埚掴呙囗帼崞猓椁虢锞聒蜮蜾蝈",
  ha: "哈",
  hai: "骸孩海氦亥害骇咴嗨颏醢",
  han: "酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉邗菡撖阚瀚晗焓颔蚶鼾",
  hen: "夯痕很狠恨",
  hang: "杭航沆绗珩桁",
  hao: "壕嚎豪毫郝好耗号浩薅嗥嚆濠灏昊皓颢蚝",
  he: "呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺诃劾壑藿嗑嗬阖盍蚵翮",
  hei: "嘿黑",
  heng: "哼亨横衡恒訇蘅",
  hong: "轰哄烘虹鸿洪宏弘红黉讧荭薨闳泓",
  hou: "喉侯猴吼厚候后堠後逅瘊篌糇鲎骺",
  hu: "呼乎忽瑚壶葫胡蝴狐糊湖弧虎唬护互沪户冱唿囫岵猢怙惚浒滹琥槲轷觳烀煳戽扈祜鹕鹱笏醐斛",
  hua: "花哗华猾滑画划化话劐浍骅桦铧稞",
  huai: "槐徊怀淮坏还踝",
  huan: "欢环桓缓换患唤痪豢焕涣宦幻郇奂垸擐圜洹浣漶寰逭缳锾鲩鬟",
  huang: "荒慌黄磺蝗簧皇凰惶煌晃幌恍谎隍徨湟潢遑璜肓癀蟥篁鳇",
  hui: "灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘诙茴荟蕙哕喙隳洄彗缋珲晖恚虺蟪麾",
  hun: "荤昏婚魂浑混诨馄阍溷缗",
  huo: "豁活伙火获或惑霍货祸攉嚯夥钬锪镬耠蠖",
  ji: "击圾基机畸稽积箕肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪居丌乩剞佶佴脔墼芨芰萁蒺蕺掎叽咭哜唧岌嵴洎彐屐骥畿玑楫殛戟戢赍觊犄齑矶羁嵇稷瘠瘵虮笈笄暨跻跽霁鲚鲫髻麂",
  jia: "嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁伽郏拮岬浃迦珈戛胛恝铗镓痂蛱笳袈跏",
  jian: "歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件健舰剑饯渐溅涧建僭谏谫菅蒹搛囝湔蹇謇缣枧柙楗戋戬牮犍毽腱睑锏鹣裥笕箴翦趼踺鲣鞯",
  jiang: "僵姜将浆江疆蒋桨奖讲匠酱降茳洚绛缰犟礓耩糨豇",
  jiao: "蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫佼僬茭挢噍峤徼姣纟敫皎鹪蛟醮跤鲛",
  jie: "窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届偈讦诘喈嗟獬婕孑桀獒碣锴疖袷颉蚧羯鲒骱髫",
  jin: "巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸尽卺荩堇噤馑廑妗缙瑾槿赆觐钅锓衿矜",
  jing: "劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净刭儆阱菁獍憬泾迳弪婧肼胫腈旌",
  jiong: "炯窘冂迥扃",
  jiu: "揪究纠玖韭久灸九酒厩救旧臼舅咎就疚僦啾阄柩桕鹫赳鬏",
  ju: "鞠拘狙疽驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧倨讵苣苴莒掬遽屦琚枸椐榘榉橘犋飓钜锔窭裾趄醵踽龃雎鞫",
  juan: "捐鹃娟倦眷卷绢鄄狷涓桊蠲锩镌隽",
  jue: "撅攫抉掘倔爵觉决诀绝厥劂谲矍蕨噘崛獗孓珏桷橛爝镢蹶觖",
  jun: "均菌钧军君峻俊竣浚郡骏捃狻皲筠麇",
  ka: "喀咖卡佧咔胩",
  ke: "咯坷苛柯棵磕颗科壳咳可渴克刻客课岢恪溘骒缂珂轲氪瞌钶疴窠蝌髁",
  kai: "开揩楷凯慨剀垲蒈忾恺铠锎",
  kan: "刊堪勘坎砍看侃凵莰莶戡龛瞰",
  kang: "康慷糠扛抗亢炕坑伉闶钪",
  kao: "考拷烤靠尻栲犒铐",
  ken: "肯啃垦恳垠裉颀",
  keng: "吭忐铿",
  kong: "空恐孔控倥崆箜",
  kou: "抠口扣寇芤蔻叩眍筘",
  ku: "枯哭窟苦酷库裤刳堀喾绔骷",
  kua: "夸垮挎跨胯侉",
  kuai: "块筷侩快蒯郐蒉狯脍",
  kuan: "宽款髋",
  kuang: "匡筐狂框矿眶旷况诓诳邝圹夼哐纩贶",
  kui: "亏盔岿窥葵奎魁傀馈愧溃馗匮夔隗揆喹喟悝愦阕逵暌睽聩蝰篑臾跬",
  kun: "坤昆捆困悃阃琨锟醌鲲髡",
  kuo: "括扩廓阔蛞",
  la: "垃拉喇蜡腊辣啦剌摺邋旯砬瘌",
  lai: "莱来赖崃徕涞濑赉睐铼癞籁",
  lan: "蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥啉岚懔漤榄斓罱镧褴",
  lang: "琅榔狼廊郎朗浪莨蒗啷阆锒稂螂",
  lao: "捞劳牢老佬姥酪烙涝唠崂栳铑铹痨醪",
  le: "勒乐肋仂叻嘞泐鳓",
  lei: "雷镭蕾磊累儡垒擂类泪羸诔荽咧漯嫘缧檑耒酹",
  ling: "棱冷拎玲菱零龄铃伶羚凌灵陵岭领另令酃塄苓呤囹泠绫柃棂瓴聆蛉翎鲮",
  leng: "楞愣",
  li: "厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐痢立粒沥隶力璃哩俪俚郦坜苈莅蓠藜捩呖唳喱猁溧澧逦娌嫠骊缡珞枥栎轹戾砺詈罹锂鹂疠疬蛎蜊蠡笠篥粝醴跞雳鲡鳢黧",
  lian: "俩联莲连镰廉怜涟帘敛脸链恋炼练挛蔹奁潋濂娈琏楝殓臁膦裢蠊鲢",
  liang: "粮凉梁粱良两辆量晾亮谅墚椋踉靓魉",
  liao: "撩聊僚疗燎寥辽潦了撂镣廖料蓼尥嘹獠寮缭钌鹩耢",
  lie: "列裂烈劣猎冽埒洌趔躐鬣",
  lin: "琳林磷霖临邻鳞淋凛赁吝蔺嶙廪遴檩辚瞵粼躏麟",
  liu: "溜琉榴硫馏留刘瘤流柳六抡偻蒌泖浏遛骝绺旒熘锍镏鹨鎏",
  long: "龙聋咙笼窿隆垄拢陇弄垅茏泷珑栊胧砻癃",
  lou: "楼娄搂篓漏陋喽嵝镂瘘耧蝼髅",
  lu: "芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮垆摅撸噜泸渌漉璐栌橹轳辂辘氇胪镥鸬鹭簏舻鲈",
  lv: "驴吕铝侣旅履屡缕虑氯律率滤绿捋闾榈膂稆褛",
  luan: "峦孪滦卵乱栾鸾銮",
  lue: "掠略锊",
  lun: "轮伦仑沦纶论囵",
  luo: "萝螺罗逻锣箩骡裸落洛骆络倮荦摞猡泺椤脶镙瘰雒",
  ma: "妈麻玛码蚂马骂嘛吗唛犸嬷杩麽",
  mai: "埋买麦卖迈脉劢荬咪霾",
  man: "瞒馒蛮满蔓曼慢漫谩墁幔缦熳镘颟螨鳗鞔",
  mang: "芒茫盲忙莽邙漭朦硭蟒",
  meng: "氓萌蒙檬盟锰猛梦孟勐甍瞢懵礞虻蜢蠓艋艨黾",
  miao: "猫苗描瞄藐秒渺庙妙喵邈缈缪杪淼眇鹋蜱",
  mao: "茅锚毛矛铆卯茂冒帽貌贸侔袤勖茆峁瑁昴牦耄旄懋瞀蛑蝥蟊髦",
  me: "么",
  mei: "玫枚梅酶霉煤没眉媒镁每美昧寐妹媚坶莓嵋猸浼湄楣镅鹛袂魅",
  men: "门闷们扪玟焖懑钔",
  mi: "眯醚靡糜迷谜弥米秘觅泌蜜密幂芈冖谧蘼嘧猕獯汨宓弭脒敉糸縻麋",
  mian: "棉眠绵冕免勉娩缅面沔湎腼眄",
  mie: "蔑灭咩蠛篾",
  min: "民抿皿敏悯闽苠岷闵泯珉",
  ming: "明螟鸣铭名命冥茗溟暝瞑酩",
  miu: "谬",
  mo: "摸摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谟茉蓦馍嫫镆秣瘼耱蟆貊貘",
  mou: "谋牟某厶哞婺眸鍪",
  mu: "拇牡亩姆母墓暮幕募慕木目睦牧穆仫苜呒沐毪钼",
  na: "拿哪呐钠那娜纳内捺肭镎衲箬",
  nai: "氖乃奶耐奈鼐艿萘柰",
  nan: "南男难囊喃囡楠腩蝻赧",
  nao: "挠脑恼闹孬垴猱瑙硇铙蛲",
  ne: "淖呢讷",
  nei: "馁",
  nen: "嫩能枘恁",
  ni: "妮霓倪泥尼拟你匿腻逆溺伲坭猊怩滠昵旎祢慝睨铌鲵",
  nian: "蔫拈年碾撵捻念廿辇黏鲇鲶",
  niang: "娘酿",
  niao: "鸟尿茑嬲脲袅",
  nie: "捏聂孽啮镊镍涅乜陧蘖嗫肀颞臬蹑",
  nin: "您柠",
  ning: "狞凝宁拧泞佞蓥咛甯聍",
  niu: "牛扭钮纽狃忸妞蚴",
  nong: "脓浓农侬",
  nu: "奴努怒呶帑弩胬孥驽",
  nv: "女恧钕衄",
  nuan: "暖",
  nuenue: "虐",
  nue: "疟谑",
  nuo: "挪懦糯诺傩搦喏锘",
  ou: "哦欧鸥殴藕呕偶沤怄瓯耦",
  pa: "啪趴爬帕怕琶葩筢",
  pai: "拍排牌徘湃派俳蒎",
  pan: "攀潘盘磐盼畔判叛爿泮袢襻蟠蹒",
  pang: "乓庞旁耪胖滂逄",
  pao: "抛咆刨炮袍跑泡匏狍庖脬疱",
  pei: "呸胚培裴赔陪配佩沛掊辔帔淠旆锫醅霈",
  pen: "喷盆湓",
  peng: "砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯堋嘭怦蟛",
  pi: "砒霹批披劈琵毗啤脾疲皮匹痞僻屁譬丕陴邳郫圮鼙擗噼庀媲纰枇甓睥罴铍痦癖疋蚍貔",
  pian: "篇偏片骗谝骈犏胼褊翩蹁",
  piao: "飘漂瓢票剽嘌嫖缥殍瞟螵",
  pie: "撇瞥丿苤氕",
  pin: "拼频贫品聘拚姘嫔榀牝颦",
  ping: "乒坪苹萍平凭瓶评屏俜娉枰鲆",
  po: "坡泼颇婆破魄迫粕叵鄱溥珀钋钷皤笸",
  pou: "剖裒踣",
  pu: "扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑匍噗濮璞氆镤镨蹼",
  qi: "期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫亟亓圻芑萋葺嘁屺岐汔淇骐绮琪琦杞桤槭欹祺憩碛蛴蜞綦綮趿蹊鳍麒",
  qia: "掐恰洽葜",
  qian: "牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉佥阡芊芡荨掮岍悭慊骞搴褰缱椠肷愆钤虔箝",
  qiang: "枪呛腔羌墙蔷强抢嫱樯戗炝锖锵镪襁蜣羟跫跄",
  qiao: "橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍劁诮谯荞愀憔缲樵毳硗跷鞒",
  qie: "切茄且怯窃郄唼惬妾挈锲箧",
  qin: "钦侵亲秦琴勤芹擒禽寝沁芩蓁蕲揿吣嗪噙溱檎螓衾",
  qing: "青轻氢倾卿清擎晴氰情顷请庆倩苘圊檠磬蜻罄箐謦鲭黥",
  qiong: "琼穷邛茕穹筇銎",
  qiu: "秋丘邱球求囚酋泅俅氽巯艽犰湫逑遒楸赇鸠虬蚯蝤裘糗鳅鼽",
  qu: "趋区蛆曲躯屈驱渠取娶龋趣去诎劬蕖蘧岖衢阒璩觑氍祛磲癯蛐蠼麴瞿黢",
  quan: "圈颧权醛泉全痊拳犬券劝诠荃獾悛绻辁畎铨蜷筌鬈",
  que: "缺炔瘸却鹊榷确雀阙悫",
  qun: "裙群逡",
  ran: "然燃冉染苒髯",
  rang: "瓤壤攘嚷让禳穰",
  rao: "饶扰绕荛娆桡",
  ruo: "惹若弱",
  re: "热偌",
  ren: "壬仁人忍韧任认刃妊纫仞荏葚饪轫稔衽",
  reng: "扔仍",
  ri: "日",
  rong: "戎茸蓉荣融熔溶容绒冗嵘狨缛榕蝾",
  rou: "揉柔肉糅蹂鞣",
  ru: "茹蠕儒孺如辱乳汝入褥蓐薷嚅洳溽濡铷襦颥",
  ruan: "软阮朊",
  rui: "蕊瑞锐芮蕤睿蚋",
  run: "闰润",
  sa: "撒洒萨卅仨挲飒",
  sai: "腮鳃塞赛噻",
  san: "三叁伞散彡馓氵毵糁霰",
  sang: "桑嗓丧搡磉颡",
  sao: "搔骚扫嫂埽臊瘙鳋",
  se: "瑟色涩啬铩铯穑",
  sen: "森",
  seng: "僧",
  sha: "莎砂杀刹沙纱傻啥煞脎歃痧裟霎鲨",
  shai: "筛晒酾",
  shan: "珊苫杉山删煽衫闪陕擅赡膳善汕扇缮剡讪鄯埏芟潸姗骟膻钐疝蟮舢跚鳝",
  shang: "墒伤商赏晌上尚裳垧绱殇熵觞",
  shao: "梢捎稍烧芍勺韶少哨邵绍劭苕潲蛸笤筲艄",
  she: "奢赊蛇舌舍赦摄射慑涉社设厍佘猞畲麝",
  shen: "砷申呻伸身深娠绅神沈审婶甚肾慎渗诜谂吲哂渖椹矧蜃",
  sheng: "声生甥牲升绳省盛剩胜圣丞渑媵眚笙",
  shi: "师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试谥埘莳蓍弑唑饣轼耆贳炻礻铈铊螫舐筮豕鲥鲺",
  shou: "收手首守寿授售受瘦兽扌狩绶艏",
  shu: "蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱恕倏塾菽忄沭涑澍姝纾毹腧殳镯秫鹬",
  shua: "刷耍唰涮",
  shuai: "摔衰甩帅蟀",
  shuan: "栓拴闩",
  shuang: "霜双爽孀",
  shui: "谁水睡税",
  shun: "吮瞬顺舜恂",
  shuo: "说硕朔烁蒴搠嗍濯妁槊铄",
  si: "斯撕嘶思私司丝死肆寺嗣四伺似饲巳厮俟兕菥咝汜泗澌姒驷缌祀祠锶鸶耜蛳笥",
  song: "松耸怂颂送宋讼诵凇菘崧嵩忪悚淞竦",
  sou: "搜艘擞嗽叟嗖嗾馊溲飕瞍锼螋",
  su: "苏酥俗素速粟僳塑溯宿诉肃夙谡蔌嗉愫簌觫稣",
  suan: "酸蒜算",
  sui: "虽隋随绥髓碎岁穗遂隧祟蓑冫谇濉邃燧眭睢",
  sun: "孙损笋荪狲飧榫跣隼",
  suo: "梭唆缩琐索锁所唢嗦娑桫睃羧",
  ta: "塌他它她塔獭挞蹋踏闼溻遢榻沓",
  tai: "胎苔抬台泰酞太态汰邰薹肽炱钛跆鲐",
  tan: "坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭郯蕈昙钽锬覃",
  tang: "汤塘搪堂棠膛唐糖傥饧溏瑭铴镗耥螗螳羰醣",
  thang: "倘躺淌",
  theng: "趟烫",
  tao: "掏涛滔绦萄桃逃淘陶讨套挑鼗啕韬饕",
  te: "特",
  teng: "藤腾疼誊滕",
  ti: "梯剔踢锑提题蹄啼体替嚏惕涕剃屉荑悌逖绨缇鹈裼醍",
  tian: "天添填田甜恬舔腆掭忝阗殄畋钿蚺",
  tiao: "条迢眺跳佻祧铫窕龆鲦",
  tie: "贴铁帖萜餮",
  ting: "厅听烃汀廷停亭庭挺艇莛葶婷梃蜓霆",
  tong: "通桐酮瞳同铜彤童桶捅筒统痛佟僮仝茼嗵恸潼砼",
  tou: "偷投头透亠",
  tu: "凸秃突图徒途涂屠土吐兔堍荼菟钍酴",
  tuan: "湍团疃",
  tui: "推颓腿蜕褪退忒煺",
  tun: "吞屯臀饨暾豚窀",
  tuo: "拖托脱鸵陀驮驼椭妥拓唾乇佗坨庹沱柝砣箨舄跎鼍",
  wa: "挖哇蛙洼娃瓦袜佤娲腽",
  wai: "歪外",
  wan: "豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕剜芄苋菀纨绾琬脘畹蜿箢",
  wang: "汪王亡枉网往旺望忘妄罔尢惘辋魍",
  wei: "威巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫倭偎诿隈葳薇帏帷崴嵬猥猬闱沩洧涠逶娓玮韪軎炜煨熨痿艉鲔",
  wen: "瘟温蚊文闻纹吻稳紊问刎愠阌汶璺韫殁雯",
  weng: "嗡翁瓮蓊蕹",
  wo: "挝蜗涡窝我斡卧握沃莴幄渥杌肟龌",
  wu: "巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误兀仵阢邬圬芴庑怃忤浯寤迕妩骛牾焐鹉鹜蜈鋈鼯",
  xi: "昔熙析西硒矽晰嘻吸锡牺稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细僖兮隰郗茜葸蓰奚唏徙饩阋浠淅屣嬉玺樨曦觋欷熹禊禧钸皙穸蜥蟋舾羲粞翕醯鼷",
  xia: "瞎虾匣霞辖暇峡侠狭下厦夏吓掀葭嗄狎遐瑕硖瘕罅黠",
  xian: "锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线冼藓岘猃暹娴氙祆鹇痫蚬筅籼酰跹",
  xiang: "相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象芗葙饷庠骧缃蟓鲞飨",
  xiao: "萧硝霄削哮嚣销消宵淆晓小孝校肖啸笑效哓咻崤潇逍骁绡枭枵筱箫魈",
  xie: "楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑偕亵勰燮薤撷廨瀣邂绁缬榭榍歙躞",
  xin: "薪芯锌欣辛新忻心信衅囟馨莘歆铽鑫",
  xing: "星腥猩惺兴刑型形邢行醒幸杏性姓陉荇荥擤悻硎",
  xiong: "兄凶胸匈汹雄熊芎",
  xiu: "休修羞朽嗅锈秀袖绣莠岫馐庥鸺貅髹",
  xu: "墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续讴诩圩蓿怵洫溆顼栩煦砉盱胥糈醑",
  xuan: "轩喧宣悬旋玄选癣眩绚儇谖萱揎馔泫洵渲漩璇楦暄炫煊碹铉镟痃",
  xue: "靴薛学穴雪血噱泶鳕",
  xun: "勋熏循旬询寻驯巡殉汛训讯逊迅巽埙荀薰峋徇浔曛窨醺鲟",
  ya: "压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶伢揠吖岈迓娅琊桠氩砑睚痖",
  yan: "焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验厣靥赝俨偃兖讠谳郾鄢芫菸崦恹闫阏洇湮滟妍嫣琰晏胭腌焱罨筵酽魇餍鼹",
  yang: "殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾徉怏泱炀烊恙蛘鞅",
  yao: "邀腰妖瑶摇尧遥窑谣姚咬舀药要耀夭爻吆崾徭瀹幺珧杳曜肴鹞窈繇鳐",
  ye: "椰噎耶爷野冶也页掖业叶曳腋夜液谒邺揶馀晔烨铘",
  yi: "一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎刈劓佾诒圪圯埸懿苡薏弈奕挹弋呓咦咿噫峄嶷猗饴怿怡悒漪迤驿缢殪贻旖熠钇镒镱痍瘗癔翊衤蜴舣羿翳酏黟",
  yin: "茵荫因殷音阴姻吟银淫寅饮尹引隐印胤鄞堙茚喑狺夤氤铟瘾蚓霪龈",
  ying: "英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映嬴郢茔莺萦撄嘤膺滢潆瀛瑛璎楹鹦瘿颍罂",
  yo: "哟唷",
  yong: "拥佣臃痈庸雍踊蛹咏泳涌永恿勇用俑壅墉慵邕镛甬鳙饔",
  you: "幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼卣攸侑莸呦囿宥柚猷牖铕疣蝣鱿黝鼬",
  yu: "迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉浴寓裕预豫驭禺毓伛俣谀谕萸蓣揄喁圄圉嵛狳饫庾阈妪妤纡瑜昱觎腴欤於煜燠聿钰鹆瘐瘀窳蝓竽舁雩龉",
  yuan: "鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院塬沅媛瑗橼爰眢鸢螈鼋",
  yue: "曰约越跃钥岳粤月悦阅龠樾刖钺",
  yun: "耘云郧匀陨允运蕴酝晕韵孕郓芸狁恽纭殒昀氲",
  za: "匝砸杂拶咂",
  zai: "栽哉灾宰载再在咱崽甾",
  zan: "攒暂赞瓒昝簪糌趱錾",
  zang: "赃脏葬奘戕臧",
  zao: "遭糟凿藻枣早澡蚤躁噪造皂灶燥唣缫",
  ze: "责择则泽仄赜啧迮昃笮箦舴",
  zei: "贼",
  zen: "怎谮",
  zeng: "增憎曾赠缯甑罾锃",
  zha: "扎喳渣札轧铡闸眨栅榨咋乍炸诈揸吒咤哳怍砟痄蚱齄",
  zhai: "摘斋宅窄债寨砦",
  zhan: "瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽谵搌旃",
  zhang: "樟章彰漳张掌涨杖丈帐账仗胀瘴障仉鄣幛嶂獐嫜璋蟑",
  zhao: "招昭找沼赵照罩兆肇召爪诏棹钊笊",
  zhe: "遮折哲蛰辙者锗蔗这浙谪陬柘辄磔鹧褚蜇赭",
  zhen: "珍斟真甄砧臻贞针侦枕疹诊震振镇阵缜桢榛轸赈胗朕祯畛鸩",
  zheng: "蒸挣睁征狰争怔整拯正政帧症郑证诤峥钲铮筝",
  zhi: "芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒卮陟郅埴芷摭帙忮彘咫骘栉枳栀桎轵轾攴贽膣祉祗黹雉鸷痣蛭絷酯跖踬踯豸觯",
  zhong: "中盅忠钟衷终种肿重仲众冢锺螽舂舯踵",
  zhou: "舟周州洲诌粥轴肘帚咒皱宙昼骤啄着倜诹荮鬻纣胄碡籀舳酎鲷",
  zhu: "珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑住注祝驻伫侏邾苎茱洙渚潴驺杼槠橥炷铢疰瘃蚰竺箸翥躅麈",
  zhua: "抓",
  zhuai: "拽",
  zhuan: "专砖转撰赚篆抟啭颛",
  zhuang: "桩庄装妆撞壮状丬",
  zhui: "椎锥追赘坠缀萑骓缒",
  zhun: "谆准",
  zhuo: "捉拙卓桌琢茁酌灼浊倬诼廴蕞擢啜浞涿杓焯禚斫",
  zi: "兹咨资姿滋淄孜紫仔籽滓子自渍字谘嵫姊孳缁梓辎赀恣眦锱秭耔笫粢觜訾鲻髭",
  zong: "鬃棕踪宗综总纵腙粽",
  zou: "邹走奏揍鄹鲰",
  zu: "租足卒族祖诅阻组俎菹啐徂驵蹴",
  zuan: "钻纂攥缵",
  zui: "嘴醉最罪",
  zun: "尊遵撙樽鳟",
  zuo: "昨左佐柞做作坐座阝阼胙祚酢",
  cou: "薮楱辏腠",
  nang: "攮哝囔馕曩",
  o: "喔",
  dia: "嗲",
  chuai: "嘬膪踹",
  cen: "岑涔",
  diu: "铥",
  nou: "耨",
  fou: "缶",
  bia: "髟"
};
function formatISODate(ISODate = "") {
  const dateStr = ISODate.replace("T", " ").replace("Z", "").split(".")[0];
  const formatDateStr = dateStr.replace(/(\s00:00:00)$/, "");
  return formatDateStr;
}
const _sfc_main$1e = defineComponent({
  name: "PageInfo",
  props: {
    pageData: {
      type: Object,
      default: () => ({})
    },
    currentCategory: {
      type: String,
      default: ""
    },
    currentTag: {
      type: String,
      default: ""
    },
    hideViews: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const { pageData, hideViews } = toRefs(props);
    const { solution, options } = useComment();
    const themeData2 = useThemeLocaleData$1();
    const author2 = computed(
      () => {
        var _a3, _b2;
        return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.author) || themeData2.value.author || "";
      }
    );
    const date = computed(() => {
      var _a3, _b2;
      const d2 = (_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.date;
      return d2 ? formatISODate(d2) : "";
    });
    const categories = computed(
      () => {
        var _a3, _b2;
        return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.categories) || [];
      }
    );
    const tags = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.tags) || [];
    });
    const showPageInfo = computed(
      () => !!author2.value || !!date.value || !!(categories.value && categories.value.length > 0) || !!(tags.value && tags.value.length > 0)
    );
    const showValineViews = computed(() => {
      return solution.value === "valine" && options.value.visitor != false && !hideViews.value;
    });
    const showWalineViews = computed(() => {
      return solution.value === "waline" && options.value.pageview != false && !hideViews.value;
    });
    return {
      author: author2,
      date,
      categories,
      tags,
      showPageInfo,
      solution,
      showValineViews,
      showWalineViews,
      convertToPinyin
    };
  }
});
const _hoisted_1$10 = {
  key: 0,
  class: "page-info"
};
const _hoisted_2$H = {
  class: "xicon-icon",
  style: { "width": "18px", "height": "18px", "font-size": "18px", "color": "inherit" },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 12 12"
};
const _hoisted_3$B = /* @__PURE__ */ createElementVNode(
  "g",
  { fill: "none" },
  [
    /* @__PURE__ */ createElementVNode("path", {
      d: "M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_4$q = [
  _hoisted_3$B
];
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  const _component_ValineViews = resolveComponent("ValineViews");
  const _component_WalineViews = resolveComponent("WalineViews");
  return _ctx.showPageInfo ? (openBlock(), createElementBlock("div", _hoisted_1$10, [
    !!_ctx.author ? (openBlock(), createBlock(_component_Xicons, {
      key: 0,
      icon: "User",
      text: _ctx.author
    }, null, 8, ["text"])) : createCommentVNode("v-if", true),
    !!_ctx.date ? (openBlock(), createBlock(_component_Xicons, {
      key: 1,
      icon: "Calendar",
      text: _ctx.date
    }, null, 8, ["text"])) : createCommentVNode("v-if", true),
    !!_ctx.categories && _ctx.categories.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
      key: 2,
      icon: "Folder"
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString(_ctx.categories.join(" ")),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    })) : createCommentVNode("v-if", true),
    !!_ctx.tags && _ctx.tags.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
      key: 3,
      icon: "Tag"
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString(_ctx.tags.join(" ")),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    })) : createCommentVNode("v-if", true),
    _ctx.showValineViews || _ctx.showWalineViews ? (openBlock(), createBlock(_component_Xicons, { key: 4 }, {
      icon: withCtx(() => [
        (openBlock(), createElementBlock("svg", _hoisted_2$H, _hoisted_4$q))
      ]),
      default: withCtx(() => [
        _ctx.showValineViews ? (openBlock(), createBlock(_component_ValineViews, { key: 0 })) : createCommentVNode("v-if", true),
        _ctx.showWalineViews ? (openBlock(), createBlock(_component_WalineViews, {
          key: 1,
          path: _ctx.pageData.path
        }, null, 8, ["path"])) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    })) : createCommentVNode("v-if", true)
  ])) : createCommentVNode("v-if", true);
}
const PageInfo$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1e, [["render", _sfc_render$H], ["__file", "PageInfo.vue"]]);
const _sfc_main$1d = defineComponent({
  components: { PageInfo: PageInfo$1 },
  props: {
    data: {
      type: Object,
      default: () => ({})
    }
  },
  setup() {
    const { solution } = useComment();
    return { solution };
  }
});
const _hoisted_1$$ = { class: "title" };
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RouterLink = resolveComponent("RouterLink");
  const _component_PageInfo = resolveComponent("PageInfo");
  const _component_MagicCard = resolveComponent("MagicCard");
  return openBlock(), createBlock(_component_MagicCard, { class: "post-item-container" }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$$, [
        createVNode(_component_RouterLink, {
          to: _ctx.data.path
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString(_ctx.data.title),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["to"])
      ]),
      createVNode(_component_PageInfo, {
        "page-data": _ctx.data,
        "hide-views": _ctx.solution === "valine"
      }, null, 8, ["page-data", "hide-views"])
    ]),
    _: 1
    /* STABLE */
  });
}
const PostItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1d, [["render", _sfc_render$G], ["__file", "PostItem.vue"]]);
const _sfc_main$1c = defineComponent({
  components: { PostItem },
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup() {
    return {};
  }
});
const _hoisted_1$_ = { class: "post-list-container" };
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PostItem = resolveComponent("PostItem");
  return openBlock(), createElementBlock("div", _hoisted_1$_, [
    (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.data, (item, index2) => {
        return openBlock(), createBlock(_component_PostItem, {
          key: index2,
          data: item
        }, null, 8, ["data"]);
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ]);
}
const PostList = /* @__PURE__ */ _export_sfc$1(_sfc_main$1c, [["render", _sfc_render$F], ["__file", "PostList.vue"]]);
var ModeIcon = /* @__PURE__ */ ((ModeIcon2) => {
  ModeIcon2["auto"] = "BrightnessContrast";
  ModeIcon2["dark"] = "Moon";
  ModeIcon2["light"] = "Sun";
  return ModeIcon2;
})(ModeIcon || {});
var EMode = /* @__PURE__ */ ((EMode2) => {
  EMode2[EMode2["auto"] = 0] = "auto";
  EMode2[EMode2["dark"] = 1] = "dark";
  EMode2[EMode2["light"] = 2] = "light";
  return EMode2;
})(EMode || {});
const APPEARANCE_KEY$1 = "vuepress-reco-color-scheme";
const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  __name: "ToggleDarkModeButton",
  setup(__props) {
    const themeConfig = useThemeLocaleData();
    const mode = ref(themeConfig.value.colorMode || "auto");
    const icon = computed(() => {
      return ModeIcon[mode.value];
    });
    let toggleMode = () => {
      const currModeIndex = EMode[mode.value];
      const nextModeIndex = currModeIndex === 2 ? 0 : currModeIndex + 1;
      mode.value = EMode[nextModeIndex];
    };
    onMounted(() => {
      const userPreference = localStorage[APPEARANCE_KEY$1];
      if (userPreference) {
        mode.value = userPreference;
      }
      const classList2 = document.documentElement.classList;
      function setDarkClass(dark) {
        classList2.toggle("dark", dark);
      }
      function handleModeChange(m2) {
        if (m2 === "auto") {
          setDarkClass(darkMedia.matches);
          localStorage.removeItem(APPEARANCE_KEY$1);
        } else {
          setDarkClass(m2 === "dark");
          localStorage[APPEARANCE_KEY$1] = m2;
        }
      }
      const darkMedia = window.matchMedia("(prefers-color-scheme: dark)");
      darkMedia.onchange = (e2) => {
        if (mode.value === "auto") {
          setDarkClass(e2.matches);
        }
      };
      watch(mode, handleModeChange);
      handleModeChange(mode.value);
    });
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createBlock(_component_Xicons, {
        icon: icon.value,
        "icon-size": "20",
        class: "btn-toggle-dark-mode",
        onClick: _cache[0] || (_cache[0] = ($event) => unref(toggleMode)())
      }, null, 8, ["icon"]);
    };
  }
});
const ToggleDarkModeButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1b, [["__file", "ToggleDarkModeButton.vue"]]);
const _sfc_main$1a = defineComponent({
  name: "Link",
  inheritAttrs: false,
  props: {
    item: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const route = useRoute();
    const routeLocale = useRouteLocale();
    const siteLocal = useSiteLocaleData();
    const themeLocal = useThemeLocaleData();
    const { item } = toRefs(props);
    const hasHttpProtocol = computed(() => isLinkHttp$1(item.value.link));
    const hasNonHttpProtocal = computed(
      () => isLinkMailto(item.value.link) || isLinkTel(item.value.link)
    );
    const linkTarget = computed(() => {
      if (hasNonHttpProtocal.value)
        return void 0;
      if (item.value.target)
        return item.value.target;
      if (hasHttpProtocol.value)
        return "_blank";
      return void 0;
    });
    const isBlankTarget = computed(() => linkTarget.value === "_blank");
    const isRouterLink = computed(
      () => !hasHttpProtocol.value && !hasNonHttpProtocal.value && !isBlankTarget.value
    );
    const linkRel = computed(() => {
      if (hasNonHttpProtocal.value)
        return void 0;
      if (item.value.rel)
        return item.value.rel;
      if (isBlankTarget.value)
        return "noopener noreferrer";
      return void 0;
    });
    const linkAriaLabel = computed(
      () => item.value.ariaLabel || item.value.text
    );
    const shouldBeActiveInSubpath = computed(() => {
      const localeKeys2 = Object.keys(siteLocal.value.locales);
      if (localeKeys2.length) {
        return !localeKeys2.some((key) => key === item.value.link);
      }
      return item.value.link !== themeLocal.value.home || routeLocale.value;
    });
    const isActiveInSubpath = computed(() => {
      if (!isRouterLink.value || !shouldBeActiveInSubpath.value) {
        return false;
      }
      return route.path.startsWith(item.value.link);
    });
    return {
      isActiveInSubpath,
      isBlankTarget,
      isRouterLink,
      linkRel,
      linkTarget,
      linkAriaLabel
    };
  }
});
const _hoisted_1$Z = ["href", "target", "rel", "aria-label"];
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  const _component_RouterLink = resolveComponent("RouterLink");
  const _component_ExternalLinkIcon = resolveComponent("ExternalLinkIcon");
  return _ctx.isRouterLink ? (openBlock(), createBlock(_component_RouterLink, mergeProps({
    key: 0,
    class: ["link", { "router-link-active": _ctx.isActiveInSubpath }],
    to: _ctx.item.link,
    "aria-label": _ctx.linkAriaLabel
  }, _ctx.$attrs, {
    key: `${_ctx.item.link}-router`
  }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "before"),
      createVNode(_component_Xicons, {
        icon: _ctx.item.icon,
        text: _ctx.item.text
      }, null, 8, ["icon", "text"]),
      renderSlot(_ctx.$slots, "after")
    ]),
    _: 3
    /* FORWARDED */
  }, 16, ["class", "to", "aria-label"])) : (openBlock(), createElementBlock("a", mergeProps({
    key: 1,
    class: "link",
    href: _ctx.item.link,
    target: _ctx.linkTarget,
    rel: _ctx.linkRel,
    "aria-label": _ctx.linkAriaLabel
  }, _ctx.$attrs, {
    key: `${_ctx.item.link}-a`
  }), [
    renderSlot(_ctx.$slots, "before"),
    createVNode(_component_Xicons, {
      icon: _ctx.item.icon,
      text: _ctx.item.text
    }, null, 8, ["icon", "text"]),
    _ctx.isBlankTarget ? (openBlock(), createBlock(_component_ExternalLinkIcon, { key: 0 })) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "after")
  ], 16, _hoisted_1$Z));
}
const Link = /* @__PURE__ */ _export_sfc$1(_sfc_main$1a, [["render", _sfc_render$E], ["__file", "Link.vue"]]);
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "DropdownTransition",
  setup(__props) {
    const setHeight = (items) => {
      items.style.height = items.scrollHeight + "px";
    };
    const unsetHeight = (items) => {
      items.style.height = "";
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: "bounce",
        mode: "out-in",
        onEnter: setHeight,
        onAfterEnter: unsetHeight,
        onBeforeLeave: setHeight
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
        /* FORWARDED */
      });
    };
  }
});
const DropdownTransition_vue_vue_type_style_index_0_lang = "";
const DropdownTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$19, [["__file", "DropdownTransition.vue"]]);
const _hoisted_1$Y = ["aria-label"];
const _hoisted_2$G = {
  key: 0,
  class: "arrow down"
};
const _hoisted_3$A = ["aria-label"];
const _hoisted_4$p = { class: "title" };
const _hoisted_5$h = { class: "dropdown-link__subtitle" };
const _hoisted_6$d = { class: "dropdown-link__subcontainer" };
const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  __name: "DropdownLink",
  props: {
    item: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const { item } = toRefs(props);
    const dropdownAriaLabel = computed(
      () => item.value.ariaLabel || item.value.text
    );
    const open = ref(false);
    const route = useRoute();
    watch(
      () => route.path,
      () => {
        open.value = false;
      }
    );
    const handleDropdown = (e2) => {
      const isTriggerByTab = e2.detail === 1;
      if (isTriggerByTab) {
        open.value = !open.value;
      } else {
        open.value = false;
      }
    };
    const isLastItemOfArray = (item2, arr) => arr[arr.length - 1] === item2;
    const inButton = ref(false);
    const handleButtonMouseEnter = () => {
      if (isMobile2.value)
        isMobile2.value = false;
      open.value = true;
      inButton.value = true;
    };
    const handleButtonMouseLeave = () => {
      inButton.value = false;
      setTimeout(() => {
        if (inButton.value || inDropdown.value) {
          open.value = true;
        } else {
          open.value = false;
        }
      }, 200);
    };
    const inDropdown = ref(false);
    const handleDropdownMouseEnter = () => {
      if (isMobile2.value)
        return;
      inDropdown.value = true;
    };
    const handleDropdownMouseLeave = () => {
      if (isMobile2.value)
        return;
      inDropdown.value = false;
      setTimeout(() => {
        if (inButton.value || inDropdown.value) {
          open.value = true;
        } else {
          open.value = false;
        }
      }, 200);
    };
    const isMobile2 = ref(true);
    const handleMobileButtonClick = () => {
      open.value = !open.value;
      if (!isMobile2.value)
        isMobile2.value = true;
    };
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(["dropdown-link", { open: open.value }])
        },
        [
          createElementVNode("button", {
            class: "dropdown-link__title",
            type: "button",
            "aria-label": dropdownAriaLabel.value,
            onClick: handleDropdown,
            onMouseenter: handleButtonMouseEnter,
            onMouseleave: handleButtonMouseLeave
          }, [
            createVNode(_component_Xicons, {
              class: "title",
              icon: unref(item).icon,
              text: unref(item).text
            }, null, 8, ["icon", "text"]),
            unref(item).text ? (openBlock(), createElementBlock("span", _hoisted_2$G)) : createCommentVNode("v-if", true)
          ], 40, _hoisted_1$Y),
          createElementVNode("button", {
            class: "dropdown-link--mobile__title",
            type: "button",
            "aria-label": dropdownAriaLabel.value,
            onClick: handleMobileButtonClick
          }, [
            createElementVNode("span", _hoisted_4$p, [
              createVNode(_component_Xicons, {
                icon: unref(item).icon,
                text: unref(item).text
              }, null, 8, ["icon", "text"])
            ]),
            unref(item).text ? (openBlock(), createElementBlock(
              "span",
              {
                key: 0,
                class: normalizeClass(["arrow", open.value ? "down" : "right"])
              },
              null,
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true)
          ], 8, _hoisted_3$A),
          createVNode(DropdownTransition, null, {
            default: withCtx(() => [
              withDirectives(createElementVNode(
                "ul",
                {
                  class: "dropdown-link__container",
                  onMouseenter: handleDropdownMouseEnter,
                  onMouseleave: handleDropdownMouseLeave
                },
                [
                  (openBlock(true), createElementBlock(
                    Fragment,
                    null,
                    renderList(unref(item).children, (child, index2) => {
                      return openBlock(), createElementBlock("li", {
                        key: child.link || index2,
                        class: "dropdown-link__item"
                      }, [
                        child.children ? (openBlock(), createElementBlock(
                          Fragment,
                          { key: 0 },
                          [
                            createElementVNode("h5", _hoisted_5$h, [
                              createVNode(_component_Xicons, {
                                icon: child.icon,
                                text: child.text
                              }, null, 8, ["icon", "text"])
                            ]),
                            createElementVNode("ul", _hoisted_6$d, [
                              (openBlock(true), createElementBlock(
                                Fragment,
                                null,
                                renderList(child.children, (grandchild) => {
                                  return openBlock(), createElementBlock("li", {
                                    key: grandchild.link,
                                    class: "dropdown-link__subitem"
                                  }, [
                                    createVNode(Link, {
                                      item: grandchild,
                                      onFocusout: ($event) => isLastItemOfArray(grandchild, child.children) && isLastItemOfArray(child, unref(item).children) && (open.value = false)
                                    }, null, 8, ["item", "onFocusout"])
                                  ]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ])
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        )) : (openBlock(), createBlock(Link, {
                          key: 1,
                          item: child,
                          onFocusout: ($event) => isLastItemOfArray(child, unref(item).children) && (open.value = false)
                        }, null, 8, ["item", "onFocusout"]))
                      ]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ],
                544
                /* HYDRATE_EVENTS, NEED_PATCH */
              ), [
                [vShow, open.value]
              ])
            ]),
            _: 1
            /* STABLE */
          })
        ],
        2
        /* CLASS */
      );
    };
  }
});
const DropdownLink = /* @__PURE__ */ _export_sfc$1(_sfc_main$18, [["__file", "DropdownLink.vue"]]);
const useNavbarSelectLanguage = () => {
  const router = useRouter();
  const routeLocale = useRouteLocale();
  const siteLocale = useSiteLocaleData();
  const themeLocal = useThemeLocaleData$1();
  return computed(() => {
    const localePaths = Object.keys(siteLocale.value.locales);
    if (localePaths.length < 2) {
      return [];
    }
    const currentPath = router.currentRoute.value.path;
    const currentFullPath = router.currentRoute.value.fullPath;
    const selectLanguageText = computed(() => {
      return themeLocal.value.selectLanguageText || "选择语言";
    });
    const languageDropdown = {
      icon: "EarthFilled",
      text: selectLanguageText.value,
      children: localePaths.map((targetLocalePath) => {
        var _a3, _b2;
        const targetSiteLocale = ((_a3 = siteLocale.value.locales) == null ? void 0 : _a3[targetLocalePath]) ?? {};
        const targetThemeLocale = ((_b2 = themeLocal.value.locales) == null ? void 0 : _b2[targetLocalePath]) ?? {};
        const targetLang = `${targetSiteLocale.lang}`;
        const text2 = targetThemeLocale.selectLanguageName ?? targetLang;
        let link;
        if (targetLang === siteLocale.value.lang) {
          link = currentFullPath;
        } else {
          const targetLocalePage = currentPath.replace(
            routeLocale.value,
            targetLocalePath
          );
          if (router.getRoutes().some((item) => item.path === targetLocalePage)) {
            link = targetLocalePage;
          } else {
            link = targetThemeLocale.home ?? targetLocalePath;
          }
        }
        return {
          text: text2,
          link
        };
      })
    };
    return [languageDropdown];
  });
};
const useNavbarRepo = () => {
  const themeLocal = useThemeLocaleData$1();
  const repo = computed(() => themeLocal.value.repo);
  const repoType = computed(
    () => repo.value ? resolveRepoType(repo.value) : null
  );
  const repoLink = computed(() => {
    if (repoType.value === "GitHub") {
      return `https://github.com/${repo.value}`;
    }
    return repo.value;
  });
  const repoLabel = computed(() => {
    if (!repoLink.value)
      return null;
    if (themeLocal.value.repoLabel)
      return themeLocal.value.repoLabel;
    if (repoType.value === null)
      return "Source";
    return repoType.value;
  });
  return computed(() => {
    if (!repoLink.value || !repoLabel.value) {
      return [];
    }
    return [
      {
        text: repoLabel.value,
        link: repoLink.value
      }
    ];
  });
};
const resolveNavbarItem = (item) => {
  if (isString$1(item)) {
    return useNavLink(item);
  }
  if (item.children) {
    return {
      ...item,
      children: item.children.map(resolveNavbarItem)
    };
  }
  return item;
};
const useNavbarConfig = () => {
  const themeLocal = useThemeLocaleData$1();
  const { categorySummary } = usePageData();
  const parseCategories = computed(() => {
    var _a3, _b2, _c, _d;
    return [
      {
        text: ((_a3 = themeLocal.value.autoAddCategoryToNavbar) == null ? void 0 : _a3.categoryText) || "Categories",
        children: Object.values(((_b2 = categorySummary == null ? void 0 : categorySummary.categories) == null ? void 0 : _b2.items) || {}).map((c2) => ({
          // @ts-ignore
          text: c2.label,
          // @ts-ignore
          link: `/categories/${convertToPinyin(c2.label)}/1/`
        }))
      },
      {
        text: ((_c = themeLocal.value.autoAddCategoryToNavbar) == null ? void 0 : _c.tagText) || "Tags",
        children: Object.values(((_d = categorySummary == null ? void 0 : categorySummary.tags) == null ? void 0 : _d.items) || {}).map((t2) => ({
          // @ts-ignore
          text: t2.label,
          // @ts-ignore
          link: `/tags/${convertToPinyin(t2.label)}/1/`
        }))
      }
    ];
  });
  return computed(() => {
    var _a3;
    let navItems = [...themeLocal.value.navbar || []];
    if (themeLocal.value.autoAddCategoryToNavbar) {
      navItems.splice(
        ((_a3 = themeLocal.value.autoAddCategoryToNavbar) == null ? void 0 : _a3.location) || 0,
        0,
        ...parseCategories.value
      );
    }
    return navItems.map(resolveNavbarItem);
  });
};
const _sfc_main$17 = defineComponent({
  name: "NavbarLinks",
  components: {
    Link,
    DropdownLink
  },
  setup() {
    const navbarConfig = useNavbarConfig();
    const navbarSelectLanguage = useNavbarSelectLanguage();
    const navbarRepo = useNavbarRepo();
    const navbarLinks = computed(() => [
      ...navbarConfig.value,
      ...navbarSelectLanguage.value,
      ...navbarRepo.value
    ]);
    return {
      navbarLinks
    };
  }
});
const _hoisted_1$X = {
  key: 0,
  class: "navbar-links"
};
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DropdownLink = resolveComponent("DropdownLink");
  const _component_Link = resolveComponent("Link");
  return _ctx.navbarLinks.length ? (openBlock(), createElementBlock("nav", _hoisted_1$X, [
    (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.navbarLinks, (item) => {
        return openBlock(), createElementBlock("div", {
          key: item.link,
          class: "navbar-links__item"
        }, [
          item.children ? (openBlock(), createBlock(_component_DropdownLink, {
            key: 0,
            item
          }, null, 8, ["item"])) : (openBlock(), createBlock(_component_Link, {
            key: 1,
            item
          }, null, 8, ["item"]))
        ]);
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ])) : createCommentVNode("v-if", true);
}
const NavbarLinks = /* @__PURE__ */ _export_sfc$1(_sfc_main$17, [["render", _sfc_render$D], ["__file", "NavbarLinks.vue"]]);
const _hoisted_1$W = { class: "site-brand" };
const _hoisted_2$F = ["src", "alt"];
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "SiteBrand",
  setup(__props) {
    const siteLocale = useSiteLocaleData();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    const siteBrandLink = computed(
      () => themeLocal.value.home || routeLocale.value
    );
    const siteBrandLogo = computed(() => themeLocal.value.logo);
    const siteBrandTitle = computed(() => siteLocale.value.title);
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return openBlock(), createElementBlock("div", _hoisted_1$W, [
        siteBrandLogo.value ? (openBlock(), createElementBlock("img", {
          key: 0,
          class: "logo",
          src: unref(withBase)(siteBrandLogo.value),
          alt: siteBrandTitle.value
        }, null, 8, _hoisted_2$F)) : createCommentVNode("v-if", true),
        siteBrandTitle.value ? (openBlock(), createBlock(_component_RouterLink, {
          key: 1,
          to: siteBrandLink.value,
          class: normalizeClass(["site-name", { "can-hide": siteBrandLogo.value }])
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString(siteBrandTitle.value),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["to", "class"])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});
const SiteBrand_vue_vue_type_style_index_0_lang = "";
const SiteBrand = /* @__PURE__ */ _export_sfc$1(_sfc_main$16, [["__file", "SiteBrand.vue"]]);
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "Navbar",
  emits: ["toggle-menus"],
  setup(__props, { emit: emits }) {
    const seriesItems = useSeriesItems();
    const siteLocale = useSiteLocaleData();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    computed(
      () => themeLocal.value.home || routeLocale.value
    );
    computed(() => themeLocal.value.logo);
    computed(() => siteLocale.value.title);
    const navbar = ref(null);
    const siteBrand = ref(null);
    const linksWrapperMaxWidth = ref(0);
    const linksWrapperStyle = computed(() => {
      if (!linksWrapperMaxWidth.value) {
        return {};
      }
      return {
        maxWidth: linksWrapperMaxWidth.value + "px"
      };
    });
    const toggleMenus = (bool) => {
      emits("toggle-menus", bool);
    };
    const isMobile2 = ref(false);
    onMounted(() => {
      const MOBILE_DESKTOP_BREAKPOINT = 768;
      const handleLinksWrapWidth = () => {
        var _a3, _b2;
        if (window.innerWidth <= MOBILE_DESKTOP_BREAKPOINT) {
          isMobile2.value = true;
          linksWrapperMaxWidth.value = 0;
        } else {
          isMobile2.value = false;
          linksWrapperMaxWidth.value = ((_a3 = navbar.value) == null ? void 0 : _a3.offsetWidth) - (((_b2 = siteBrand.value) == null ? void 0 : _b2.offsetWidth) || 0) - 50;
          toggleMenus(false);
        }
      };
      handleLinksWrapWidth();
      window.addEventListener("resize", throttle(handleLinksWrapWidth), false);
      window.addEventListener("orientationchange", handleLinksWrapWidth, false);
    });
    return (_ctx, _cache) => {
      const _component_NavbarSearch = resolveComponent("NavbarSearch");
      return openBlock(), createElementBlock(
        "header",
        {
          ref_key: "navbar",
          ref: navbar,
          class: "navbar-container",
          style: normalizeStyle({ top: unref(seriesItems).length > 0 && isMobile2.value ? "-4rem" : "0" })
        },
        [
          createVNode(SiteBrand, { class: "nav-item" }),
          createElementVNode(
            "div",
            {
              class: "nav-item navbar-links-wrapper",
              style: normalizeStyle(linksWrapperStyle.value)
            },
            [
              createElementVNode("div", null, [
                createVNode(_component_NavbarSearch)
              ]),
              createVNode(NavbarLinks),
              createVNode(ToggleDarkModeButton, { class: "btn--dark-mode" }),
              createVNode(Xicons, {
                class: "btn-toggle-menus",
                icon: "OverflowMenuVertical",
                iconSize: 20,
                onClick: toggleMenus
              })
            ],
            4
            /* STYLE */
          )
        ],
        4
        /* STYLE */
      );
    };
  }
});
const Navbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$15, [["__file", "Navbar.vue"]]);
const _hoisted_1$V = ["title"];
const _hoisted_2$E = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "icon",
    "aria-hidden": "true"
  },
  [
    /* @__PURE__ */ createElementVNode("span"),
    /* @__PURE__ */ createElementVNode("span"),
    /* @__PURE__ */ createElementVNode("span")
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$z = [
  _hoisted_2$E
];
const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "ToggleSeriesButton",
  emits: ["toggle"],
  setup(__props, { emit: emits }) {
    const toggle = () => {
      emits("toggle");
    };
    const themeLocal = useThemeLocaleData$1();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "toggle-series-button",
        title: unref(themeLocal).toggleSeries,
        "aria-expanded": "false",
        role: "button",
        tabindex: "0",
        onClick: toggle
      }, _hoisted_3$z, 8, _hoisted_1$V);
    };
  }
});
const ToggleSeriesButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$14, [["__file", "ToggleSeriesButton.vue"]]);
const _hoisted_1$U = {
  ref: "subnavbar",
  class: "sub-navbar-container"
};
const _hoisted_2$D = { class: "nav-item" };
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  __name: "SubNavbar",
  emits: ["toggle-series"],
  setup(__props, { emit: emits }) {
    const toggleSeries = () => {
      emits("toggle-series");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "header",
        _hoisted_1$U,
        [
          createElementVNode("span", _hoisted_2$D, [
            createVNode(ToggleSeriesButton, { onToggle: toggleSeries }),
            createTextVNode(" Series ")
          ])
        ],
        512
        /* NEED_PATCH */
      );
    };
  }
});
const SubNavbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["__file", "SubNavbar.vue"]]);
const normalizePath = (path) => decodeURI(path).replace(/#.*$/, "").replace(/(index)?\.(md|html)$/, "");
const isActiveLink = (route, link) => {
  if (link === void 0) {
    return false;
  }
  if (route.hash === link) {
    return true;
  }
  const currentPath = normalizePath(route.path);
  const targetPath = normalizePath(link);
  return currentPath === targetPath;
};
const isActiveItem$1 = (route, item) => {
  if (isActiveLink(route, item.link)) {
    return true;
  }
  if (item.children) {
    return item.children.some((child) => isActiveItem$1(route, child));
  }
  return false;
};
const togglecollapsible = (e2, item) => {
  item.collapsible = !!!item.collapsible;
  const currentNode = e2.target.querySelector(".arrow");
  const nextNode = e2.target.nextElementSibling;
  if (item.collapsible) {
    currentNode.classList.remove("down");
    currentNode.classList.add("right");
    nextNode.style.display = "none";
  } else {
    currentNode.classList.remove("right");
    currentNode.classList.add("down");
    nextNode.style.display = "block";
  }
};
const renderItem$1 = (item, props) => {
  if (item.link) {
    return h$5(Link, {
      ...props,
      item
    });
  }
  return h$5("h5", {
    ...props,
    onClick: (e2) => togglecollapsible(e2, item)
  }, [item.text, h$5("span", {
    class: !!item.collapsible ? "arrow right" : "arrow down"
  })]);
};
const renderChildren$1 = (item) => {
  var _a3;
  if (!((_a3 = item.children) === null || _a3 === void 0 ? void 0 : _a3.length)) {
    return null;
  }
  return h$5("ul", {
    style: {
      display: !!item.collapsible ? "none" : "block"
    }
  }, item.children.map((child) => h$5("li", h$5(SeriesItem, {
    item: child
  }))));
};
const SeriesItem = ({
  item
}) => {
  const route = useRoute();
  const active = isActiveItem$1(route, item);
  if (item.children) {
    return [h$5("section", {
      class: "series-group series-item"
    }, [renderItem$1(item, {
      class: {
        "series-heading": true,
        active
      }
    }), renderChildren$1(item)])];
  }
  return [renderItem$1(item, {
    class: {
      "series-item": true,
      active
    }
  })];
};
SeriesItem.displayName = "SeriesItem";
SeriesItem.props = {
  item: {
    type: Object,
    required: true
  }
};
const _hoisted_1$T = { class: "series-container" };
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "Series",
  setup(__props) {
    const themeLocal = useThemeLocaleData$1();
    const { sortSeries: sortSeries2 } = useSortSeries();
    const seriesItems = useSeriesItems();
    const sortedSeries = computed(() => {
      if (!themeLocal.value.autoSetSeries) {
        return seriesItems.value;
      }
      const series = sortSeries2(seriesItems.value);
      return series;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("aside", _hoisted_1$T, [
        createVNode(SiteBrand),
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(sortedSeries.value, (item) => {
            return openBlock(), createBlock(unref(SeriesItem), {
              item,
              key: item.link || item.text
            }, null, 8, ["item"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]);
    };
  }
});
const Series = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__file", "Series.vue"]]);
const isActiveItem = (route, item) => {
  if (route.hash === item.link) {
    return true;
  }
  if (item.children) {
    return item.children.some((child) => isActiveItem(route, child));
  }
  return false;
};
const renderItem = (item, props) => {
  return h$5("li", {
    ...props
  }, h$5(Link, {
    class: "page-catalog-item",
    item
  }));
};
const renderChildren = (item) => {
  var _a3;
  if (!((_a3 = item.children) === null || _a3 === void 0 ? void 0 : _a3.length)) {
    return [null];
  }
  return item.children.map((child) => h$5(CatalogItem, {
    item: child
  }));
};
const CatalogItem = ({
  item
}) => {
  const route = useRoute();
  const active = isActiveItem(route, item);
  if (item.children && item.children.length > 0) {
    return [renderItem(item, {
      class: {
        [`page-catalog-menu-depth_${item.level || 2}`]: true,
        active
      }
    }), ...renderChildren(item)];
  }
  return [renderItem(item, {
    class: {
      [`page-catalog-menu-depth_${item.level || 2}`]: true,
      active
    }
  })];
};
CatalogItem.displayName = "CatalogItem";
CatalogItem.props = {
  item: {
    type: Object,
    required: true
  }
};
const _hoisted_1$S = { class: "page-catalog-container" };
const _hoisted_2$C = { class: "tip" };
const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  __name: "Catalog",
  setup(__props) {
    const catalog = usePageCatalog();
    const themeConfig = useThemeLocaleData();
    const catalogTitle = computed(() => {
      return themeConfig.value.catalogTitle || "ON THIS PAGE";
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$S, [
        createElementVNode(
          "h5",
          _hoisted_2$C,
          toDisplayString(catalogTitle.value),
          1
          /* TEXT */
        ),
        createElementVNode("ul", null, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(unref(catalog), (item) => {
              return openBlock(), createBlock(unref(CatalogItem), {
                key: item.link || item.text,
                item
              }, null, 8, ["item"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ]);
    };
  }
});
const Catalog = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "Catalog.vue"]]);
function useSiteInfo() {
  const siteLocale = useSiteLocaleData();
  const themeLocal = useThemeLocaleData();
  const siteBrandLogo = computed(() => themeLocal.value.logo);
  const siteBrandTitle = computed(() => siteLocale.value.title);
  const sitePassword = computed(() => {
    const _password = themeLocal.value.password;
    if (!_password)
      return [];
    return Array.isArray(_password) ? _password : [_password];
  });
  return {
    siteBrandLogo,
    siteBrandTitle,
    sitePassword
  };
}
function useHandlePassword$1(sitePassword, emit) {
  const password = ref("");
  const passwordRef = ref(null);
  const lockIcon = ref("Locked");
  const lockText = ref("请输入密码");
  watch(password, (newVal) => {
    if (newVal.length !== 6)
      return;
    if (sitePassword.value.includes(md5(md5(newVal)))) {
      lockIcon.value = "Unlocked";
      lockText.value = "密码正确，请重稍后！";
      setTimeout(() => {
        emit("pass");
      }, 600);
    } else {
      password.value = "";
      lockText.value = "密码错误，请重新输入！";
    }
  });
  const focus = () => {
    passwordRef.value.focus();
  };
  return {
    password,
    passwordRef,
    lockIcon,
    lockText,
    focus
  };
}
const _imports_0$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAMAAAC7IEhfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURUxpcfjxsuzNbOC3gOCzcezbl/PWkvnpveKrTPXMmtmTRu/ljumwSdq1geSbP+a8ae+zSurBV/LjrO7Yb+bNlfrrrtmNP/PgdenEWurKhenFdt2rYt/EjPXnu+e9faFjNbWReNq8fdi1hZ1xTuOtVVxBUlIxSGFPX+jGXvHgmu/hn/Hfj96tYe7Yqea7XfXimPLghP334+Cwbvr32N3CiN/Bd+K5fui0Wt2fUeS2U+zOeuO1Y/bmiuPEiuG0bqyKduG5hfvOWaBuWk8sPa6DW++jROfFZfLkl86JV/nuyOzZfvjVY9qkYd20dJ9yXL+YWWxSWcmjbpyQdoyHee7ZfOGsVuTBau3WeOW7V92nUdCSRee3UcaEQuOwVufJk4deQfPOgIpsTt2fR6R/Vtyzd86keNqsab6SX8GYdPWlPPy/VZySeevMYufDeenMZtqkT9KRU/LNYP3aj8imfLCMbdQsG+m+Xem4UurDXtYgF+e2Weq+VRgWb+/KXui7WOWzUxESfO3BWQ8JatIWEduVQdcKCw8PcttQJ+GjSenIZNZfLhcHX9dKKNqXUOnBaN+fR8pEIuO4YdOEPOm0T+/GXNdBJNS6c96jUNIeEsZRJOhyNPbKaedoLeR2OelcJG9wehkaeIN9etQ1HvDOYqqkhdhzNNg6H/jCUv3VWNEIBRUeidl+OPG+UtmjW+GQP9x0OsdeLMsLCPfFXSMOXfAsEcEOEaqBUaWOZU0GRM+wax81jbOgboeFf8izeu6uWaSbfb2ve+OtV9RqMt1rNN2DQt6IN49aOOaiQ7slGmlgblBMb8ovF91YKMcfEF9ujex/M2FkfYeMjJKNfnl3d5wGHpJ7Xu2NQuKxTNBZLseoWb9oOfY7GcE7LWUZSGYEOPevRp+AXDVGinSAi4ZvW60TFUcmU7Cbe7ipdNBGJv7oapJsSV8nUa81NL9GI/R6LbORVbJQOCgueogKJ3ZjXuNCHK4HGn1oYDMfXLp7Pi8LVmsuUKM7LkFXknNiZHtdUdwjFSsuVN8AAAB1dFJOUwAE/hMaDRsI/gH+FPw6/L/+9GT+cS/+7vyP0M0kQbD5w1uI/uf5+v7sTHyU3FvVPLgXvyRJ/aPk1fyq66Vn2NEt/Nv85/7eh2FLzPfvsvX9+N7m8trP7+ntyafrm/OH+Jz59+3Pn3/Mq+qq+NHq5MF4+InD117Lt0kAAAU3SURBVDjLbdV3VJNnFAdgE8gkCQkJS9nInspQRGSIu+496qhard3tySAkIYuEbCBkAAFCwpCN7CkgKGUvBffee1S7z+kXUiL2cP9+zu97733Pe79582YXaFFIAMHFJdqFEBCyCDRv7kLAYGbmMegoN5fo6Gg3AjrG3AwGQ8wBYdaObsfj4pydDx06cuTo0bi4427rHGFzBEJ8ok66bHJ3dr5w4enThoZNm1xOEgIgcwQ6nIj3XHnB+epVobC7qqK5tdHTM/6Ew/8jQTAoOv72SgBWVw/marIkFQboHo+GghCfdmt9eOMWj3tPCzVqjk7B56uJk6qOca8t4T9BZ2eCINahG7d6eLg3ZOVyknU6saKEMzLZWeDl9XM4GgozzQkUEmS51cPTa8v5kSJiQgJRp1CoOUMDZ9MmRj08jjkBnzdBxxWbH/zm9W7kJVENQKKiSM2pH1p1ti3vgefWY6EOINMEQ7fla7WXGjS5yclEIJPDIRLPnMnNedRBo+VvC40BzZwwyHVbPpN5qSHXBHUA5GvaC2i8ie2uQZBpiVgUc8ry63wmzf13/q/JyQkJuqIiXUJCSUkRX9lJ4+VtD15uPX3vIAf0qUAjHDRAokLMF+uIABw0wvXBjiEGCHH98qtVD9uYzNubRzTJJamX023g8J4qtTo3p/kRjZff8eOGNVYQExwHzvhq8iXnTGZ1OndqqrKHSMyabG6l8do6MmL9fA3QzC0cg2nvKC3tu4e6lfkiNfVcYVlZVVVZTyz90j88bUE7Fut00GwabsRgmh+Wlva/g6+qzkxNFQoLC7u7e5A1lA9eTG2BEotysjdA88X+NpVS5Z0WWu3r6pwc8ePUx0KhWNydU3X1N1rpHSW4F+O/2NwAF3xmYyNV/t3CE/31IiuLLzZkisUazeXXteyWO2FgDNcE09Nvnb07zGRfrK+7NijMzDxXmJN1ra7+vYg9fJdUzLWJtJwFx+4C8H1dHf8yAM9Nw4si3vAYq5iLDDTC8MVfyGqy2wtamE0379cPDQ0MDOj4fMX1tzd52o727Oykz43NmAEwpSY7rLOltKnp7cX7938B6vr1589vNtHePFIa4DJj107HkNwuajZ4bJjGFolEtU03btz4o1YkYvNGJwQbSFQ4fP4ycyOUIFVdNdKCsTdaNpstevDsz2e1Ijabp80bp8dSu2YgdH5YhUQiwfRKwzpb730YzWts3Pyqr7+/fzSvOQ3VK5PBk3avh07DbysAWYkhScOUjbfb2lqvXLkykdfXlz+eRu3FyGRTETuCDRBi5bsnQqVC2pSdL6/R6+n08nIslkTB4+msyvNIJHzKzpvgY3iKsHVWgXvgKiSysAxbfBqo4mIsNvb0kyexxQCUdEV4f+NjDZteTlAr39W4iKn0dK6Mrmex5HIGQ6/foE+RISVp0l2rCT4W/71tIHO1t10E0obLpdBJjKQkBomu1wtSZCqVFLxrfkDQzA6AOQasiLSzM5BEFoVComRksBhweBJVABZIF/q7zoJWKyIFAgqFSjVACoWewSCnpFAZYABG+kf5zEALv2BbPB6flkalMoBUEolBlslS4FQqiSQA422Xr7EwweW2tnjwR0iWA2OGUxkkEhhsOwuCoNZ+y7xxZDIro7xcLieTUSgyg8VKTKQIdu/w83WwQJi2N5RgHxi4fz8OlwgguRyFYuDs7HA47+/WB/taQT5uSAQIYhGDXvvDvn17dy5dunDhkiU7F1haHraPcnWAWkA+XfgIM/O1aw8c+H6vES4AoP3BUPTH38K/OmNBlhC2jIMAAAAASUVORK5CYII=";
const name = "vuepress-theme-reco";
const version = "2.0.0-beta.68";
const description = "> TODO: description";
const homepage = "https://github.com/recoluan/vuepress-theme-reco#readme";
const bugs = {
  url: "https://github.com/recoluan/vuepress-theme-reco/issues"
};
const repository = {
  type: "git",
  url: "git+https://github.com/recoluan/vuepress-theme-reco.git"
};
const license = "MIT";
const author = "reco_luan <recoluan@qq.com>";
const main = "lib/node/index.js";
const types = "lib/node/index.d.ts";
const type = "module";
const directories = {
  lib: "lib",
  test: "__tests__"
};
const files = [
  "lib",
  "templates"
];
const publishConfig = {
  access: "public"
};
const dependencies = {
  "@vicons/carbon": "^0.12.0",
  "@vuepress-reco/shared": "2.0.0-beta.68",
  "@vuepress-reco/tailwindcss-config": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-bulletin-popover": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-comments": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-page": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-code-copy": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-markdown-task": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-vue-preview": "2.0.0-beta.68",
  "@vuepress/bundler-vite": "2.0.0-beta.67",
  "@vuepress/bundler-webpack": "2.0.0-beta.67",
  "@vuepress/client": "2.0.0-beta.67",
  "@vuepress/core": "2.0.0-beta.67",
  "@vuepress/plugin-active-header-links": "2.0.0-beta.67",
  "@vuepress/plugin-back-to-top": "2.0.0-beta.67",
  "@vuepress/plugin-container": "2.0.0-beta.67",
  "@vuepress/plugin-external-link-icon": "2.0.0-beta.67",
  "@vuepress/plugin-git": "2.0.0-beta.67",
  "@vuepress/plugin-medium-zoom": "2.0.0-beta.67",
  "@vuepress/plugin-nprogress": "2.0.0-beta.67",
  "@vuepress/plugin-palette": "2.0.0-beta.67",
  "@vuepress/plugin-prismjs": "2.0.0-beta.67",
  "@vuepress/plugin-register-components": "2.0.0-beta.67",
  "@vuepress/plugin-search": "2.0.0-beta.67",
  "@vuepress/plugin-docsearch": "2.0.0-beta.67",
  "@vuepress/plugin-theme-data": "2.0.0-beta.67",
  "@vuepress/shared": "2.0.0-beta.67",
  "@vuepress/utils": "2.0.0-beta.67",
  autoprefixer: "10.4.7",
  postcss: "8.4.14",
  "postcss-each": "1.1.0",
  "postcss-import": "14.0.2",
  tailwindcss: "3.1.6",
  vue: "^3.3.4",
  "vue-router": "^4.2.2"
};
const devDependencies = {
  "eslint-config-vuepress": "3.2.1",
  "eslint-config-vuepress-typescript": "2.2.1",
  prettier: "2.2.1",
  "sort-package-json": "1.44.0"
};
const peerDependencies = {
  vuepress: "2.0.0-beta.67"
};
const scripts = {
  test: 'echo "Error: run tests from root" && exit 1',
  build: "tsc --build tsconfig.build.json",
  clean: "rimraf lib *.tsbuildinfo",
  copy: 'cpx "src/**/*.{d.ts,vue,scss,css,svg,png,jpg}" lib'
};
const packageInfo = {
  name,
  version,
  description,
  homepage,
  bugs,
  repository,
  license,
  author,
  main,
  types,
  type,
  directories,
  files,
  publishConfig,
  dependencies,
  devDependencies,
  peerDependencies,
  scripts
};
const _hoisted_1$R = { class: "footer-wrapper" };
const _hoisted_2$B = {
  class: "xicon-icon",
  style: { "width": "18px", "height": "18px", "font-size": "18px", "color": "inherit" },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
};
const _hoisted_3$y = /* @__PURE__ */ createElementVNode(
  "g",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  },
  [
    /* @__PURE__ */ createElementVNode("circle", {
      cx: "12",
      cy: "12",
      r: "9"
    }),
    /* @__PURE__ */ createElementVNode("path", { d: "M14 9.75a3.016 3.016 0 0 0-4.163.173a2.993 2.993 0 0 0 0 4.154A3.016 3.016 0 0 0 14 14.25" })
  ],
  -1
  /* HOISTED */
);
const _hoisted_4$o = [
  _hoisted_3$y
];
const _hoisted_5$g = { key: 0 };
const _hoisted_6$c = {
  class: "xicon-icon",
  style: { "width": "18px", "height": "18px", "font-size": "18px", "color": "inherit" },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 12 12"
};
const _hoisted_7$9 = /* @__PURE__ */ createElementVNode(
  "g",
  { fill: "none" },
  [
    /* @__PURE__ */ createElementVNode("path", {
      d: "M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_8$7 = [
  _hoisted_7$9
];
const _hoisted_9$6 = {
  key: 1,
  class: "cyber-security"
};
const _hoisted_10$5 = /* @__PURE__ */ createElementVNode(
  "img",
  {
    src: _imports_0$1,
    alt: ""
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_11$4 = ["href"];
const _sfc_main$10 = {
  __name: "Footer",
  setup(__props) {
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData$1();
    const frontmatter = usePageFrontmatter();
    const { solution, options } = useComment();
    const { version: version2 } = packageInfo;
    const showAccessNumber = computed(() => {
      if (solution.value === "valine")
        return options.value.visitor != false;
      if (solution.value === "waline")
        return options.value.pageview != false;
      return false;
    });
    const copyRight = computed(() => {
      var _a3, _b2;
      let text2 = "";
      if (themeLocal.value.author) {
        text2 += `${themeLocal.value.author} `;
      }
      const startYear = (_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.footer) == null ? void 0 : _b2.startYear;
      const currYear = (/* @__PURE__ */ new Date()).getFullYear();
      if (startYear && startYear != currYear) {
        text2 += `${startYear} - `;
      }
      text2 += currYear;
      return text2;
    });
    const homeLink = computed(() => themeLocal.value.home || routeLocale.value);
    const isShowCommentAtHomePage = computed(() => {
      var _a3;
      return (_a3 = frontmatter.value.modules || []) == null ? void 0 : _a3.includes("Comment");
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
      const _component_Xicons = resolveComponent("Xicons");
      const _component_ValineViews = resolveComponent("ValineViews");
      const _component_WalineViews = resolveComponent("WalineViews");
      const _component_Comments = resolveComponent("Comments");
      return openBlock(), createElementBlock("div", _hoisted_1$R, [
        createElementVNode("span", null, [
          createVNode(_component_Xicons, {
            icon: "ColorPalette",
            link: "https://vuepress-theme-reco.recoluan.com",
            target: "_blank",
            text: `vuepress-theme-reco@${unref(version2)}`
          }, null, 8, ["text"])
        ]),
        withDirectives(createElementVNode(
          "span",
          null,
          [
            createVNode(_component_Xicons, {
              icon: "Security",
              link: (_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.footer) == null ? void 0 : _b2.recordLink,
              text: (_d = (_c = unref(frontmatter)) == null ? void 0 : _c.footer) == null ? void 0 : _d.record,
              target: "_blank"
            }, null, 8, ["link", "text"])
          ],
          512
          /* NEED_PATCH */
        ), [
          [vShow, (_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.footer) == null ? void 0 : _f.record]
        ]),
        createElementVNode("span", null, [
          createVNode(_component_Xicons, { text: copyRight.value }, {
            icon: withCtx(() => [
              (openBlock(), createElementBlock("svg", _hoisted_2$B, _hoisted_4$o))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["text"])
        ]),
        showAccessNumber.value ? (openBlock(), createElementBlock("span", _hoisted_5$g, [
          createVNode(_component_Xicons, null, {
            icon: withCtx(() => [
              (openBlock(), createElementBlock("svg", _hoisted_6$c, _hoisted_8$7))
            ]),
            default: withCtx(() => [
              unref(solution) === "valine" ? (openBlock(), createBlock(_component_ValineViews, {
                key: 0,
                idVal: homeLink.value
              }, null, 8, ["idVal"])) : createCommentVNode("v-if", true),
              unref(solution) === "waline" ? (openBlock(), createBlock(_component_WalineViews, {
                key: 1,
                path: homeLink.value
              }, null, 8, ["path"])) : createCommentVNode("v-if", true)
            ]),
            _: 1
            /* STABLE */
          })
        ])) : createCommentVNode("v-if", true),
        ((_h = (_g = unref(frontmatter)) == null ? void 0 : _g.footer) == null ? void 0 : _h.cyberSecurityRecord) ? (openBlock(), createElementBlock("span", _hoisted_9$6, [
          _hoisted_10$5,
          createElementVNode("a", {
            href: ((_j = (_i = unref(frontmatter)) == null ? void 0 : _i.footer) == null ? void 0 : _j.cyberSecurityLink) || "#",
            target: "_blank"
          }, toDisplayString((_l = (_k = unref(frontmatter)) == null ? void 0 : _k.footer) == null ? void 0 : _l.cyberSecurityRecord), 9, _hoisted_11$4)
        ])) : createCommentVNode("v-if", true),
        !isShowCommentAtHomePage.value ? (openBlock(), createBlock(_component_Comments, {
          key: 2,
          "hide-comments": true
        })) : createCommentVNode("v-if", true)
      ]);
    };
  }
};
const Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "Footer.vue"]]);
const _hoisted_1$Q = { class: "password-wrapper" };
const _hoisted_2$A = { class: "site-info" };
const _hoisted_3$x = ["src", "alt"];
const _hoisted_4$n = {
  key: 1,
  class: "site-name"
};
const _hoisted_5$f = { key: 0 };
const _hoisted_6$b = { key: 0 };
const _hoisted_7$8 = { key: 0 };
const _hoisted_8$6 = { key: 0 };
const _hoisted_9$5 = { key: 0 };
const _hoisted_10$4 = { key: 0 };
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["pass"],
  setup(__props, { emit }) {
    const { siteBrandLogo, siteBrandTitle, sitePassword } = useSiteInfo();
    const { password, passwordRef, lockIcon, lockText, focus } = useHandlePassword$1(
      sitePassword,
      emit
    );
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock("div", _hoisted_1$Q, [
        withDirectives(createElementVNode(
          "input",
          {
            maxlength: "6",
            type: "password",
            ref_key: "passwordRef",
            ref: passwordRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(password) ? password.value = $event : null)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vModelText, unref(password)]
        ]),
        createElementVNode("div", _hoisted_2$A, [
          unref(siteBrandLogo) ? (openBlock(), createElementBlock("img", {
            key: 0,
            class: "logo",
            src: unref(withBase)(unref(siteBrandLogo)),
            alt: unref(siteBrandTitle)
          }, null, 8, _hoisted_3$x)) : createCommentVNode("v-if", true),
          unref(siteBrandTitle) ? (openBlock(), createElementBlock(
            "h1",
            _hoisted_4$n,
            toDisplayString(unref(siteBrandTitle)),
            1
            /* TEXT */
          )) : createCommentVNode("v-if", true)
        ]),
        createElementVNode("div", null, [
          createVNode(_component_Xicons, {
            icon: unref(lockIcon),
            text: unref(lockText)
          }, null, 8, ["icon", "text"])
        ]),
        createElementVNode("ul", {
          class: "password-show",
          onClick: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => unref(focus) && unref(focus)(...args))
        }, [
          createElementVNode("li", null, [
            unref(password).length > 0 ? (openBlock(), createElementBlock("i", _hoisted_5$f)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 1 ? (openBlock(), createElementBlock("i", _hoisted_6$b)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 2 ? (openBlock(), createElementBlock("i", _hoisted_7$8)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 3 ? (openBlock(), createElementBlock("i", _hoisted_8$6)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 4 ? (openBlock(), createElementBlock("i", _hoisted_9$5)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 5 ? (openBlock(), createElementBlock("i", _hoisted_10$4)) : createCommentVNode("v-if", true)
          ])
        ]),
        createVNode(Footer)
      ]);
    };
  }
});
const Password$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "index.vue"]]);
const _hoisted_1$P = { class: "mobile-menus-container" };
const _hoisted_2$z = { class: "appearance" };
const _hoisted_3$w = /* @__PURE__ */ createElementVNode(
  "span",
  null,
  "Appearance",
  -1
  /* HOISTED */
);
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "NavbarDropdownNemu",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$P, [
        createVNode(NavbarLinks, { class: "mobile" }),
        createElementVNode("div", _hoisted_2$z, [
          _hoisted_3$w,
          createVNode(ToggleDarkModeButton)
        ])
      ]);
    };
  }
});
const NavbarDropdownNemu = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "NavbarDropdownNemu.vue"]]);
function useSeries(toggleSeries, toggleMobileMenus) {
  let unregisterRouterHook;
  onMounted(() => {
    const router = useRouter();
    const {
      direction: direction2
    } = useScrollDirection();
    unregisterRouterHook = router.afterEach((to, from) => {
      if (to.path !== from.path) {
        toggleSeries(false);
        toggleMobileMenus(false);
        direction2.value = "";
      }
    });
  });
  onUnmounted(() => {
    unregisterRouterHook();
  });
}
const SITE_PASSWORD_PASS = "SITE_PASSWORD_PASS";
function usePassword$1() {
  const themeLocal = useThemeLocaleData();
  const setedSitePassword = ref(!!themeLocal.value.password);
  const siteLoaded = ref(false);
  const sitePasswordPass = ref(true);
  onMounted(() => {
    let sitePasswordPassCache = "true";
    {
      sitePasswordPassCache = sessionStorage.getItem(SITE_PASSWORD_PASS);
    }
    if (themeLocal.value.password && sitePasswordPassCache !== "true") {
      sitePasswordPass.value = false;
    }
    siteLoaded.value = true;
  });
  const handlePass = () => {
    sitePasswordPass.value = true;
    {
      sessionStorage.setItem(SITE_PASSWORD_PASS, "true");
    }
  };
  return {
    siteLoaded,
    sitePasswordPass,
    setedSitePassword,
    handlePass
  };
}
function useInitCodeCopy() {
  const route = useRoute();
  const {
    path
  } = toRefs(route);
  const {
    initCopyBtn
  } = useInitCopyBtn();
  watch(path, () => {
    setTimeout(() => {
      initCopyBtn();
    }, 1e3);
  });
}
const _hoisted_1$O = { key: 1 };
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    const {
      isOpenSeries,
      isShowSeries,
      isShowCatalog,
      toggleSeries
    } = useSeriesData();
    const { isOpenMobileMenus, toggleMobileMenus } = useMobileMenus();
    const { siteLoaded, sitePasswordPass, setedSitePassword, handlePass } = usePassword$1();
    const containerClass = computed(() => [
      {
        "series--open": isOpenSeries.value,
        "series--no": !isShowSeries.value,
        "show-series": isShowSeries.value,
        "show-catalog": isShowCatalog.value,
        "mobile-menus--active": isOpenMobileMenus.value
      },
      frontmatter.value.pageClass
    ]);
    const seriesItems = useSeriesItems();
    onMounted(() => {
      useInitCodeCopy();
    });
    useSeries(toggleSeries, toggleMobileMenus);
    return (_ctx, _cache) => {
      return !unref(setedSitePassword) ? (openBlock(), createElementBlock(
        "div",
        {
          key: 0,
          class: normalizeClass(["common-wrapper", containerClass.value])
        },
        [
          createVNode(Navbar, { onToggleMenus: unref(toggleMobileMenus) }, null, 8, ["onToggleMenus"]),
          unref(seriesItems).length > 0 ? (openBlock(), createBlock(SubNavbar, {
            key: 0,
            onToggleSeries: unref(toggleSeries)
          }, null, 8, ["onToggleSeries"])) : createCommentVNode("v-if", true),
          createVNode(NavbarDropdownNemu),
          createElementVNode("div", {
            class: "series-mask",
            onClick: _cache[0] || (_cache[0] = ($event) => unref(toggleSeries)(false))
          }),
          createVNode(Series),
          renderSlot(_ctx.$slots, "default"),
          unref(isShowCatalog) ? (openBlock(), createBlock(Catalog, { key: 1 })) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : (openBlock(), createElementBlock(
        "div",
        {
          key: 1,
          class: normalizeClass(["common-wrapper", containerClass.value])
        },
        [
          unref(siteLoaded) && !unref(sitePasswordPass) ? (openBlock(), createBlock(Password$1, {
            class: "out",
            key: "out",
            onPass: unref(handlePass)
          }, null, 8, ["onPass"])) : createCommentVNode("v-if", true),
          unref(siteLoaded) && unref(sitePasswordPass) ? (openBlock(), createElementBlock("div", _hoisted_1$O, [
            createVNode(Navbar, { onToggleMenus: unref(toggleMobileMenus) }, null, 8, ["onToggleMenus"]),
            unref(seriesItems).length > 0 ? (openBlock(), createBlock(SubNavbar, {
              key: 0,
              onToggleSeries: unref(toggleSeries)
            }, null, 8, ["onToggleSeries"])) : createCommentVNode("v-if", true),
            createVNode(NavbarDropdownNemu),
            createElementVNode("div", {
              class: "series-mask",
              onClick: _cache[1] || (_cache[1] = ($event) => unref(toggleSeries)(false))
            }),
            createVNode(Series),
            renderSlot(_ctx.$slots, "default"),
            unref(isShowCatalog) ? (openBlock(), createBlock(Catalog, { key: 1 })) : createCommentVNode("v-if", true)
          ])) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      ));
    };
  }
});
const Common = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "index.vue"]]);
const _hoisted_1$N = {
  key: 0,
  class: "pagation-container"
};
const _hoisted_2$y = {
  class: "ellipsis",
  key: "ellipsis-front"
};
const _hoisted_3$v = ["onClick"];
const _hoisted_4$m = {
  class: "ellipsis",
  key: "ellipsis-back"
};
const _hoisted_5$e = {
  class: "jumpinput",
  key: "input"
};
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "Pagation",
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    pageSize: {
      type: Number,
      default: 10
    },
    total: {
      type: Number,
      default: 0
    },
    totalPage: {
      type: Number,
      default: 0
    }
  },
  emits: ["change"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const targetPage = ref(null);
    const tp = computed(() => {
      return Math.ceil(props.total / props.pageSize);
    });
    const showStartFakePageNum = computed(() => {
      return efont.value && !indexes.value.includes(1);
    });
    const showLastFakePageNum = computed(() => {
      return efont.value && !indexes.value.includes(tp.value);
    });
    const efont = computed(() => {
      return tp.value > 7;
    });
    const indexes = computed(() => {
      const ar = [];
      let left = 1;
      let right = tp.value;
      if (tp.value >= 7) {
        if (props.currentPage > 5 && props.currentPage < tp.value - 4) {
          left = Number(props.currentPage) - 3;
          right = Number(props.currentPage) + 3;
        } else {
          if (props.currentPage <= 5) {
            left = 1;
            right = 7;
          } else {
            right = tp.value;
            left = tp.value - 6;
          }
        }
      }
      while (left <= right) {
        ar.push(left);
        left++;
      }
      return ar;
    });
    const jumpPage = (page) => {
      const p2 = parseInt(page);
      if (p2 <= tp.value && p2 > 0) {
        emits("change", p2);
        return;
      }
      alert(`请输入大于0，并且小于等于${tp.value}的页码！`);
    };
    const goPrev = () => {
      let currentPage = props.currentPage;
      if (currentPage > 1) {
        emits("change", --currentPage);
      }
    };
    const goNext = () => {
      let currentPage = props.currentPage;
      if (currentPage < tp.value) {
        emits("change", ++currentPage);
      }
    };
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return tp.value > 1 ? (openBlock(), createElementBlock("div", _hoisted_1$N, [
        __props.currentPage > 1 ? (openBlock(), createBlock(_component_Xicons, {
          class: "jump",
          icon: "ChevronLeft",
          iconSize: 16,
          unselectable: "on",
          key: "left",
          onClick: goPrev
        })) : createCommentVNode("v-if", true),
        showStartFakePageNum.value ? (openBlock(), createElementBlock("span", {
          class: "jump",
          key: "page-one",
          onClick: _cache[0] || (_cache[0] = ($event) => jumpPage(1))
        }, "1")) : createCommentVNode("v-if", true),
        showStartFakePageNum.value && indexes.value[0] > 2 ? (openBlock(), createElementBlock("span", _hoisted_2$y, "...")) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(indexes.value, (num) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(["jump", { active: __props.currentPage == num }]),
              key: `page-${num}`,
              onClick: ($event) => jumpPage(num)
            }, toDisplayString(num), 11, _hoisted_3$v);
          }),
          128
          /* KEYED_FRAGMENT */
        )),
        showLastFakePageNum.value && tp.value - indexes.value.at(-1) > 1 ? (openBlock(), createElementBlock("span", _hoisted_4$m, "...")) : createCommentVNode("v-if", true),
        showLastFakePageNum.value ? (openBlock(), createElementBlock(
          "span",
          {
            class: "jump",
            key: "page-lastest",
            onClick: _cache[1] || (_cache[1] = ($event) => jumpPage(tp.value))
          },
          toDisplayString(tp.value),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        __props.currentPage < tp.value ? (openBlock(), createBlock(_component_Xicons, {
          class: "jump",
          key: "right",
          icon: "ChevronRight",
          iconSize: 16,
          onClick: goNext
        })) : createCommentVNode("v-if", true),
        createElementVNode("span", _hoisted_5$e, [
          withDirectives(createElementVNode(
            "input",
            {
              type: "text",
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => targetPage.value = $event)
            },
            null,
            512
            /* NEED_PATCH */
          ), [
            [vModelText, targetPage.value]
          ])
        ]),
        createElementVNode("span", {
          class: "jump go",
          key: "go",
          onClick: _cache[3] || (_cache[3] = ($event) => jumpPage(targetPage.value))
        }, "Go")
      ])) : createCommentVNode("v-if", true);
    };
  }
});
const Pagation = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__file", "Pagation.vue"]]);
const _sfc_main$X = defineComponent({
  components: { Common, PostList, Pagation },
  setup() {
    const {
      categoryPosts,
      categorySummary
    } = usePageData();
    const router = useRouter();
    const categoryList = computed(() => {
      let list = [];
      const currentCategoryKey = categoryPosts.value.currentCategoryKey;
      if (currentCategoryKey) {
        const { items = [] } = categorySummary[currentCategoryKey];
        list = Object.values(items);
      }
      return list;
    });
    const handlePagation = (page) => {
      const {
        currentCategoryKey,
        currentCategoryValue
      } = categoryPosts.value;
      router.push(`/${currentCategoryKey}/${currentCategoryValue}/${page}/`);
    };
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return {
      categoryList,
      categoryPosts,
      handlePagation,
      convertToPinyin
    };
  }
});
const _hoisted_1$M = { class: "categories-container" };
const _hoisted_2$x = { class: "category-list" };
const _hoisted_3$u = { class: "text" };
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RouterLink = resolveComponent("RouterLink");
  const _component_PostList = resolveComponent("PostList");
  const _component_Pagation = resolveComponent("Pagation");
  const _component_Common = resolveComponent("Common");
  return openBlock(), createBlock(_component_Common, null, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$M, [
        createElementVNode("ul", _hoisted_2$x, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.categoryList, ({ label, length }, index2) => {
              return openBlock(), createElementBlock(
                "li",
                {
                  key: index2,
                  class: normalizeClass([
                    "category-item",
                    {
                      active: _ctx.categoryPosts.currentCategoryValue === _ctx.convertToPinyin(label)
                    }
                  ])
                },
                [
                  createVNode(_component_RouterLink, {
                    class: "category-link",
                    to: `/${_ctx.categoryPosts.currentCategoryKey}/${_ctx.convertToPinyin(label)}/1/`
                  }, {
                    default: withCtx(() => [
                      createElementVNode(
                        "span",
                        _hoisted_3$u,
                        toDisplayString(label),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["to"])
                ],
                2
                /* CLASS */
              );
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        createVNode(_component_PostList, {
          data: _ctx.categoryPosts.pages
        }, null, 8, ["data"]),
        _ctx.categoryPosts.totalPage > 10 ? (openBlock(), createBlock(_component_Pagation, {
          key: 0,
          currentPage: _ctx.categoryPosts.currentPage,
          total: _ctx.categoryPosts.totalPage,
          onChange: _ctx.handlePagation
        }, null, 8, ["currentPage", "total", "onChange"])) : createCommentVNode("v-if", true)
      ])
    ]),
    _: 1
    /* STABLE */
  });
}
const Categories = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["render", _sfc_render$C], ["__file", "Categories.vue"]]);
const _hoisted_1$L = { class: "banner-brand__content" };
const _hoisted_2$w = ["src"];
const _hoisted_3$t = { key: 1 };
const _hoisted_4$l = { key: 2 };
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "Banner",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    const heroImage = computed(() => {
      var _a3, _b2, _c, _d;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroImage) ? withBase((_d = (_c = frontmatter.value) == null ? void 0 : _c.banner) == null ? void 0 : _d.heroImage) : null;
    });
    const heroImageStyle = computed(
      () => frontmatter.value.banner.heroImageStyle || {}
    );
    const bgImageStyle = computed(() => {
      var _a3;
      const { bgImageStyle: bgImageStyle2, bgImage } = ((_a3 = frontmatter.value) == null ? void 0 : _a3.banner) || {};
      const initBgImageStyle = bgImage ? {
        textAlign: "center",
        overflow: "hidden",
        background: `url(${withBase(bgImage)}) center/cover no-repeat`
      } : {};
      return bgImageStyle2 ? { ...initBgImageStyle, ...bgImageStyle2 } : initBgImageStyle;
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f, _g, _h;
      return openBlock(), createElementBlock(
        "section",
        {
          class: "banner-wrapper",
          style: normalizeStyle({ ...bgImageStyle.value })
        },
        [
          createElementVNode("div", _hoisted_1$L, [
            heroImage.value ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: heroImage.value,
              style: normalizeStyle({
                heroImageStyle: heroImageStyle.value
              }),
              alt: "heroImage"
            }, null, 12, _hoisted_2$w)) : createCommentVNode("v-if", true),
            ((_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroText) ? (openBlock(), createElementBlock(
              "h1",
              _hoisted_3$t,
              toDisplayString((_d = (_c = unref(frontmatter)) == null ? void 0 : _c.banner) == null ? void 0 : _d.heroText),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            ((_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.banner) == null ? void 0 : _f.tagline) ? (openBlock(), createElementBlock(
              "p",
              _hoisted_4$l,
              toDisplayString((_h = (_g = unref(frontmatter)) == null ? void 0 : _g.banner) == null ? void 0 : _h.tagline),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true)
          ])
        ],
        4
        /* STYLE */
      );
    };
  }
});
const Banner = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "Banner.vue"]]);
const _hoisted_1$K = { class: "banner-brand__content" };
const _hoisted_2$v = {
  key: 0,
  class: "title"
};
const _hoisted_3$s = {
  key: 1,
  class: "description"
};
const _hoisted_4$k = {
  key: 2,
  class: "tagline"
};
const _hoisted_5$d = {
  key: 3,
  class: "btn-group"
};
const _hoisted_6$a = {
  key: 4,
  class: "social-links"
};
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "BannerBrand",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    computed(() => {
      var _a3, _b2, _c, _d;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.heroImage) ? withBase((_d = (_c = frontmatter.value) == null ? void 0 : _c.bannerBrand) == null ? void 0 : _d.heroImage) : null;
    });
    const buttons = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.buttons) || [];
    });
    const socialLinks = computed(() => {
      var _a3, _b2;
      return (((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.socialLinks) || []).map((item) => {
        if (!item.color)
          item.color = createOneColor();
        return item;
      });
    });
    computed(
      () => frontmatter.value.bannerBrand.heroImageStyle || {}
    );
    const bgImageStyle = computed(() => {
      var _a3;
      const { bgImageStyle: bgImageStyle2, bgImage } = ((_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) || {};
      const initBgImageStyle = bgImage ? {
        overflow: "hidden",
        background: `url(${withBase(bgImage)}) center/cover no-repeat`
      } : {};
      return bgImageStyle2 ? { ...initBgImageStyle, ...bgImageStyle2 } : initBgImageStyle;
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock(
        "section",
        {
          class: "banner-brand__wrapper",
          style: normalizeStyle({ ...bgImageStyle.value })
        },
        [
          createElementVNode("div", _hoisted_1$K, [
            ((_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.title) ? (openBlock(), createElementBlock(
              "h1",
              _hoisted_2$v,
              toDisplayString((_d = (_c = unref(frontmatter)) == null ? void 0 : _c.bannerBrand) == null ? void 0 : _d.title),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            ((_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.bannerBrand) == null ? void 0 : _f.description) ? (openBlock(), createElementBlock(
              "p",
              _hoisted_3$s,
              toDisplayString((_h = (_g = unref(frontmatter)) == null ? void 0 : _g.bannerBrand) == null ? void 0 : _h.description),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            ((_j = (_i = unref(frontmatter)) == null ? void 0 : _i.bannerBrand) == null ? void 0 : _j.tagline) ? (openBlock(), createElementBlock(
              "p",
              _hoisted_4$k,
              toDisplayString((_l = (_k = unref(frontmatter)) == null ? void 0 : _k.bannerBrand) == null ? void 0 : _l.tagline),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            buttons.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(buttons.value, (btn, index2) => {
                  return openBlock(), createBlock(_component_Xicons, {
                    class: normalizeClass(btn.type),
                    key: index2,
                    icon: btn.icon,
                    text: btn.text,
                    link: btn.link,
                    "icon-size": "18",
                    "text-size": "14"
                  }, null, 8, ["class", "icon", "text", "link"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])) : createCommentVNode("v-if", true),
            socialLinks.value.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_6$a, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(socialLinks.value, (item, index2) => {
                  return openBlock(), createElementBlock("li", {
                    class: "social-item",
                    key: index2
                  }, [
                    createVNode(_component_Xicons, {
                      icon: item.icon,
                      link: item.link,
                      style: normalizeStyle({ color: item.color }),
                      target: "_blank"
                    }, null, 8, ["icon", "link", "style"])
                  ]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])) : createCommentVNode("v-if", true)
          ])
        ],
        4
        /* STYLE */
      );
    };
  }
});
const BannerBrand = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__file", "BannerBrand.vue"]]);
const _sfc_main$U = defineComponent({
  setup(props, ctx) {
    const themeLocal = useThemeLocaleData$1();
    const frontmatter = usePageFrontmatter();
    const socialLinks = computed(() => {
      var _a3, _b2;
      return (((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.blog) == null ? void 0 : _b2.socialLinks) || []).map((item) => {
        if (!item.color)
          item.color = createOneColor();
        return item;
      });
    });
    return { themeLocal, socialLinks };
  }
});
const _hoisted_1$J = { class: "personal-info-wrapper" };
const _hoisted_2$u = ["src"];
const _hoisted_3$r = {
  key: 1,
  class: "name"
};
const _hoisted_4$j = { class: "social-links" };
const _hoisted_5$c = /* @__PURE__ */ createElementVNode(
  "hr",
  null,
  null,
  -1
  /* HOISTED */
);
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  return openBlock(), createElementBlock("div", _hoisted_1$J, [
    _ctx.themeLocal.authorAvatar ? (openBlock(), createElementBlock("img", {
      key: 0,
      class: "personal-img",
      src: _ctx.$withBase(_ctx.themeLocal.authorAvatar),
      alt: "author-avatar"
    }, null, 8, _hoisted_2$u)) : createCommentVNode("v-if", true),
    _ctx.themeLocal.author ? (openBlock(), createElementBlock(
      "p",
      _hoisted_3$r,
      toDisplayString(_ctx.themeLocal.author),
      1
      /* TEXT */
    )) : createCommentVNode("v-if", true),
    createCommentVNode(" 支持 hover 展示文案、图片 "),
    createElementVNode("ul", _hoisted_4$j, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.socialLinks, (item, index2) => {
          return openBlock(), createElementBlock("li", {
            class: "social-item",
            key: index2
          }, [
            createVNode(_component_Xicons, {
              icon: item.icon,
              link: item.link,
              style: normalizeStyle({ color: item.color }),
              target: "_blank"
            }, null, 8, ["icon", "link", "style"])
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]),
    _hoisted_5$c
  ]);
}
const PersonalInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["render", _sfc_render$B], ["__file", "PersonalInfo.vue"]]);
const _hoisted_1$I = { class: "home-blog-content" };
const _hoisted_2$t = { class: "blog-list" };
const _hoisted_3$q = { class: "module-title" };
const _hoisted_4$i = { class: "category-wrapper" };
const _hoisted_5$b = { class: "text" };
const _hoisted_6$9 = { class: "num" };
const _hoisted_7$7 = { class: "module-title" };
const _hoisted_8$5 = { class: "tag-wrapper" };
const perPage$1 = 10;
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "Blog",
  setup(__props) {
    const { posts, categorySummary } = usePageData();
    const currentPage = ref(1);
    const categories = computed(() => {
      var _a3;
      return ((_a3 = categorySummary == null ? void 0 : categorySummary.categories) == null ? void 0 : _a3.items) || [];
    });
    const tags = computed(() => {
      var _a3;
      return ((_a3 = categorySummary == null ? void 0 : categorySummary.tags) == null ? void 0 : _a3.items) || [];
    });
    const postsOfCurrentPage = computed(() => {
      const start = (currentPage.value - 1) * perPage$1;
      const end = currentPage.value * perPage$1;
      return (posts || []).slice(start, end);
    });
    let handlePagation = (page) => {
    };
    const route = useRoute();
    const router = useRouter();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    const queryPage = computed(() => route.query.page);
    {
      handlePagation = (page) => {
        currentPage.value = page;
        const homeHref = themeLocal.value.home || routeLocale.value;
        router.push(page > 1 ? `${homeHref}?page=${page}` : homeHref);
        window.scrollTo({ left: 0, top: 0, behavior: "smooth" });
      };
      onMounted(() => {
        watch(queryPage, (newVal) => {
          if (newVal) {
            currentPage.value = Number(newVal);
          }
        });
      });
      window.addEventListener(
        "scroll",
        throttle(() => {
          const card = document.querySelector(".info-wrapper");
          if (card) {
            card.setAttribute("data-x", card.offsetLeft);
            card.setAttribute("data-y", card.offsetTop);
            card.setAttribute("data-width", card.clientWidth);
            card.setAttribute("data-height", card.clientHeight);
          }
        }, 50)
      );
    }
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      const _component_router_link = resolveComponent("router-link");
      const _component_MagicCard = resolveComponent("MagicCard");
      return openBlock(), createElementBlock("section", _hoisted_1$I, [
        createElementVNode("section", _hoisted_2$t, [
          createVNode(PostList, { data: postsOfCurrentPage.value }, null, 8, ["data"]),
          createVNode(Pagation, {
            currentPage: currentPage.value,
            total: unref(posts).length,
            onChange: unref(handlePagation)
          }, null, 8, ["currentPage", "total", "onChange"])
        ]),
        createVNode(_component_MagicCard, { class: "info-wrapper" }, {
          default: withCtx(() => [
            createVNode(PersonalInfo),
            createElementVNode("h4", _hoisted_3$q, [
              createVNode(_component_Xicons, {
                icon: "Folder",
                text: "Categories"
              })
            ]),
            createElementVNode("ul", _hoisted_4$i, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(categories.value, (value, key, index2) => {
                  return openBlock(), createElementBlock("li", {
                    class: "category-item",
                    key: index2
                  }, [
                    createVNode(_component_router_link, {
                      class: "category-link",
                      to: `/categories/${key}/1/`
                    }, {
                      default: withCtx(() => [
                        createElementVNode(
                          "span",
                          _hoisted_5$b,
                          toDisplayString(value.label),
                          1
                          /* TEXT */
                        ),
                        createElementVNode(
                          "span",
                          _hoisted_6$9,
                          toDisplayString(value.length),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1032, ["to"])
                  ]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            createElementVNode("h4", _hoisted_7$7, [
              createVNode(_component_Xicons, {
                icon: "Tag",
                text: "Tags"
              })
            ]),
            createElementVNode("ul", _hoisted_8$5, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(tags.value, (value, key, index2) => {
                  return openBlock(), createElementBlock(
                    "li",
                    {
                      class: "tag-item",
                      key: index2,
                      style: normalizeStyle({ borderColor: unref(createOneColor)() })
                    },
                    [
                      createVNode(_component_router_link, {
                        class: "tag-link",
                        to: `/tags/${key}/1/`
                      }, {
                        default: withCtx(() => [
                          createTextVNode(
                            toDisplayString(value.label),
                            1
                            /* TEXT */
                          )
                        ]),
                        _: 2
                        /* DYNAMIC */
                      }, 1032, ["to"])
                    ],
                    4
                    /* STYLE */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ]),
          _: 1
          /* STABLE */
        })
      ]);
    };
  }
});
const Blog = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__file", "Blog.vue"]]);
const _sfc_main$S = {};
const _hoisted_1$H = { class: "theme-reco-default-content" };
function _sfc_render$A(_ctx, _cache) {
  const _component_Content = resolveComponent("Content");
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createCommentVNode(" content "),
      createElementVNode("section", _hoisted_1$H, [
        createVNode(_component_Content)
      ])
    ],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const MdContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["render", _sfc_render$A], ["__file", "MdContent.vue"]]);
const _sfc_main$R = {};
function _sfc_render$z(_ctx, _cache) {
  const _component_Comments = resolveComponent("Comments");
  return openBlock(), createBlock(_component_Comments, { "hide-comments": false });
}
const Comment = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["render", _sfc_render$z], ["__file", "Comment.vue"]]);
const _hoisted_1$G = { class: "home-wrapper" };
const __default__$2 = defineComponent({
  name: "HomeWrapper",
  components: {
    Banner,
    BannerBrand,
    Blog,
    MdContent,
    Comment,
    Footer
  }
});
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(frontmatter).modules || ["Banner", "Blog", "Footer"], (key) => {
            return openBlock(), createBlock(resolveDynamicComponent(key), { key });
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]);
    };
  }
});
const Home = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "index.vue"]]);
const resolveFromFrontmatterConfig = (conf) => {
  if (conf === false) {
    return null;
  }
  if (isString$1(conf)) {
    return useNavLink(conf);
  }
  if (isPlainObject$1(conf)) {
    return conf;
  }
  return false;
};
const resolveFromSeriesItems = (seriesItems, currentPath, offset2) => {
  const index2 = seriesItems.findIndex((item) => item.link === currentPath);
  if (index2 !== -1) {
    const targetItem = seriesItems[index2 + offset2];
    if (!(targetItem == null ? void 0 : targetItem.link)) {
      return null;
    }
    return targetItem;
  }
  for (const item of seriesItems) {
    if (item.children) {
      const childResult = resolveFromSeriesItems(
        item.children,
        currentPath,
        offset2
      );
      if (childResult) {
        return childResult;
      }
    }
  }
  return null;
};
const _sfc_main$P = defineComponent({
  name: "PageNav",
  components: { Link },
  setup() {
    const frontmatter = usePageFrontmatter();
    const seriesItems = useSeriesItems();
    const route = useRoute();
    const router = useRouter();
    const prevNavLink = computed(() => {
      const prevConfig = resolveFromFrontmatterConfig(frontmatter.value.prev);
      if (prevConfig !== false) {
        return prevConfig;
      }
      return resolveFromSeriesItems(seriesItems.value, route.path, -1);
    });
    const nextNavLink = computed(() => {
      const nextConfig = resolveFromFrontmatterConfig(frontmatter.value.next);
      if (nextConfig !== false) {
        return nextConfig;
      }
      return resolveFromSeriesItems(seriesItems.value, route.path, 1);
    });
    const go = (link) => {
      router.push(link);
    };
    return {
      prevNavLink,
      nextNavLink,
      go
    };
  }
});
const _hoisted_1$F = {
  key: 0,
  class: "page-nav"
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.prevNavLink || _ctx.nextNavLink ? (openBlock(), createElementBlock("nav", _hoisted_1$F, [
    createElementVNode(
      "p",
      {
        class: normalizeClass(["inner", { hasPrev: !!_ctx.prevNavLink, hasNext: !!_ctx.nextNavLink }])
      },
      [
        _ctx.prevNavLink ? (openBlock(), createElementBlock(
          "span",
          {
            key: 0,
            class: "page-nav-item prev",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.go(_ctx.prevNavLink.link))
          },
          " ← " + toDisplayString(_ctx.prevNavLink.text),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        _ctx.nextNavLink ? (openBlock(), createElementBlock(
          "span",
          {
            key: 1,
            class: "page-nav-item next",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.go(_ctx.nextNavLink.link))
          },
          toDisplayString(_ctx.nextNavLink.text) + " → ",
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ],
      2
      /* CLASS */
    )
  ])) : createCommentVNode("v-if", true);
}
const PageNav = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["render", _sfc_render$y], ["__file", "PageNav.vue"]]);
const useEditNavLink$1 = () => {
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    const showEditLink = frontmatter.value.editLink ?? themeLocal.value.editLink ?? true;
    if (!showEditLink) {
      return null;
    }
    const {
      repo,
      docsRepo = repo,
      docsBranch = "main",
      docsDir = "",
      editLinkText
    } = themeLocal.value;
    if (!docsRepo)
      return null;
    const editLink = resolveEditLink({
      docsRepo,
      docsBranch,
      docsDir,
      filePathRelative: page.value.filePathRelative,
      editLinkPattern: themeLocal.value.editLinkPattern
    });
    if (!editLink)
      return null;
    return {
      text: editLinkText ?? "Edit this page",
      link: editLink,
      icon: "Edit",
      hideExternalLinkIcon: true
    };
  });
};
const useLastUpdated$1 = () => {
  useSiteLocaleData();
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    var _a3, _b2;
    const showLastUpdated = frontmatter.value.lastUpdated ?? themeLocal.value.lastUpdated ?? true;
    if (!showLastUpdated)
      return null;
    if (!((_a3 = page.value.git) == null ? void 0 : _a3.updatedTime))
      return null;
    const updatedDate = new Date((_b2 = page.value.git) == null ? void 0 : _b2.updatedTime);
    return updatedDate.toLocaleString();
  });
};
const _sfc_main$O = defineComponent({
  name: "PageMeta",
  components: { Link },
  setup() {
    const themeLocal = useThemeLocaleData$1();
    const editNavLink = useEditNavLink$1();
    const lastUpdated = useLastUpdated$1();
    return {
      themeLocal,
      editNavLink,
      lastUpdated
    };
  }
});
const _hoisted_1$E = { class: "page-meta" };
const _hoisted_2$s = {
  key: 0,
  class: "meta-item edit-link"
};
const _hoisted_3$p = {
  key: 1,
  class: "meta-item last-updated"
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  return openBlock(), createElementBlock("footer", _hoisted_1$E, [
    _ctx.editNavLink ? (openBlock(), createElementBlock("div", _hoisted_2$s, [
      createVNode(_component_Xicons, {
        class: "meta-item-label",
        icon: _ctx.editNavLink.icon,
        text: _ctx.editNavLink.text,
        link: _ctx.editNavLink.link,
        target: "_blank",
        "icon-size": "20",
        "text-size": "14"
      }, null, 8, ["icon", "text", "link"])
    ])) : createCommentVNode("v-if", true),
    _ctx.lastUpdated ? (openBlock(), createElementBlock("div", _hoisted_3$p, [
      createVNode(_component_Xicons, {
        class: "meta-item-label",
        icon: "Calendar",
        text: `${_ctx.themeLocal.lastUpdatedText || "Last Updated"} ${_ctx.lastUpdated}`,
        "icon-size": "20",
        "text-size": "14"
      }, null, 8, ["text"])
    ])) : createCommentVNode("v-if", true)
  ]);
}
const PageMeta$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["render", _sfc_render$x], ["__file", "PageMeta.vue"]]);
function usePageInfo() {
  const frontmatter = usePageFrontmatter();
  const pagePassword = computed(() => {
    const _password = frontmatter.value.password;
    if (!_password)
      return [];
    return Array.isArray(_password) ? _password : [_password];
  });
  return {
    pagePassword
  };
}
function useHandlePassword(pagePassword, emit) {
  const password = ref("");
  const passwordRef = ref(null);
  const lockIcon = ref("Locked");
  const lockText = ref("请输入密码");
  watch(password, (newVal) => {
    if (newVal.length !== 6)
      return;
    if (pagePassword.value.includes(md5(md5(newVal)))) {
      lockIcon.value = "Unlocked";
      lockText.value = "密码正确，请重稍后！";
      setTimeout(() => {
        emit("pass");
      }, 600);
    } else {
      password.value = "";
      lockText.value = "密码错误，请重新输入！";
    }
  });
  const focus = () => {
    passwordRef.value.focus();
  };
  return {
    password,
    passwordRef,
    lockIcon,
    lockText,
    focus
  };
}
const _hoisted_1$D = { class: "page-password-wrapper" };
const _hoisted_2$r = { key: 0 };
const _hoisted_3$o = { key: 0 };
const _hoisted_4$h = { key: 0 };
const _hoisted_5$a = { key: 0 };
const _hoisted_6$8 = { key: 0 };
const _hoisted_7$6 = { key: 0 };
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["pass"],
  setup(__props, { emit }) {
    const { pagePassword } = usePageInfo();
    const { password, passwordRef, lockIcon, lockText, focus } = useHandlePassword(
      pagePassword,
      emit
    );
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        withDirectives(createElementVNode(
          "input",
          {
            maxlength: "6",
            type: "password",
            ref_key: "passwordRef",
            ref: passwordRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(password) ? password.value = $event : null)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vModelText, unref(password)]
        ]),
        createElementVNode("div", null, [
          createVNode(_component_Xicons, {
            icon: unref(lockIcon),
            text: unref(lockText)
          }, null, 8, ["icon", "text"])
        ]),
        createElementVNode("ul", {
          class: "password-show",
          onClick: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => unref(focus) && unref(focus)(...args))
        }, [
          createElementVNode("li", null, [
            unref(password).length > 0 ? (openBlock(), createElementBlock("i", _hoisted_2$r)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 1 ? (openBlock(), createElementBlock("i", _hoisted_3$o)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 2 ? (openBlock(), createElementBlock("i", _hoisted_4$h)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 3 ? (openBlock(), createElementBlock("i", _hoisted_5$a)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 4 ? (openBlock(), createElementBlock("i", _hoisted_6$8)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 5 ? (openBlock(), createElementBlock("i", _hoisted_7$6)) : createCommentVNode("v-if", true)
          ])
        ])
      ]);
    };
  }
});
const Password = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "index.vue"]]);
let PAGE_PASSWORD_PASS = "PAGE_PASSWORD_PASS";
function usePassword() {
  const route = useRoute();
  PAGE_PASSWORD_PASS = `${PAGE_PASSWORD_PASS}:${route.path}`;
  const frontmatter = usePageFrontmatter();
  const pageLoaded = ref(false);
  const pagePasswordPass = ref(true);
  const setedPagePassword = ref(!!frontmatter.value.password);
  onMounted(() => {
    let pagePasswordPassCache = "true";
    {
      pagePasswordPassCache = sessionStorage.getItem(PAGE_PASSWORD_PASS);
    }
    if (frontmatter.value.password && pagePasswordPassCache !== "true") {
      pagePasswordPass.value = false;
    }
    pageLoaded.value = true;
  });
  const handlePass = () => {
    pagePasswordPass.value = true;
    {
      sessionStorage.setItem(PAGE_PASSWORD_PASS, "true");
    }
  };
  return {
    pageLoaded,
    pagePasswordPass,
    setedPagePassword,
    handlePass
  };
}
const _hoisted_1$C = { class: "page-container" };
const _hoisted_2$q = {
  key: 0,
  class: "page-title"
};
const _hoisted_3$n = {
  key: 1,
  class: "theme-reco-default-content"
};
const _hoisted_4$g = {
  key: 2,
  class: "theme-reco-default-content"
};
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    const pageData = usePageData$1();
    const { options } = useComment();
    const { pageLoaded, pagePasswordPass, setedPagePassword, handlePass } = usePassword();
    const title = computed(
      () => {
        var _a3, _b2, _c;
        return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.title) || ((_c = pageData == null ? void 0 : pageData.value) == null ? void 0 : _c.title) || "";
      }
    );
    const shouldHideComments = computed(() => {
      var _a3;
      const { hideComments: hideCommentsInSinglePage } = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter;
      const { hideComments: hideCommentsInAllPage } = options.value;
      return hideCommentsInSinglePage === true || hideCommentsInSinglePage !== false && hideCommentsInAllPage === true;
    });
    return (_ctx, _cache) => {
      const _component_Content = resolveComponent("Content");
      const _component_Comments = resolveComponent("Comments");
      return openBlock(), createElementBlock("main", _hoisted_1$C, [
        !!title.value ? (openBlock(), createElementBlock(
          "h1",
          _hoisted_2$q,
          toDisplayString(title.value),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        createVNode(PageInfo$1, { "page-data": unref(pageData) }, null, 8, ["page-data"]),
        !unref(setedPagePassword) ? (openBlock(), createElementBlock("div", _hoisted_3$n, [
          createVNode(_component_Content)
        ])) : (openBlock(), createElementBlock("div", _hoisted_4$g, [
          unref(pageLoaded) && !unref(pagePasswordPass) ? (openBlock(), createBlock(Password, {
            key: 0,
            onPass: unref(handlePass)
          }, null, 8, ["onPass"])) : createCommentVNode("v-if", true),
          unref(pageLoaded) && unref(pagePasswordPass) ? (openBlock(), createBlock(_component_Content, { key: 1 })) : createCommentVNode("v-if", true)
        ])),
        createVNode(PageMeta$1),
        createVNode(PageNav),
        createVNode(_component_Comments, { "hide-comments": shouldHideComments.value }, null, 8, ["hide-comments"])
      ]);
    };
  }
});
const Page$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "index.vue"]]);
const _hoisted_1$B = { class: "theme-container" };
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const page = usePageData$1();
    const frontmatter = usePageFrontmatter();
    const scrollPromise2 = useScrollPromise();
    const onBeforeEnter = scrollPromise2.resolve;
    const onBeforeLeave = scrollPromise2.pending;
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$B, [
        createVNode(Common, null, {
          default: withCtx(() => [
            unref(frontmatter).home === true ? (openBlock(), createBlock(Home, { key: 0 })) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: "fade-slide-y",
              mode: "out-in",
              onBeforeEnter: unref(onBeforeEnter),
              onBeforeLeave: unref(onBeforeLeave)
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(Page$1, {
                  key: unref(page).path
                }))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["onBeforeEnter", "onBeforeLeave"]))
          ]),
          _: 1
          /* STABLE */
        })
      ]);
    };
  }
});
const Layout$2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "Layout.vue"]]);
const _imports_0 = "/assets/taken-42974550.svg";
const _hoisted_1$A = /* @__PURE__ */ createElementVNode(
  "h1",
  null,
  "404",
  -1
  /* HOISTED */
);
const _hoisted_2$p = /* @__PURE__ */ createElementVNode(
  "p",
  null,
  "Oops! Page does not exist.",
  -1
  /* HOISTED */
);
const _hoisted_3$m = /* @__PURE__ */ createElementVNode(
  "img",
  { src: _imports_0 },
  null,
  -1
  /* HOISTED */
);
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "NotFound",
  setup(__props) {
    const router = useRouter();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    const goHome = () => {
      router.push(withBase(themeLocal.value.home || routeLocale.value));
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [
          createElementVNode("section", { class: "page-404-wrapper" }, [
            createElementVNode("div", { class: "content" }, [
              _hoisted_1$A,
              _hoisted_2$p,
              createElementVNode("div", {
                class: "xicon-container",
                onClick: goHome
              }, "Go Home")
            ]),
            _hoisted_3$m
          ])
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const NotFound = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "NotFound.vue"]]);
const _hoisted_1$z = { class: "posts-container" };
const perPage = 10;
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "Posts",
  setup(__props) {
    const { posts } = usePageData();
    const currentPage = ref(1);
    const blogContentTop = ref(0);
    const postsOfCurrentPage = computed(() => {
      const start = (currentPage.value - 1) * perPage;
      const end = currentPage.value * perPage;
      return (posts || []).slice(start, end);
    });
    let handlePagation = (page) => {
    };
    const route = useRoute();
    const router = useRouter();
    useRouteLocale();
    useThemeLocaleData();
    const queryPage = computed(() => route.query.page);
    {
      handlePagation = (page) => {
        currentPage.value = page;
        const homeHref = withBase("/posts/");
        router.push(page > 1 ? `${homeHref}?page=${page}` : homeHref);
        setTimeout(() => {
          if (blogContentTop.value === 0) {
            const blogContent = document.querySelector(".home-blog-content");
            if (blogContent)
              blogContentTop.value = blogContent.getBoundingClientRect().top;
          }
          window.scrollTo({ left: 0, top: 0, behavior: "smooth" });
        }, 100);
      };
      onMounted(() => {
        watch(queryPage, (newVal) => {
          if (newVal) {
            currentPage.value = Number(newVal);
          }
        });
      });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", _hoisted_1$z, [
        createVNode(PostList, { data: postsOfCurrentPage.value }, null, 8, ["data"]),
        createVNode(Pagation, {
          currentPage: currentPage.value,
          total: unref(posts).length,
          onChange: unref(handlePagation)
        }, null, 8, ["currentPage", "total", "onChange"])
      ]);
    };
  }
});
const Posts$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "Posts.vue"]]);
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "Posts",
  setup(__props) {
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [
          createVNode(Posts$1)
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const Posts = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "Posts.vue"]]);
const _hoisted_1$y = { class: "timeline-content" };
const _hoisted_2$o = { class: "year" };
const _hoisted_3$l = { class: "year-wrapper" };
const _hoisted_4$f = { class: "date" };
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "Timeline",
  setup(__props) {
    const { posts } = usePageData();
    const dataMap = {};
    posts.forEach((post) => {
      if (!post.frontmatter.date)
        return;
      let connector = post.frontmatter.date.includes("/") ? "/" : "-";
      const [year, mounth, day] = formatISODate(post.frontmatter.date).split(" ")[0].split(connector) || [];
      if (!year || !mounth || !day)
        return;
      if (!dataMap[year]) {
        dataMap[year] = [{
          ...post,
          date: `${mounth}${connector}${day}`
        }];
        return;
      }
      dataMap[year].push({
        ...post,
        date: `${mounth}-${day}`
      });
    });
    const timelineData = Object.keys(dataMap).reduce(
      (all2, next) => {
        all2.push({
          year: next,
          data: dataMap[next]
        });
        return all2;
      },
      []
    );
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return openBlock(), createBlock(Common, { class: "timeline-wrapper" }, {
        default: withCtx(() => [
          createElementVNode("ul", _hoisted_1$y, [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(unref(timelineData), (item, index2) => {
                return openBlock(), createElementBlock("li", { key: index2 }, [
                  createElementVNode(
                    "h2",
                    _hoisted_2$o,
                    toDisplayString(item.year),
                    1
                    /* TEXT */
                  ),
                  createElementVNode("ul", _hoisted_3$l, [
                    (openBlock(true), createElementBlock(
                      Fragment,
                      null,
                      renderList(item.data, (subItem, subIndex) => {
                        return openBlock(), createElementBlock("li", {
                          key: subIndex,
                          class: "item"
                        }, [
                          createElementVNode(
                            "span",
                            _hoisted_4$f,
                            toDisplayString(subItem.date),
                            1
                            /* TEXT */
                          ),
                          createVNode(_component_RouterLink, {
                            class: "title",
                            to: subItem.path
                          }, {
                            default: withCtx(() => [
                              createTextVNode(
                                toDisplayString(subItem.title),
                                1
                                /* TEXT */
                              )
                            ]),
                            _: 2
                            /* DYNAMIC */
                          }, 1032, ["to"])
                        ]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const Timeline$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "Timeline.vue"]]);
const _hoisted_1$x = { class: "friendship-link-container" };
const _hoisted_2$n = { class: "logo" };
const _hoisted_3$k = ["src"];
const _hoisted_4$e = { class: "title" };
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "FriendshipLink",
  setup(__props) {
    const themeLocal = useThemeLocaleData$1();
    const friendshipLinks = computed(() => {
      return themeLocal.value.friendshipLinks || [];
    });
    const handlClick = (link) => {
      window.open(link, "_blank");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$x, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(friendshipLinks.value, (item, index2) => {
            return openBlock(), createBlock(unref(MagicCard), {
              class: "friendship-link-item",
              key: index2,
              onClick: () => handlClick(item.link)
            }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_2$n, [
                  createElementVNode("img", {
                    src: item.logo
                  }, null, 8, _hoisted_3$k)
                ]),
                createElementVNode(
                  "span",
                  _hoisted_4$e,
                  toDisplayString(item.title),
                  1
                  /* TEXT */
                )
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]);
    };
  }
});
const FriendshipLink$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "FriendshipLink.vue"]]);
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "FriendshipLink",
  setup(__props) {
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [
          createVNode(FriendshipLink$1)
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const FriendshipLink = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "FriendshipLink.vue"]]);
const layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Categories,
  FriendshipLink,
  Layout: Layout$2,
  NotFound,
  Posts,
  Timeline: Timeline$1
}, Symbol.toStringTag, { value: "Module" }));
const clientConfig11 = defineClientConfig({
  enhance(...args) {
    applyClientEnhance(...args);
  },
  setup() {
    applyClientSetup$1();
  },
  layouts
});
async function applyClientSetup() {
  const posts = [{ "title": "音乐播放器测试", "frontmatter": { "id": "blog_1", "title": "音乐播放器测试", "date": "2023-09-08T00:00:00.000Z" }, "path": "/blogs/blogtest.html" }, { "title": "9月8日", "frontmatter": { "id": "blog-2023-09-08_1", "title": "9月8日", "date": "2023-09-08T00:00:00.000Z" }, "path": "/blogs/shuoshuotest.html" }];
  const series = {};
  const categorySummary = { "categories": { "pageSize": 10, "items": {}, "layout": "Categories" }, "tags": { "pageSize": 10, "items": {}, "layout": "Categories" } };
  const categoryPosts = {};
  provide(postsSymbol, posts);
  provide(seriesSymbol, series);
  provide(categorySummarySymbol, categorySummary);
  provide(categoryPaginationPostsSymbol, categoryPosts);
}
const clientConfig12 = defineClientConfig({
  setup() {
    applyClientSetup();
  }
});
const hopeInject = "";
const clientConfig13 = {};
let i$6 = {};
const t$4 = Symbol(""), n$6 = () => inject(t$4), s$4 = (o2) => {
  o2.provide(t$4, i$6);
};
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b2[i3] = start += 1 << eb[i3 - 1];
  }
  var r2 = new i32(b2[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j2 = b2[i3]; j2 < b2[i3 + 1]; ++j2) {
      r2[j2] = j2 - b2[i3] << 5 | i3;
    }
  }
  return {
    b: b2,
    r: r2
  };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b;
var rev = new u16(32768);
for (var i$5 = 0; i$5 < 32768; ++i$5) {
  var x$5 = (i$5 & 43690) >> 1 | (i$5 & 21845) << 1;
  x$5 = (x$5 & 52428) >> 2 | (x$5 & 13107) << 2;
  x$5 = (x$5 & 61680) >> 4 | (x$5 & 3855) << 4;
  rev[i$5] = ((x$5 & 65280) >> 8 | (x$5 & 255) << 8) >> 1;
}
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i3 = 0;
  var l2 = new u16(mb);
  for (; i3 < s2; ++i3) {
    if (cd[i3])
      ++l2[cd[i3] - 1];
  }
  var le2 = new u16(mb);
  for (i3 = 1; i3 < mb; ++i3) {
    le2[i3] = le2[i3 - 1] + l2[i3 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v3 = le2[cd[i3] - 1]++ << r_1;
        for (var m2 = v3 | (1 << r_1) - 1; v3 <= m2; ++v3) {
          co[rev[v3] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le2[cd[i3] - 1]++] >> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (var i$5 = 0; i$5 < 144; ++i$5)
  flt[i$5] = 8;
for (var i$5 = 144; i$5 < 256; ++i$5)
  flt[i$5] = 9;
for (var i$5 = 256; i$5 < 280; ++i$5)
  flt[i$5] = 7;
for (var i$5 = 280; i$5 < 288; ++i$5)
  flt[i$5] = 8;
var fdt = new u8(32);
for (var i$5 = 0; i$5 < 32; ++i$5)
  fdt[i$5] = 5;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max$1 = function(a2) {
  var m2 = a2[0];
  for (var i3 = 1; i3 < a2.length; ++i3) {
    if (a2[i3] > m2)
      m2 = a2[i3];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v3, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v3.length)
    e2 = v3.length;
  var n2 = new u8(e2 - s2);
  n2.set(v3.subarray(s2, e2));
  return n2;
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt2) {
  var e2 = new Error(msg || ec[ind]);
  e2.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e2, err);
  if (!nt2)
    throw e2;
  return e2;
};
var inflt = function(dat, st2, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st2.f && !st2.l)
    return buf || new u8(0);
  var noBuf = !buf || st2.i != 2;
  var noSt = st2.i;
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type2 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type2) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t2), bt2);
        st2.b = bt2 += l2, st2.p = pos = t2 * 8, st2.f = final;
        continue;
      } else if (type2 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type2 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$1(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >> 4;
          if (s2 < 16) {
            ldt[i3++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i3 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i3++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max$1(lt2);
        dbt = max$1(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c2)
        err(2);
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b2 = fleb[i3];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i3];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt2 + 131072);
        var end = bt2 + add;
        if (bt2 < dt2) {
          var shift2 = dl - dt2, dend = Math.min(dt2, end);
          if (shift2 + bt2 < 0)
            err(3);
          for (; bt2 < dend; ++bt2)
            buf[bt2] = dict[shift2 + bt2];
        }
        for (; bt2 < end; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end;
      }
    }
    st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var et$2 = /* @__PURE__ */ new u8(0);
var zls = function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
};
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {
    i: 2
  }, opts && opts.out, opts && opts.dictionary);
}
var te = typeof TextEncoder != "undefined" && /* @__PURE__ */ new TextEncoder();
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et$2, {
    stream: true
  });
  tds = 1;
} catch (e2) {
}
var dutf8 = function(d2) {
  for (var r2 = "", i3 = 0; ; ) {
    var c2 = d2[i3++];
    var eb = (c2 > 127) + (c2 > 223) + (c2 > 239);
    if (i3 + eb > d2.length)
      return {
        s: r2,
        r: slc(d2, i3 - 1)
      };
    if (!eb)
      r2 += String.fromCharCode(c2);
    else if (eb == 3) {
      c2 = ((c2 & 15) << 18 | (d2[i3++] & 63) << 12 | (d2[i3++] & 63) << 6 | d2[i3++] & 63) - 65536, r2 += String.fromCharCode(55296 | c2 >> 10, 56320 | c2 & 1023);
    } else if (eb & 1)
      r2 += String.fromCharCode((c2 & 31) << 6 | d2[i3++] & 63);
    else
      r2 += String.fromCharCode((c2 & 15) << 12 | (d2[i3++] & 63) << 6 | d2[i3++] & 63);
  }
};
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i3 = 0; i3 < str.length; ++i3)
      ar_1[i3] = str.charCodeAt(i3);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l2 = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai2 = 0;
  var w2 = function(v3) {
    ar[ai2++] = v3;
  };
  for (var i3 = 0; i3 < l2; ++i3) {
    if (ai2 + 5 > ar.length) {
      var n2 = new u8(ai2 + 8 + (l2 - i3 << 1));
      n2.set(ar);
      ar = n2;
    }
    var c2 = str.charCodeAt(i3);
    if (c2 < 128 || latin1)
      w2(c2);
    else if (c2 < 2048)
      w2(192 | c2 >> 6), w2(128 | c2 & 63);
    else if (c2 > 55295 && c2 < 57344)
      c2 = 65536 + (c2 & 1023 << 10) | str.charCodeAt(++i3) & 1023, w2(240 | c2 >> 18), w2(128 | c2 >> 12 & 63), w2(128 | c2 >> 6 & 63), w2(128 | c2 & 63);
    else
      w2(224 | c2 >> 12), w2(128 | c2 >> 6 & 63), w2(128 | c2 & 63);
  }
  return slc(ar, 0, ai2);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r2 = "";
    for (var i3 = 0; i3 < dat.length; i3 += 16384)
      r2 += String.fromCharCode.apply(null, dat.subarray(i3, i3 + 16384));
    return r2;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a3 = dutf8(dat), s2 = _a3.s, r2 = _a3.r;
    if (r2.length)
      err(8);
    return s2;
  }
}
const C$5 = ({
  size: e2 = 48,
  stroke: t2 = 4,
  wrapper: n2 = true,
  height: o2 = 2 * e2
}) => {
  const i3 = h$5("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: e2,
    height: e2,
    preserveAspectRatio: "xMidYMid",
    viewBox: "25 25 50 50"
  }, [h$5("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    dur: "2s",
    keyTimes: "0;1",
    repeatCount: "indefinite",
    values: "0;360"
  }), h$5("circle", {
    cx: "50",
    cy: "50",
    r: "20",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": t2,
    "stroke-linecap": "round"
  }, [h$5("animate", {
    attributeName: "stroke-dasharray",
    dur: "1.5s",
    keyTimes: "0;0.5;1",
    repeatCount: "indefinite",
    values: "1,200;90,200;1,200"
  }), h$5("animate", {
    attributeName: "stroke-dashoffset",
    dur: "1.5s",
    keyTimes: "0;0.5;1",
    repeatCount: "indefinite",
    values: "0;-35px;-125px"
  })])]);
  return n2 ? h$5("div", {
    class: "loading-icon-wrapper",
    style: `display:flex;align-items:center;justify-content:center;height:${o2}px`
  }, i3) : i3;
};
C$5.displayName = "LoadingIcon";
const p$4 = Array.isArray, fe$1 = (e2) => typeof e2 == "function", ve$1 = (e2) => typeof e2 == "string";
var d$6 = (e2) => Object.prototype.toString.call(e2) === "[object Object]";
const Re = (e2) => typeof e2 == "function", M$4 = Object.entries, v$5 = (e2, ...t2) => {
  if (t2.length === 0)
    return e2;
  const n2 = t2.shift() || null;
  return n2 && M$4(n2).forEach(([o2, i3]) => {
    o2 === "__proto__" || o2 === "constructor" || (d$6(e2[o2]) && d$6(i3) ? v$5(e2[o2], i3) : p$4(i3) ? e2[o2] = [...i3] : d$6(i3) ? e2[o2] = {
      ...i3
    } : e2[o2] = n2[o2]);
  }), v$5(e2, ...t2);
}, R$3 = (e2) => (e2.endsWith(".md") && (e2 = `${e2.slice(0, -3)}.html`), !e2.endsWith("/") && !e2.endsWith(".html") && (e2 = `${e2}.html`), e2 = e2.replace(/(^|\/)(?:README|index).html$/i, "$1"), e2), A$4 = (e2) => {
  const [t2, n2 = ""] = e2.split("#");
  return t2 ? `${R$3(t2)}${n2 ? `#${n2}` : ""}` : e2;
};
const Fe = (e2) => {
  const t2 = atob(e2);
  return strFromU8(unzlibSync(strToU8(t2, true)));
}, w$5 = (e2, ...t2) => {
  const n2 = e2.resolve(...t2), o2 = n2.matched[n2.matched.length - 1];
  if (!(o2 != null && o2.redirect))
    return n2;
  const {
    redirect: i3
  } = o2, r2 = fe$1(i3) ? i3(n2) : i3, a2 = ve$1(r2) ? {
    path: r2
  } : r2;
  return w$5(e2, {
    hash: n2.hash,
    query: n2.query,
    params: n2.params,
    ...a2
  });
}, y$5 = (e2) => {
  if (!(e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey) && !e2.defaultPrevented && !(e2.button !== void 0 && e2.button !== 0)) {
    if (e2.currentTarget) {
      const t2 = e2.currentTarget.getAttribute("target");
      if (t2 != null && t2.match(/\b_blank\b/i))
        return;
    }
    return e2.preventDefault(), true;
  }
}, T$3 = (e2) => {
  const t2 = useRouter(), n2 = useRoute(), o2 = computed(() => w$5(t2, unref(e2))), i3 = computed(() => o2.value.fullPath === n2.fullPath), r2 = (a2 = {}) => y$5(a2) ? t2.push(unref(e2)).catch() : Promise.resolve();
  return {
    route: o2,
    href: computed(() => o2.value.href),
    isActive: i3,
    navigate: r2
  };
};
defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: String,
      required: true
    }
  },
  slots: Object,
  setup(e2, {
    slots: t2
  }) {
    const n2 = toRef(e2, "to"), o2 = T$3(n2);
    return () => {
      var i3;
      return h$5("a", {
        class: ["vp-link", {
          "vp-active": o2.isActive.value
        }],
        href: o2.href.value,
        onClick: o2.navigate
      }, (i3 = t2.default) == null ? void 0 : i3.call(t2, o2));
    };
  }
});
const j$1 = ({
  to: e2 = "",
  class: t2 = "",
  ...n2
}, {
  slots: o2
}) => {
  var i3;
  const r2 = useRouter(), a2 = (m2 = {}) => y$5(m2) ? r2.push(e2).catch() : Promise.resolve();
  return h$5("a", {
    ...n2,
    class: ["vp-link", t2],
    href: withBase(A$4(e2)),
    onClick: a2
  }, (i3 = o2.default) == null ? void 0 : i3.call(o2));
};
j$1.displayName = "VPLink";
const Qe$1 = (e2, t2) => {
  const n2 = t2 ? t2._instance : getCurrentInstance();
  return d$6(n2 == null ? void 0 : n2.appContext.components) && (e2 in n2.appContext.components || camelize(e2) in n2.appContext.components || capitalize(camelize(e2)) in n2.appContext.components);
}, Ze$1 = (e2) => {
  const t2 = useRouteLocale();
  return computed(() => e2[t2.value]);
};
const photoswipe = "";
const photoSwipe = "";
const P$3 = ".page-container :not(a) > img:not([no-view])", x$4 = { "/": { "closeTitle": "关闭", "downloadTitle": "下载图片", "fullscreenTitle": "切换全屏", "zoomTitle": "缩放", "arrowPrevTitle": "上一个 (左箭头)", "arrowNextTitle": "下一个 (右箭头)" } }, A$3 = 800, b$5 = '<div class="photo-swipe-loading"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div>', H$3 = (e2) => isString$1(e2) ? Array.from(document.querySelectorAll(e2)) : e2.map((l2) => Array.from(document.querySelectorAll(l2))).flat(), h$4 = (e2) => new Promise((l2, m2) => {
  e2.complete ? l2({
    type: "image",
    element: e2,
    src: e2.src,
    width: e2.naturalWidth,
    height: e2.naturalHeight,
    alt: e2.alt,
    msrc: e2.src
  }) : (e2.onload = () => l2(h$4(e2)), e2.onerror = (d2) => m2(d2));
}), N$1 = () => {
  const {
    isSupported: e2,
    toggle: l2
  } = useFullscreen(), m2 = n$6(), d2 = Ze$1(x$4), v3 = usePageData$1();
  let n2;
  const g2 = (a2) => {
    a2.on("uiRegister", () => {
      e2 && a2.ui.registerElement({
        name: "fullscreen",
        order: 7,
        isButton: true,
        html: '<svg class="pswp__icn" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M249.5 270.833H437v-75H212a37.5 37.5 0 0 0-37.5 37.5v225h75v-187.5zm-37.5 600h225v-75H249.5v-187.5h-75v225a37.5 37.5 0 0 0 37.5 37.5zm637.5-37.5v-225h-75v187.5H587v75h225a37.5 37.5 0 0 0 37.5-37.5zM587 270.833h187.5v187.5h75v-225a37.5 37.5 0 0 0-37.5-37.5H587v75z"/></svg>',
        onClick: () => {
          l2();
        }
      }), a2.ui.registerElement({
        name: "download",
        order: 8,
        isButton: true,
        tagName: "a",
        html: {
          isCustomSVG: true,
          inner: '<path d="M20.5 14.3 17.1 18V10h-2.2v7.9l-3.4-3.6L10 16l6 6.1 6-6.1-1.5-1.6ZM23 23H9v2h14" id="pswp__icn-download"/>',
          outlineID: "pswp__icn-download"
        },
        onInit: (r2, o2) => {
          r2.setAttribute("download", ""), r2.setAttribute("target", "_blank"), r2.setAttribute("rel", "noopener"), o2.on("change", () => {
            r2.setAttribute("href", o2.currSlide.data.src);
          });
        }
      }), a2.ui.registerElement({
        name: "bulletsIndicator",
        className: "photo-swipe-bullets-indicator",
        appendTo: "wrapper",
        onInit: (r2, o2) => {
          const t2 = [];
          let i3 = -1;
          for (let s2 = 0; s2 < o2.getNumItems(); s2++) {
            const c2 = document.createElement("div");
            c2.className = "photo-swipe-bullet", c2.onclick = (w2) => {
              o2.goTo(t2.indexOf(w2.target));
            }, t2.push(c2), r2.appendChild(c2);
          }
          o2.on("change", () => {
            i3 >= 0 && t2[i3].classList.remove("active"), t2[o2.currIndex].classList.add("active"), i3 = o2.currIndex;
          });
        }
      });
    });
  }, p2 = () => Promise.all([__vitePreload(() => import("./photoswipe.esm-514cb96e.js"), true ? [] : void 0), nextTick().then(() => new Promise((a2) => setTimeout(a2, A$3)).then(() => H$3(P$3)))]).then(([{
    default: a2
  }, r2]) => {
    const o2 = r2.map((t2) => ({
      html: b$5,
      element: t2,
      msrc: t2.src
    }));
    r2.forEach((t2, i3) => {
      const s2 = () => {
        n2 = new a2({
          preloaderDelay: 0,
          showHideAnimationType: "zoom",
          ...d2.value,
          ...m2,
          dataSource: o2,
          index: i3,
          ...{
            closeOnVerticalDrag: true,
            wheelToZoom: false
          }
        }), g2(n2), n2.addFilter("thumbEl", () => t2), n2.addFilter("placeholderSrc", () => t2.src), n2.init();
      };
      t2.style.cursor = "zoom-in", t2.addEventListener("click", () => {
        s2();
      }), t2.addEventListener("keypress", ({
        key: c2
      }) => {
        c2 === "Enter" && s2();
      });
    }), r2.forEach((t2, i3) => {
      h$4(t2).then((s2) => {
        o2.splice(i3, 1, s2), n2 == null || n2.refreshSlideContent(i3);
      });
    });
  });
  onMounted(() => {
    useEventListener("wheel", () => {
      n2 == null || n2.close();
    }), p2(), watch(() => v3.value.path, () => p2());
  });
};
var M$3 = defineClientConfig({
  enhance: ({
    app: e2
  }) => {
    s$4(e2);
  },
  setup: () => {
    N$1();
  }
});
const vpCard = "";
const t$3 = ({
  title: c2,
  desc: e2 = "",
  logo: l2 = "",
  color: s2 = "",
  link: o2 = ""
}) => {
  const i3 = [h$5("img", {
    class: "vp-card-logo",
    src: withBase(l2)
  }), h$5("div", {
    class: "vp-card-content"
  }, [h$5("div", {
    class: "vp-card-title",
    innerHTML: c2
  }), h$5("hr"), h$5("div", {
    class: "vp-card-desc",
    innerHTML: e2
  })])], a2 = {
    class: "vp-card"
  };
  return s2 && (a2.style = {
    background: s2
  }), isLinkExternal(o2) ? h$5("a", {
    href: o2,
    target: "_blank",
    ...a2
  }, i3) : h$5(j$1, {
    to: o2,
    ...a2
  }, () => i3);
};
t$3.displayName = "VPCard";
const figure = "";
const footnote = "";
const imageMark = "";
const mermaid = "";
let i$4 = {};
const o$4 = Symbol(""), r$5 = () => inject(o$4), t$2 = (e2) => {
  e2.provide(o$4, i$4);
};
const o$3 = {
  useMaxWidth: false
}, L$5 = (e2) => ({
  dark: e2,
  background: e2 ? "#1e1e1e" : "#fff",
  primaryColor: e2 ? "#389d70" : "#4abf8a",
  primaryBorderColor: e2 ? "#389d70" : "#4abf8a",
  primaryTextColor: "#fff",
  secondaryColor: "#ffb500",
  secondaryBorderColor: e2 ? "#fff" : "#000",
  secondaryTextColor: e2 ? "#ddd" : "#333",
  tertiaryColor: e2 ? "#282828" : "#efeef4",
  tertiaryBorderColor: e2 ? "#bbb" : "#242424",
  tertiaryTextColor: e2 ? "#ddd" : "#333",
  noteBkgColor: e2 ? "#f6d365" : "#fff5ad",
  noteTextColor: "#242424",
  noteBorderColor: e2 ? "#f6d365" : "#333",
  lineColor: e2 ? "#d3d3d3" : "#333",
  textColor: e2 ? "#fff" : "#242424",
  mainBkg: e2 ? "#389d70" : "#4abf8a",
  errorBkgColor: "#eb4d5d",
  errorTextColor: "#fff",
  nodeBorder: e2 ? "#389d70" : "#4abf8a",
  nodeTextColor: e2 ? "#fff" : "#242424",
  signalTextColor: e2 ? "#9e9e9e" : "#242424",
  classText: "#fff",
  labelColor: "#fff",
  fillType0: e2 ? "#cf1322" : "#f1636e",
  fillType1: "#f39c12",
  fillType2: "#2ecc71",
  fillType3: "#fa541c",
  fillType4: "#25a55b",
  fillType5: "#13c2c2",
  fillType6: "#096dd9",
  fillType7: "#aa6fe9"
});
var k$3 = defineComponent({
  name: "Mermaid",
  props: {
    id: {
      type: String,
      required: true
    },
    code: {
      type: String,
      required: true
    }
  },
  setup(e2) {
    const {
      themeVariables: d2,
      ...s2
    } = r$5(), f2 = shallowRef(), m2 = computed(() => Fe(e2.code)), l2 = ref(""), i3 = ref(false), c2 = async () => {
      const [{
        default: t2
      }] = await Promise.all([__vitePreload(() => import("mermaid"), true ? [] : void 0), new Promise((r2) => setTimeout(r2, 800))]);
      t2.initialize({
        theme: "base",
        themeVariables: {
          ...L$5(i3.value),
          ...Re(d2) ? d2(i3.value) : d2
        },
        flowchart: o$3,
        sequence: o$3,
        journey: o$3,
        gantt: o$3,
        er: o$3,
        pie: o$3,
        ...s2,
        startOnLoad: false
      }), l2.value = (await t2.render(e2.id, m2.value)).svg;
    }, p2 = () => {
      const {
        body: t2
      } = document, r2 = document.createElement("div");
      r2.classList.add("mermaid-preview"), r2.innerHTML = l2.value, t2.appendChild(r2), r2.addEventListener("click", () => {
        t2.removeChild(r2);
      });
    }, u3 = () => {
      const t2 = `data:image/svg+xml;charset=utf8,${l2.value.replace(/<br>/g, "<br />").replace(/%/g, "%25").replace(/"/g, "%22").replace(/'/g, "%27").replace(/&/g, "%26").replace(/#/g, "%23").replace(/{/g, "%7B").replace(/}/g, "%7D").replace(/</g, "%3C").replace(/>/g, "%3E")}`, r2 = document.createElement("a");
      r2.setAttribute("href", t2), r2.setAttribute("download", `${e2.id}.svg`), r2.click();
    };
    return onMounted(() => {
      const t2 = document.documentElement, r2 = () => t2.classList.contains("dark") || t2.getAttribute("data-theme") === "dark";
      i3.value = r2(), c2(), useMutationObserver(t2, () => {
        i3.value = r2();
      }, {
        attributeFilter: ["class", "data-theme"],
        attributes: true
      }), watch(i3, () => c2());
    }), () => [h$5("div", {
      class: "mermaid-actions"
    }, [h$5("button", {
      class: "preview-button",
      onClick: () => p2(),
      title: "preview",
      innerHTML: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1316 1024" fill="currentColor"><path d="M658.286 0C415.89 0 0 297.106 0 512c0 214.82 415.89 512 658.286 512 242.322 0 658.285-294.839 658.285-512S900.608 0 658.286 0zm0 877.714c-161.573 0-512-221.769-512-365.714 0-144.018 350.427-365.714 512-365.714 161.572 0 512 217.16 512 365.714s-350.428 365.714-512 365.714z"/><path d="M658.286 292.571a219.429 219.429 0 1 0 0 438.858 219.429 219.429 0 0 0 0-438.858zm0 292.572a73.143 73.143 0 1 1 0-146.286 73.143 73.143 0 0 1 0 146.286z"/></svg>'
    }), h$5("button", {
      class: "download-button",
      onClick: () => u3(),
      title: "download",
      innerHTML: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor"><path d="M828.976 894.125H190.189c-70.55 0-127.754-57.185-127.754-127.753V606.674c0-17.634 14.31-31.933 31.933-31.933h63.889c17.634 0 31.932 14.299 31.932 31.933v95.822c0 35.282 28.596 63.877 63.877 63.877h511.033c35.281 0 63.877-28.595 63.877-63.877v-95.822c0-17.634 14.298-31.933 31.943-31.933h63.878c17.635 0 31.933 14.299 31.933 31.933v159.7c0 70.566-57.191 127.751-127.754 127.751zM249.939 267.51c12.921-12.92 33.885-12.92 46.807 0l148.97 148.972V94.893c0-17.634 14.302-31.947 31.934-31.947h63.876c17.638 0 31.946 14.313 31.946 31.947v321.589l148.97-148.972c12.922-12.92 33.876-12.92 46.797 0l46.814 46.818c12.922 12.922 12.922 33.874 0 46.807L552.261 624.93c-1.14 1.138-21.664 13.684-42.315 13.693-20.877.01-41.88-12.542-43.021-13.693L203.122 361.135c-12.923-12.934-12.923-33.885 0-46.807l46.817-46.818z"/></svg>'
    })]), h$5("div", {
      ref: f2,
      class: "mermaid-wrapper"
    }, l2.value ? h$5("div", {
      class: "mermaid-content",
      innerHTML: l2.value
    }) : h$5(C$5, {
      class: "mermaid-loading",
      height: 96
    }))];
  }
});
const s$3 = {
  showCompileOutput: false,
  clearConsole: false,
  ssr: false
};
let e$4 = s$3;
const n$5 = Symbol(""), r$4 = () => inject(n$5), t$1 = (o2) => {
  o2.provide(n$5, e$4);
};
const katex_min = "";
const katex = "";
const clientConfig15 = defineClientConfig({
  enhance: ({
    app
  }) => {
    app.component("VPCard", t$3);
    t$2(app);
    app.component("Mermaid", k$3);
    t$1(app);
    app.component("VuePlayground", defineAsyncComponent(() => __vitePreload(() => import("./VuePlayground-8a6ff5be.js"), true ? [] : void 0)));
  },
  setup: () => {
  }
});
const biliBili = "";
const e$3 = "accelerometer; autoplay; clipboard-write; encrypted-media; fullscreen; gyroscope; picture-in-picture";
const h$3 = (e2) => isString$1(e2) ? e2 : `${e2}px`, z$3 = (e2, u3 = 0) => {
  const o2 = shallowRef(), p2 = computed(() => h$3(unref(e2.width) || "100%")), m2 = ref("auto"), l2 = (t2) => {
    if (isString$1(t2)) {
      const [i3, s2] = t2.split(":"), a2 = Number(i3) / Number(s2);
      if (!Number.isNaN(a2))
        return a2;
    }
    return typeof t2 == "number" ? t2 : 16 / 9;
  }, N2 = (t2) => {
    const i3 = unref(e2.height), s2 = l2(unref(e2.ratio));
    return i3 ? h$3(i3) : `${Number(t2) / s2 + unref(u3)}px`;
  }, r2 = () => {
    o2.value && (m2.value = N2(o2.value.clientWidth));
  };
  return onMounted(() => {
    r2(), isRef(u3) && watch(u3, () => r2()), useEventListener("orientationchange", () => r2()), useEventListener("resize", () => r2());
  }), {
    el: o2,
    width: p2,
    height: m2
  };
};
const d$5 = "https://player.bilibili.com/player.html";
var S$3 = defineComponent({
  name: "BiliBili",
  props: {
    bvid: {
      type: String,
      default: ""
    },
    aid: {
      type: String,
      default: ""
    },
    cid: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: "A BiliBili video"
    },
    page: {
      type: [String, Number],
      default: 1
    },
    width: {
      type: [String, Number],
      default: "100%"
    },
    height: {
      type: [String, Number],
      default: void 0
    },
    ratio: {
      type: [String, Number],
      default: 16 / 9
    },
    time: {
      type: [String, Number],
      default: 0
    },
    autoplay: Boolean
  },
  setup(i3) {
    const {
      el: m2,
      width: n2,
      height: f2
    } = z$3(i3), e2 = ref(false), l2 = computed(() => {
      const {
        aid: a2,
        bvid: r2,
        cid: o2,
        autoplay: u3,
        time: p2,
        page: s2
      } = i3;
      return a2 && o2 ? `${d$5}?aid=${a2}&cid=${o2}&t=${p2}&autoplay=${u3 ? 1 : 0}&page=${s2}` : r2 ? `${d$5}?bvid=${r2}&t=${p2}&autoplay=${u3 ? 1 : 0}` : null;
    });
    return () => l2.value ? [h$5("div", {
      class: "bilibili-desc"
    }, h$5("a", {
      class: "sr-only",
      href: l2.value
    }, i3.title)), h$5("iframe", {
      ref: m2,
      src: l2.value,
      title: i3.title,
      class: "bilibili-iframe",
      allow: e$3,
      style: {
        width: n2.value,
        height: e2.value ? f2.value : 0
      },
      onLoad: () => {
        e2.value = true;
      }
    }), e2.value ? null : h$5(C$5)] : [];
  }
});
const srOnly = "";
const clientConfig16 = defineClientConfig({
  enhance: ({
    app
  }) => {
    if (!Qe$1("BiliBili"))
      app.component("BiliBili", S$3);
  },
  setup: () => {
  },
  rootComponents: []
});
const _Fontaine_ost13___HOYOMiX = "/assets/「Fontaine」ost-13 - HOYO-MiX-17c7ef45.mp3";
const __vite_glob_0_0$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost13___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost2___HOYOMiX = "/assets/「Fontaine」ost-2 - HOYO-MiX-e9a0a09d.mp3";
const __vite_glob_0_1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost2___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost20___HOYOMiX = "/assets/「Fontaine」ost-20 - HOYO-MiX-fafc51b0.mp3";
const __vite_glob_0_2$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost20___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost22___HOYOMiX = "/assets/「Fontaine」ost-22 - HOYO-MiX-35bbf440.mp3";
const __vite_glob_0_3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost22___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost23___HOYOMiX = "/assets/「Fontaine」ost-23 - HOYO-MiX-53dbbf8d.mp3";
const __vite_glob_0_4$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost23___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost31___HOYOMiX = "/assets/「Fontaine」ost-31 - HOYO-MiX-0eb6268e.mp3";
const __vite_glob_0_5$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost31___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost55___HOYOMiX = "/assets/「Fontaine」ost-55 - HOYO-MiX-8c9e0d5d.mp3";
const __vite_glob_0_6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost55___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost64___HOYOMiX = "/assets/「Fontaine」ost-64 - HOYO-MiX-1f66b1af.mp3";
const __vite_glob_0_7$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost64___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$E = {
  name: "Meting",
  props: {
    music: {
      required: false,
      type: Object,
      validator: (obj) => {
        if (obj.auto) {
          return true;
        } else if (obj.server === "local") {
          return !!obj.path;
        } else if (["netease", "tencent", "kuwo", "kugou", "baidu"].includes(obj.server)) {
          return !!obj.type && !!obj.mid;
        }
        return false;
      },
      default: null
    },
    additionalAudios: {
      required: false,
      type: Array,
      default: () => []
    },
    mini: {
      required: false,
      type: Boolean,
      default: null
    },
    float: {
      required: false,
      type: Boolean,
      default: false
    },
    theme: {
      required: false,
      type: String,
      default: "#b7daff"
    },
    shuffle: {
      required: false,
      type: Boolean,
      default: false
    },
    repeat: {
      required: false,
      type: String,
      default: "repeat-all"
    },
    customAudioType: {
      required: false,
      type: Object,
      default: void 0
    },
    mutex: {
      required: false,
      type: Boolean,
      default: true
    },
    lrcType: {
      required: false,
      type: Number,
      default: 0
    },
    showLrc: {
      required: false,
      type: Boolean,
      default: false
    },
    listFolded: {
      required: false,
      type: Boolean,
      default: true
    },
    listMaxHeight: {
      required: false,
      type: Number,
      default: 250
    },
    storageName: {
      required: false,
      type: String,
      default: "vuepress-plugin-meting"
    },
    autoplay: {
      required: false,
      type: Boolean,
      default: false
    },
    preload: {
      required: false,
      type: String,
      default: "auto"
    },
    volume: {
      required: false,
      type: Number,
      default: 0.7
    },
    controls: {
      required: false,
      type: Boolean,
      default: false
    },
    muted: {
      required: false,
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      metingApi: "https://api.i-meto.com/meting/api",
      audio: reactive([{
        title: "加载音乐列表中..",
        artist: " ",
        pic: "",
        src: "null"
      }]),
      rules: [["music.163.com.*song.*id=(\\d+)", "netease", "song"], ["music.163.com.*album.*id=(\\d+)", "netease", "album"], ["music.163.com.*artist.*id=(\\d+)", "netease", "artist"], ["music.163.com.*playlist.*id=(\\d+)", "netease", "playlist"], ["music.163.com.*discover/toplist.*id=(\\d+)", "netease", "playlist"], ["y.qq.com.*song/(\\w+).html", "tencent", "song"], ["y.qq.com.*album/(\\w+).html", "tencent", "album"], ["y.qq.com.*singer/(\\w+).html", "tencent", "artist"], ["y.qq.com.*playsquare/(\\w+).html", "tencent", "playlist"], ["y.qq.com.*playlist/(\\w+).html", "tencent", "playlist"], ["xiami.com.*song/(\\w+)", "xiami", "song"], ["xiami.com.*album/(\\w+)", "xiami", "album"], ["xiami.com.*artist/(\\w+)", "xiami", "artist"], ["xiami.com.*collect/(\\w+)", "xiami", "playlist"]],
      localRules: [["/(.+/)?(.+)\\.(.+)", "local", "song", 2], ["/(.+)?/|/", "local", "playlist"]]
    };
  },
  created() {
    const mapFunc2 = (obj) => ({
      title: obj.name || obj.title || "Audio name",
      artist: obj.artist || obj.author || "Audio artist",
      src: obj.url || obj.src,
      pic: obj.pic,
      lrc: obj.lrc || obj.lyric || "",
      theme: obj.pic,
      type: obj.type || "auto"
    });
    if (this.music === null) {
      if (this.additionalAudios.length) {
        this.audio = this.additionalAudios.map(mapFunc2);
      }
      return;
    }
    const {
      auto,
      type: type2,
      server,
      mid,
      path
    } = this.music;
    let params;
    if (auto) {
      const parsed_params = this.parse_link(auto);
      params = {
        ...parsed_params,
        r: Math.random()
      };
    } else if (server === "local") {
      params = this.parse_link(path, this.localRules);
      if (params.type === "playlist") {
        const musics = /* @__PURE__ */ Object.assign({
          "../../../public/music/「Fontaine」ost-13 - HOYO-MiX.mp3": __vite_glob_0_0$2,
          "../../../public/music/「Fontaine」ost-2 - HOYO-MiX.mp3": __vite_glob_0_1$2,
          "../../../public/music/「Fontaine」ost-20 - HOYO-MiX.mp3": __vite_glob_0_2$2,
          "../../../public/music/「Fontaine」ost-22 - HOYO-MiX.mp3": __vite_glob_0_3$2,
          "../../../public/music/「Fontaine」ost-23 - HOYO-MiX.mp3": __vite_glob_0_4$2,
          "../../../public/music/「Fontaine」ost-31 - HOYO-MiX.mp3": __vite_glob_0_5$2,
          "../../../public/music/「Fontaine」ost-55 - HOYO-MiX.mp3": __vite_glob_0_6$2,
          "../../../public/music/「Fontaine」ost-64 - HOYO-MiX.mp3": __vite_glob_0_7$2
        });
        this.audio = Object.keys(musics).map((m2) => {
          const reg = new RegExp(`.*public(${path}(.+?)( - (.+))?\\.mp3)`);
          const match = m2.match(reg);
          return {
            title: match[2],
            artist: match[4],
            src: match[1],
            pic: "/images/avatar.png"
          };
        });
      } else {
        const [dir, title, _2, artist, suf] = path.match(/.+\/(.+?)( - (.+))?\.(\w+)/);
        this.audio = [{
          title,
          artist,
          src: path,
          pic: "/images/avatar.png"
        }];
      }
      this.audio.concat(this.additionalAudios.map(mapFunc2));
      return;
    } else {
      params = {
        server,
        type: type2,
        id: mid,
        r: Math.random()
      };
    }
    let url = this.metingApi;
    let paramsArray = [];
    Object.keys(params).forEach((key) => paramsArray.push(key + "=" + params[key]));
    url += "?" + paramsArray.join("&");
    fetch(url, {
      headers: {
        referer: null
      }
    }).then((res) => res.json()).then((result) => {
      const res = result.map(mapFunc2);
      if (res.length) {
        this.audio = this.additionalAudios.map(mapFunc2).concat(res);
        this.setAudio();
      }
    });
  },
  mounted() {
    this.setAudio();
  },
  methods: {
    parse_link(link, rules = this.rules.concat(this.localRules)) {
      for (let rule of rules) {
        let patt = new RegExp(rule[0]);
        let res = patt.exec(link);
        if (res !== null) {
          return {
            server: rule[1],
            type: rule[2],
            id: res[rule[3] ?? 1]
          };
        }
      }
      return {
        server: "",
        type: "",
        id: ""
      };
    },
    setAudio() {
      const {
        aplayer
      } = this.$refs;
      aplayer.setAudioList(this.audio);
    }
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_APlayer = resolveComponent("APlayer");
  return openBlock(), createBlock(_component_APlayer, {
    ref: "aplayer",
    music: $data.audio[0],
    mini: $props.mini,
    theme: $props.theme,
    float: $props.float,
    shuffle: $props.shuffle,
    repeat: $props.repeat,
    "custom-audio-type": $props.customAudioType,
    mutex: $props.mutex,
    "lrc-type": $props.lrcType,
    "show-lrc": $props.showLrc,
    "list-folded": $props.listFolded,
    "list-max-height": $props.listMaxHeight.toString(),
    "storage-name": $props.storageName,
    preload: $props.preload,
    volume: $props.volume,
    autoplay: $props.autoplay,
    controls: $props.controls,
    muted: $props.muted
  }, null, 8, ["music", "mini", "theme", "float", "shuffle", "repeat", "custom-audio-type", "mutex", "lrc-type", "show-lrc", "list-folded", "list-max-height", "storage-name", "preload", "volume", "autoplay", "controls", "muted"]);
}
const Meting = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["render", _sfc_render$w], ["__file", "Meting.vue"]]);
const MetingGlobal_vue_vue_type_style_index_0_lang = "";
const _sfc_main$D = {
  name: "MetingGlobal",
  data() {
    return {
      ...{
        "auto": "",
        "server": "",
        "type": "",
        "mid": "",
        "path": ""
      },
      ...{
        "additionalAudios": [],
        "mini": false,
        "float": false,
        "theme": "#b7daff",
        "shuffle": false,
        "repeat": "repeat-all",
        "mutex": true,
        "lrcType": 0,
        "showLrc": false,
        "listFolded": false,
        "listMaxHeight": 250,
        "storageName": "vuepress-plugin-meting",
        "autoplay": false,
        "preload": "auto",
        "volume": 0.7,
        "controls": false,
        "muted": false
      }
    };
  },
  mounted() {
    if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
      this.aplayer_fixed_mobile_switch();
    }
  },
  methods: {
    aplayer_fixed_mobile_switch() {
      const aplayer = document.getElementById("aplayer-fixed");
      if (aplayer === null)
        return;
      aplayer.querySelector(".aplayer-body");
      const btn = aplayer.querySelector(".aplayer-miniswitcher");
      aplayer.querySelector(".aplayer-lrc");
      btn.onclick = () => {
      };
    }
  }
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Meting = resolveComponent("Meting");
  return openBlock(), createBlock(_component_Meting, {
    ref: "meting",
    id: "aplayer-fixed",
    music: {
      auto: _ctx.auto,
      server: _ctx.server,
      type: _ctx.type,
      mid: _ctx.mid,
      path: _ctx.path
    },
    auto: _ctx.auto,
    server: _ctx.server,
    type: _ctx.type,
    mid: _ctx.mid,
    "additional-audios": _ctx.additionalAudios,
    mini: _ctx.mini,
    theme: _ctx.theme,
    float: true,
    shuffle: _ctx.shuffle,
    repeat: _ctx.repeat,
    mutex: _ctx.mutex,
    "lrc-type": _ctx.lrcType,
    "show-lrc": _ctx.showLrc,
    "list-folded": _ctx.listFolded,
    "list-max-height": _ctx.listMaxHeight,
    "storage-name": _ctx.storageName,
    autoplay: _ctx.autoplay,
    preload: _ctx.preload,
    volume: _ctx.volume,
    controls: _ctx.controls,
    muted: _ctx.muted,
    class: normalizeClass(_ctx.mini ? "fixed" : "")
  }, null, 8, ["music", "auto", "server", "type", "mid", "additional-audios", "mini", "theme", "shuffle", "repeat", "mutex", "lrc-type", "show-lrc", "list-folded", "list-max-height", "storage-name", "autoplay", "preload", "volume", "controls", "muted", "class"]);
}
const MetingGlobal = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["render", _sfc_render$v], ["__file", "MetingGlobal.vue"]]);
const __vite_glob_0_0$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M4 16c0-6.6 5.4-12 12-12s12 5.4 12 12c0 1.2-0.8 2-2 2s-2-0.8-2-2c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8c1.2 0 2 0.8 2 2s-0.8 2-2 2c-6.6 0-12-5.4-12-12z"></path>\r\n</svg>';
const __vite_glob_0_1$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M26.667 5.333h-21.333c-0 0-0.001 0-0.001 0-1.472 0-2.666 1.194-2.666 2.666 0 0 0 0.001 0 0.001v-0 16c0 0 0 0.001 0 0.001 0 1.472 1.194 2.666 2.666 2.666 0 0 0.001 0 0.001 0h21.333c0 0 0.001 0 0.001 0 1.472 0 2.666-1.194 2.666-2.666 0-0 0-0.001 0-0.001v0-16c0-0 0-0.001 0-0.001 0-1.472-1.194-2.666-2.666-2.666-0 0-0.001 0-0.001 0h0zM5.333 16h5.333v2.667h-5.333v-2.667zM18.667 24h-13.333v-2.667h13.333v2.667zM26.667 24h-5.333v-2.667h5.333v2.667zM26.667 18.667h-13.333v-2.667h13.333v2.667z"></path>\r\n</svg>';
const __vite_glob_0_2$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-5 0 32 32">\r\n    <path d="M20.8 14.4q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2zM1.6 11.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2zM20.8 20.8q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2z"></path>\r\n</svg>';
const __vite_glob_0_3$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4h-11.64v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v0.973h-2.667v-3.64l-4-4zM22.667 17.333h2.667v5.573l-2.667-2.667v-2.907zM22.667 6.667v-4l5.333 5.333-5.333 5.333v-4h-10.907l-2.667-2.667h13.573z"></path>\r\n</svg>';
const __vite_glob_0_4$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-8 0 32 32">\r\n    <path d="M14.080 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112v-18.24q0-2.048 2.88-2.048zM2.88 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112v-18.24q0-2.048 2.88-2.048z"></path>\r\n</svg>';
const __vite_glob_0_5$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-8 0 32 32">\r\n    <path d="M15.552 15.168q0.448 0.32 0.448 0.832 0 0.448-0.448 0.768l-13.696 8.512q-0.768 0.512-1.312 0.192t-0.544-1.28v-16.448q0-0.96 0.544-1.28t1.312 0.192z"></path>\r\n</svg>';
const __vite_glob_0_6$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-1 0 32 32">\r\n  <path d="M25.6 9.92q1.344 0 2.272 0.928t0.928 2.272v9.28q0 1.28-0.928 2.24t-2.272 0.96h-22.4q-1.28 0-2.24-0.96t-0.96-2.24v-9.28q0-1.344 0.96-2.272t2.24-0.928h8v-3.52l6.4 5.76-6.4 5.76v-3.52h-6.72v6.72h19.84v-6.72h-4.8v-4.48h6.080z"></path>\r\n</svg>';
const __vite_glob_0_7$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n<path d="M9.333 9.333h13.333v4l5.333-5.333-5.333-5.333v4h-16v8h2.667v-5.333zM22.667 22.667h-13.333v-4l-5.333 5.333 5.333 5.333v-4h16v-8h-2.667v5.333z"></path>\r\n</svg>';
const __vite_glob_0_8$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 38 32">\r\n  <path d="M2.072 21.577c0.71-0.197 1.125-0.932 0.928-1.641-0.221-0.796-0.333-1.622-0.333-2.457 0-5.049 4.108-9.158 9.158-9.158h5.428c0.056-0.922 0.221-1.816 0.482-2.667h-5.911c-3.158 0-6.128 1.23-8.361 3.463s-3.463 5.203-3.463 8.361c0 1.076 0.145 2.143 0.431 3.171 0.164 0.59 0.7 0.976 1.284 0.976 0.117 0 0.238-0.016 0.357-0.049zM21.394 25.613h-12.409v-2.362c0-0.758-0.528-1.052-1.172-0.652l-5.685 3.522c-0.644 0.4-0.651 1.063-0.014 1.474l5.712 3.69c0.637 0.411 1.158 0.127 1.158-0.63v-2.374h12.409c3.158 0 6.128-1.23 8.361-3.463 1.424-1.424 2.44-3.148 2.99-5.029-0.985 0.368-2.033 0.606-3.125 0.691-1.492 3.038-4.619 5.135-8.226 5.135zM28.718 0c-4.985 0-9.026 4.041-9.026 9.026s4.041 9.026 9.026 9.026 9.026-4.041 9.026-9.026-4.041-9.026-9.026-9.026zM30.392 13.827h-1.728v-6.822c-0.635 0.576-1.433 1.004-2.407 1.285v-1.713c0.473-0.118 0.975-0.325 1.506-0.62 0.532-0.325 0.975-0.665 1.329-1.034h1.3v8.904z"></path>\r\n</svg>';
const __vite_glob_0_9$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M9.333 9.333h13.333v4l5.333-5.333-5.333-5.333v4h-16v8h2.667v-5.333zM22.667 22.667h-13.333v-4l-5.333 5.333 5.333 5.333v-4h16v-8h-2.667v5.333zM17.333 20v-8h-1.333l-2.667 1.333v1.333h2v5.333h2z"></path>\r\n</svg>';
const __vite_glob_0_10$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M22.667 4l7 6-7 6 7 6-7 6v-4h-3.653l-3.76-3.76 2.827-2.827 2.587 2.587h2v-8h-2l-12 12h-6v-4h4.347l12-12h3.653v-4zM2.667 8h6l3.76 3.76-2.827 2.827-2.587-2.587h-4.347v-4z"></path>\r\n</svg>';
const __vite_glob_0_11$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M25.468 6.947c-0.326-0.172-0.724-0.151-1.030 0.057l-6.438 4.38v-3.553c0-0.371-0.205-0.71-0.532-0.884-0.326-0.172-0.724-0.151-1.030 0.057l-12 8.164c-0.274 0.186-0.438 0.496-0.438 0.827s0.164 0.641 0.438 0.827l12 8.168c0.169 0.115 0.365 0.174 0.562 0.174 0.16 0 0.321-0.038 0.468-0.116 0.327-0.173 0.532-0.514 0.532-0.884v-3.556l6.438 4.382c0.169 0.115 0.365 0.174 0.562 0.174 0.16 0 0.321-0.038 0.468-0.116 0.327-0.173 0.532-0.514 0.532-0.884v-16.333c0-0.371-0.205-0.71-0.532-0.884z"></path>\r\n</svg>';
const __vite_glob_0_12$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8zM20.576 16q0 1.344-0.768 2.528t-2.016 1.664q-0.16 0.096-0.448 0.096-0.448 0-0.8-0.32t-0.32-0.832q0-0.384 0.192-0.64t0.544-0.448 0.608-0.384 0.512-0.64 0.192-1.024-0.192-1.024-0.512-0.64-0.608-0.384-0.544-0.448-0.192-0.64q0-0.48 0.32-0.832t0.8-0.32q0.288 0 0.448 0.096 1.248 0.48 2.016 1.664t0.768 2.528z"></path>\r\n</svg>';
const __vite_glob_0_13$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8z"></path>\r\n</svg>';
const __vite_glob_0_14$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8zM20.576 16q0 1.344-0.768 2.528t-2.016 1.664q-0.16 0.096-0.448 0.096-0.448 0-0.8-0.32t-0.32-0.832q0-0.384 0.192-0.64t0.544-0.448 0.608-0.384 0.512-0.64 0.192-1.024-0.192-1.024-0.512-0.64-0.608-0.384-0.544-0.448-0.192-0.64q0-0.48 0.32-0.832t0.8-0.32q0.288 0 0.448 0.096 1.248 0.48 2.016 1.664t0.768 2.528zM25.152 16q0 2.72-1.536 5.056t-4 3.36q-0.256 0.096-0.448 0.096-0.48 0-0.832-0.352t-0.32-0.8q0-0.704 0.672-1.056 1.024-0.512 1.376-0.8 1.312-0.96 2.048-2.4t0.736-3.104-0.736-3.104-2.048-2.4q-0.352-0.288-1.376-0.8-0.672-0.352-0.672-1.056 0-0.448 0.32-0.8t0.8-0.352q0.224 0 0.48 0.096 2.496 1.056 4 3.36t1.536 5.056zM29.728 16q0 4.096-2.272 7.552t-6.048 5.056q-0.224 0.096-0.448 0.096-0.48 0-0.832-0.352t-0.32-0.8q0-0.64 0.704-1.056 0.128-0.064 0.384-0.192t0.416-0.192q0.8-0.448 1.44-0.896 2.208-1.632 3.456-4.064t1.216-5.152-1.216-5.152-3.456-4.064q-0.64-0.448-1.44-0.896-0.128-0.096-0.416-0.192t-0.384-0.192q-0.704-0.416-0.704-1.056 0-0.448 0.32-0.8t0.832-0.352q0.224 0 0.448 0.096 3.776 1.632 6.048 5.056t2.272 7.552z"></path>\r\n</svg>';
const aplayerIcon_vue_vue_type_style_index_0_lang = "";
const assets = /* @__PURE__ */ Object.assign({
  "../assets/loading.svg": __vite_glob_0_0$1,
  "../assets/lrc.svg": __vite_glob_0_1$1,
  "../assets/menu.svg": __vite_glob_0_2$1,
  "../assets/no-repeat.svg": __vite_glob_0_3$1,
  "../assets/pause.svg": __vite_glob_0_4$1,
  "../assets/play.svg": __vite_glob_0_5$1,
  "../assets/repeat-all-legacy.svg": __vite_glob_0_6$1,
  "../assets/repeat-all.svg": __vite_glob_0_7$1,
  "../assets/repeat-one-legacy.svg": __vite_glob_0_8$1,
  "../assets/repeat-one.svg": __vite_glob_0_9$1,
  "../assets/shuffle.svg": __vite_glob_0_10$1,
  "../assets/skip.svg": __vite_glob_0_11$1,
  "../assets/volume-down.svg": __vite_glob_0_12$1,
  "../assets/volume-off.svg": __vite_glob_0_13$1,
  "../assets/volume-up.svg": __vite_glob_0_14$1
});
const SVGs = {};
for (const [path, inlineSvg] of Object.entries(assets)) {
  const viewBox = inlineSvg.match(/^<svg.+?viewBox="(.+?)".*>/)[1];
  const d2 = inlineSvg.match(/<path.+?d="(.+?)".*>/)[1];
  const name2 = path.match(/^.*\/(.+?)\.svg$/)[1];
  SVGs[name2] = {
    viewBox,
    d: d2
  };
}
const _sfc_main$C = {
  props: ["type"],
  computed: {
    svg() {
      this.type;
      if (this.type === "prev" || this.type === "next")
        ;
      return SVGs[this.type] || {};
    },
    style() {
      if (this.type === "next") {
        return {
          transform: "rotate(180deg)"
        };
      }
      return {};
    }
  }
};
const _hoisted_1$w = ["viewBox"];
const _hoisted_2$m = /* @__PURE__ */ createElementVNode(
  "use",
  {
    "xlink:href": "#aplayer-${type}"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$j = ["d"];
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    height: "100%",
    version: "1.1",
    viewBox: $options.svg.viewBox,
    width: "100%",
    style: normalizeStyle($options.style)
  }, [_hoisted_2$m, createElementVNode("path", {
    class: "aplayer-fill",
    d: $options.svg.d
  }, null, 8, _hoisted_3$j)], 12, _hoisted_1$w);
}
const Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["render", _sfc_render$u], ["__file", "aplayer-icon.vue"]]);
const aplayerIconbutton_vue_vue_type_style_index_0_lang = "";
const _sfc_main$B = {
  components: {
    Icon
  },
  props: ["icon"]
};
const _hoisted_1$v = {
  type: "button",
  class: "aplayer-icon"
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon = resolveComponent("icon");
  return openBlock(), createElementBlock("button", _hoisted_1$v, [createVNode(_component_icon, {
    type: $props.icon
  }, null, 8, ["type"])]);
}
const IconButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$t], ["__file", "aplayer-iconbutton.vue"]]);
const aplayerThumbnail_vue_vue_type_style_index_0_lang = "";
const _sfc_main$A = {
  components: {
    IconButton
  },
  props: {
    pic: String,
    theme: String,
    playing: {
      type: Boolean,
      default: false
    },
    enableDrag: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      hasMovedSinceMouseDown: false,
      dragStartX: 0,
      dragStartY: 0
    };
  },
  computed: {
    currentPicStyleObj() {
      if (!this.pic)
        return {};
      return {
        backgroundImage: `url(${this.pic})`,
        backgroundColor: this.theme
      };
    }
  },
  methods: {
    onDragBegin(e2) {
      if (this.enableDrag) {
        this.hasMovedSinceMouseDown = false;
        this.$emit("dragbegin");
        this.dragStartX = e2.clientX;
        this.dragStartY = e2.clientY;
        document.addEventListener("mousemove", this.onDocumentMouseMove);
        document.addEventListener("mouseup", this.onDocumentMouseUp);
      }
    },
    onDocumentMouseMove(e2) {
      this.hasMovedSinceMouseDown = true;
      this.$emit("dragging", {
        offsetLeft: e2.clientX - this.dragStartX,
        offsetTop: e2.clientY - this.dragStartY
      });
    },
    onDocumentMouseUp(e2) {
      document.removeEventListener("mouseup", this.onDocumentMouseUp);
      document.removeEventListener("mousemove", this.onDocumentMouseMove);
      this.$emit("dragend");
    },
    onClick() {
      if (!this.hasMovedSinceMouseDown) {
        this.$emit("toggleplay");
      }
    }
  }
};
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_button = resolveComponent("icon-button");
  return openBlock(), createElementBlock(
    "div",
    {
      class: "aplayer-pic",
      style: normalizeStyle($options.currentPicStyleObj),
      onMousedown: _cache[0] || (_cache[0] = (...args) => $options.onDragBegin && $options.onDragBegin(...args)),
      onClick: _cache[1] || (_cache[1] = (...args) => $options.onClick && $options.onClick(...args))
    },
    [createElementVNode(
      "div",
      {
        class: normalizeClass(["aplayer-button", $props.playing ? "aplayer-pause" : "aplayer-play"])
      },
      [createVNode(_component_icon_button, {
        icon: $props.playing ? "pause" : "play",
        class: normalizeClass($props.playing ? "aplayer-icon-pause" : "aplayer-icon-play")
      }, null, 8, ["icon", "class"])],
      2
      /* CLASS */
    )],
    36
    /* STYLE, HYDRATE_EVENTS */
  );
}
const Thumbnail = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$s], ["__file", "aplayer-thumbnail.vue"]]);
const aplayerList_vue_vue_type_style_index_0_lang = "";
const _sfc_main$z = {
  props: {
    show: {
      type: Boolean,
      default: true
    },
    currentMusic: Object,
    musicList: {
      type: Array,
      default() {
        return [];
      }
    },
    playIndex: {
      type: Number,
      default: 0
    },
    theme: String,
    listmaxheight: String
  },
  computed: {
    listHeightStyle() {
      return {
        height: `${33 * this.musicList.length - 1}px`,
        maxHeight: this.listmaxheight || ""
      };
    }
  }
};
const _hoisted_1$u = ["onClick"];
const _hoisted_2$l = {
  class: "aplayer-list-index"
};
const _hoisted_3$i = {
  class: "aplayer-list-title"
};
const _hoisted_4$d = {
  class: "aplayer-list-author"
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "slide-v",
    persisted: ""
  }, {
    default: withCtx(() => [withDirectives(createElementVNode(
      "div",
      {
        class: "aplayer-list",
        style: normalizeStyle($options.listHeightStyle),
        ref: "list"
      },
      [createElementVNode(
        "ol",
        {
          ref: "ol",
          style: normalizeStyle($options.listHeightStyle)
        },
        [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList($props.musicList, (aMusic, index2) => {
            return openBlock(), createElementBlock("li", {
              key: index2,
              class: normalizeClass({
                "aplayer-list-light": aMusic === $props.currentMusic
              }),
              onClick: ($event) => _ctx.$emit("selectsong", aMusic)
            }, [createElementVNode(
              "span",
              {
                class: "aplayer-list-cur",
                style: normalizeStyle({
                  background: $props.theme
                })
              },
              null,
              4
              /* STYLE */
            ), createElementVNode(
              "span",
              _hoisted_2$l,
              toDisplayString(index2 + 1),
              1
              /* TEXT */
            ), createElementVNode(
              "span",
              _hoisted_3$i,
              toDisplayString(aMusic.title || "Untitled"),
              1
              /* TEXT */
            ), createElementVNode(
              "span",
              _hoisted_4$d,
              toDisplayString(aMusic.artist || "Unknown"),
              1
              /* TEXT */
            )], 10, _hoisted_1$u);
          }),
          128
          /* KEYED_FRAGMENT */
        ))],
        4
        /* STYLE */
      )],
      4
      /* STYLE */
    ), [[vShow, $props.show]])]),
    _: 1
    /* STABLE */
  });
}
const MusicList = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$r], ["__file", "aplayer-list.vue"]]);
function parseLrc(lrc_s) {
  if (lrc_s) {
    lrc_s = lrc_s.replace(/([^\]^\n])\[/g, (match, p1) => p1 + "\n[");
    const lyric = lrc_s.split("\n");
    const lrc = [];
    const lyricLen = lyric.length;
    for (let i3 = 0; i3 < lyricLen; i3++) {
      const lrcTimes = lyric[i3].match(/\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g);
      const lrcText = lyric[i3].replace(/.*\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g, "").replace(/<(\d{2}):(\d{2})(\.(\d{2,3}))?>/g, "").replace(/^\s+|\s+$/g, "");
      if (lrcTimes) {
        const timeLen = lrcTimes.length;
        for (let j2 = 0; j2 < timeLen; j2++) {
          const oneTime = /\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/.exec(lrcTimes[j2]);
          const min2sec = oneTime[1] * 60;
          const sec2sec = parseInt(oneTime[2]);
          const msec2sec = oneTime[4] ? parseInt(oneTime[4]) / ((oneTime[4] + "").length === 2 ? 100 : 1e3) : 0;
          const lrcTime = min2sec + sec2sec + msec2sec;
          lrc.push([lrcTime, lrcText]);
        }
      }
    }
    lrc.sort((a2, b2) => a2[0] - b2[0]);
    return lrc;
  } else {
    return [];
  }
}
function warn(message) {
  return void 0;
}
function getElementViewLeft(element) {
  let actualLeft = element.offsetLeft;
  let current = element.offsetParent;
  let elementScrollLeft;
  while (current !== null) {
    actualLeft += current.offsetLeft;
    current = current.offsetParent;
  }
  elementScrollLeft = document.body.scrollLeft + document.documentElement.scrollLeft;
  return actualLeft - elementScrollLeft;
}
function getElementViewTop(element) {
  let actualTop = element.offsetTop;
  let current = element.offsetParent;
  let elementScrollTop;
  while (current !== null) {
    actualTop += current.offsetTop;
    current = current.offsetParent;
  }
  elementScrollTop = document.body.scrollTop + document.documentElement.scrollTop;
  return actualTop - elementScrollTop;
}
const aplayerControllerProgress_vue_vue_type_style_index_0_lang = "";
const _sfc_main$y = {
  components: {
    Icon
  },
  props: ["loadProgress", "playProgress", "theme"],
  data() {
    return {
      thumbHovered: false
    };
  },
  methods: {
    onThumbMouseDown(e2) {
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragbegin", percentage);
      document.addEventListener("mousemove", this.onDocumentMouseMove);
      document.addEventListener("mouseup", this.onDocumentMouseUp);
    },
    onDocumentMouseMove(e2) {
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragging", percentage);
    },
    onDocumentMouseUp(e2) {
      document.removeEventListener("mouseup", this.onDocumentMouseUp);
      document.removeEventListener("mousemove", this.onDocumentMouseMove);
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragend", percentage);
    },
    onThumbTouchStart(e2) {
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragbegin", percentage);
      document.addEventListener("touchmove", this.onDocumentTouchMove);
      document.addEventListener("touchend", this.onDocumentTouchEnd);
    },
    onDocumentTouchMove(e2) {
      const touch = e2.changedTouches[0];
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (touch.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragging", percentage);
    },
    onDocumentTouchEnd(e2) {
      document.removeEventListener("touchend", this.onDocumentTouchEnd);
      document.removeEventListener("touchmove", this.onDocumentTouchMove);
      const touch = e2.changedTouches[0];
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (touch.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragend", percentage);
    }
  }
};
const _hoisted_1$t = {
  class: "aplayer-bar"
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon = resolveComponent("icon");
  return openBlock(), createElementBlock(
    "div",
    {
      class: "aplayer-bar-wrap",
      onMousedown: _cache[2] || (_cache[2] = (...args) => $options.onThumbMouseDown && $options.onThumbMouseDown(...args)),
      onTouchstart: _cache[3] || (_cache[3] = (...args) => $options.onThumbTouchStart && $options.onThumbTouchStart(...args)),
      ref: "barWrap"
    },
    [createElementVNode("div", _hoisted_1$t, [createElementVNode(
      "div",
      {
        class: "aplayer-loaded",
        style: normalizeStyle({
          width: `${$props.loadProgress * 100}%`
        })
      },
      null,
      4
      /* STYLE */
    ), createElementVNode(
      "div",
      {
        class: "aplayer-played",
        style: normalizeStyle({
          width: `${$props.playProgress * 100}%`,
          background: $props.theme
        })
      },
      [createElementVNode(
        "span",
        {
          ref: "thumb",
          onMouseover: _cache[0] || (_cache[0] = ($event) => $data.thumbHovered = true),
          onMouseout: _cache[1] || (_cache[1] = ($event) => $data.thumbHovered = false),
          class: "aplayer-thumb",
          style: normalizeStyle({
            borderColor: $props.theme,
            backgroundColor: $data.thumbHovered ? $props.theme : "#fff"
          })
        },
        [createElementVNode(
          "span",
          {
            class: "aplayer-loading-icon",
            style: normalizeStyle({
              backgroundColor: $props.theme
            })
          },
          [createVNode(_component_icon, {
            type: "loading"
          })],
          4
          /* STYLE */
        )],
        36
        /* STYLE, HYDRATE_EVENTS */
      )],
      4
      /* STYLE */
    )])],
    544
    /* HYDRATE_EVENTS, NEED_PATCH */
  );
}
const VProgress = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$q], ["__file", "aplayer-controller-progress.vue"]]);
const aplayerControllerVolume_vue_vue_type_style_index_0_lang = "";
const barHeight = 40;
const _sfc_main$x = {
  components: {
    IconButton
  },
  props: ["volume", "muted", "theme"],
  computed: {
    volumeIcon() {
      if (this.muted || this.volume <= 0)
        return "volume-off";
      if (this.volume >= 1)
        return "volume-up";
      return "volume-down";
    }
  },
  methods: {
    adjustVolume(e2) {
      let percentage = (barHeight - e2.clientY + getElementViewTop(this.$refs.bar)) / barHeight;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("setvolume", percentage);
    },
    onBarMouseDown() {
      document.addEventListener("mousemove", this.onDocumentMouseMove);
      document.addEventListener("mouseup", this.onDocumentMouseUp);
    },
    onDocumentMouseMove(e2) {
      let percentage = (barHeight - e2.clientY + getElementViewTop(this.$refs.bar)) / barHeight;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("setvolume", percentage);
    },
    onDocumentMouseUp(e2) {
      document.removeEventListener("mouseup", this.onDocumentMouseUp);
      document.removeEventListener("mousemove", this.onDocumentMouseMove);
      let percentage = (barHeight - e2.clientY + getElementViewTop(this.$refs.bar)) / barHeight;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("setvolume", percentage);
    }
  }
};
const _hoisted_1$s = {
  class: "aplayer-volume-wrap"
};
const _hoisted_2$k = {
  class: "aplayer-volume-bar",
  ref: "bar"
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_button = resolveComponent("icon-button");
  return openBlock(), createElementBlock("div", _hoisted_1$s, [createVNode(_component_icon_button, {
    class: normalizeClass(`aplayer-icon-${$options.volumeIcon}`),
    icon: $options.volumeIcon,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("togglemute"))
  }, null, 8, ["class", "icon"]), createElementVNode(
    "div",
    {
      class: "aplayer-volume-bar-wrap",
      onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onBarMouseDown && $options.onBarMouseDown(...args))
    },
    [createElementVNode(
      "div",
      _hoisted_2$k,
      [createElementVNode(
        "div",
        {
          class: "aplayer-volume",
          style: normalizeStyle({
            height: $props.muted ? 0 : `${Math.trunc($props.volume * 100)}%`,
            background: $props.theme
          })
        },
        null,
        4
        /* STYLE */
      )],
      512
      /* NEED_PATCH */
    )],
    32
    /* HYDRATE_EVENTS */
  )]);
}
const Volume = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$p], ["__file", "aplayer-controller-volume.vue"]]);
const aplayerController_vue_vue_type_style_index_0_lang = "";
const _sfc_main$w = {
  components: {
    IconButton,
    VProgress,
    Volume
  },
  props: ["shuffle", "repeat", "stat", "theme", "volume", "muted"],
  computed: {
    loadProgress() {
      if (this.stat.duration === 0)
        return 0;
      return this.stat.loadedTime / this.stat.duration;
    },
    playProgress() {
      if (this.stat.duration === 0)
        return 0;
      return this.stat.playedTime / this.stat.duration;
    }
  },
  methods: {
    secondToTime(second) {
      if (isNaN(second)) {
        return "00:00";
      }
      const pad0 = (num) => {
        return num < 10 ? "0" + num : "" + num;
      };
      const min2 = Math.trunc(second / 60);
      const sec = Math.trunc(second - min2 * 60);
      const hours = Math.trunc(min2 / 60);
      const minAdjust = Math.trunc(second / 60 - 60 * Math.trunc(second / 60 / 60));
      return second >= 3600 ? pad0(hours) + ":" + pad0(minAdjust) + ":" + pad0(sec) : pad0(min2) + ":" + pad0(sec);
    }
  }
};
const _hoisted_1$r = {
  class: "aplayer-controller"
};
const _hoisted_2$j = {
  class: "aplayer-time"
};
const _hoisted_3$h = {
  class: "aplayer-time-inner"
};
const _hoisted_4$c = {
  class: "aplayer-ptime"
};
const _hoisted_5$9 = {
  class: "aplayer-dtime"
};
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_v_progress = resolveComponent("v-progress");
  const _component_volume = resolveComponent("volume");
  const _component_icon_button = resolveComponent("icon-button");
  return openBlock(), createElementBlock("div", _hoisted_1$r, [createVNode(_component_v_progress, {
    loadProgress: $options.loadProgress,
    playProgress: $options.playProgress,
    theme: $props.theme,
    onDragbegin: _cache[0] || (_cache[0] = (val) => _ctx.$emit("dragbegin", val)),
    onDragend: _cache[1] || (_cache[1] = (val) => _ctx.$emit("dragend", val)),
    onDragging: _cache[2] || (_cache[2] = (val) => _ctx.$emit("dragging", val))
  }, null, 8, ["loadProgress", "playProgress", "theme"]), createElementVNode("div", _hoisted_2$j, [createElementVNode("div", _hoisted_3$h, [createTextVNode(" - "), createElementVNode(
    "span",
    _hoisted_4$c,
    toDisplayString($options.secondToTime($props.stat.playedTime)),
    1
    /* TEXT */
  ), createTextVNode(" / "), createElementVNode(
    "span",
    _hoisted_5$9,
    toDisplayString($options.secondToTime($props.stat.duration)),
    1
    /* TEXT */
  )]), !_ctx.$parent.isMobile ? (openBlock(), createBlock(_component_volume, {
    key: 0,
    volume: $props.volume,
    theme: $props.theme,
    muted: $props.muted,
    onTogglemute: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("togglemute")),
    onSetvolume: _cache[4] || (_cache[4] = (v3) => _ctx.$emit("setvolume", v3))
  }, null, 8, ["volume", "theme", "muted"])) : createCommentVNode("v-if", true), createVNode(_component_icon_button, {
    class: normalizeClass(["aplayer-icon-mode", {
      "inactive": !$props.shuffle
    }]),
    icon: "shuffle",
    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("toggleshuffle"))
  }, null, 8, ["class"]), createVNode(_component_icon_button, {
    class: normalizeClass(["aplayer-icon-mode", {
      "inactive": $props.repeat === "no-repeat"
    }]),
    icon: $props.repeat === "repeat-one" ? "repeat-one" : "repeat-all",
    onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("nextmode"))
  }, null, 8, ["icon", "class"]), createVNode(_component_icon_button, {
    class: normalizeClass(["aplayer-icon-menu", {
      "inactive": !_ctx.$parent.showList
    }]),
    icon: "menu",
    onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("togglelist"))
  }, null, 8, ["class"])])]);
}
const Controls = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$o], ["__file", "aplayer-controller.vue"]]);
const aplayerLrc_vue_vue_type_style_index_0_lang = "";
const _sfc_main$v = {
  props: {
    currentMusic: {
      type: Object,
      required: true
    },
    playStat: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      displayLrc: "",
      currentLineIndex: 0
    };
  },
  computed: {
    lrcLines() {
      return parseLrc(this.displayLrc);
    },
    currentLine() {
      if (this.currentLineIndex > this.lrcLines.length - 1) {
        return null;
      }
      return this.lrcLines[this.currentLineIndex];
    },
    transformStyle() {
      return {
        transform: `translateY(${-this.currentLineIndex * 16}px)`,
        webkitTransform: `translateY(${-this.currentLineIndex * 16}px)`
      };
    }
  },
  methods: {
    applyLrc(lrc) {
      if (/^https?:\/\//.test(lrc)) {
        this.fetchLrc(lrc);
      } else {
        this.displayLrc = lrc;
      }
    },
    fetchLrc(src) {
      fetch(src).then((response) => response.text()).then((lrc) => {
        this.displayLrc = lrc;
      });
    },
    hideLrc() {
      this.displayLrc = "";
    }
  },
  watch: {
    currentMusic: {
      immediate: true,
      handler(music) {
        this.currentLineIndex = 0;
        if (music.lrc) {
          this.applyLrc(music.lrc);
        } else {
          this.hideLrc();
        }
      }
    },
    "playStat.playedTime"(playedTime) {
      for (let i3 = 0; i3 < this.lrcLines.length; i3++) {
        const line = this.lrcLines[i3];
        const nextLine = this.lrcLines[i3 + 1];
        if (playedTime >= line[0] && (!nextLine || playedTime < nextLine[0])) {
          this.currentLineIndex = i3;
        }
      }
    }
  }
};
const _hoisted_1$q = {
  class: "aplayer-lrc"
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$q, [createElementVNode(
    "div",
    {
      class: "aplayer-lrc-contents",
      style: normalizeStyle($options.transformStyle)
    },
    [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList($options.lrcLines, (line, index2) => {
        return openBlock(), createElementBlock(
          "p",
          {
            key: index2,
            class: normalizeClass({
              "aplayer-lrc-current": index2 === $data.currentLineIndex
            })
          },
          toDisplayString(line[1]),
          3
          /* TEXT, CLASS */
        );
      }),
      128
      /* KEYED_FRAGMENT */
    ))],
    4
    /* STYLE */
  )]);
}
const Lyrics = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$n], ["__file", "aplayer-lrc.vue"]]);
const vueAplayer_vue_vue_type_style_index_0_lang = "";
const picThemeCache = {};
let activeMutex = null;
const REPEAT = {
  NONE: "none",
  MUSIC: "music",
  LIST: "list",
  NO_REPEAT: "no-repeat",
  REPEAT_ONE: "repeat-one",
  REPEAT_ALL: "repeat-all"
};
const VueAPlayer = {
  name: "APlayer",
  disableVersionBadge: false,
  components: {
    Thumbnail,
    Controls,
    MusicList,
    Lyrics
  },
  props: {
    music: {
      type: Object,
      required: true,
      validator(song) {
        return !!song.src;
      }
    },
    mini: {
      type: Boolean,
      default: false
    },
    showLrc: {
      type: Boolean,
      default: false
    },
    mutex: {
      type: Boolean,
      default: true
    },
    theme: {
      type: String,
      default: "#41b883"
    },
    listMaxHeight: String,
    /**
     * @since 1.4.1
     * Fold playlist initially
     */
    listFolded: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.2.0 Float mode
     */
    float: {
      type: Boolean,
      default: false
    },
    // Audio attributes as props
    // since 1.4.0
    // autoplay controls muted preload volume
    // autoplay is not observable
    /**
     * @since 1.4.0
     * not observable
     */
    autoplay: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.4.0
     * whether to show native audio controls below Vue-APlayer
     * only work in development environment and not mini mode
     *
     * observable
     */
    controls: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.4.0
     * observable, sync
     */
    muted: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.4.0
     * observable
     */
    preload: String,
    /**
     * @since 1.4.0
     * observable, sync
     */
    volume: {
      type: Number,
      default: 0.8,
      validator(value) {
        return value >= 0 && value <= 1;
      }
    },
    // play order control
    // since 1.5.0
    /**
     * @since 1.5.0
     * @see https://support.apple.com/en-us/HT207230
     * twoWay
     */
    shuffle: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.5.0
     * @see https://support.apple.com/en-us/HT207230
     * twoWay
     */
    repeat: {
      type: String,
      default: REPEAT.NO_REPEAT
    }
  },
  data() {
    return {
      internalMusic: this.music,
      isPlaying: false,
      isSeeking: false,
      wasPlayingBeforeSeeking: false,
      isMobile: /mobile/i.test(window.navigator.userAgent),
      playStat: {
        duration: 0,
        loadedTime: 0,
        playedTime: 0
      },
      showList: !this.listFolded,
      list: [],
      // handle Promise returned from audio.play()
      // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play
      audioPlayPromise: Promise.resolve(),
      // @since 1.2.0 float mode
      floatOriginX: 0,
      floatOriginY: 0,
      floatOffsetLeft: 0,
      floatOffsetTop: 0,
      // @since 1.3.0 self adapting theme
      selfAdaptingTheme: null,
      // @since 1.4.0
      // sync muted, volume
      internalMuted: this.muted,
      internalVolume: this.volume,
      // @since 1.4.1
      // Loading indicator
      isLoading: false,
      // @since 1.5.1
      // sync shuffle, repeat
      internalShuffle: this.shuffle,
      internalRepeat: this.repeat,
      // for shuffling
      shuffledList: []
    };
  },
  computed: {
    // alias for $refs.audio
    audio() {
      return this.$refs.audio;
    },
    // sync music
    currentMusic: {
      get() {
        return this.internalMusic;
      },
      set(val) {
        this.$emit("update:music", val);
        this.internalMusic = val;
      }
    },
    // props wrappers
    currentTheme() {
      return this.selfAdaptingTheme || this.currentMusic.theme || this.theme;
    },
    isFloatMode() {
      return this.float && !this.isMobile;
    },
    shouldAutoplay() {
      if (this.isMobile)
        return false;
      return this.autoplay;
    },
    musicList() {
      return this.list;
    },
    shouldShowNativeControls() {
      return this.controls && !this.mini;
    },
    // useful
    floatStyleObj() {
      return {
        transform: `translate(${this.floatOffsetLeft}px, ${this.floatOffsetTop}px)`,
        webkitTransform: `translate(${this.floatOffsetLeft}px, ${this.floatOffsetTop}px)`
      };
    },
    currentPicStyleObj() {
      if (this.currentMusic && this.currentMusic.pic) {
        return {
          backgroundImage: `url(${this.currentMusic.pic})`
        };
      }
      return {};
    },
    loadProgress() {
      if (this.playStat.duration === 0)
        return 0;
      return this.playStat.loadedTime / this.playStat.duration;
    },
    playProgress() {
      if (this.playStat.duration === 0)
        return 0;
      return this.playStat.playedTime / this.playStat.duration;
    },
    playIndex: {
      get() {
        return this.shuffledList.indexOf(this.currentMusic);
      },
      set(val) {
        this.currentMusic = this.shuffledList[val % this.shuffledList.length];
      }
    },
    shouldRepeat() {
      return this.repeatMode !== REPEAT.NO_REPEAT;
    },
    // since 1.4.0
    // sync muted, volume
    isAudioMuted: {
      get() {
        return this.internalMuted;
      },
      set(val) {
        this.$emit("update:muted", val);
        this.internalMuted = val;
      }
    },
    audioVolume: {
      get() {
        return this.internalVolume;
      },
      set(val) {
        this.$emit("update:volume", val);
        this.internalVolume = val;
      }
    },
    // since 1.5.0
    // sync shuffle, repeat
    shouldShuffle: {
      get() {
        return this.internalShuffle;
      },
      set(val) {
        this.$emit("update:shuffle", val);
        this.internalShuffle = val;
      }
    },
    repeatMode: {
      get() {
        switch (this.internalRepeat) {
          case REPEAT.NONE:
          case REPEAT.NO_REPEAT:
            return REPEAT.NO_REPEAT;
          case REPEAT.MUSIC:
          case REPEAT.REPEAT_ONE:
            return REPEAT.REPEAT_ONE;
          default:
            return REPEAT.REPEAT_ALL;
        }
      },
      set(val) {
        this.$emit("update:repeat", val);
        this.internalRepeat = val;
      }
    }
  },
  methods: {
    // Float mode
    onDragBegin() {
      this.floatOriginX = this.floatOffsetLeft;
      this.floatOriginY = this.floatOffsetTop;
    },
    onDragAround({
      offsetLeft,
      offsetTop
    }) {
      this.floatOffsetLeft = this.floatOriginX + offsetLeft;
      this.floatOffsetTop = this.floatOriginY + offsetTop;
    },
    // functions
    setNextMode() {
      if (this.repeatMode === REPEAT.REPEAT_ALL) {
        this.repeatMode = REPEAT.REPEAT_ONE;
      } else if (this.repeatMode === REPEAT.REPEAT_ONE) {
        this.repeatMode = REPEAT.NO_REPEAT;
      } else {
        this.repeatMode = REPEAT.REPEAT_ALL;
      }
    },
    thenPlay() {
      this.$nextTick(() => {
        this.play();
      });
    },
    setAudioList(list) {
      this.list = list;
      this.shuffledList = this.getShuffledList();
    },
    // controls
    // play/pause
    toggle() {
      if (!this.audio.paused) {
        this.pause();
      } else {
        this.play();
      }
    },
    play() {
      if (this.mutex) {
        if (activeMutex && activeMutex !== this) {
          activeMutex.pause();
        }
        activeMutex = this;
      }
      const audioPlayPromise = this.audio.play();
      if (audioPlayPromise) {
        return this.audioPlayPromise = new Promise((resolve, reject) => {
          this.rejectPlayPromise = reject;
          audioPlayPromise.then((res) => {
            this.rejectPlayPromise = null;
            resolve(res);
          }).catch(warn);
        });
      }
    },
    pause() {
      this.audioPlayPromise.then(() => {
        this.audio.pause();
      }).catch(() => {
        this.audio.pause();
      });
      if (this.rejectPlayPromise) {
        this.rejectPlayPromise();
        this.rejectPlayPromise = null;
      }
    },
    // progress bar
    onProgressDragBegin(val) {
      this.wasPlayingBeforeSeeking = this.isPlaying;
      this.pause();
      this.isSeeking = true;
      if (!isNaN(this.audio.duration)) {
        this.audio.currentTime = this.audio.duration * val;
      }
    },
    onProgressDragging(val) {
      if (isNaN(this.audio.duration)) {
        this.playStat.playedTime = 0;
      } else {
        this.audio.currentTime = this.audio.duration * val;
      }
    },
    onProgressDragEnd(val) {
      this.isSeeking = false;
      if (this.wasPlayingBeforeSeeking) {
        this.thenPlay();
      }
    },
    // volume
    toggleMute() {
      this.setAudioMuted(!this.audio.muted);
    },
    setAudioMuted(val) {
      this.audio.muted = val;
    },
    setAudioVolume(val) {
      this.audio.volume = val;
      if (val > 0) {
        this.setAudioMuted(false);
      }
    },
    // playlist
    getShuffledList() {
      if (!this.list.length) {
        return [this.internalMusic];
      }
      let unshuffled = [...this.list];
      if (!this.internalShuffle || unshuffled.length <= 1) {
        return unshuffled;
      }
      let indexOfCurrentMusic = unshuffled.indexOf(this.internalMusic);
      if (unshuffled.length === 2 && indexOfCurrentMusic !== -1) {
        if (indexOfCurrentMusic === 0) {
          return unshuffled;
        } else {
          return [this.internalMusic, unshuffled[0]];
        }
      }
      for (let i3 = unshuffled.length - 1; i3 > 0; i3--) {
        const j2 = Math.floor(Math.random() * (i3 + 1));
        const tmp = unshuffled[i3];
        unshuffled[i3] = unshuffled[j2];
        unshuffled[j2] = tmp;
      }
      if (indexOfCurrentMusic !== -1) {
        indexOfCurrentMusic = unshuffled.indexOf(this.internalMusic);
        if (indexOfCurrentMusic !== 0) {
          [unshuffled[0], unshuffled[indexOfCurrentMusic]] = [unshuffled[indexOfCurrentMusic], unshuffled[0]];
        }
      }
      return unshuffled;
    },
    onSelectSong(song) {
      if (this.currentMusic === song) {
        this.toggle();
      } else {
        this.currentMusic = song;
        this.thenPlay();
      }
    },
    // event handlers
    // for keeping up with audio states
    onAudioPlay() {
      this.isPlaying = true;
    },
    onAudioPause() {
      this.isPlaying = false;
    },
    onAudioWaiting() {
      this.isLoading = true;
    },
    onAudioCanplay() {
      this.isLoading = false;
    },
    onAudioDurationChange() {
      if (this.audio.duration !== 1) {
        this.playStat.duration = this.audio.duration;
      }
    },
    onAudioProgress() {
      if (this.audio.buffered.length) {
        this.playStat.loadedTime = this.audio.buffered.end(this.audio.buffered.length - 1);
      } else {
        this.playStat.loadedTime = 0;
      }
    },
    onAudioTimeUpdate() {
      this.playStat.playedTime = this.audio.currentTime;
    },
    onAudioSeeking() {
      this.playStat.playedTime = this.audio.currentTime;
    },
    onAudioSeeked() {
      this.playStat.playedTime = this.audio.currentTime;
    },
    onAudioVolumeChange() {
      this.audioVolume = this.audio.volume;
      this.isAudioMuted = this.audio.muted;
    },
    onAudioEnded() {
      if (this.repeatMode === REPEAT.REPEAT_ALL) {
        if (this.shouldShuffle && this.playIndex === this.shuffledList.length - 1) {
          this.shuffledList = this.getShuffledList();
        }
        this.playIndex++;
        this.thenPlay();
      } else if (this.repeatMode === REPEAT.REPEAT_ONE) {
        this.thenPlay();
      } else {
        this.playIndex++;
        if (this.playIndex !== 0) {
          this.thenPlay();
        } else if (this.shuffledList.length === 1) {
          this.audio.currentTime = 0;
        }
      }
    },
    initAudio() {
      this.audio.controls = this.shouldShowNativeControls;
      this.audio.muted = this.muted;
      this.audio.preload = this.preload;
      this.audio.volume = this.volume;
      const mediaEvents = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "interruptbegin", "interruptend", "loadeddata", "loadedmetadata", "loadstart", "mozaudioavailable", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
      mediaEvents.forEach((event) => {
        this.audio.addEventListener(event, (e2) => this.$emit(event, e2));
      });
      this.audio.addEventListener("play", this.onAudioPlay);
      this.audio.addEventListener("pause", this.onAudioPause);
      this.audio.addEventListener("abort", this.onAudioPause);
      this.audio.addEventListener("waiting", this.onAudioWaiting);
      this.audio.addEventListener("canplay", this.onAudioCanplay);
      this.audio.addEventListener("progress", this.onAudioProgress);
      this.audio.addEventListener("durationchange", this.onAudioDurationChange);
      this.audio.addEventListener("seeking", this.onAudioSeeking);
      this.audio.addEventListener("seeked", this.onAudioSeeked);
      this.audio.addEventListener("timeupdate", this.onAudioTimeUpdate);
      this.audio.addEventListener("volumechange", this.onAudioVolumeChange);
      this.audio.addEventListener("ended", this.onAudioEnded);
      if (this.currentMusic) {
        this.audio.src = this.currentMusic.src;
      }
    },
    setSelfAdaptingTheme() {
      if ((this.currentMusic.theme || this.theme) === "pic") {
        const pic = this.currentMusic.pic;
        if (picThemeCache[pic]) {
          this.selfAdaptingTheme = picThemeCache[pic];
        } else {
          try {
            new ColorThief().getColorAsync(pic, ([r2, g2, b2]) => {
              picThemeCache[pic] = `rgb(${r2}, ${g2}, ${b2})`;
              this.selfAdaptingTheme = `rgb(${r2}, ${g2}, ${b2})`;
            });
          } catch (e2) {
            warn("color-thief is required to support self-adapting theme");
          }
        }
      } else {
        this.selfAdaptingTheme = null;
      }
    }
  },
  watch: {
    music(music) {
      this.internalMusic = music;
    },
    currentMusic: {
      handler(music) {
        this.setSelfAdaptingTheme();
        const src = music.src;
        if (/\.m3u8(?=(#|\?|$))/.test(src)) {
          if (this.audio.canPlayType("application/x-mpegURL") || this.audio.canPlayType("application/vnd.apple.mpegURL")) {
            this.audio.src = src;
          } else {
            try {
              const Hls = require("hls.js");
              if (Hls.isSupported()) {
                if (!this.hls) {
                  this.hls = new Hls();
                }
                this.hls.loadSource(src);
                this.hls.attachMedia(this.audio);
              } else {
                warn("HLS is not supported on your browser");
                this.audio.src = src;
              }
            } catch (e2) {
              warn("hls.js is required to support m3u8");
              this.audio.src = src;
            }
          }
        } else {
          this.audio.src = src;
        }
      }
    },
    // since 1.4.0
    // observe controls, muted, preload, volume
    shouldShowNativeControls(val) {
      this.audio.controls = val;
    },
    isAudioMuted(val) {
      this.audio.muted = val;
    },
    preload(val) {
      this.audio.preload = val;
    },
    audioVolume(val) {
      this.audio.volume = val;
    },
    // sync muted, volume
    muted(val) {
      this.internalMuted = val;
    },
    volume(val) {
      this.internalVolume = val;
    },
    // sync shuffle, repeat
    shuffle(val) {
      this.internalShuffle = val;
    },
    repeat(val) {
      this.internalRepeat = val;
    }
  },
  created() {
    this.shuffledList = this.getShuffledList();
  },
  mounted() {
    this.initAudio();
    this.setSelfAdaptingTheme();
    if (this.autoplay)
      this.play();
  },
  beforeUnmount() {
    if (activeMutex === this) {
      activeMutex = null;
    }
    if (this.hls) {
      this.hls.destroy();
    }
  }
};
const _sfc_main$u = VueAPlayer;
const _hoisted_1$p = {
  class: "aplayer-body"
};
const _hoisted_2$i = {
  class: "aplayer-info"
};
const _hoisted_3$g = {
  class: "aplayer-music"
};
const _hoisted_4$b = {
  class: "aplayer-title"
};
const _hoisted_5$8 = {
  class: "aplayer-author"
};
const _hoisted_6$7 = {
  ref: "audio"
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_thumbnail = resolveComponent("thumbnail");
  const _component_lyrics = resolveComponent("lyrics");
  const _component_controls = resolveComponent("controls");
  const _component_music_list = resolveComponent("music-list");
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["aplayer", {
        "aplayer-mini": _ctx.mini,
        "aplayer-withlist": !_ctx.mini && _ctx.musicList.length > 0,
        "aplayer-withlrc": !_ctx.mini && (!!_ctx.$slots.display || _ctx.showLrc),
        "aplayer-float": _ctx.isFloatMode,
        "aplayer-loading": _ctx.isPlaying && _ctx.isLoading
      }]),
      style: normalizeStyle(_ctx.floatStyleObj)
    },
    [createElementVNode("div", _hoisted_1$p, [createVNode(_component_thumbnail, {
      pic: _ctx.currentMusic.pic,
      playing: _ctx.isPlaying,
      "enable-drag": _ctx.isFloatMode,
      theme: _ctx.currentTheme,
      onToggleplay: _ctx.toggle,
      onDragbegin: _ctx.onDragBegin,
      onDragging: _ctx.onDragAround
    }, null, 8, ["pic", "playing", "enable-drag", "theme", "onToggleplay", "onDragbegin", "onDragging"]), withDirectives(createElementVNode(
      "div",
      _hoisted_2$i,
      [createElementVNode("div", _hoisted_3$g, [createElementVNode(
        "span",
        _hoisted_4$b,
        toDisplayString(_ctx.currentMusic.title || "Untitled"),
        1
        /* TEXT */
      ), createElementVNode(
        "span",
        _hoisted_5$8,
        toDisplayString(_ctx.currentMusic.artist || "Unknown"),
        1
        /* TEXT */
      )]), renderSlot(_ctx.$slots, "display", {
        currentMusic: _ctx.currentMusic,
        playStat: _ctx.playStat
      }, () => [_ctx.showLrc ? (openBlock(), createBlock(_component_lyrics, {
        key: 0,
        "current-music": _ctx.currentMusic,
        "play-stat": _ctx.playStat
      }, null, 8, ["current-music", "play-stat"])) : createCommentVNode("v-if", true)]), createVNode(_component_controls, {
        shuffle: _ctx.shouldShuffle,
        repeat: _ctx.repeatMode,
        stat: _ctx.playStat,
        volume: _ctx.audioVolume,
        muted: _ctx.isAudioMuted,
        theme: _ctx.currentTheme,
        onToggleshuffle: _cache[0] || (_cache[0] = ($event) => _ctx.shouldShuffle = !_ctx.shouldShuffle),
        onTogglelist: _cache[1] || (_cache[1] = ($event) => _ctx.showList = !_ctx.showList),
        onTogglemute: _ctx.toggleMute,
        onSetvolume: _ctx.setAudioVolume,
        onDragbegin: _ctx.onProgressDragBegin,
        onDragend: _ctx.onProgressDragEnd,
        onDragging: _ctx.onProgressDragging,
        onNextmode: _ctx.setNextMode
      }, null, 8, ["shuffle", "repeat", "stat", "volume", "muted", "theme", "onTogglemute", "onSetvolume", "onDragbegin", "onDragend", "onDragging", "onNextmode"])],
      512
      /* NEED_PATCH */
    ), [[vShow, !_ctx.mini]])]), createElementVNode(
      "audio",
      _hoisted_6$7,
      null,
      512
      /* NEED_PATCH */
    ), createVNode(_component_music_list, {
      show: _ctx.showList && !_ctx.mini,
      "current-music": _ctx.currentMusic,
      "music-list": _ctx.musicList,
      "play-index": _ctx.playIndex,
      listmaxheight: _ctx.listMaxHeight,
      theme: _ctx.currentTheme,
      onSelectsong: _ctx.onSelectSong
    }, null, 8, ["show", "current-music", "music-list", "play-index", "listmaxheight", "theme", "onSelectsong"])],
    6
    /* CLASS, STYLE */
  );
}
const APlayer = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$m], ["__file", "vue-aplayer.vue"]]);
const clientConfig17 = defineClientConfig({
  enhance: async ({
    app
  }) => {
    if (typeof window !== "undefined") {
      localStorage.setItem("aplayer-setting", "[]");
      app.component("APlayer", APlayer);
    }
    app.component("Meting", Meting);
    app.component("MetingGlobal", MetingGlobal);
  },
  rootComponents: void 0
});
const volume = {
  data() {
    return {
      volumeKey: "reco-bgm-volume"
    };
  },
  methods: {
    setVolume(val) {
      sessionStorage.setItem(this.volumeKey, val);
    },
    getVolume() {
      return sessionStorage.getItem(this.volumeKey);
    },
    removeVolume() {
      sessionStorage.removeItem(this.volumeKey);
    }
  }
};
const _sfc_main$t = {
  name: "ModuleTransition",
  props: {
    delay: {
      type: String,
      default: "0"
    },
    duration: {
      type: String,
      default: ".25"
    },
    position: {
      type: String,
      default: "left"
    }
  },
  methods: {
    setStyle(items) {
      items.style.transition = `${this.duration}s ease-in-out ${this.delay}s`;
      items.style.transitionProperty = "all";
      items.style.transform = this.position === "right" ? "translateX(20px)" : "translateX(-20px)";
      items.style.opacity = 0;
    },
    unsetStyle(items) {
      items.style.transform = null, items.style.transitionProperty = "opacity";
      items.style.opacity = 1;
    }
  }
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "ModuleTransition",
    onEnter: $options.setStyle,
    onAfterEnter: $options.unsetStyle,
    onBeforeLeave: $options.setStyle,
    onAfterLeave: _ctx.unsetTransform
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
    /* FORWARDED */
  }, 8, ["onEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]);
}
const ModuleTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$l], ["__file", "ModuleTransition.vue"]]);
const BgMusic_vue_vue_type_style_index_0_scoped_355e2f24_lang = "";
const mapFunc = (obj) => ({
  name: obj.name || obj.title || "未知歌曲",
  artist: obj.artist || obj.author || "未知歌手",
  url: obj.url || obj.src,
  cover: obj.pic,
  lrc: obj.lrc || obj.lyric || ""
});
function resolveAudios(requiredAudio) {
  let files2 = null;
  let covers = null;
  const syn = [], asyn = [];
  for (const e2 of requiredAudio) {
    if (!("type" in e2)) {
      syn.push(e2);
      continue;
    }
    switch (e2.type) {
      case "dir": {
        if (!files2)
          files2 = /* @__PURE__ */ Object.assign({
            "../../../public/music/「Fontaine」ost-13 - HOYO-MiX.mp3": __vite_glob_0_0$2,
            "../../../public/music/「Fontaine」ost-2 - HOYO-MiX.mp3": __vite_glob_0_1$2,
            "../../../public/music/「Fontaine」ost-20 - HOYO-MiX.mp3": __vite_glob_0_2$2,
            "../../../public/music/「Fontaine」ost-22 - HOYO-MiX.mp3": __vite_glob_0_3$2,
            "../../../public/music/「Fontaine」ost-23 - HOYO-MiX.mp3": __vite_glob_0_4$2,
            "../../../public/music/「Fontaine」ost-31 - HOYO-MiX.mp3": __vite_glob_0_5$2,
            "../../../public/music/「Fontaine」ost-55 - HOYO-MiX.mp3": __vite_glob_0_6$2,
            "../../../public/music/「Fontaine」ost-64 - HOYO-MiX.mp3": __vite_glob_0_7$2
          });
        if (!covers)
          covers = /* @__PURE__ */ Object.assign({});
        syn.push(...Object.keys(files2).map((m2) => {
          const reg = new RegExp(`.*public(${e2.url}(.+?)( - (.+))?\\.mp3)`);
          const match = m2.match(reg);
          const coverUrl = m2.replace(".mp3", ".png");
          return {
            name: match[2] ?? "未知歌曲",
            artist: match[4] ?? "未知歌手",
            url: match[1],
            cover: coverUrl in covers ? coverUrl : "/images/avatar.png"
          };
        }));
        break;
      }
      case "remote": {
        const params = {
          server: e2.from,
          type: "playlist",
          id: e2.mid,
          r: Math.random()
        };
        let url = e2.api, paramsArr = [];
        Object.keys(params).forEach((key) => paramsArr.push(key + "=" + params[key]));
        url += "?" + paramsArr.join("&");
        const headers = {
          referer: null
        };
        const prom = fetch(url, {
          headers
        }).then((res) => res.json()).then((result) => {
          const mapped = result.map(mapFunc);
          return mapped;
        });
        asyn.push(prom);
        break;
      }
    }
  }
  return {
    audios: syn,
    asyncAudios: asyn
  };
}
const _sfc_main$s = {
  mixins: [volume],
  components: {
    ModuleTransition
  },
  data() {
    return {
      /** @type {string} */
      defaultCover: "/images/avatar.png",
      /** @type {import("../index").PositionOptions} */
      panelPosition: {
        "right": "10px",
        "bottom": "10px",
        "z-index": "40"
      },
      curIndex: 0,
      curPlayStatus: "paused",
      /** @type {Audio[]} */
      audiolist: [{
        name: "音乐加载中..",
        artist: "",
        url: "",
        cover: ""
      }],
      /** @type {boolean} */
      autoplay: false,
      /** @type {boolean} */
      draggable: true,
      isFloat: false,
      isMini: false,
      firstLoad: true,
      isMute: false,
      isFault: false,
      /** @type {"left" | "right"} */
      floatPosition: "right",
      /** @type {import("vue").StyleValue} */
      floatStyle: {
        "bottom": "200px",
        "z-index": "40"
      },
      /** @type {boolean} */
      autoShrink: false,
      /** @type {"mini" | "float"} */
      shrinkMode: "float",
      initPos: true,
      dragging: false,
      align: {
        x: "left",
        y: "bottom"
      },
      // 记录播放器的对齐状态
      oMouse: null,
      orgX: 0,
      orgY: 0,
      posX: 0,
      posY: 0
    };
  },
  created() {
    const {
      audios,
      asyncAudios
    } = resolveAudios([{
      "type": "remote",
      "api": "https://api.i-meto.com/meting/api",
      "from": "netease",
      "mid": "8785212327"
    }]);
    let inited = false;
    if (audios && audios.length) {
      this.audiolist = audios;
      inited = true;
    }
    Promise.all(asyncAudios).then((res) => {
      if (!inited) {
        this.audiolist = [];
        inited = true;
      }
      this.audiolist.push(...res.flat());
    });
    const {
      right,
      top
    } = this.panelPosition;
    right && (this.align.x = "right");
    top && (this.align.y = "top");
  },
  computed: {
    rotate() {
      return this.curPlayStatus === "playing" ? "rotate" : "";
    },
    panelPos() {
      const {
        x: alignX,
        y: alignY
      } = this.align;
      return this.initPos ? this.panelPosition : {
        left: alignX === "left" ? `${this.posX}px` : null,
        right: alignX === "right" ? `${this.posX}px` : null,
        top: alignY === "top" ? `${this.posY}px` : null,
        bottom: alignY === "bottom" ? `${this.posY}px` : null,
        "z-index": this.panelPosition["z-index"]
      };
    }
  },
  mounted() {
    if (this.floatPosition === "left") {
      this.floatStyle = {
        ...this.floatStyle,
        "left": "0",
        "border-top-right-radius": "20px",
        "border-bottom-right-radius": "20px"
      };
    } else {
      this.floatStyle = {
        ...this.floatStyle,
        "right": "0",
        "border-top-left-radius": "20px",
        "border-bottom-left-radius": "20px"
      };
    }
    this.isMini = this.isMobile();
    if (this.autoShrink)
      this.toggleMode(true);
    let {
      left,
      right,
      top,
      bottom
    } = this.$refs.bgmBox.style;
    [left, right, top, bottom] = [left, right, top, bottom].map((e2) => e2 ? parseInt(e2.match(/\d+/)[0]) : 0);
    this.posX = this.align.x === "left" ? left : right;
    this.posY = this.align.y === "top" ? top : bottom;
    this.initPos = false;
  },
  methods: {
    /** @param { MouseEvent } oe */
    onDragBegin(oe2) {
      if (!this.draggable)
        return;
      [this.orgX, this.orgY] = [this.posX, this.posY];
      this.oMouse = oe2;
      document.addEventListener("mousemove", this.onDragAround);
      document.addEventListener("mouseup", this.onDragEnd);
    },
    /** @param { MouseEvent } e */
    onDragAround(e2) {
      const {
        innerWidth: winW,
        innerHeight: winH
      } = window;
      const {
        offsetWidth: objW,
        offsetHeight: objH
      } = this.$refs.bgmBox;
      const {
        min: min2,
        max: max2
      } = Math;
      this.dragging = true;
      let dx = e2.clientX - this.oMouse.clientX;
      let dy = e2.clientY - this.oMouse.clientY;
      this.align.x === "right" && (dx = -dx);
      this.align.y === "bottom" && (dy = -dy);
      this.posX = max2(0, min2(this.orgX + dx, winW - objW));
      this.posY = max2(0, min2(this.orgY + dy, winH - objH));
    },
    onDragEnd() {
      this.dragging = false;
      document.removeEventListener("mousemove", this.onDragAround);
      document.removeEventListener("mouseup", this.onDragEnd);
    },
    isMobile() {
      return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    },
    // 显示或隐藏歌曲信息
    toggleMode(bool) {
      const isMobile2 = this.isMobile();
      if (isMobile2 || this.shrinkMode === "float") {
        this.isFloat = bool;
      } else if (!isMobile2 && this.shrinkMode === "mini") {
        this.isMini = bool;
      }
    },
    // audio canplay回调事件
    playReady() {
      if (this.firstLoad) {
        if (this.getVolume()) {
          const percent = this.getVolume();
          this.$refs.vbar.style.width = percent * 100 + "%";
          this.$refs.bgm.volume = percent;
        } else {
          const vbar_width = this.$refs.bgm.volume * 100 + "%";
          this.$refs.vbar.style.width = vbar_width;
        }
        this.firstLoad = false;
        if (this.autoplay) {
          this.tryAutoPlay();
        }
      }
      if (this.curPlayStatus === "playing") {
        this.playBgm();
      }
    },
    tryAutoPlay() {
      let tryCount = 0;
      const playPromise = this.$refs.bgm.play();
      if (!playPromise)
        return;
      const tryPlay = async () => {
        try {
          await playPromise;
          this.curPlayStatus = "playing";
        } catch (e2) {
          const handleClick = () => {
            this.playBgm();
            window.removeEventListener("click", handleClick);
          };
          tryCount < 3 ? setTimeout(tryPlay, 1e3) : window.addEventListener("click", handleClick);
        }
      };
      tryPlay();
    },
    // 暂停
    pauseBgm() {
      this.$refs.bgm.pause();
      this.curPlayStatus = "paused";
    },
    // 播放
    playBgm() {
      const playPromise = this.$refs.bgm.play();
      if (playPromise !== void 0) {
        playPromise.then((res) => {
          if (this.isFault) {
            this.isFault = false;
          }
          this.curPlayStatus = "playing";
        }).catch((err2) => {
          this.isFault = true;
          this.pauseBgm();
        });
      }
    },
    // 播放下一首
    playNext() {
      this.$refs.pbar.style.width = 0;
      this.isFault = false;
      if (this.curIndex >= this.audiolist.length - 1) {
        this.curIndex = 0;
      } else {
        this.curIndex++;
      }
    },
    // 播放上一首
    playLast() {
      this.$refs.pbar.style.width = 0;
      this.isFault = false;
      if (this.curIndex <= 0) {
        this.curIndex = this.audiolist.length - 1;
      } else {
        this.curIndex--;
      }
    },
    // bgm结束时自动下一首
    bgmEnded() {
      this.$refs.pbar.style.width = 0;
      this.playNext();
    },
    // 更新歌曲进度条
    timeUpdate() {
      const total_time = this.$refs.bgm.duration;
      const cur_time = this.$refs.bgm.currentTime;
      const bar_width = cur_time / total_time * 100 + "%";
      this.$refs.pbar.style.width = bar_width;
    },
    // 点击进度条跳播
    progressJump(e2) {
      const total_time = this.$refs.bgm.duration;
      const percent = e2.offsetX / 150;
      if (isNaN(total_time))
        return;
      this.$refs.bgm.currentTime = percent * total_time;
    },
    // 点击音量条修改音量
    volumeJump(e2) {
      const percent = e2.offsetX / 57;
      if (percent >= 0 && percent <= 1) {
        this.isMute = !(percent > 0);
        this.$refs.vbar.style.width = percent * 100 + "%";
        this.$refs.bgm.volume = percent;
        this.setVolume(this.$refs.bgm.volume);
      }
    },
    // 静音
    muteBgm() {
      this.isMute = true;
      this.setVolume(this.$refs.bgm.volume);
      this.$refs.vbar.style.width = 0;
      this.$refs.bgm.volume = 0;
    },
    // 取消静音
    unMuteBgm() {
      this.isMute = false;
      if (this.getVolume()) {
        const percent = this.getVolume();
        this.$refs.vbar.style.width = percent * 100 + "%";
        this.$refs.bgm.volume = percent;
      } else {
        this.$refs.vbar.style.width = "100%";
        this.$refs.bgm.volume = 1;
      }
    }
  }
};
const _withScopeId$4 = (n2) => (pushScopeId("data-v-355e2f24"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$o = {
  class: "reco-bgm-panel"
};
const _hoisted_2$h = ["src"];
const _hoisted_3$f = ["src"];
const _hoisted_4$a = {
  key: 0,
  class: "mini-operation"
};
const _hoisted_5$7 = {
  key: 1,
  class: "falut-message"
};
const _hoisted_6$6 = {
  class: "reco-bgm-info"
};
const _hoisted_7$5 = {
  class: "info-box"
};
const _hoisted_8$4 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "reco-bgm reco-bgm-music music"
  },
  null,
  -1
  /* HOISTED */
));
const _hoisted_9$4 = {
  class: "info-box"
};
const _hoisted_10$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "reco-bgm reco-bgm-artist"
  },
  null,
  -1
  /* HOISTED */
));
const _hoisted_11$3 = {
  class: "reco-bgm-progress"
};
const _hoisted_12$1 = {
  class: "bar",
  ref: "pbar"
};
const _hoisted_13$1 = {
  class: "reco-bgm-operation"
};
const _hoisted_14 = {
  class: "bar",
  ref: "vbar"
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_module_transition = resolveComponent("module-transition");
  return openBlock(), createElementBlock("div", _hoisted_1$o, [createCommentVNode(" 播放器 "), createElementVNode("audio", {
    id: "bgm",
    src: $data.audiolist[$data.curIndex].url,
    ref: "bgm",
    onEnded: _cache[0] || (_cache[0] = (...args) => $options.bgmEnded && $options.bgmEnded(...args)),
    onCanplay: _cache[1] || (_cache[1] = (...args) => $options.playReady && $options.playReady(...args)),
    onTimeupdate: _cache[2] || (_cache[2] = (...args) => $options.timeUpdate && $options.timeUpdate(...args))
  }, null, 40, _hoisted_2$h), createVNode(_component_module_transition, {
    position: $data.floatPosition
  }, {
    default: withCtx(() => [withDirectives(createElementVNode(
      "div",
      {
        onClick: _cache[3] || (_cache[3] = ($event) => $options.toggleMode(false)),
        class: "reco-float-box",
        style: normalizeStyle($data.floatStyle)
      },
      [createElementVNode("img", {
        class: normalizeClass($options.rotate),
        src: $data.audiolist[$data.curIndex].cover ?? $data.defaultCover
      }, null, 10, _hoisted_3$f)],
      4
      /* STYLE */
    ), [[vShow, $data.isFloat]])]),
    _: 1
    /* STABLE */
  }, 8, ["position"]), createVNode(_component_module_transition, {
    position: $data.align.x
  }, {
    default: withCtx(() => [withDirectives(createElementVNode(
      "div",
      {
        ref: "bgmBox",
        class: "reco-bgm-box",
        style: normalizeStyle($options.panelPos),
        onMousedown: _cache[16] || (_cache[16] = (...args) => $options.onDragBegin && $options.onDragBegin(...args))
      },
      [createCommentVNode(" 封面 "), createElementVNode(
        "div",
        {
          class: normalizeClass(["reco-bgm-cover", $options.rotate]),
          onClick: _cache[6] || (_cache[6] = ($event) => $options.toggleMode(false)),
          style: normalizeStyle(`background-image:url(${$data.audiolist[$data.curIndex].cover ?? $data.defaultCover})`)
        },
        [createCommentVNode(" mini操作栏 "), $data.isMini ? (openBlock(), createElementBlock("div", _hoisted_4$a, [$data.curPlayStatus === "playing" ? (openBlock(), createElementBlock("i", {
          key: 0,
          onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $options.pauseBgm && $options.pauseBgm(...args), ["stop"])),
          class: "reco-bgm reco-bgm-pause clickable"
        })) : $data.curPlayStatus === "paused" ? (openBlock(), createElementBlock("i", {
          key: 1,
          onClick: _cache[5] || (_cache[5] = withModifiers((...args) => $options.playBgm && $options.playBgm(...args), ["stop"])),
          class: "reco-bgm reco-bgm-play clickable"
        })) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true), createCommentVNode(" 错误信息显示 "), $data.isFault ? (openBlock(), createElementBlock("div", _hoisted_5$7, " 播放失败 ")) : createCommentVNode("v-if", true)],
        6
        /* CLASS, STYLE */
      ), createCommentVNode(' <module-transition duration=".15"> '), createCommentVNode(" 歌曲信息栏 "), withDirectives(createElementVNode(
        "div",
        _hoisted_6$6,
        [createCommentVNode(" 歌曲名 "), createElementVNode("div", _hoisted_7$5, [_hoisted_8$4, createTextVNode(
          " " + toDisplayString($data.audiolist[$data.curIndex].name),
          1
          /* TEXT */
        )]), createCommentVNode(" 艺术家名 "), createElementVNode("div", _hoisted_9$4, [_hoisted_10$3, createTextVNode(
          " " + toDisplayString($data.audiolist[$data.curIndex].artist),
          1
          /* TEXT */
        )]), createCommentVNode(" 歌曲进度条 "), createElementVNode("div", _hoisted_11$3, [createElementVNode("div", {
          class: "progress-bar clickable bar",
          onClick: _cache[7] || (_cache[7] = (...args) => $options.progressJump && $options.progressJump(...args))
        }, [createElementVNode(
          "div",
          _hoisted_12$1,
          null,
          512
          /* NEED_PATCH */
        )])]), createCommentVNode(" 歌曲操作栏 "), createElementVNode("div", _hoisted_13$1, [createElementVNode("i", {
          class: "reco-bgm reco-bgm-last last clickable",
          onClick: _cache[8] || (_cache[8] = (...args) => $options.playLast && $options.playLast(...args))
        }), $data.curPlayStatus === "playing" ? (openBlock(), createElementBlock("i", {
          key: 0,
          onClick: _cache[9] || (_cache[9] = (...args) => $options.pauseBgm && $options.pauseBgm(...args)),
          class: "reco-bgm reco-bgm-pause pause clickable"
        })) : $data.curPlayStatus === "paused" ? (openBlock(), createElementBlock(
          "i",
          {
            key: 1,
            ref: "play",
            onClick: _cache[10] || (_cache[10] = (...args) => $options.playBgm && $options.playBgm(...args)),
            class: "reco-bgm reco-bgm-play play clickable"
          },
          null,
          512
          /* NEED_PATCH */
        )) : createCommentVNode("v-if", true), createElementVNode("i", {
          class: "reco-bgm reco-bgm-next next clickable",
          onClick: _cache[11] || (_cache[11] = (...args) => $options.playNext && $options.playNext(...args))
        }), $data.isMute ? (openBlock(), createElementBlock("i", {
          key: 2,
          onClick: _cache[12] || (_cache[12] = (...args) => $options.unMuteBgm && $options.unMuteBgm(...args)),
          class: "reco-bgm reco-bgm-mute mute clickable"
        })) : (openBlock(), createElementBlock("i", {
          key: 3,
          onClick: _cache[13] || (_cache[13] = (...args) => $options.muteBgm && $options.muteBgm(...args)),
          class: "reco-bgm reco-bgm-volume1 volume clickable"
        })), createElementVNode("div", {
          class: "volume-bar clickable bar",
          onClick: _cache[14] || (_cache[14] = (...args) => $options.volumeJump && $options.volumeJump(...args))
        }, [createElementVNode(
          "div",
          _hoisted_14,
          null,
          512
          /* NEED_PATCH */
        )])])],
        512
        /* NEED_PATCH */
      ), [[vShow, !$data.isMini]]), createCommentVNode(" </module-transition> "), createCommentVNode(" 收起按钮 "), createCommentVNode(' <module-transition duration=".15"> '), !$data.isMini ? (openBlock(), createElementBlock("div", {
        key: 0,
        onClick: _cache[15] || (_cache[15] = ($event) => $options.toggleMode(true)),
        class: "reco-bgm-left-box"
      }, [createElementVNode(
        "i",
        {
          class: normalizeClass(["reco-bgm", `reco-bgm-${$data.align.x}`])
        },
        null,
        2
        /* CLASS */
      )])) : createCommentVNode("v-if", true), createCommentVNode(" </module-transition> ")],
      36
      /* STYLE, HYDRATE_EVENTS */
    ), [[vShow, !$data.isFloat]])]),
    _: 1
    /* STABLE */
  }, 8, ["position"])]);
}
const BgMusic = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$k], ["__scopeId", "data-v-355e2f24"], ["__file", "BgMusic.vue"]]);
const clientConfig18 = defineClientConfig({
  enhance: async ({
    app
  }) => {
    app.component("BgMusic", BgMusic);
  },
  rootComponents: [BgMusic]
});
const _hoisted_1$n = {
  key: 0,
  class: "xicon-container"
};
const _hoisted_2$g = ["src"];
const _hoisted_3$e = {
  class: "info"
};
const _hoisted_4$9 = {
  key: 0,
  class: "location",
  n: ""
};
const _hoisted_5$6 = /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "fas fa-map-marker-alt"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_6$5 = {
  key: 1,
  class: "date"
};
const _hoisted_7$4 = /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "fas fa-clock"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_8$3 = {
  class: "description"
};
const _hoisted_9$3 = {
  key: 0,
  class: "album-info"
};
const _hoisted_10$2 = {
  class: "title"
};
const _hoisted_11$2 = {
  class: "descrption"
};
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "Container",
  props: {
    id: {
      required: true,
      type: String
    },
    src: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: "photo",
      validate: (val) => ["album", "photo"].includes(val)
    },
    title: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    date: {
      type: Date,
      default: null
    },
    location: {
      type: String,
      default: ""
    }
  },
  emits: ["click"],
  setup(__props, {
    emit
  }) {
    const mask = ref(false);
    const loading = ref(true);
    const error = ref(false);
    return (_ctx, _cache) => {
      const _component_xicons = resolveComponent("xicons");
      const _component_MagicCard = resolveComponent("MagicCard");
      return openBlock(), createBlock(_component_MagicCard, {
        class: normalizeClass(["photo-container", {
          photo: __props.type === "photo",
          album: __props.type === "album"
        }]),
        onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click", __props.id))
      }, {
        default: withCtx(() => [createElementVNode(
          "div",
          {
            class: normalizeClass(["photo-img", {
              empty: !__props.src || error.value,
              loading: loading.value
            }]),
            onMouseenter: _cache[3] || (_cache[3] = ($event) => mask.value = true)
          },
          [!__props.src || error.value ? (openBlock(), createElementBlock("div", _hoisted_1$n, [createVNode(_component_xicons, {
            icon: "NoImage"
          })])) : (openBlock(), createElementBlock("img", {
            key: 1,
            src: __props.src,
            onLoad: _cache[0] || (_cache[0] = ($event) => loading.value = false),
            onError: _cache[1] || (_cache[1] = ($event) => error.value = true)
          }, null, 40, _hoisted_2$g)), __props.type === "photo" && true ? (openBlock(), createElementBlock(
            "div",
            {
              key: 2,
              class: "photo-mask",
              onMouseleave: _cache[2] || (_cache[2] = ($event) => mask.value = false)
            },
            [createElementVNode("div", _hoisted_3$e, [createElementVNode(
              "h3",
              null,
              toDisplayString(__props.title),
              1
              /* TEXT */
            ), createElementVNode("div", null, [createElementVNode("p", null, [__props.location ? (openBlock(), createElementBlock("span", _hoisted_4$9, [_hoisted_5$6, createTextVNode(
              " " + toDisplayString(__props.location),
              1
              /* TEXT */
            )])) : createCommentVNode("v-if", true), __props.date ? (openBlock(), createElementBlock("span", _hoisted_6$5, [_hoisted_7$4, createTextVNode(
              toDisplayString(__props.date),
              1
              /* TEXT */
            )])) : createCommentVNode("v-if", true)]), createElementVNode(
              "p",
              _hoisted_8$3,
              toDisplayString(__props.description),
              1
              /* TEXT */
            )])])],
            32
            /* HYDRATE_EVENTS */
          )) : createCommentVNode("v-if", true)],
          34
          /* CLASS, HYDRATE_EVENTS */
        ), __props.type === "album" ? (openBlock(), createElementBlock("div", _hoisted_9$3, [createElementVNode(
          "div",
          _hoisted_10$2,
          toDisplayString(__props.title),
          1
          /* TEXT */
        ), createElementVNode(
          "div",
          _hoisted_11$2,
          toDisplayString(__props.description),
          1
          /* TEXT */
        )])) : createCommentVNode("v-if", true)]),
        _: 1
        /* STABLE */
      }, 8, ["class"]);
    };
  }
});
const Container_vue_vue_type_style_index_0_lang = "";
const Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "Container.vue"]]);
const __vite_glob_0_0 = "/assets/2019-3-0484df66.png";
const __vite_glob_0_1 = "/assets/2020-1-4f259201.png";
const __vite_glob_0_2 = "/assets/Bkg2-3510cccd.gif";
const __vite_glob_0_3 = "/assets/MY48-3-af6b9a12.png";
const __vite_glob_0_4 = "/assets/MY52-2-f114818d.png";
const __vite_glob_0_5 = "/assets/MY52-5-2a42a6ce.png";
const __vite_glob_0_6 = "/assets/MY57-a320017b.png";
const __vite_glob_0_7 = "/assets/psb (1)-311f9601.png";
const __vite_glob_0_8 = "/assets/psb (2)-f056bd30.png";
const __vite_glob_0_9 = "/assets/psb-f51096b0.png";
const __vite_glob_0_10 = "/assets/MY55-4-4d03b147.png";
const __vite_glob_0_11 = "/assets/MY55-40be5c3f.png";
const __vite_glob_0_12 = "/assets/MY56-3-e5ead1a6.png";
const __vite_glob_0_13 = "/assets/MY56-4-3ee9222d.png";
const __vite_glob_0_14 = "/assets/MY56-5-11809f65.png";
const __vite_glob_0_15 = "/assets/MY59-6-55e96185.png";
const _sfc_main$q = {
  name: "PhotoPage",
  props: {
    id: {
      type: String
    },
    albumId: {
      type: String,
      required: true
    },
    photoMap: {
      type: Object,
      required: true
    }
  },
  emits: {
    back: () => true
  },
  computed: {
    curId() {
      const {
        fileName
      } = this.$route.params;
      return fileName && [this.albumId, fileName].join(":") || this.id;
    },
    fileName() {
      return this.curId.split(":")[1];
    },
    src() {
      return this.photoMap[this.curId];
    }
  },
  created() {
  },
  setup() {
    const pageMap2 = usePageMap();
    return {
      pageMap: pageMap2
    };
  }
};
const _hoisted_1$m = {
  class: "photo-page-wrapper"
};
const _hoisted_2$f = ["src"];
const _hoisted_3$d = {
  key: 1
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  var _a3;
  const _component_Content = resolveComponent("Content");
  return openBlock(), createElementBlock("div", _hoisted_1$m, [createElementVNode("img", {
    width: "400",
    height: "300",
    src: $options.src
  }, null, 8, _hoisted_2$f), createCommentVNode(" 相片所对应的md文件的内容 "), ((_a3 = $setup.pageMap[$options.curId]) == null ? void 0 : _a3.key) ? (openBlock(), createBlock(_component_Content, {
    key: 0,
    "page-key": $setup.pageMap[$options.curId].key
  }, null, 8, ["page-key"])) : (openBlock(), createElementBlock("div", _hoisted_3$d, "该相片暂无正文"))]);
}
const PhotoPage = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$j], ["__file", "PhotoPage.vue"]]);
const localPhotos = /* @__PURE__ */ Object.assign({
  "../../public/images/albums/test_album_1/2019-3.png": __vite_glob_0_0,
  "../../public/images/albums/test_album_1/2020-1.png": __vite_glob_0_1,
  "../../public/images/albums/test_album_1/Bkg2.gif": __vite_glob_0_2,
  "../../public/images/albums/test_album_1/MY48-3.png": __vite_glob_0_3,
  "../../public/images/albums/test_album_1/MY52-2.png": __vite_glob_0_4,
  "../../public/images/albums/test_album_1/MY52-5.png": __vite_glob_0_5,
  "../../public/images/albums/test_album_1/MY57.png": __vite_glob_0_6,
  "../../public/images/albums/test_album_1/psb (1).png": __vite_glob_0_7,
  "../../public/images/albums/test_album_1/psb (2).png": __vite_glob_0_8,
  "../../public/images/albums/test_album_1/psb.png": __vite_glob_0_9,
  "../../public/images/albums/test_album_2/MY55-4.png": __vite_glob_0_10,
  "../../public/images/albums/test_album_2/MY55.png": __vite_glob_0_11,
  "../../public/images/albums/test_album_2/MY56-3.png": __vite_glob_0_12,
  "../../public/images/albums/test_album_2/MY56-4.png": __vite_glob_0_13,
  "../../public/images/albums/test_album_2/MY56-5.png": __vite_glob_0_14,
  "../../public/images/albums/test_album_2/MY59-6.png": __vite_glob_0_15
});
Object.values(localPhotos);
const localPhotoMap = {};
for (const relPath in localPhotos) {
  const match = ((_a2 = relPath.match(/^.*images(.*)/)) == null ? void 0 : _a2[1]) ?? null;
  if (!match)
    continue;
  localPhotoMap[match] = localPhotos[relPath];
}
const usePhotoMap = () => localPhotoMap;
const useAlbumPhotosMap = (id) => {
  var _a3;
  const map = {};
  for (const relPath in localPhotos) {
    const match = ((_a3 = relPath.match(new RegExp(`^.*images/albums/${id}/(.*)`))) == null ? void 0 : _a3[1]) ?? null;
    if (!match)
      continue;
    const photoId = [id, match].join(":");
    map[photoId] = localPhotos[relPath];
  }
  return map;
};
const siteData = useSiteData();
const albums = computed(() => {
  const pageMap2 = siteData.value.pageIdMap;
  const entries2 = Object.entries(pageMap2).filter(([id, pageData]) => id !== "albums" && !id.includes(":") && pageData.path.startsWith("/albums/"));
  return Object.fromEntries(entries2);
});
const useAlbums = () => albums;
const addPhotoRoutes = (router) => {
  const routes = router.getRoutes();
  const prohibited = [];
  for (const id in albums.value) {
    const pageData = albums.value[id];
    if (pageData.path == "/albums/")
      continue;
    const route = routes.find((e2) => e2.name === albums.value[id].key);
    if (!route || !route.name)
      continue;
    if (pageData.path === `/albums/${id}/`) {
      const photoPage = () => h$5(PhotoPage, {
        albumId: id,
        photoMap: useAlbumPhotosMap(id)
      });
      photoPage.displayName = "PhotoPage";
      router.removeRoute(route.name);
      route.children.push({
        path: ":fileName",
        component: photoPage
      });
      router.addRoute(route);
      router.replace(router.currentRoute.value.fullPath);
      const childRoutes = routes.filter((r2) => r2.path !== route.path && r2.path.startsWith(route.path));
      for (const childRoute of childRoutes) {
        const {
          path
        } = childRoute;
        const allowed = ["README.md", "index.html"];
        if (allowed.some((e2) => path.endsWith(e2)))
          continue;
        prohibited.push(path);
      }
    }
  }
  router.beforeEach((to, from, next) => {
    if (prohibited.includes(to.fullPath)) {
      next({
        path: "/404"
      });
    } else
      next();
  });
};
const _sfc_main$p = {
  components: {
    Container
  },
  setup() {
    const pageMap2 = usePageMap();
    const albums2 = useAlbums();
    const photoMap = usePhotoMap();
    return {
      pageMap: pageMap2,
      albums: albums2,
      photoMap
    };
  },
  methods: {
    getAbsUrl(album) {
      var _a3;
      const cover = (_a3 = album.frontmatter) == null ? void 0 : _a3.cover;
      if (!cover)
        return "";
      const relPath = `/albums/${album.id}/${cover}`;
      return this.photoMap[relPath] ?? "";
    },
    onClick(id) {
      this.$router.push(this.pageMap[id].path);
    }
  }
};
const AlbumList_vue_vue_type_style_index_0_scoped_8efd530d_lang = "";
const _hoisted_1$l = {
  class: "album-list"
};
const _hoisted_2$e = {
  class: "album-box"
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Container = resolveComponent("Container");
  return openBlock(), createElementBlock("section", _hoisted_1$l, [(openBlock(true), createElementBlock(
    Fragment,
    null,
    renderList(Object.entries($setup.albums), ([id, album]) => {
      return openBlock(), createElementBlock("div", _hoisted_2$e, [createVNode(_component_Container, mergeProps(
        {
          id,
          src: $options.getAbsUrl(album),
          type: "album"
        },
        /** @ts-ignore */
        album.frontmatter,
        {
          onClick: $options.onClick
        }
      ), null, 16, ["id", "src", "onClick"])]);
    }),
    256
    /* UNKEYED_FRAGMENT */
  ))]);
}
const AlbumList = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$i], ["__scopeId", "data-v-8efd530d"], ["__file", "AlbumList.vue"]]);
const _sfc_main$o = {
  components: {
    Container,
    PhotoPage
  },
  props: {
    albumId: {
      type: String,
      required: true
    }
  },
  data() {
    const photoMap = useAlbumPhotosMap(this.albumId);
    const entries2 = Object.entries(photoMap);
    const photos = entries2.length ? new Array(20).fill(null).map((n2, i3) => {
      const rIdx = randInt({
        min: 0,
        max: entries2.length
      });
      return {
        id: entries2[rIdx][0],
        src: entries2[rIdx][1],
        title: "测试图画标题#" + i3,
        description: "描述：" + entries2[rIdx][0],
        date: /* @__PURE__ */ new Date()
      };
    }) : [];
    return {
      curPhotoId: "",
      photoMap,
      photos,
      pageMap: usePageMap()
    };
  },
  computed: {
    pageKey() {
      return this.pageMap[this.albumId].key;
    },
    pagePath() {
      return this.pageMap[this.albumId].path;
    }
  },
  methods: {
    showPhotoPage(photoId) {
      this.curPhotoId = photoId;
    }
  }
};
const PhotoList_vue_vue_type_style_index_0_scoped_a15becb0_lang = "";
const _withScopeId$3 = (n2) => (pushScopeId("data-v-a15becb0"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$k = {
  class: "photo-list-wrapper"
};
const _hoisted_2$d = {
  key: 0,
  class: "photo-page"
};
const _hoisted_3$c = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode(
  "button",
  null,
  "返回相册",
  -1
  /* HOISTED */
));
const _hoisted_4$8 = [_hoisted_3$c];
const _hoisted_5$5 = {
  key: 1,
  class: "photo-list"
};
const _hoisted_6$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode(
  "button",
  null,
  "返回首页",
  -1
  /* HOISTED */
));
const _hoisted_7$3 = [_hoisted_6$4];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PhotoPage = resolveComponent("PhotoPage");
  const _component_Container = resolveComponent("Container");
  return openBlock(), createElementBlock("div", _hoisted_1$k, [$data.curPhotoId ? (openBlock(), createElementBlock("section", _hoisted_2$d, [createElementVNode("div", {
    class: "back-link transparent-btn",
    onClick: _cache[0] || (_cache[0] = ($event) => $data.curPhotoId = "")
  }, _hoisted_4$8), createVNode(_component_PhotoPage, {
    id: $data.curPhotoId,
    "album-id": $props.albumId,
    "photo-map": $data.photoMap,
    onBack: _cache[1] || (_cache[1] = ($event) => $data.curPhotoId = "")
  }, null, 8, ["id", "album-id", "photo-map"])])) : (openBlock(), createElementBlock("section", _hoisted_5$5, [createElementVNode("div", {
    class: "back-link transparent-btn",
    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$router.push("/albums"))
  }, _hoisted_7$3), (openBlock(true), createElementBlock(
    Fragment,
    null,
    renderList($data.photos, (p2, i3) => {
      return openBlock(), createBlock(_component_Container, mergeProps({
        key: i3,
        type: "photo"
      }, p2, {
        onClick: $options.showPhotoPage
      }), null, 16, ["onClick"]);
    }),
    128
    /* KEYED_FRAGMENT */
  ))]))]);
}
const PhotoList = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$h], ["__scopeId", "data-v-a15becb0"], ["__file", "PhotoList.vue"]]);
const _hoisted_1$j = /* @__PURE__ */ createElementVNode(
  "div",
  {
    style: {
      "text-align": "center"
    }
  },
  "---【页面开发中】这里是相册---",
  -1
  /* HOISTED */
);
const _hoisted_2$c = /* @__PURE__ */ createElementVNode(
  "hr",
  null,
  null,
  -1
  /* HOISTED */
);
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const pageData = usePageData$1();
    const albumId = computed(() => pageData.value.frontmatter.id);
    const scrollPromise2 = useScrollPromise();
    const onBeforeEnter = scrollPromise2.resolve;
    const onBeforeLeave = scrollPromise2.pending;
    const {
      initMagicCard
    } = useMagicCard();
    onMounted(() => {
      initMagicCard();
      initImgCache();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
      initImgCache();
    });
    return (_ctx, _cache) => {
      const _component_Content = resolveComponent("Content");
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [createVNode(Transition, {
          name: "fade-slide-y",
          mode: "out-in",
          onBeforeEnter: unref(onBeforeEnter),
          onBeforeLeave: unref(onBeforeLeave)
        }, {
          default: withCtx(() => [(openBlock(), createElementBlock("main", {
            key: unref(pageData).path,
            class: "album-main"
          }, [_hoisted_1$j, createCommentVNode(" 相册的md正文 "), createCommentVNode(" 每一个相册在/docs/album目录下都必须建一个id同名的目录，并在其中添加README.md作为正文 "), createCommentVNode(" 可以在同目录内添加某一张该相片 "), createVNode(_component_Content), _hoisted_2$c, unref(pageData).path === "/albums/" ? (openBlock(), createBlock(AlbumList, {
            key: 0
          })) : albumId.value ? (openBlock(), createBlock(PhotoList, {
            key: 1,
            "album-id": albumId.value
          }, null, 8, ["album-id"])) : createCommentVNode("v-if", true)]))]),
          _: 1
          /* STABLE */
        }, 8, ["onBeforeEnter", "onBeforeLeave"])]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const Layout_vue_vue_type_style_index_0_lang = "";
const Layout$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "Layout.vue"]]);
const _sfc_main$m = defineComponent({
  name: "WalineViews",
  props: {
    articleId: {
      type: String,
      default: null
    },
    path: String
  },
  setup() {
    const route = useRoute();
    const articleInfo = inject(ARTICLE_INFO_KEY);
    const userInfo2 = useUserInfo();
    const isAdmin = computed(() => userInfo2.value.type === "administrator");
    const pageView = computed(() => (articleInfo == null ? void 0 : articleInfo.value.pageView.toString()) ?? "0");
    return {
      route,
      pageView,
      isAdmin
    };
  },
  watch: {
    pageView() {
      this.viewFn();
    }
  },
  methods: {
    viewFn(update = false) {
      this.pageviewCount(`[data-path="${this.path}"]`, update);
    },
    pageviewCount(selector, update) {
      const id = (this.articleId || this.path) ?? "";
      const controller = new AbortController();
      const elements = Array.from(
        // pageview selectors
        document.querySelectorAll(selector)
      );
      elements.forEach((el) => el.innerText = this.pageView);
      if (update) {
        this.$api.addPageView(id).then(() => {
          elements.forEach((el) => el.innerText = ((Number(el.innerText) || 0) + 1).toString());
        });
      }
      return controller.abort.bind(controller);
    }
  },
  mounted() {
    this.viewFn(!this.isAdmin && this.route.path === this.path);
  },
  updated() {
    this.viewFn();
  }
});
const _hoisted_1$i = ["data-path"];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: "waline-pageview-count",
    "data-path": _ctx.path
  }, null, 8, _hoisted_1$i);
}
const WalineViews = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$g], ["__file", "WalineViews.vue"]]);
const i$3 = () => {
  const e2 = usePageData$1();
  return computed(() => e2.value.readingTime ?? null);
}, n$4 = typeof { "/": { "word": "约 $word 字", "less1Minute": "小于 1 分钟", "time": "大约 $time 分钟" } } > "u" ? null : { "/": { "word": "约 $word 字", "less1Minute": "小于 1 分钟", "time": "大约 $time 分钟" } }, a$3 = (e2, o2) => {
  const {
    minutes: r2,
    words: l2
  } = e2, {
    less1Minute: m2,
    word: c2,
    time: d2
  } = o2;
  return {
    time: r2 < 1 ? m2 : d2.replace("$time", Math.round(r2).toString()),
    words: c2.replace("$word", l2.toString())
  };
}, u$5 = {
  words: "",
  time: ""
}, s$2 = () => n$4 ? Ze$1(n$4) : computed(() => null), L$4 = () => {
  if (typeof n$4 > "u")
    return computed(() => u$5);
  const e2 = i$3(), o2 = s$2();
  return computed(() => e2.value && o2.value ? a$3(e2.value, o2.value) : u$5);
};
const _sfc_main$l = defineComponent({
  name: "PageInfo",
  components: {
    WalineViews
  },
  props: {
    pageData: {
      type: Object,
      default: () => ({})
    },
    currentCategory: {
      type: String,
      default: ""
    },
    currentTag: {
      type: String,
      default: ""
    },
    hideViews: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      readingTimeData: i$3(),
      readingTimeLocale: L$4()
    };
  },
  setup(props) {
    const {
      pageData,
      hideViews
    } = toRefs(props);
    const themeData2 = useThemeLocaleData$1();
    const author2 = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.author) || themeData2.value.author || "";
    });
    const date = computed(() => {
      var _a3, _b2;
      const d2 = (_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.date;
      return d2 ? formatISODate(d2) : "";
    });
    const categories = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.categories) || [];
    });
    const articleId = computed(() => {
      var _a3, _b2, _c;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.id) || ((_c = pageData == null ? void 0 : pageData.value) == null ? void 0 : _c.path);
    });
    const tags = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.tags) || [];
    });
    const showPageInfo = computed(() => !!author2.value || !!date.value || !!(categories.value && categories.value.length > 0) || !!(tags.value && tags.value.length > 0));
    const showWalineViews = computed(() => !hideViews.value);
    return {
      author: author2,
      date,
      categories,
      tags,
      showPageInfo,
      showWalineViews,
      convertToPinyin,
      articleId
    };
  }
});
const _hoisted_1$h = {
  key: 0,
  class: "page-info"
};
const _hoisted_2$b = {
  class: "xicon-icon",
  style: {
    "width": "18px",
    "height": "18px",
    "font-size": "18px",
    "color": "inherit"
  },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 12 12"
};
const _hoisted_3$b = /* @__PURE__ */ createElementVNode(
  "g",
  {
    fill: "none"
  },
  [/* @__PURE__ */ createElementVNode("path", {
    d: "M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z",
    fill: "currentColor"
  })],
  -1
  /* HOISTED */
);
const _hoisted_4$7 = [_hoisted_3$b];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  const _component_WalineViews = resolveComponent("WalineViews");
  return _ctx.showPageInfo ? (openBlock(), createElementBlock("div", _hoisted_1$h, [!!_ctx.author ? (openBlock(), createBlock(_component_Xicons, {
    key: 0,
    icon: "User",
    text: _ctx.author
  }, null, 8, ["text"])) : createCommentVNode("v-if", true), !!_ctx.date ? (openBlock(), createBlock(_component_Xicons, {
    key: 1,
    icon: "Calendar",
    text: _ctx.date
  }, null, 8, ["text"])) : createCommentVNode("v-if", true), !!_ctx.categories && _ctx.categories.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
    key: 2,
    icon: "Folder"
  }, {
    default: withCtx(() => [createTextVNode(
      toDisplayString(_ctx.categories.join(" ")),
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), !!_ctx.tags && _ctx.tags.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
    key: 3,
    icon: "Tag"
  }, {
    default: withCtx(() => [createTextVNode(
      toDisplayString(_ctx.tags.join(" ")),
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), _ctx.showWalineViews ? (openBlock(), createBlock(_component_Xicons, {
    key: 4
  }, {
    icon: withCtx(() => [(openBlock(), createElementBlock("svg", _hoisted_2$b, _hoisted_4$7))]),
    default: withCtx(() => [_ctx.showWalineViews ? (openBlock(), createBlock(_component_WalineViews, {
      key: 0,
      path: _ctx.pageData.path,
      "article-id": _ctx.articleId
    }, null, 8, ["path", "article-id"])) : createCommentVNode("v-if", true)]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), createElementVNode("div", null, [!!_ctx.readingTimeData ? (openBlock(), createBlock(_component_Xicons, {
    key: 0,
    icon: "Data2"
  }, {
    default: withCtx(() => [createTextVNode(
      toDisplayString(_ctx.readingTimeData.words) + " 字 ",
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), !!_ctx.readingTimeData ? (openBlock(), createBlock(_component_Xicons, {
    key: 1,
    icon: "Time"
  }, {
    default: withCtx(() => [createTextVNode(
      " 预计阅读 " + toDisplayString(Math.round(_ctx.readingTimeData.minutes * 10) / 10) + " 分钟 ",
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true)])])) : createCommentVNode("v-if", true);
}
const PageInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$f], ["__file", "PageInfo.vue"]]);
const useEditNavLink = () => {
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    const showEditLink = frontmatter.value.editLink ?? themeLocal.value.editLink ?? true;
    if (!showEditLink) {
      return null;
    }
    const {
      repo,
      docsRepo = repo,
      docsBranch = "main",
      docsDir = "",
      editLinkText
    } = themeLocal.value;
    if (!docsRepo)
      return null;
    const editLink = resolveEditLink({
      docsRepo,
      docsBranch,
      docsDir,
      filePathRelative: page.value.filePathRelative,
      editLinkPattern: themeLocal.value.editLinkPattern
    });
    if (!editLink)
      return null;
    return {
      text: editLinkText ?? "Edit this page",
      link: editLink,
      icon: "Edit",
      hideExternalLinkIcon: true
    };
  });
};
const useLastUpdated = () => {
  useSiteLocaleData();
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    var _a3, _b2;
    const showLastUpdated = frontmatter.value.lastUpdated ?? themeLocal.value.lastUpdated ?? true;
    if (!showLastUpdated)
      return null;
    if (!((_a3 = page.value.git) == null ? void 0 : _a3.updatedTime))
      return null;
    const updatedDate = new Date((_b2 = page.value.git) == null ? void 0 : _b2.updatedTime);
    return updatedDate.toLocaleString();
  });
};
const _sfc_main$k = defineComponent({
  name: "PageMeta",
  components: {
    Link
  },
  setup() {
    const themeLocal = useThemeLocaleData$1();
    const editNavLink = useEditNavLink();
    const lastUpdated = useLastUpdated();
    return {
      themeLocal,
      editNavLink,
      lastUpdated
    };
  }
});
const _hoisted_1$g = {
  class: "page-meta"
};
const _hoisted_2$a = {
  key: 0,
  class: "meta-item edit-link"
};
const _hoisted_3$a = {
  key: 1,
  class: "meta-item last-updated"
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  return openBlock(), createElementBlock("footer", _hoisted_1$g, [_ctx.editNavLink ? (openBlock(), createElementBlock("div", _hoisted_2$a, [createVNode(_component_Xicons, {
    class: "meta-item-label",
    icon: _ctx.editNavLink.icon,
    text: _ctx.editNavLink.text,
    link: _ctx.editNavLink.link,
    target: "_blank",
    "icon-size": "20",
    "text-size": "14"
  }, null, 8, ["icon", "text", "link"])])) : createCommentVNode("v-if", true), _ctx.lastUpdated ? (openBlock(), createElementBlock("div", _hoisted_3$a, [createVNode(_component_Xicons, {
    class: "meta-item-label",
    icon: "Calendar",
    text: `最后于 ${_ctx.lastUpdated} 更新`,
    "icon-size": "20",
    "text-size": "14"
  }, null, 8, ["text"])])) : createCommentVNode("v-if", true)]);
}
const PageMeta = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$e], ["__file", "PageMeta.vue"]]);
const _hoisted_1$f = {
  class: "page-container"
};
const _hoisted_2$9 = {
  key: 0,
  class: "page-title"
};
const _hoisted_3$9 = {
  key: 1,
  class: "theme-reco-default-content"
};
const _hoisted_4$6 = {
  key: 2,
  class: "theme-reco-default-content"
};
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    var _a4, _b2;
    const lang = usePageLang();
    const pageData = usePageData$1();
    const {
      pageLoaded,
      pagePasswordPass,
      setedPagePassword,
      handlePass
    } = usePassword();
    const title = computed(() => {
      var _a5, _b3, _c;
      return ((_b3 = (_a5 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a5.frontmatter) == null ? void 0 : _b3.title) || ((_c = pageData == null ? void 0 : pageData.value) == null ? void 0 : _c.title) || "";
    });
    let _a3;
    const options = ref({
      id: (_b2 = (_a4 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a4.frontmatter) == null ? void 0 : _b2.id,
      path: withBase((_a3 = pageData.value) === null || _a3 === void 0 ? void 0 : _a3.path),
      login: "force"
    });
    const walineOption = computed(() => {
      return {
        lang: lang.value || "zh-CN",
        dark: 'html[class="dark"]',
        ...options.value,
        pageview: false
      };
    });
    const shouldHideComments = computed(() => {
      var _a5;
      const {
        hideComments: hideCommentsInSinglePage
      } = (_a5 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a5.frontmatter;
      const {
        hideComments: hideCommentsInAllPage
      } = options.value;
      return hideCommentsInSinglePage === true || hideCommentsInSinglePage !== false && hideCommentsInAllPage === true;
    });
    const RecoWalineWrapper = () => {
      if (shouldHideComments.value)
        return null;
      return h$5("div", {
        class: "reco-waline-wrapper"
      }, h$5(Waline$1, walineOption.value));
    };
    return (_ctx, _cache) => {
      const _component_Content = resolveComponent("Content");
      return openBlock(), createElementBlock("main", _hoisted_1$f, [!!title.value ? (openBlock(), createElementBlock(
        "h1",
        _hoisted_2$9,
        toDisplayString(title.value),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true), createVNode(PageInfo, {
        "page-data": unref(pageData)
      }, null, 8, ["page-data"]), !unref(setedPagePassword) ? (openBlock(), createElementBlock("div", _hoisted_3$9, [createVNode(_component_Content)])) : (openBlock(), createElementBlock("div", _hoisted_4$6, [unref(pageLoaded) && !unref(pagePasswordPass) ? (openBlock(), createBlock(Password, {
        key: 0,
        onPass: unref(handlePass)
      }, null, 8, ["onPass"])) : createCommentVNode("v-if", true), unref(pageLoaded) && unref(pagePasswordPass) ? (openBlock(), createBlock(_component_Content, {
        key: 1
      })) : createCommentVNode("v-if", true)])), createVNode(PageMeta), createVNode(PageNav), createVNode(RecoWalineWrapper)]);
    };
  }
});
const Page = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "index.vue"]]);
const _sfc_main$i = {
  props: {
    modelValue: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    tag: {
      type: Number,
      default: 0
    },
    icon: {
      type: String
    }
  },
  emits: {
    "update:modelValue": (val) => true
  },
  watch: {
    modelValue(val) {
      if (val)
        setTimeout(() => this.load = true, 200);
      else
        setTimeout(() => this.load = false, 500);
    }
  },
  setup(props) {
    const load = ref(props.modelValue);
    const posX = ref(void 0);
    const posXS = computed(() => posX.value === void 0 ? void 0 : `${posX.value}px`);
    const posY = ref(void 0);
    const posYS = computed(() => posY.value === void 0 ? void 0 : `${posY.value}px`);
    return {
      load,
      posX,
      posY,
      posXS,
      posYS
    };
  },
  mounted() {
    window.addEventListener("resize", this.onResize);
  },
  unmounted() {
    window.removeEventListener("resize", this.onResize);
  },
  methods: {
    onResize() {
      const container = this.$refs.containerRef;
      const {
        offsetLeft: left = 0,
        offsetTop: top = 0,
        offsetWidth: width = 0,
        offsetHeight: height = 0
      } = container ?? {};
      this.posX = window.innerWidth - width - left;
      this.posY = top;
    }
  }
};
const Popup_vue_vue_type_style_index_0_lang = "";
const Popup_vue_vue_type_style_index_1_scoped_2e67f465_lang = "";
const _hoisted_1$e = {
  class: "popup-head"
};
const _hoisted_2$8 = ["textContent"];
const _hoisted_3$8 = {
  class: "popup-content"
};
const _hoisted_4$5 = {
  key: 0,
  class: "popup-tag"
};
const _hoisted_5$4 = {
  class: "popup-icon"
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  return $setup.load ? (openBlock(), createElementBlock(
    "div",
    {
      key: 0,
      ref: "containerRef",
      class: normalizeClass(["popup popup-container", {
        popin: $props.modelValue,
        popout: !$props.modelValue
      }]),
      style: normalizeStyle({
        "--x": $setup.posXS,
        "--y": $setup.posYS
      })
    },
    [createElementVNode("div", _hoisted_1$e, [$props.icon ? (openBlock(), createBlock(_component_xicons, {
      key: 0,
      icon: $props.icon,
      class: "popup-title"
    }, {
      default: withCtx(() => [createTextVNode(
        toDisplayString($props.title),
        1
        /* TEXT */
      )]),
      _: 1
      /* STABLE */
    }, 8, ["icon"])) : (openBlock(), createElementBlock("span", {
      key: 1,
      class: "popup-title",
      textContent: toDisplayString($props.title)
    }, null, 8, _hoisted_2$8)), createElementVNode("span", {
      class: "popup-close",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", false))
    }, [createVNode(_component_xicons, {
      icon: "Close",
      iconSize: "25"
    })])]), createElementVNode("div", _hoisted_3$8, [renderSlot(_ctx.$slots, "default", {}, void 0, true)])],
    6
    /* CLASS, STYLE */
  )) : (openBlock(), createElementBlock(
    "div",
    {
      key: 1,
      ref: "popupButtonRef",
      class: normalizeClass(["popup popup-button", {
        popin: !$props.modelValue,
        popout: $props.modelValue
      }]),
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", true))
    },
    [$props.tag > 0 ? (openBlock(), createElementBlock(
      "div",
      _hoisted_4$5,
      toDisplayString($props.tag < 10 ? `${$props.tag}` : "9+"),
      1
      /* TEXT */
    )) : createCommentVNode("v-if", true), createElementVNode("div", _hoisted_5$4, [createVNode(_component_xicons, {
      icon: "ChevronLeft",
      iconSize: "30"
    })])],
    2
    /* CLASS */
  ));
}
const Popup = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$d], ["__scopeId", "data-v-2e67f465"], ["__file", "Popup.vue"]]);
const _sfc_main$h = {
  components: {
    Popup
  },
  setup() {
    var _a3;
    const open = ref(false);
    const userInfo2 = useUserInfo();
    const data = ref({
      id: ((_a3 = userInfo2.value) == null ? void 0 : _a3.id) ?? "",
      replies: [],
      likes: []
    });
    const emoji2 = useEmoji();
    const now2 = useNow();
    const locale = {
      seconds: "秒前",
      minutes: "分钟前",
      hours: "小时前",
      days: "天前",
      now: "刚刚"
    };
    const getTimeDesc = (date) => getTimeAgo(new Date(date), now2.value, locale);
    const likesUserDesc = computed(() => {
      const {
        likes
      } = data.value;
      const userSet = new Map(likes.map((l2) => [l2.userId, l2.userName]));
      const names = `<strong>${[...userSet.values()].slice(0, 3).join("、")}</strong>`;
      const count = userSet.size;
      return count < 3 ? names : `${names}等<strong>${count}</strong>人`;
    });
    const dataCount = computed(() => {
      var _a4;
      return data.value.replies.filter((e2) => !e2.read).length + (((_a4 = data.value.likes) == null ? void 0 : _a4.length) || 0);
    });
    const pageMap2 = usePageMap();
    return {
      open,
      data,
      emoji: emoji2,
      now: now2,
      userInfo: userInfo2,
      getTimeDesc,
      parseEmoji,
      likesUserDesc,
      dataCount,
      pageMap: pageMap2
    };
  },
  mounted() {
    var _a3;
    if ((_a3 = this.userInfo) == null ? void 0 : _a3.id) {
      this.refreshData();
    }
  },
  watch: {
    userInfo(val) {
      if (val == null ? void 0 : val.id) {
        this.refreshData();
      }
    }
  },
  methods: {
    refreshData() {
      this.data.replies.splice(0, this.data.replies.length);
      this.data.likes.splice(0, this.data.likes.length);
      const update = (res, admin) => {
        var _a3;
        const viewReplies = Object.entries(res.data.replies || []).map(([aid, replies]) => replies.map((r2) => ({
          parentId: aid,
          commentId: r2.id,
          admin,
          ...r2
        }))).flat();
        this.data.replies.push(...viewReplies);
        this.data.likes.push(...((_a3 = res.data) == null ? void 0 : _a3.likes) || []);
      };
      this.$api.getRecentComments(this.userInfo.id).then((res) => update(res, false));
      if (this.userInfo.type === "administrator") {
        this.$api.getRecentComments("admin").then((res) => update(res, true));
      }
    },
    parse(content) {
      let uriDecoded = decodeURIComponent(content);
      const len = uriDecoded.length;
      const overflow = len >= 100;
      overflow && (uriDecoded = uriDecoded.slice(0, 100));
      let text2 = parseHTMLText(uriDecoded);
      overflow && (text2 += `<span class="overflow-desc">...剩余${len - 100}字</span>`);
      return parseEmoji(text2, this.emoji.map);
    },
    readAllLikes() {
      const {
        likes
      } = this.data;
      if (!likes.length)
        return;
      const userId = this.userInfo.id;
      this.$api.removeRecentComments(userId, [], likes.map((e2) => e2.userId)).then(() => this.data.likes.splice(0, likes.length));
    },
    readComment(item) {
      if (item.read)
        return;
      const userId = item.admin ? "admin" : this.userInfo.id;
      this.$api.removeRecentComments(userId, [item.commentId]).then(() => {
        item.read = true;
      });
    }
  }
};
const RecentComments_vue_vue_type_style_index_0_lang = "";
const RecentComments_vue_vue_type_style_index_1_scoped_d491bf77_lang = "";
const _withScopeId$2 = (n2) => (pushScopeId("data-v-d491bf77"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$d = {
  class: "content-wrapper"
};
const _hoisted_2$7 = {
  key: 0
};
const _hoisted_3$7 = {
  key: 0,
  class: "recent-like"
};
const _hoisted_4$4 = {
  class: "desc"
};
const _hoisted_5$3 = ["innerHTML"];
const _hoisted_6$3 = {
  class: "button"
};
const _hoisted_7$2 = {
  class: "header"
};
const _hoisted_8$2 = ["innerHTML"];
const _hoisted_9$2 = {
  class: "footer"
};
const _hoisted_10$1 = {
  class: "buttons"
};
const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode(
  "span",
  {
    class: "text"
  },
  "已读",
  -1
  /* HOISTED */
));
const _hoisted_12 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode(
  "span",
  {
    class: "text"
  },
  "查看",
  -1
  /* HOISTED */
));
const _hoisted_13 = {
  key: 1,
  class: "recent-empty"
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  const _component_router_link = resolveComponent("router-link");
  const _component_Popup = resolveComponent("Popup");
  return $setup.userInfo.id ? (openBlock(), createBlock(_component_Popup, {
    key: 0,
    title: "最近消息",
    icon: "ChatLaunch",
    modelValue: $setup.open,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.open = $event),
    tag: $setup.dataCount
  }, {
    default: withCtx(() => {
      var _a3, _b2;
      return [createElementVNode("div", _hoisted_1$d, [((_a3 = $setup.data.likes) == null ? void 0 : _a3.length) || ((_b2 = $setup.data.replies) == null ? void 0 : _b2.length) ? (openBlock(), createElementBlock("div", _hoisted_2$7, [createVNode(Transition, {
        name: "recent-likes"
      }, {
        default: withCtx(() => {
          var _a4, _b3;
          return [((_a4 = $setup.data.likes) == null ? void 0 : _a4.length) ? (openBlock(), createElementBlock("div", _hoisted_3$7, [createElementVNode("div", _hoisted_4$4, [createElementVNode("span", {
            innerHTML: $setup.likesUserDesc
          }, null, 8, _hoisted_5$3), createTextVNode(
            "点赞了你的评论共" + toDisplayString((_b3 = $setup.data.likes) == null ? void 0 : _b3.length) + "次 ",
            1
            /* TEXT */
          )]), createElementVNode("div", _hoisted_6$3, [createElementVNode("button", {
            class: "text",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.readAllLikes && $options.readAllLikes(...args))
          }, " 已读 ")])])) : createCommentVNode("v-if", true)];
        }),
        _: 1
        /* STABLE */
      }), createVNode(TransitionGroup, {
        class: "recent-replies",
        name: "recent-replies",
        tag: "div"
      }, {
        default: withCtx(() => [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList($setup.data.replies.filter((e2) => !e2.read), (item) => {
            return openBlock(), createElementBlock("div", {
              class: "recent-reply-item",
              key: item.id
            }, [createElementVNode("div", _hoisted_7$2, [createElementVNode(
              "strong",
              null,
              toDisplayString(item.user.nickname),
              1
              /* TEXT */
            ), createTextVNode(" 于 "), createElementVNode(
              "span",
              null,
              toDisplayString($setup.getTimeDesc(item.time)),
              1
              /* TEXT */
            ), createTextVNode(" 回复了你： ")]), createElementVNode("div", {
              class: "content",
              innerHTML: $options.parse(item.content)
            }, null, 8, _hoisted_8$2), createElementVNode("div", _hoisted_9$2, [createVNode(
              _component_xicons,
              {
                icon: "Blog"
              },
              {
                default: withCtx(() => {
                  var _a4, _b3;
                  return [createTextVNode(
                    toDisplayString(((_b3 = (_a4 = $setup.pageMap) == null ? void 0 : _a4[item.parentId]) == null ? void 0 : _b3.title) ?? "(已删除)"),
                    1
                    /* TEXT */
                  )];
                }),
                _: 2
                /* DYNAMIC */
              },
              1024
              /* DYNAMIC_SLOTS */
            ), createElementVNode("div", _hoisted_10$1, [createVNode(_component_xicons, {
              icon: "ImproveRelevance",
              class: normalizeClass(["button", {
                visited: item.read
              }]),
              onClick: ($event) => $options.readComment(item)
            }, {
              default: withCtx(() => [_hoisted_11$1]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["class", "onClick"]), createVNode(
              _component_xicons,
              {
                icon: "TextLink",
                class: "button"
              },
              {
                default: withCtx(() => {
                  var _a4;
                  return [((_a4 = $setup.pageMap) == null ? void 0 : _a4[item.parentId]) ? (openBlock(), createBlock(_component_router_link, {
                    key: 0,
                    to: $setup.pageMap[item.parentId].path
                  }, {
                    default: withCtx(() => [_hoisted_12]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["to"])) : createCommentVNode("v-if", true)];
                }),
                _: 2
                /* DYNAMIC */
              },
              1024
              /* DYNAMIC_SLOTS */
            )])])]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))]),
        _: 1
        /* STABLE */
      })])) : (openBlock(), createElementBlock("div", _hoisted_13, " 暂时没有消息哦~ 小孤独(: )～ "))])];
    }),
    _: 1
    /* STABLE */
  }, 8, ["modelValue", "tag"])) : createCommentVNode("v-if", true);
}
const RecentComments = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["render", _sfc_render$c], ["__scopeId", "data-v-d491bf77"], ["__file", "RecentComments.vue"]]);
const _hoisted_1$c = {
  class: "theme-container"
};
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const page = usePageData$1();
    const frontmatter = usePageFrontmatter();
    const scrollPromise2 = useScrollPromise();
    const onBeforeEnter = scrollPromise2.resolve;
    const onBeforeLeave = scrollPromise2.pending;
    const {
      proxy: proxy2
    } = getCurrentInstance();
    const {
      initMagicCard
    } = useMagicCard();
    const api = proxy2.$api;
    const articleId = computed(() => {
      return frontmatter.value.id ?? page.value.path;
    });
    provide(ARTICLE_ID_KEY, articleId);
    const articleInfo = ref({
      id: articleId.value,
      time: NaN,
      pageView: 0,
      trends: {}
    });
    const getArticleInfo = () => {
      api.getArticleInfo(articleId.value).then((resp) => {
        articleInfo.value = resp.data;
      });
    };
    provide(ARTICLE_INFO_KEY, articleInfo);
    onBeforeMount(() => {
      getArticleInfo();
    });
    const testMsg = (e2) => e2.altKey && e2.key === "c" && (proxy2 == null ? void 0 : proxy2.$msg({
      type: "success",
      text: '我在测试一段很长的消息Σ(⊙▽⊙"a',
      delay: 12e3
    }));
    onMounted(() => {
      initMagicCard();
      initImgCache();
      window.addEventListener("keydown", testMsg);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", testMsg);
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
      initImgCache();
      getArticleInfo();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [createVNode(Common, null, {
        default: withCtx(() => [unref(frontmatter).home === true ? (openBlock(), createBlock(Home, {
          key: 0
        })) : (openBlock(), createBlock(Transition, {
          key: 1,
          name: "fade-slide-y",
          mode: "out-in",
          onBeforeEnter: unref(onBeforeEnter),
          onBeforeLeave: unref(onBeforeLeave)
        }, {
          default: withCtx(() => [(openBlock(), createBlock(Page, {
            key: unref(page).path
          }))]),
          _: 1
          /* STABLE */
        }, 8, ["onBeforeEnter", "onBeforeLeave"])), createVNode(RecentComments)]),
        _: 1
        /* STABLE */
      })]);
    };
  }
});
const Layout = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "Layout.vue"]]);
const _sfc_main$f = {
  components: {
    Common,
    LoadingIcon,
    Pad: () => h$5("span", {
      style: {
        padding: "5px"
      }
    })
  },
  setup() {
    const frontend = ref(true);
    const page = ref(1);
    const status = ref("load");
    const data = ref([]);
    const dataMap = computed(() => {
      const map = {};
      for (const item of data.value) {
        let date = "未知年份";
        if (item.date) {
          date = item.date.toLocaleDateString();
        }
        if (!map[date]) {
          map[date] = [item];
        } else {
          map[date].push(item);
        }
      }
      return map;
    });
    const timelineData = computed(() => {
      return Object.entries(dataMap.value).map(([date, data2]) => ({
        date,
        data: data2
      }));
    });
    const startIndex = ref(0);
    return {
      frontend,
      page,
      status,
      data,
      timelineData,
      startIndex
    };
  },
  mounted() {
    {
      this.init(this.frontend);
    }
  },
  watch: {
    frontend(val) {
      this.init(val);
    }
  },
  methods: {
    init(frontend) {
      this.page = 1;
      this.startIndex = 0;
      this.data.splice(0, this.data.length);
      this.getCommitsInfo(frontend);
    },
    async getCommitsInfo(frontend, page = 1) {
      const pageSize = 25;
      const repo = frontend ? "LancreeVuepressBlog" : "LancreeBlogServer";
      try {
        this.status = "load";
        const {
          data
        } = await this.$api.getCommitsInfo(repo, page, pageSize);
        this.startIndex = this.timelineData.length;
        this.data.push(...data.map((e2) => ({
          ...e2,
          date: new Date(e2.date)
        })));
        this.status = "part";
        if (!data.length || data.length < pageSize) {
          this.status = "all";
        }
      } catch {
        this.status = "error";
      }
    }
  }
};
const Timeline_vue_vue_type_style_index_0_scoped_4c130a7c_lang = "";
const _hoisted_1$b = {
  class: "timeline-title"
};
const _hoisted_2$6 = {
  class: "github-note"
};
const _hoisted_3$6 = {
  class: "timeline-content"
};
const _hoisted_4$3 = {
  class: "year"
};
const _hoisted_5$2 = {
  class: "year-wrapper"
};
const _hoisted_6$2 = {
  class: "sha"
};
const _hoisted_7$1 = {
  key: 0,
  class: "date"
};
const _hoisted_8$1 = {
  class: "message"
};
const _hoisted_9$1 = {
  class: "load-more"
};
const _hoisted_10 = {
  key: 0,
  class: "wl-loading"
};
const _hoisted_11 = {
  key: 3,
  class: "no-more"
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  const _component_Pad = resolveComponent("Pad");
  const _component_LoadingIcon = resolveComponent("LoadingIcon");
  const _component_Common = resolveComponent("Common");
  return openBlock(), createBlock(_component_Common, {
    class: "timeline-wrapper"
  }, {
    default: withCtx(() => [createElementVNode("h2", _hoisted_1$b, [createElementVNode("div", {
      class: "transparent-btn",
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.frontend = !$setup.frontend)
    }, [createVNode(_component_xicons, null, {
      icon: withCtx(() => [createVNode(_component_xicons, {
        icon: "Renew",
        class: normalizeClass({
          rotate: $setup.status === "load",
          reverse: $setup.status === "load"
        }),
        style: {
          "margin-right": ".25rem"
        }
      }, null, 8, ["class"])]),
      default: withCtx(() => [createTextVNode(
        " " + toDisplayString($setup.frontend ? "Vuepress 前端" : "Go Hertz 后端"),
        1
        /* TEXT */
      )]),
      _: 1
      /* STABLE */
    })]), createTextVNode(" 提交历史 "), createElementVNode("div", _hoisted_2$6, [createVNode(_component_xicons, {
      icon: "LogoGithub"
    }, {
      default: withCtx(() => [createTextVNode("每小时刷新")]),
      _: 1
      /* STABLE */
    })])]), createElementVNode("ul", _hoisted_3$6, [createVNode(TransitionGroup, {
      name: "fade-right-in"
    }, {
      default: withCtx(() => [(openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($setup.timelineData, (item, index2) => {
          return openBlock(), createElementBlock(
            "li",
            {
              key: ($setup.frontend ? "0_" : "1_") + item.date || index2,
              style: normalizeStyle({
                "--delay": `${(index2 - $setup.startIndex) * 0.1}s`
              })
            },
            [createElementVNode(
              "h3",
              _hoisted_4$3,
              toDisplayString(item.date),
              1
              /* TEXT */
            ), createElementVNode("ul", _hoisted_5$2, [createVNode(
              TransitionGroup,
              {
                name: "fade-right-in"
              },
              {
                default: withCtx(() => [(openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(item.data, (subItem, subIndex) => {
                    return openBlock(), createElementBlock("li", {
                      key: subItem.sha || subIndex,
                      class: "item"
                    }, [createVNode(_component_xicons, {
                      icon: "Commit"
                    }), createVNode(_component_Pad), createElementVNode(
                      "span",
                      _hoisted_6$2,
                      toDisplayString(subItem.sha.slice(0, 8)),
                      1
                      /* TEXT */
                    ), createVNode(_component_xicons, {
                      icon: "Time"
                    }), createVNode(_component_Pad), subItem.date ? (openBlock(), createElementBlock(
                      "span",
                      _hoisted_7$1,
                      toDisplayString(subItem.date.toLocaleTimeString()),
                      1
                      /* TEXT */
                    )) : createCommentVNode("v-if", true), createElementVNode(
                      "span",
                      _hoisted_8$1,
                      toDisplayString(subItem.message),
                      1
                      /* TEXT */
                    ), subItem.committer ? (openBlock(), createBlock(
                      _component_xicons,
                      {
                        key: 1,
                        class: "committer",
                        icon: "UserCertification"
                      },
                      {
                        default: withCtx(() => [createTextVNode(
                          toDisplayString(subItem.committer),
                          1
                          /* TEXT */
                        ), createVNode(_component_Pad)]),
                        _: 2
                        /* DYNAMIC */
                      },
                      1024
                      /* DYNAMIC_SLOTS */
                    )) : createCommentVNode("v-if", true)]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))]),
                _: 2
                /* DYNAMIC */
              },
              1024
              /* DYNAMIC_SLOTS */
            )])],
            4
            /* STYLE */
          );
        }),
        128
        /* KEYED_FRAGMENT */
      ))]),
      _: 1
      /* STABLE */
    }), createElementVNode("li", _hoisted_9$1, [$setup.status === "load" ? (openBlock(), createElementBlock("div", _hoisted_10, [createVNode(_component_LoadingIcon, {
      size: 30
    })])) : $setup.status === "part" ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "transparent-btn",
      onClick: _cache[1] || (_cache[1] = ($event) => $options.getCommitsInfo($setup.frontend, ++$setup.page))
    }, [createVNode(_component_xicons, {
      icon: "ResultOld"
    }, {
      default: withCtx(() => [createTextVNode("加载更多")]),
      _: 1
      /* STABLE */
    })])) : $setup.status === "error" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "transparent-btn",
      onClick: _cache[2] || (_cache[2] = ($event) => $options.getCommitsInfo($setup.frontend, $setup.page))
    }, [createVNode(_component_xicons, {
      icon: "Renew"
    }, {
      default: withCtx(() => [createTextVNode("重试")]),
      _: 1
      /* STABLE */
    })])) : (openBlock(), createElementBlock("div", _hoisted_11, " 没有更多了哟~ "))])])]),
    _: 1
    /* STABLE */
  });
}
const Timeline = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$b], ["__scopeId", "data-v-4c130a7c"], ["__file", "Timeline.vue"]]);
const APPEARANCE_KEY = "vuepress-reco-color-scheme";
const PREFER_SCHEME_MEDIAKEY = "(prefers-color-scheme: dark)";
const clientConfig20 = defineClientConfig({
  enhance({
    app
  }) {
    class SetItemEvent extends StorageEvent {
    }
    const myStorage = function(win) {
      if (!win) {
        return;
      }
      const storage = {
        clear: function() {
          for (const key in this) {
            if (typeof this[key] !== "function")
              this[key] = null;
          }
          return true;
        },
        key: function(index2) {
          return Object.keys(this)[index2];
        }
      };
      return new Proxy(storage, {
        set: function(target, key, value) {
          var oldValue = target[key];
          if (oldValue === value) {
            return false;
          }
          var setItemEvent = new SetItemEvent("myStorage", {
            key,
            oldValue,
            newValue: value,
            url: win.location.href
          });
          win.dispatchEvent(setItemEvent);
          target[key] = value;
          return true;
        },
        get: function(target, key) {
          return target[key] ?? null;
        },
        deleteProperty: function(target, key) {
          target[key] = null;
          return true;
        }
      });
    }(window);
    Object.defineProperty(window, "myStorage", {
      value: myStorage,
      writable: true
    });
  },
  setup: () => {
  }
});
const _sfc_main$e = {
  props: {
    text: {
      required: true,
      type: String
    },
    darkMode: {
      type: Boolean,
      default: false
    },
    ruby: {
      type: Object,
      default: null,
      validate: (e2) => {
        return !e2 || e2.light;
      }
    }
  },
  data() {
    return {
      mousePos: []
    };
  },
  created() {
    this.mousePos = new Array(this.text.length).fill({
      x: "0px",
      y: "0px"
    });
  },
  mounted() {
    window.addEventListener("mousemove", throttle$1((event) => {
      const heroText = this.$refs.heroText;
      if (!heroText)
        return;
      const {
        pageX: x2,
        pageY: y3
      } = event;
      this.mousePos = heroText.map((t2) => {
        const {
          x: ox,
          y: oy
        } = getAbsolutePos(t2);
        return {
          x: `${x2 - ox}px`,
          y: `${y3 - oy}px`
        };
      });
    }, 100));
  }
};
const _hoisted_1$a = {
  key: 0,
  class: "banner-brand__hero-text"
};
const _hoisted_2$5 = {
  key: 0
};
const _hoisted_3$5 = {
  key: 1
};
const _hoisted_4$2 = /* @__PURE__ */ createElementVNode(
  "hr",
  {
    class: "banner-brand__hr"
  },
  null,
  -1
  /* HOISTED */
);
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.text ? (openBlock(), createElementBlock("h1", _hoisted_1$a, [(openBlock(true), createElementBlock(
    Fragment,
    null,
    renderList($props.text, (c2, i3) => {
      return openBlock(), createElementBlock(
        "span",
        {
          ref_for: true,
          ref: "heroText",
          key: i3,
          style: normalizeStyle({
            "--delay": `${i3 * 100}ms`,
            "--x": $data.mousePos[i3].x,
            "--y": $data.mousePos[i3].y
          })
        },
        [createElementVNode("ruby", null, [createTextVNode(
          toDisplayString(c2) + " ",
          1
          /* TEXT */
        ), $props.darkMode && $props.ruby && $props.ruby.dark ? (openBlock(), createElementBlock(
          "rt",
          _hoisted_2$5,
          toDisplayString($props.ruby.dark[i3] ?? ""),
          1
          /* TEXT */
        )) : $props.ruby && $props.ruby.light ? (openBlock(), createElementBlock(
          "rt",
          _hoisted_3$5,
          toDisplayString($props.ruby.light[i3] ?? ""),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)])],
        4
        /* STYLE */
      );
    }),
    128
    /* KEYED_FRAGMENT */
  )), _hoisted_4$2])) : createCommentVNode("v-if", true);
}
const HeroText = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$a], ["__file", "HeroText.vue"]]);
const _sfc_main$d = {
  props: {
    scrollTo: {
      type: [Number, String, Object],
      default: 0,
      validate: (e2) => ["number", "string"].includes(typeof e2) || e2 instanceof Element
    }
  },
  methods: {
    scroll() {
      if (typeof this.scrollTo === "number") {
        window.scroll({
          left: 0,
          top: this.scrollTo,
          behavior: "smooth"
        });
      } else {
        const el = typeof this.scrollTo === "string" ? document.querySelector(this.scrollTo) : this.scrollTo;
        el == null ? void 0 : el.scrollIntoView({
          behavior: "smooth"
        });
      }
    }
  }
};
const DownIcon_vue_vue_type_style_index_0_scoped_3d9ab88b_lang = "";
const _withScopeId$1 = (n2) => (pushScopeId("data-v-3d9ab88b"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$9 = {
  class: "down-icon-wrapper"
};
const _hoisted_2$4 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode(
  "svg",
  {
    class: "down-svg",
    fill: "none",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  },
  [/* @__PURE__ */ createElementVNode("path", {
    d: "M19 14l-7 7m0 0l-7-7m7 7V3"
  })],
  -1
  /* HOISTED */
));
const _hoisted_3$4 = [_hoisted_2$4];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [createElementVNode("div", {
    class: "down-icon",
    onClick: _cache[0] || (_cache[0] = (...args) => $options.scroll && $options.scroll(...args))
  }, _hoisted_3$4)]);
}
const DownIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["render", _sfc_render$9], ["__scopeId", "data-v-3d9ab88b"], ["__file", "DownIcon.vue"]]);
const _hoisted_1$8 = {
  class: "wind-base"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "WindBase",
  setup(__props) {
    const windStrength = ref(0);
    const windAngle = ref(180);
    const windStrengthTo = ref(0);
    const windAngleTo = ref(180);
    const windStep = ref(1);
    let itv1 = null;
    let itv2 = null;
    watch([windStrengthTo, windAngleTo], (nvals) => {
      itv1 = setInterval(() => {
        windStrength.value = passTo(windStrength.value, nvals[0], windStep.value);
        windAngle.value = passTo(windAngle.value, nvals[1], windStep.value);
        if (windStrength.value === nvals[0] && windAngle.value === nvals[1]) {
          clearInterval(itv1);
        }
      }, 20);
    });
    onMounted(() => {
      if (isMobile(window) === false) {
        itv2 = setInterval(() => {
          if (Math.random() < 0.2) {
            itv1 && clearInterval(itv1);
            windStrengthTo.value = randFloat(0, 4);
            windAngleTo.value = Math.random() < 0.5 ? randInt(-10, 30) : randInt(150, 190);
            windStep.value = randFloat(0.1, 0.5);
          }
        }, 5e3);
      }
    });
    onUnmounted(() => {
      if (itv1)
        clearInterval(itv1);
      if (itv2)
        clearInterval(itv2);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [renderSlot(_ctx.$slots, "default", {
        strength: windStrength.value,
        direction: windAngle.value
      })]);
    };
  }
});
const WindBase = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "WindBase.vue"]]);
const _hoisted_1$7 = {
  id: "flower-canvas"
};
const _hoisted_2$3 = ["width", "height"];
const _hoisted_3$3 = ["width", "height"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "Flowers",
  props: {
    windStrength: {
      type: Number,
      default: 0
    },
    windAngle: {
      type: Number,
      default: 0
    }
  },
  setup(__props) {
    const props = __props;
    const frontCanvas = ref();
    const backCanvas = ref();
    const w2 = ref(1920);
    const h2 = ref(280);
    let itv = null;
    class Flower {
      constructor(scaleRange, speedXRange, speedYRange) {
        this.scaleRange = scaleRange;
        this.speedXRange = speedXRange;
        this.speedYRange = speedYRange;
        [this.x, this.y] = [0, 0];
        [this.speedX, this.speedY] = [0, 0];
        [this.width, this.height] = [0, 0];
        this.rotate = 0;
        this.speedR = 1;
        this.scale = 0;
        this.img = null;
      }
      show(ctx) {
        this.img = new Image();
        const src = Math.random() > 0.5 ? "/images/flower1.svg" : "/images/flower2.svg";
        this.img.src = src;
        this.regen(this.speedX, this.speedY, true);
        this.img.onload = () => {
          const ratio = this.img.width / this.img.height;
          [this.width, this.height] = [ratio * this.scale, this.scale];
          ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        };
      }
      regen(dx, dy, rand = false) {
        this.scale = Array.isArray(this.scaleRange) ? randElem(this.scaleRange) : randFloat(this.scaleRange);
        [this.speedX, this.speedY] = [randFloat(this.speedXRange), randFloat(this.speedYRange)];
        if (rand) {
          [this.x, this.y] = [randFloat(0, w2.value), randFloat(0, h2.value)];
        } else {
          const ratio = (w2.value + dy) / (w2.value + h2.value + dx + dy);
          const [initX, initY] = Math.random() < ratio ? [randFloat(0, w2.value), dy >= 0 ? 0 : h2.value] : [dx >= 0 ? 0 : w2.value, randFloat(0, h2.value)];
          [this.x, this.y] = [initX, initY];
        }
      }
      draw(ctx, rotate = 0) {
        if (!this.rotate) {
          return ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        }
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(rotate * Math.PI / 180);
        ctx.drawImage(this.img, 0, 0, this.width, this.height);
        ctx.restore();
      }
      // 花瓣移动，会受风的影响
      move(ctx) {
        const wStr = props.windStrength, wAgl = props.windAngle * Math.PI / 180;
        const dx = this.speedX + (wStr ? wStr * Math.cos(wAgl) : 0);
        const dy = this.speedY + (wStr ? wStr * Math.sin(wAgl) : 0);
        const {
          width: cw,
          height: ch
        } = this;
        if (!inRange(this.x + dx, -cw, w2.value + cw) || !inRange(this.y + dy, -ch, h2.value + ch)) {
          this.regen(dx, dy);
        } else
          [this.x, this.y] = [this.x + dx, this.y + dy];
        this.rotate = (this.rotate + this.speedR) % 360;
        this.draw(ctx, this.rotate);
      }
    }
    onMounted(() => {
      const scales = [[10, 12.5, 15], [17.5, 20, 22.5]];
      const speedXRange = {
        min: 0,
        max: 2
      };
      const speedYRange = {
        min: 1,
        max: 1.5
      };
      const FlowerCounts = isMobile(window) === false ? [20, 5] : [10, 3];
      w2.value = window.innerWidth;
      h2.value = window.innerHeight;
      for (const [i3, canvas] of [backCanvas.value, frontCanvas.value].entries()) {
        let movee = function() {
          if (!ctx)
            return;
          ctx.clearRect(0, 0, w2.value, h2.value);
          for (const flower of flowers) {
            flower.move(ctx);
          }
        };
        if (!canvas)
          return;
        let ctx = canvas.getContext("2d");
        if (!ctx)
          return;
        const flowers = [];
        for (let t2 = 0; t2 < FlowerCounts[i3]; t2++) {
          const fr = new Flower(scales[i3], speedXRange, speedYRange);
          flowers.push(fr);
          fr.show(ctx);
        }
        itv = setInterval(movee, 20);
        movee();
        window.addEventListener("resize", () => {
          w2.value = window.innerWidth;
          h2.value = window.innerHeight;
        });
      }
    });
    onUnmounted(() => {
      if (itv)
        clearInterval(itv);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [createElementVNode("canvas", {
        ref_key: "frontCanvas",
        ref: frontCanvas,
        width: w2.value,
        height: h2.value,
        class: "flower-canvas front"
      }, null, 8, _hoisted_2$3), createElementVNode("canvas", {
        ref_key: "backCanvas",
        ref: backCanvas,
        width: w2.value,
        height: h2.value,
        class: "flower-canvas back"
      }, " 您的浏览器不支持canvas请升级！ ", 8, _hoisted_3$3)]);
    };
  }
});
const Flowers_vue_vue_type_style_index_0_scoped_28d5ea85_lang = "";
const Flowers = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__scopeId", "data-v-28d5ea85"], ["__file", "Flowers.vue"]]);
var p$3 = (r2, t2, i3) => {
  if (!t2.has(r2))
    throw TypeError("Cannot " + i3);
};
var e$2 = (r2, t2, i3) => (p$3(r2, t2, "read from private field"), i3 ? i3.call(r2) : t2.get(r2)), w$4 = (r2, t2, i3) => {
  if (t2.has(r2))
    throw TypeError("Cannot add the same private member more than once");
  t2 instanceof WeakSet ? t2.add(r2) : t2.set(r2, i3);
}, g$5 = (r2, t2, i3, s2) => (p$3(r2, t2, "write to private field"), s2 ? s2.call(r2, i3) : t2.set(r2, i3), i3);
const C$4 = 2147483647;
var n$3, d$4;
const u$4 = class u {
  constructor(t2, i3, s2, h2 = true) {
    w$4(this, n$3, void 0);
    w$4(this, d$4, void 0);
    g$5(this, n$3, {
      width: 0,
      height: 0
    });
    const {
      el: l2,
      ctx: o2
    } = u$4.initCanvas(t2);
    this.el = l2, this.ctx = o2, g$5(this, d$4, h2), this.size = {
      width: i3 || window.innerWidth,
      height: s2 || window.innerHeight
    };
  }
  get size() {
    return {
      ...e$2(this, n$3)
    };
  }
  set size({
    width: t2,
    height: i3
  }) {
    var h2;
    if (e$2(this, n$3).width === t2 && e$2(this, n$3).height === i3)
      return;
    e$2(this, n$3).width = t2, e$2(this, n$3).height = i3;
    const s2 = (h2 = e$2(this, d$4) ? window.devicePixelRatio : 1) != null ? h2 : 1;
    this.el.width = Math.round(e$2(this, n$3).width * s2), this.el.height = Math.round(e$2(this, n$3).height * s2), this.el.style.width = e$2(this, n$3).width + "px", this.el.style.height = e$2(this, n$3).height + "px", e$2(this, d$4) && this.ctx.scale(s2, s2);
  }
  clear() {
    u$4.clearCanvas(this.ctx, {
      ...e$2(this, n$3)
    });
  }
  to(t2) {
    t2.ctx.drawImage(this.el, 0, 0, e$2(this, n$3).width, e$2(this, n$3).height);
  }
  handleResize(t2) {
    this.size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  static setCanvasStyle(t2, i3, s2) {
    const h2 = t2.style, {
      zIndex: l2 = 0,
      opacity: o2 = 1
    } = i3;
    h2.position = "fixed", h2.top = "0", h2.left = "0", h2.zIndex = l2.toString(), h2.width = (s2 ? s2.width : t2.width).toString() + "px", h2.height = (s2 ? s2.height : t2.height).toString() + "px", o2 !== 1 && (h2.opacity = o2.toString()), h2.pointerEvents = "none";
  }
  static initCanvas(t2) {
    t2 || (t2 = document.createElement("canvas"));
    const i3 = t2.getContext("2d");
    return {
      el: t2,
      ctx: i3
    };
  }
  static createOffscreenCanvas() {
    return new u$4();
  }
  static clearCanvas(t2, i3) {
    const {
      width: s2,
      height: h2
    } = i3;
    t2.clearRect(0, 0, s2, h2);
  }
};
let x$3 = u$4;
n$3 = /* @__PURE__ */ new WeakMap(), d$4 = /* @__PURE__ */ new WeakMap();
var a$2, c$3;
let y$4 = class y {
  constructor(t2, i3, s2, h2 = true, l2 = true, o2 = {
    zIndex: 0,
    opacity: 1
  }) {
    w$4(this, a$2, void 0);
    w$4(this, c$3, void 0);
    g$5(this, a$2, new x$3(t2, i3, s2, h2)), x$3.setCanvasStyle(e$2(this, a$2).el, o2, {
      width: i3,
      height: s2
    }), g$5(this, c$3, l2 ? new x$3(void 0, i3, s2, h2) : null);
  }
  get size() {
    return e$2(this, a$2).size;
  }
  draw(t2) {
    var s2;
    const i3 = (s2 = e$2(this, c$3)) != null ? s2 : e$2(this, a$2);
    i3.clear(), t2(i3.ctx, {
      ...i3.size
    });
  }
  render() {
    !e$2(this, c$3) || (e$2(this, a$2).clear(), e$2(this, c$3).to(e$2(this, a$2)));
  }
  handleResize(t2) {
    e$2(this, a$2).handleResize(t2), e$2(this, c$3) && e$2(this, c$3).handleResize(t2);
  }
  clear() {
    e$2(this, a$2).clear(), e$2(this, c$3) && e$2(this, c$3).clear();
  }
};
a$2 = /* @__PURE__ */ new WeakMap(), c$3 = /* @__PURE__ */ new WeakMap();
var f$3 = (o2, t2, e2) => {
  if (!t2.has(o2))
    throw TypeError("Cannot " + e2);
};
var r$3 = (o2, t2, e2) => (f$3(o2, t2, "read from private field"), e2 ? e2.call(o2) : t2.get(o2)), h$2 = (o2, t2, e2) => {
  if (t2.has(o2))
    throw TypeError("Cannot add the same private member more than once");
  t2 instanceof WeakSet ? t2.add(o2) : t2.set(o2, e2);
}, d$3 = (o2, t2, e2, n2) => (f$3(o2, t2, "write to private field"), n2 ? n2.call(o2, e2) : t2.set(o2, e2), e2);
const p$2 = (o2) => typeof o2 == "string";
var s$1;
let M$2 = class M {
  constructor() {
    h$2(this, s$1, void 0);
    d$3(this, s$1, /* @__PURE__ */ new Map());
  }
  add(t2, e2, n2 = window) {
    r$3(this, s$1).has(n2) || r$3(this, s$1).set(n2, /* @__PURE__ */ new Map());
    const c2 = r$3(this, s$1).get(n2);
    c2.has(t2) || c2.set(t2, /* @__PURE__ */ new Set()), c2.get(t2).add(e2);
  }
  startAll() {
    for (const [t2, e2] of r$3(this, s$1))
      for (const [n2, c2] of e2)
        for (const a2 of c2)
          t2.addEventListener(n2, a2);
  }
  stopAll() {
    for (const [t2, e2] of r$3(this, s$1))
      for (const [n2, c2] of e2)
        for (const a2 of c2)
          t2.removeEventListener(n2, a2);
  }
  clear() {
    r$3(this, s$1).clear();
  }
};
s$1 = /* @__PURE__ */ new WeakMap();
function g$4() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function w$3(o2) {
  return !!o2.touches;
}
let i$2 = class i {
  static randomFloat(t2, e2) {
    return Math.random() * (e2 - t2) + t2;
  }
  static randomInt(t2, e2) {
    return Math.floor(i.randomFloat(t2, e2));
  }
  static choice(t2) {
    const e2 = t2.length, n2 = Math.floor(e2 * Math.random());
    return t2[n2];
  }
  static color(t2 = "0123456789ABCDEF") {
    return "#" + i.choice(t2) + i.choice(t2) + i.choice(t2) + i.choice(t2) + i.choice(t2) + i.choice(t2);
  }
};
function v$4(o2, {
  leftColor: t2 = "#fff",
  rightColor: e2 = "#444",
  leftBgColor: n2 = "#35495e",
  rightBgColor: c2 = "#00ffc0"
} = {}) {
}
function l$3() {
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function b$4() {
  return !!l$3().matches;
}
var Y$1 = (r2, i3, h2) => {
  if (!i3.has(r2))
    throw TypeError("Cannot " + h2);
};
var t = (r2, i3, h2) => (Y$1(r2, i3, "read from private field"), h2 ? h2.call(r2) : i3.get(r2)), e$1 = (r2, i3, h2) => {
  if (i3.has(r2))
    throw TypeError("Cannot add the same private member more than once");
  i3 instanceof WeakSet ? i3.add(r2) : i3.set(r2, h2);
}, d$2 = (r2, i3, h2, s2) => (Y$1(r2, i3, "write to private field"), s2 ? s2.call(r2, h2) : i3.set(r2, h2), h2);
var l$2 = (r2, i3, h2) => (Y$1(r2, i3, "access private method"), h2);
var o$2, g$3, f$2;
let v$3 = class v {
  constructor(i3 = 0, h2 = 0, s2 = 0) {
    e$1(this, o$2, null);
    e$1(this, g$3, null);
    e$1(this, f$2, 50);
    this.x = i3, this.y = h2, this.z = s2;
  }
  bindGlobalSpeed(i3) {
    return d$2(this, o$2, i3), this;
  }
  bindColor(i3) {
    return d$2(this, g$3, i3), this;
  }
  reset(i3, h2 = false) {
    h2 || (this.x = Math.random() * i3.width, this.y = Math.random() * i3.height), this.z = 0.2 + Math.random() * 0.8;
  }
  move(i3) {
    let h2, s2, a2;
    if (this.x += t(this, o$2).x * this.z, this.y += t(this, o$2).y * this.z, this.x += (this.x - i3.width / 2) * t(this, o$2).z * this.z, this.y += (this.y - i3.height / 2) * t(this, o$2).z * this.z, this.z += t(this, o$2).z, this.x < -t(this, f$2) || this.x > i3.width + t(this, f$2) || this.y < -t(this, f$2) || this.y > i3.height + t(this, f$2))
      switch (h2 = "z", s2 = Math.abs(t(this, o$2).tx), a2 = Math.abs(t(this, o$2).ty), s2 > 1 && a2 > 1 && (h2 = (s2 > a2 ? Math.random() < Math.abs(t(this, o$2).x) / (s2 + a2) ? "h" : "v" : Math.random() < Math.abs(t(this, o$2).y) / (s2 + a2) ? "v" : "h") == "h" ? t(this, o$2).x > 0 ? "l" : "r" : t(this, o$2).y > 0 ? "t" : "b"), this.reset(i3, true), h2) {
        case "z":
          this.z = 0.1, this.x = Math.random() * i3.width, this.y = Math.random() * i3.height;
          break;
        case "l":
          this.x = -3, this.y = Math.random() * i3.height;
          break;
        case "r":
          this.x = i3.width + 3, this.y = Math.random() * i3.height;
          break;
        case "t":
          this.x = Math.random() * i3.width, this.y = -3;
          break;
        case "b":
          this.x = Math.random() * i3.width, this.y = i3.height + 3;
      }
  }
  draw(i3, h2) {
    i3.lineCap = "round", i3.lineWidth = 3 * this.z, i3.strokeStyle = t(this, g$3), i3.beginPath(), i3.moveTo(this.x, this.y);
    let s2 = 2 * t(this, o$2).x, a2 = 2 * t(this, o$2).y;
    Math.abs(s2) < 0.1 && (s2 = 0.5), Math.abs(a2) < 0.1 && (a2 = 0.5), i3.lineTo(this.x + s2, this.y + a2), i3.stroke();
  }
};
o$2 = /* @__PURE__ */ new WeakMap(), g$3 = /* @__PURE__ */ new WeakMap(), f$2 = /* @__PURE__ */ new WeakMap();
var M$1, y$3, w$2, u$3, c$2, b$3, n$2, p$1, x$2, m$3, P$2, L$3, T$2, R$2, A$2, O$2, H$2, V, B$2, j, k$2, q$1, z$2, C$3, F$2, I$1, W$3, J$2, X$2, K$2;
let et$1 = class et {
  constructor({
    numParticles: i3 = null,
    particleColor: h2 = "rgba(102, 175, 239, .2)"
  } = {}, s2 = {}) {
    e$1(this, P$2);
    e$1(this, T$2);
    e$1(this, A$2);
    e$1(this, H$2);
    e$1(this, B$2);
    e$1(this, k$2);
    e$1(this, z$2);
    e$1(this, F$2);
    e$1(this, W$3);
    e$1(this, X$2);
    e$1(this, M$1, void 0);
    e$1(this, y$3, void 0);
    e$1(this, w$2, void 0);
    e$1(this, u$3, null);
    e$1(this, c$2, /* @__PURE__ */ new Set());
    e$1(this, b$3, null);
    e$1(this, n$2, {
      x: 0,
      y: 0,
      tx: 0,
      ty: 0,
      z: 5e-4
    });
    e$1(this, p$1, false);
    e$1(this, x$2, false);
    e$1(this, m$3, new M$2());
    d$2(this, M$1, i3), p$2(h2) && (h2 = {
      light: h2,
      dark: h2
    }), d$2(this, y$3, h2), d$2(this, w$2, s2), this.animate = this.animate.bind(this);
  }
  mount(i3) {
    d$2(this, x$2, false), d$2(this, u$3, new y$4(i3, window.innerWidth, window.innerHeight, true, true, t(this, w$2))), l$2(this, P$2, L$3).call(this), l$2(this, B$2, j).call(this), l$2(this, A$2, O$2).call(this), v$4("Theme Meteor 🌠", {
      leftBgColor: "#66afe0"
    });
  }
  unmount() {
    l$2(this, H$2, V).call(this), l$2(this, T$2, R$2).call(this), d$2(this, x$2, true), d$2(this, b$3, null);
  }
  animate(i3) {
    if (t(this, x$2)) {
      t(this, u$3).clear();
      return;
    }
    if (requestAnimationFrame(this.animate), !t(this, p$1)) {
      t(this, n$2).tx *= 0.95, t(this, n$2).ty *= 0.95, t(this, n$2).x += 0.7 * (t(this, n$2).tx - t(this, n$2).x), t(this, n$2).y += 0.7 * (t(this, n$2).ty - t(this, n$2).y);
      for (const h2 of t(this, c$2))
        h2.move(t(this, u$3).size);
      t(this, u$3).draw((h2, s2) => {
        for (const a2 of t(this, c$2))
          a2.draw(h2, i3);
      }), t(this, u$3).render();
    }
  }
};
M$1 = /* @__PURE__ */ new WeakMap(), y$3 = /* @__PURE__ */ new WeakMap(), w$2 = /* @__PURE__ */ new WeakMap(), u$3 = /* @__PURE__ */ new WeakMap(), c$2 = /* @__PURE__ */ new WeakMap(), b$3 = /* @__PURE__ */ new WeakMap(), n$2 = /* @__PURE__ */ new WeakMap(), p$1 = /* @__PURE__ */ new WeakMap(), x$2 = /* @__PURE__ */ new WeakMap(), m$3 = /* @__PURE__ */ new WeakMap(), P$2 = /* @__PURE__ */ new WeakSet(), L$3 = function() {
  var s2;
  const i3 = (s2 = t(this, M$1)) != null ? s2 : (window.innerWidth + window.innerHeight) / 8, h2 = b$4() ? t(this, y$3).dark : t(this, y$3).light;
  for (let a2 = 0; a2 < i3; a2++) {
    const D2 = new v$3(0, 0, 0).bindColor(h2).bindGlobalSpeed(t(this, n$2));
    D2.reset(t(this, u$3).size, false), t(this, c$2).add(D2);
  }
}, T$2 = /* @__PURE__ */ new WeakSet(), R$2 = function() {
  t(this, c$2).clear();
}, A$2 = /* @__PURE__ */ new WeakSet(), O$2 = function() {
  g$4() ? (t(this, m$3).add("touchmove", l$2(this, k$2, q$1).bind(this)), t(this, m$3).add("touchend", l$2(this, z$2, C$3).bind(this))) : (t(this, m$3).add("mousemove", l$2(this, k$2, q$1).bind(this)), t(this, m$3).add("mouseleave", l$2(this, z$2, C$3).bind(this))), t(this, m$3).add("visibilitychange", l$2(this, X$2, K$2).bind(this)), t(this, m$3).add("change", l$2(this, W$3, J$2).bind(this), l$3()), t(this, m$3).add("resize", r$6(l$2(this, F$2, I$1).bind(this), 500)), t(this, m$3).startAll();
}, H$2 = /* @__PURE__ */ new WeakSet(), V = function() {
  t(this, m$3).stopAll(), t(this, m$3).clear();
}, B$2 = /* @__PURE__ */ new WeakSet(), j = function() {
  requestAnimationFrame(this.animate);
}, k$2 = /* @__PURE__ */ new WeakSet(), q$1 = function(i3) {
  const h2 = {
    x: w$3(i3) ? i3.touches[0].clientX : i3.clientX,
    y: w$3(i3) ? i3.touches[0].clientY : i3.clientY
  };
  if (t(this, b$3)) {
    const s2 = {
      x: h2.x - t(this, b$3).x,
      y: h2.y - t(this, b$3).y
    };
    t(this, n$2).tx = t(this, n$2).x + s2.x / 8, t(this, n$2).ty = t(this, n$2).y + s2.y / 8;
  }
  d$2(this, b$3, h2);
}, z$2 = /* @__PURE__ */ new WeakSet(), C$3 = function(i3) {
  d$2(this, b$3, null);
}, F$2 = /* @__PURE__ */ new WeakSet(), I$1 = function(i3) {
  t(this, u$3).handleResize(i3);
  for (const h2 of t(this, c$2))
    h2.reset(t(this, u$3).size, false);
}, W$3 = /* @__PURE__ */ new WeakSet(), J$2 = function(i3) {
  const h2 = b$4() ? t(this, y$3).dark : t(this, y$3).light;
  for (const s2 of t(this, c$2))
    s2.bindColor(h2);
}, X$2 = /* @__PURE__ */ new WeakSet(), K$2 = function(i3) {
  d$2(this, p$1, document.hidden);
};
const _sfc_main$a = {
  name: "Meteor",
  props: {
    numParticles: {
      type: Number,
      default: null
    },
    zIndex: {
      type: Number,
      default: -C$4
    }
  },
  mounted() {
    const themeConfig = {
      numParticles: this.numParticles,
      particleColor: {
        light: "rgba(191, 230, 226, .2)",
        dark: "rgba(191, 230, 226, .2)"
      }
    };
    const canvasOptions = {
      opacity: 1,
      zIndex: this.zIndex
    };
    const meteor = new et$1(themeConfig, canvasOptions);
    const el = this.$refs.canvas;
    meteor.mount(el);
  }
};
const _hoisted_1$6 = {
  ref: "canvas",
  id: "theme-meteor"
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "canvas",
    _hoisted_1$6,
    null,
    512
    /* NEED_PATCH */
  );
}
const Meteor = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$8], ["__file", "Meteor.vue"]]);
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string")
    throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(r$2(x2, 2), 16)), parseInt(r$2(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h2, s2, l2, a2] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s2) !== s2)
      throw new ColorError$1(color);
    if (guard(0, 100, l2) !== l2)
      throw new ColorError$1(color);
    return [...hslToRgb(h2, s2, l2), Number.isNaN(a2) ? 1 : a2];
  }
  throw new ColorError$1(color);
}
function hash(str) {
  let hash2 = 5381;
  let i3 = str.length;
  while (i3) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i3);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt = (x2) => parseInt(x2.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16);
  let prefix = "";
  for (let i3 = 0; i3 < 6 - hex.length; i3++) {
    prefix += "0";
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color);
  return `#${result}`;
}
const r$2 = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
const reducedHexRegex = new RegExp(`^#${r$2("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex = new RegExp(`^#${r$2("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r$2(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color) => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l2 = lightness / 100;
  if (saturation === 0) {
    return [l2, l2, l2].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l2 - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l2 - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function rgba(red, green, blue, alpha) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}
function transparentize(color, amount) {
  const [r2, g2, b2, a2] = parseToRgba(color);
  return rgba(r2, g2, b2, a2 - amount);
}
function opacify(color, amount) {
  return transparentize(color, -amount);
}
var J$1 = (n2, t2, s2) => {
  if (!t2.has(n2))
    throw TypeError("Cannot " + s2);
};
var i$1 = (n2, t2, s2) => (J$1(n2, t2, "read from private field"), s2 ? s2.call(n2) : t2.get(n2)), h$1 = (n2, t2, s2) => {
  if (t2.has(n2))
    throw TypeError("Cannot add the same private member more than once");
  t2 instanceof WeakSet ? t2.add(n2) : t2.set(n2, s2);
}, e = (n2, t2, s2, p2) => (J$1(n2, t2, "write to private field"), p2 ? p2.call(n2, s2) : t2.set(n2, s2), s2);
var l$1 = (n2, t2, s2) => (J$1(n2, t2, "access private method"), s2);
function ai(n2, t2, s2) {
  return (n2 - t2) / (s2 - t2);
}
var y$2, w$1, b$2, x$1, g$2, A$1, S$2, F$1, k$1, c$1;
class ri {
  constructor(t2 = 0, s2 = {
    x: 0,
    y: 0
  }, p2 = i$2.randomInt(50, 500), f2 = i$2.randomInt(40, 100), V2 = i$2.randomFloat(0, Math.PI * 2), j2 = i$2.randomInt(1, 3), G2 = i$2.choice(["yellow", "pink", "red", "orange", "purple", "cyan"])) {
    h$1(this, y$2, void 0);
    h$1(this, w$1, void 0);
    h$1(this, b$2, void 0);
    h$1(this, x$1, void 0);
    h$1(this, g$2, void 0);
    h$1(this, A$1, void 0);
    h$1(this, S$2, void 0);
    h$1(this, F$1, void 0);
    h$1(this, k$1, 1);
    h$1(this, c$1, void 0);
    e(this, y$2, t2), e(this, w$1, s2), e(this, b$2, p2), e(this, x$1, f2), e(this, g$2, V2), e(this, A$1, j2), e(this, S$2, G2), e(this, F$1, {
      x: Math.cos(i$1(this, g$2)) * i$1(this, x$1),
      y: Math.sin(i$1(this, g$2)) * i$1(this, x$1)
    }), e(this, c$1, {
      ...i$1(this, w$1)
    });
  }
  move(t2) {
    const s2 = ai(t2, i$1(this, y$2), i$1(this, y$2) + i$1(this, b$2));
    i$1(this, c$1).x = i$1(this, w$1).x + i$1(this, F$1).x * s2, i$1(this, c$1).y = i$1(this, w$1).y + i$1(this, F$1).y * s2, e(this, k$1, 1 - s2);
  }
  draw(t2, s2) {
    t2.fillStyle = opacify(i$1(this, S$2), i$1(this, k$1)), t2.beginPath(), t2.arc(i$1(this, c$1).x, i$1(this, c$1).y, i$1(this, A$1), 0, Math.PI * 2), t2.fill();
  }
  shouldRemove(t2) {
    return t2 > i$1(this, y$2) + i$1(this, b$2);
  }
}
y$2 = /* @__PURE__ */ new WeakMap(), w$1 = /* @__PURE__ */ new WeakMap(), b$2 = /* @__PURE__ */ new WeakMap(), x$1 = /* @__PURE__ */ new WeakMap(), g$2 = /* @__PURE__ */ new WeakMap(), A$1 = /* @__PURE__ */ new WeakMap(), S$2 = /* @__PURE__ */ new WeakMap(), F$1 = /* @__PURE__ */ new WeakMap(), k$1 = /* @__PURE__ */ new WeakMap(), c$1 = /* @__PURE__ */ new WeakMap();
var li = /* @__PURE__ */ ((n2) => (n2.FOLLOW = "follow", n2.TRAIL = "trail", n2))(li || {}), D$1, X$1, o$1, P$1, R$1, z$1, Y, u$2, m$2, a$1, I, v$2, M2, r$1, E$2, $, T$1, C$2, B$1, K$1, H$1, Q$1, L$2, Z$1, O$1, _$1, W$2, N, U$1, ii;
class fi {
  constructor({
    mode: t2 = "trail",
    numParticles: s2 = 20,
    sparkleFactor: p2 = 1,
    particleDurationRange: f2 = [50, 500],
    particleDistanceRange: V2 = [40, 100],
    particleSizeRange: j2 = [1, 3]
  } = {}, G2 = {}) {
    h$1(this, E$2);
    h$1(this, T$1);
    h$1(this, B$1);
    h$1(this, H$1);
    h$1(this, L$2);
    h$1(this, O$1);
    h$1(this, W$2);
    h$1(this, U$1);
    h$1(this, D$1, void 0);
    h$1(this, X$1, void 0);
    h$1(this, o$1, void 0);
    h$1(this, P$1, void 0);
    h$1(this, R$1, void 0);
    h$1(this, z$1, void 0);
    h$1(this, Y, void 0);
    h$1(this, u$2, null);
    h$1(this, m$2, /* @__PURE__ */ new Set());
    h$1(this, a$1, null);
    h$1(this, I, void 0);
    h$1(this, v$2, false);
    h$1(this, M2, false);
    h$1(this, r$1, new M$2());
    e(this, D$1, t2), e(this, X$1, s2), e(this, o$1, p2), e(this, P$1, f2), e(this, R$1, V2), e(this, z$1, j2), e(this, I, i$1(this, o$1)), e(this, Y, G2), this.animate = this.animate.bind(this);
  }
  mount(t2) {
    e(this, M2, false), e(this, u$2, new y$4(t2, window.innerWidth, window.innerHeight, true, true, i$1(this, Y))), l$1(this, E$2, $).call(this), v$4("Theme Sparkler 🎇", {
      leftBgColor: "#989900"
    });
  }
  unmount() {
    l$1(this, T$1, C$2).call(this), e(this, M2, true), e(this, a$1, null);
  }
  animate(t2) {
    if (i$1(this, M2)) {
      i$1(this, u$2).clear();
      return;
    }
    if (requestAnimationFrame(this.animate), !i$1(this, v$2)) {
      for (const s2 of i$1(this, m$2))
        s2.move(t2);
      for (i$1(this, u$2).draw((s2, p2) => {
        for (const f2 of i$1(this, m$2))
          f2.draw(s2, t2), f2.shouldRemove(t2) && i$1(this, m$2).delete(f2);
      }), i$1(this, u$2).render(); i$1(this, m$2).size < i$1(this, X$1); )
        i$1(this, m$2).add(new ri(t2 + i$2.randomInt(0, 300 / i$1(this, o$1)), i$1(this, D$1) === "trail" ? {
          ...i$1(this, a$1)
        } : i$1(this, a$1), i$2.randomFloat(i$1(this, P$1)[0], i$1(this, P$1)[1] / i$1(this, o$1)), i$2.randomFloat(i$1(this, R$1)[0], i$1(this, R$1)[1] * (i$1(this, o$1) === 1 ? 1 : i$1(this, o$1) / 3)), i$2.randomFloat(0, Math.PI * 2), i$2.randomInt(i$1(this, z$1)[0], i$1(this, z$1)[1] * (i$1(this, o$1) === 1 ? 1 : i$1(this, o$1) / 3)), i$2.choice(["yellow", "pink", "red", "orange", "purple", "cyan"])));
    }
  }
}
D$1 = /* @__PURE__ */ new WeakMap(), X$1 = /* @__PURE__ */ new WeakMap(), o$1 = /* @__PURE__ */ new WeakMap(), P$1 = /* @__PURE__ */ new WeakMap(), R$1 = /* @__PURE__ */ new WeakMap(), z$1 = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), u$2 = /* @__PURE__ */ new WeakMap(), m$2 = /* @__PURE__ */ new WeakMap(), a$1 = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), v$2 = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), r$1 = /* @__PURE__ */ new WeakMap(), E$2 = /* @__PURE__ */ new WeakSet(), $ = function() {
  g$4() ? (i$1(this, r$1).add("touchstart", l$1(this, L$2, Z$1).bind(this)), i$1(this, r$1).add("touchmove", l$1(this, H$1, Q$1).bind(this)), i$1(this, r$1).add("touchend", l$1(this, O$1, _$1).bind(this))) : (i$1(this, r$1).add("mousedown", l$1(this, L$2, Z$1).bind(this)), i$1(this, r$1).add("mousemove", l$1(this, H$1, Q$1).bind(this)), i$1(this, r$1).add("mouseup", l$1(this, O$1, _$1).bind(this))), i$1(this, r$1).add("visibilitychange", l$1(this, U$1, ii).bind(this)), i$1(this, r$1).add("resize", r$6(l$1(this, W$2, N).bind(this), 500)), i$1(this, r$1).startAll();
}, T$1 = /* @__PURE__ */ new WeakSet(), C$2 = function() {
  i$1(this, r$1).stopAll(), i$1(this, r$1).clear();
}, B$1 = /* @__PURE__ */ new WeakSet(), K$1 = function() {
  requestAnimationFrame(this.animate);
}, H$1 = /* @__PURE__ */ new WeakSet(), Q$1 = function(t2) {
  const s2 = {
    x: w$3(t2) ? t2.touches[0].clientX : t2.clientX,
    y: w$3(t2) ? t2.touches[0].clientY : t2.clientY
  };
  if (!i$1(this, a$1)) {
    e(this, a$1, {
      x: s2.x,
      y: s2.y
    }), l$1(this, B$1, K$1).call(this);
    return;
  }
  i$1(this, a$1).x = s2.x, i$1(this, a$1).y = s2.y;
}, L$2 = /* @__PURE__ */ new WeakSet(), Z$1 = function(t2) {
  const s2 = {
    x: w$3(t2) ? t2.touches[0].clientX : t2.clientX,
    y: w$3(t2) ? t2.touches[0].clientY : t2.clientY
  };
  i$1(this, a$1) || (e(this, a$1, {
    x: s2.x,
    y: s2.y
  }), l$1(this, B$1, K$1).call(this)), i$1(this, a$1).x = s2.x, i$1(this, a$1).y = s2.y, i$1(this, o$1) === i$1(this, I) && e(this, o$1, i$1(this, o$1) * 4);
}, O$1 = /* @__PURE__ */ new WeakSet(), _$1 = function(t2) {
  e(this, o$1, i$1(this, I));
}, W$2 = /* @__PURE__ */ new WeakSet(), N = function(t2) {
  i$1(this, u$2).handleResize(t2);
}, U$1 = /* @__PURE__ */ new WeakSet(), ii = function(t2) {
  e(this, v$2, document.hidden);
};
({
  name: "Sparkler",
  props: {
    mode: {
      type: String,
      default: li.TRAIL
    },
    numParticles: {
      type: Number,
      default: 20
    },
    zIndex: {
      type: Number,
      default: C$4
    }
  },
  mounted() {
    const themeConfig = {
      mode: this.mode,
      numParticles: this.numParticles
    };
    const canvasOptions = {
      opacity: 0.6,
      zIndex: this.zIndex
    };
    const sparkler = new fi(themeConfig, canvasOptions);
    const el = this.$refs.canvas;
    sparkler.mount(el);
  }
});
const _sfc_main$9 = {
  props: {
    transitionName: {
      type: String,
      default: "fade"
    },
    textList: {
      type: Array,
      required: true
    },
    duration: {
      type: [Number, Array],
      default: 0
    }
  },
  emits: {
    tick: () => true,
    loop: () => true,
    over: () => true
  },
  setup(props) {
    const index2 = ref(0);
    const {
      textList,
      duration
    } = toRefs(props);
    const period = ref(null);
    const resDuration = computed(() => {
      const d2 = duration.value;
      if (typeof d2 === "number" && d2 <= 0 || Array.isArray(d2) && !d2.length)
        return textList.value.map((txt) => Math.log2((txt.length || 1) + 1) * 0.8);
      return d2;
    });
    const curDuration = computed(() => {
      const d2 = resDuration.value, i3 = index2.value;
      if (typeof d2 === "number")
        return d2;
      else {
        const dlen = d2.length;
        return d2[Math.min(i3, dlen - 1)];
      }
    });
    const curDurationStr = computed(() => {
      return `${curDuration.value}s`;
    });
    return {
      index: index2,
      period,
      curDuration,
      curDurationStr
    };
  },
  mounted() {
    this.start();
  },
  methods: {
    start() {
      const len = this.textList.length;
      const tick = () => {
        this.clear(false);
        this.$emit("tick");
        if (this.index + 1 >= len) {
          this.$emit("loop");
        }
        this.index = (this.index + 1) % len;
        this.period = setTimeout(tick, this.curDuration * 1e3);
      };
      this.index = 0;
      this.period = setTimeout(tick, this.curDuration * 1e3);
    },
    clear(emit = true) {
      if (this.period) {
        clearTimeout(this.period);
      }
      if (emit) {
        this.$emit("over");
      }
    }
  }
};
const AnimatedText_vue_vue_type_style_index_0_scoped_1ac80f97_lang = "";
const _hoisted_1$5 = {
  class: "trs-text"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: $props.transitionName,
    style: normalizeStyle({
      "--dura": $setup.curDurationStr
    })
  }, {
    default: withCtx(() => [(openBlock(), createElementBlock("div", {
      class: "animated-text",
      key: $setup.index
    }, [createElementVNode(
      "div",
      _hoisted_1$5,
      toDisplayString($props.textList[$setup.index]),
      1
      /* TEXT */
    )]))]),
    _: 1
    /* STABLE */
  }, 8, ["name", "style"]);
}
const AnimatedText = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$7], ["__scopeId", "data-v-1ac80f97"], ["__file", "AnimatedText.vue"]]);
const _hoisted_1$4 = {
  key: 0,
  class: "banner-brand__mask"
};
const _hoisted_2$2 = {
  key: 3,
  class: "banner-brand__content"
};
const _hoisted_3$2 = {
  class: "banner-brand__hero-image"
};
const _hoisted_4$1 = ["src"];
const _hoisted_5$1 = {
  key: 0,
  class: "banner-brand__hero-tagline"
};
const _hoisted_6$1 = {
  class: "typing-text"
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "MyBanner",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    const isPC = ref(false);
    const animatedText = ref(["江作青罗带 山如碧玉簪", "美如画廊的峰丛\n却是饱受石穿之灾的大地", "「八树」缠根此间\n汲走流洪 化解石荒", "歌舞升平间\n危机悄然降临", "你又该如何去守护\n这即将被溶没的音符呢？"]);
    const kana = ref(["ハッ", "ケイ", "せ", "かい", "の", "うた", "ひめ"]);
    const pinyin = ref(["Bā", "Guì", "Shì", "Jiè", "De", "Gē", "Jī"]);
    const bg = ref();
    const bgHeight = ref(0);
    const bgfar = ref();
    const bgnear = ref();
    const mode = ref(null);
    const animationOver = ref(false);
    onBeforeMount(() => {
      isPC.value = isMobile(window) === false;
    });
    const bgMove = (e2, [fwr, fhr] = [5e-3, 4e-3], [nwr, nhr] = [0.02, 0.012]) => {
      if (!bgfar.value || !bgnear.value)
        return;
      if (!inViewport(bgfar.value) && !inViewport(bgnear.value))
        return;
      const {
        pageX: x2,
        pageY: y3
      } = e2;
      const {
        x: fx,
        y: fy,
        width: fw,
        height: fh
      } = getAbsolutePos(bgfar.value);
      const {
        x: nx,
        y: ny,
        width: nw,
        height: nh
      } = getAbsolutePos(bgnear.value);
      const ftx = (x2 - fx - fw / 2) * fwr, fty = (y3 - fy - fh / 2) * fhr;
      const ntx = (x2 - nx - nw / 2) * nwr, nty = (y3 - ny - nh / 2) * nhr;
      bgfar.value.style.setProperty("--tl", `translate(${ftx}px, ${fty}px)`);
      bgnear.value.style.setProperty("--tl", `translate(${ntx}px, ${nty}px)`);
    };
    const onMouseMove = throttle$1((e2) => bgMove(e2, [5e-3, 4e-3], [0.02, 0.012]), 100);
    onMounted(() => {
      document.body.classList.add("scroll-fixed", "touch-none");
      watch(animationOver, (over) => {
        over ? document.body.classList.remove("scroll-fixed", "touch-none") : document.body.classList.add("scroll-fixed", "touch-none");
      });
      const toggleBtns = document.querySelectorAll(".btn-toggle-dark-mode");
      mode.value = localStorage.getItem(APPEARANCE_KEY);
      toggleBtns.forEach((e2) => e2.addEventListener("click", () => {
        const event = new StorageEvent("toggleMode", {
          newValue: localStorage.getItem(APPEARANCE_KEY)
        });
        window.dispatchEvent(event);
      }));
      window.addEventListener("toggleMode", (e2) => {
        mode.value = e2.newValue;
      });
      bgHeight.value = getAbsolutePos(bg.value).height;
      window.addEventListener("resize", () => {
        bgHeight.value = getAbsolutePos(bg.value).height;
      });
      if (isPC.value) {
        window.addEventListener("mousemove", onMouseMove);
      }
    });
    onUnmounted(() => {
      if (isPC.value) {
        window.removeEventListener("mousemove", onMouseMove);
      }
    });
    const isDarkMode = computed(() => {
      if (!mode.value || mode.value === "auto") {
        return window.matchMedia(PREFER_SCHEME_MEDIAKEY).matches;
      }
      return mode.value === "dark";
    });
    const heroImage = computed(() => {
      var _a3, _b2, _c, _d;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroImage) ? withBase((_d = (_c = frontmatter.value) == null ? void 0 : _c.banner) == null ? void 0 : _d.heroImage) : void 0;
    });
    const heroImageStyle = computed(() => frontmatter.value.banner.heroImageStyle || {});
    const bgImageStyle = computed(() => {
      var _a3;
      const {
        bgImageStyle: bgImageStyle2,
        bgImage,
        bgImageDark
      } = ((_a3 = frontmatter.value) == null ? void 0 : _a3.banner) || {};
      const image = isDarkMode.value && bgImageDark ? bgImageDark : bgImage;
      const asImage = (layer) => image.replace(".", "-" + layer + ".");
      const initBgImageStyle = image ? {
        textAlign: "center",
        overflow: "hidden",
        "--background": `url(${withBase(image)})`,
        "--background-sky": `url(${withBase(asImage("sky"))})`,
        "--background-far": `url(${withBase(asImage("far"))})`,
        "--background-near": `url(${withBase(asImage("near"))})`
      } : {};
      return bgImageStyle2 ? {
        ...initBgImageStyle,
        ...bgImageStyle2
      } : initBgImageStyle;
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f;
      const _component_xicons = resolveComponent("xicons");
      return openBlock(), createElementBlock(
        "section",
        {
          ref_key: "bg",
          ref: bg,
          class: normalizeClass(["banner-wrapper", {
            pc: isPC.value
          }]),
          style: normalizeStyle(bgImageStyle.value)
        },
        [isPC.value ? (openBlock(), createElementBlock(
          "div",
          {
            key: 0,
            ref_key: "bgfar",
            ref: bgfar,
            class: "banner-bg far"
          },
          null,
          512
          /* NEED_PATCH */
        )) : createCommentVNode("v-if", true), isPC.value ? (openBlock(), createElementBlock(
          "div",
          {
            key: 1,
            ref_key: "bgnear",
            ref: bgnear,
            class: "banner-bg near"
          },
          null,
          512
          /* NEED_PATCH */
        )) : createCommentVNode("v-if", true), createVNode(Transition, {
          name: "fade-slowly"
        }, {
          default: withCtx(() => [!animationOver.value ? (openBlock(), createElementBlock("div", _hoisted_1$4, [createVNode(_component_xicons, {
            icon: "Redo",
            class: "skip-btn",
            "text-size": 15,
            onClick: _cache[0] || (_cache[0] = ($event) => animationOver.value = true)
          }, {
            default: withCtx(() => [createTextVNode(" 跳过 ")]),
            _: 1
            /* STABLE */
          })])) : createCommentVNode("v-if", true)]),
          _: 1
          /* STABLE */
        }), !animationOver.value ? (openBlock(), createBlock(AnimatedText, {
          key: 2,
          class: "banner-brand__animated-text",
          "text-list": animatedText.value,
          onLoop: _cache[1] || (_cache[1] = ($event) => animationOver.value = true)
        }, null, 8, ["text-list"])) : (openBlock(), createElementBlock("div", _hoisted_2$2, [createElementVNode("div", _hoisted_3$2, [heroImage.value ? (openBlock(), createElementBlock("img", {
          key: 0,
          src: heroImage.value,
          style: normalizeStyle(heroImageStyle.value),
          alt: "heroImage"
        }, null, 12, _hoisted_4$1)) : createCommentVNode("v-if", true)]), createElementVNode("div", null, [createVNode(HeroText, {
          text: (_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroText,
          "dark-mode": isDarkMode.value,
          ruby: {
            light: pinyin.value,
            dark: kana.value
          }
        }, null, 8, ["text", "dark-mode", "ruby"]), ((_d = (_c = unref(frontmatter)) == null ? void 0 : _c.banner) == null ? void 0 : _d.tagline) ? (openBlock(), createElementBlock("p", _hoisted_5$1, [createElementVNode(
          "div",
          _hoisted_6$1,
          toDisplayString((_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.banner) == null ? void 0 : _f.tagline),
          1
          /* TEXT */
        )])) : createCommentVNode("v-if", true)]), createVNode(DownIcon, {
          "scroll-to": bgHeight.value
        }, null, 8, ["scroll-to"])])), isDarkMode.value ? (openBlock(), createBlock(unref(Meteor), {
          key: 4,
          "num-particles": isPC.value ? null : 15,
          "z-index": 3
        }, null, 8, ["num-particles"])) : createCommentVNode("v-if", true), createVNode(unref(WindBase), null, {
          default: withCtx(({
            strength,
            direction: direction2
          }) => [!isDarkMode.value ? (openBlock(), createBlock(unref(Flowers), {
            key: 0,
            "wind-strength": strength,
            "wind-angle": direction2
          }, null, 8, ["wind-strength", "wind-angle"])) : createCommentVNode("v-if", true)]),
          _: 1
          /* STABLE */
        })],
        6
        /* CLASS, STYLE */
      );
    };
  }
});
const MyBanner_vue_vue_type_style_index_0_lang = "";
const MyBanner = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__file", "MyBanner.vue"]]);
const _sfc_main$7 = {
  props: {
    show: {
      type: Boolean,
      default: true
    }
  }
};
const MidText_vue_vue_type_style_index_0_scoped_05cc4695_lang = "";
const _withScopeId = (n2) => (pushScopeId("data-v-05cc4695"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3 = {
  class: "sup",
  key: "sup"
};
const _hoisted_2$1 = {
  class: "title",
  key: "title"
};
const _hoisted_3$1 = {
  class: "content",
  key: "content"
};
const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  [/* @__PURE__ */ createTextVNode("OC: 一个以壮侗系文化为背景的二次元幻想世界"), /* @__PURE__ */ createElementVNode("span", {
    class: "mark"
  }, " ×")],
  -1
  /* HOISTED */
));
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  [/* @__PURE__ */ createTextVNode("一些关于壮侗文化风格的见闻和研究"), /* @__PURE__ */ createElementVNode("span", {
    class: "mark"
  }, " ×")],
  -1
  /* HOISTED */
));
const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  [/* @__PURE__ */ createTextVNode("一些前后端应用和游戏开发技术心得"), /* @__PURE__ */ createElementVNode("span", {
    class: "mark"
  }, " ×")],
  -1
  /* HOISTED */
));
const _hoisted_7 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  [/* @__PURE__ */ createTextVNode("一些板绘渣作练习"), /* @__PURE__ */ createElementVNode("span", {
    class: "mark"
  }, " ×")],
  -1
  /* HOISTED */
));
const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  [/* @__PURE__ */ createTextVNode("一点随心的想法与脑洞、还有牢骚"), /* @__PURE__ */ createElementVNode("span", {
    class: "mark"
  }, " ×")],
  -1
  /* HOISTED */
));
const _hoisted_9 = [_hoisted_4, _hoisted_5, _hoisted_6, _hoisted_7, _hoisted_8];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    name: "fade-right-in"
  }, {
    default: withCtx(() => [$props.show ? (openBlock(), createElementBlock("div", _hoisted_1$3, " 欢迎来到我的个人博客！ ")) : createCommentVNode("v-if", true), $props.show ? (openBlock(), createElementBlock("div", _hoisted_2$1, " 在这里，你将了解到 ")) : createCommentVNode("v-if", true), $props.show ? (openBlock(), createElementBlock("ul", _hoisted_3$1, _hoisted_9)) : createCommentVNode("v-if", true)]),
    _: 1
    /* STABLE */
  });
}
const MidText = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$6], ["__scopeId", "data-v-05cc4695"], ["__file", "MidText.vue"]]);
const _hoisted_1$2 = ["src"];
const _hoisted_2 = ["src"];
const _hoisted_3 = {
  class: "mid-banner__content"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "MidBanner",
  setup(__props) {
    const imageCache = useImageCache();
    const wrapperRef = ref(null);
    const back0x = ref(-200);
    const back1x = ref(350);
    const back2x = ref(500);
    const back3x = ref(1e3);
    const back4x = ref(-1100);
    const groundx = ref(0);
    const towerbr = ref(100);
    const lighto = ref(0.5);
    const showContent = ref(false);
    const nana = reactive({
      index: 0,
      tx: -280,
      opacity: 1
    });
    const nanaImg = computed(() => {
      return imageCache[`/images/Ma-${nana.index}.png`].value;
    });
    const tianjiu = reactive({
      tx: -120,
      opacity: 1
    });
    const tianjiuImg = computed(() => {
      return imageCache["/images/Tianjiu_0.png"].value;
    });
    const normalize = (x2, max2, min2 = 0) => (x2 - min2) / (max2 - min2);
    let itv = null;
    let stop = false;
    function onScroll(e2) {
      if (wrapperRef.value === null || !inViewport(wrapperRef.value))
        return;
      const {
        floor: f2,
        min: min2
      } = Math;
      const {
        y: y3,
        height
      } = getAbsolutePos(wrapperRef.value);
      const scroll = this.scrollY + this.innerHeight;
      const init = y3, dest = y3 + height;
      const diff = scroll - y3;
      const rate = 1 - normalize(diff, dest - init);
      if (rate > 0 && rate < 1) {
        back0x.value = f2(-200 - 150 * rate ** 1.5);
        back1x.value = f2(350 - 300 * rate ** 1.5);
        back2x.value = f2(500 - 450 * rate ** 1.5);
        back3x.value = f2(1e3 - 600 * rate ** 1.5);
        back4x.value = f2(-1100 + 800 * rate ** 1.5);
        towerbr.value = f2(100 - rate * 95);
        lighto.value = f2(0.5 - rate * 0.5);
      }
      showContent.value = rate < 0.2;
      if (rate > 0 && !stop) {
        nana.tx = f2(-280 - 800 * rate);
        nana.opacity = 1 - rate;
        showContent.value = false;
      } else {
        stop = true;
        if (itv)
          setTimeout(() => {
            itv && clearInterval(itv);
            itv = null;
            nana.index = 0;
          }, 2e3);
      }
    }
    onMounted(() => {
      window.addEventListener("scroll", onScroll);
      itv = setInterval(() => nana.index = (nana.index + 1) % 5, 300);
    });
    onUnmounted(() => {
      window.removeEventListener("scroll", onScroll);
      if (itv)
        clearInterval(itv);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "section",
        {
          ref_key: "wrapperRef",
          ref: wrapperRef,
          class: "mid-banner-wrapper",
          style: normalizeStyle({
            "--tx": `${back0x.value}px`
          })
        },
        [createElementVNode(
          "div",
          {
            class: "mid-banner__bg back1",
            style: normalizeStyle({
              "--tx": `${back1x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg back2",
            style: normalizeStyle({
              "--tx": `${back2x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg tower",
            style: normalizeStyle({
              "--ft": `${towerbr.value}%`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg back3",
            style: normalizeStyle({
              "--tx": `${back3x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg back4",
            style: normalizeStyle({
              "--tx": `${back4x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg light",
            style: normalizeStyle({
              "--o": `${lighto.value}%`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg ground",
            style: normalizeStyle({
              "--tx": `${groundx.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode("img", {
          class: "mid-banner__char nana",
          src: nanaImg.value,
          style: normalizeStyle({
            "--tx": `${nana.tx}px`,
            "--o": nana.opacity
          })
        }, null, 12, _hoisted_1$2), createElementVNode("img", {
          class: "mid-banner__char tianjiu",
          src: tianjiuImg.value,
          style: normalizeStyle({
            "--tx": `${tianjiu.tx}px`,
            "--o": tianjiu.opacity
          })
        }, null, 12, _hoisted_2), createElementVNode("div", _hoisted_3, [createVNode(MidText, {
          show: showContent.value
        }, null, 8, ["show"])])],
        4
        /* STYLE */
      );
    };
  }
});
const MidBanner_vue_vue_type_style_index_0_scoped_2d6b37a5_lang = "";
const MidBanner = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__scopeId", "data-v-2d6b37a5"], ["__file", "MidBanner.vue"]]);
const _sfc_main$5 = {
  components: {
    Xicons
  },
  name: "Message",
  props: {
    text: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      // warn 警告  error 错误  success 成功 info 消息
      default: "warn"
    },
    delay: {
      type: Number,
      default: 3e3
    }
  },
  setup() {
    const style2 = {
      info: {
        icon: "Information"
      },
      warn: {
        icon: "Warning",
        color: "#E6A23C",
        backgroundColor: "rgb(253, 246, 236)",
        borderColor: "rgb(250, 236, 216)"
      },
      error: {
        icon: "Error",
        color: "#F56C6C",
        backgroundColor: "rgb(254, 240, 240)",
        borderColor: "rgb(253, 226, 226)"
      },
      success: {
        icon: "CheckmarkOutline",
        color: "#67C23A",
        backgroundColor: "rgb(240, 249, 235)",
        borderColor: "rgb(225, 243, 216)"
      }
    };
    const visible = ref(false);
    return {
      style: style2,
      visible
    };
  },
  mounted() {
    this.visible = true;
    let timeout = setTimeout(() => {
      this.visible = false;
      clearTimeout(timeout);
    }, this.delay - 200);
  }
};
const Message_vue_vue_type_style_index_0_scoped_d438ee3c_lang = "";
const _hoisted_1$1 = {
  class: "text"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [createCommentVNode(" vue动画：从上滑入且淡出 "), createVNode(Transition, {
      name: "down",
      persisted: ""
    }, {
      default: withCtx(() => [withDirectives(createElementVNode(
        "div",
        {
          ref: "message",
          class: "message",
          style: normalizeStyle({
            ...$setup.style[$props.type]
          })
        },
        [createCommentVNode(" 不同提示图标会变 "), createVNode(_component_xicons, {
          class: "iconfont",
          icon: $setup.style[$props.type].icon
        }, null, 8, ["icon"]), createElementVNode(
          "span",
          _hoisted_1$1,
          toDisplayString($props.text),
          1
          /* TEXT */
        )],
        4
        /* STYLE */
      ), [[vShow, $setup.visible]])]),
      _: 1
      /* STABLE */
    })],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const Message$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-d438ee3c"], ["__file", "Message.vue"]]);
const Message = ({
  type: type2,
  text: text2,
  delay: delay2 = 3e3
}) => {
  let container = document.getElementById("message-group");
  if (!container) {
    container = document.createElement("div");
    container.setAttribute("id", "message-group");
    document.body.appendChild(container);
  }
  const div = document.createElement("div");
  div.setAttribute("class", "message-container");
  container.appendChild(div);
  let timer = null;
  const vnode = createVNode(Message$1, {
    type: type2,
    text: text2,
    delay: delay2
  });
  render(vnode, div);
  timer && clearTimeout(timer);
  timer = setTimeout(() => {
    render(null, div);
    container == null ? void 0 : container.removeChild(div);
  }, delay2);
};
const Tooltip_vue_vue_type_style_index_0_scoped_bb385077_lang = "";
const _sfc_main = {
  setup() {
    const tooltipShow = ref(false);
    const text2 = ref();
    const placements2 = ref("left");
    function showTip() {
      tooltipShow.value = true;
    }
    function hiddenTip() {
      tooltipShow.value = false;
    }
    const tooltipPostiton = ref({
      x: 0,
      y: 0
    });
    const tooltipStyle = computed(() => {
      return {
        transform: `translate3d(${tooltipPostiton.value.x}px,${tooltipPostiton.value.y}px,0)`
      };
    });
    return {
      tooltipShow,
      showTip,
      hiddenTip,
      tooltipPostiton,
      tooltipStyle,
      text: text2,
      placements: placements2
    };
  }
};
const _hoisted_1 = ["innerHTML"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [createCommentVNode(" 指示 "), createVNode(Transition, {
      name: "tooltip",
      persisted: ""
    }, {
      default: withCtx(() => [withDirectives(createElementVNode(
        "div",
        {
          class: "zc-tooltip",
          style: normalizeStyle($setup.tooltipStyle)
        },
        [createElementVNode("span", {
          class: "zc-tooltip-text",
          innerHTML: $setup.text
        }, null, 8, _hoisted_1), createElementVNode(
          "div",
          {
            class: normalizeClass(["zc-tooltip-arrow", [{
              "left": $setup.placements == "left"
            }, {
              "bottom": $setup.placements == "bottom"
            }, {
              "right": $setup.placements == "right"
            }, {
              "top": $setup.placements == "top"
            }]])
          },
          null,
          2
          /* CLASS */
        )],
        4
        /* STYLE */
      ), [[vShow, $setup.tooltipShow]])]),
      _: 1
      /* STABLE */
    })],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const Tooltip$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-bb385077"], ["__file", "Tooltip.vue"]]);
function node() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
function tokenFun() {
  return node() + node() + node();
}
function clearEvent(el) {
  if (el._tipHandler) {
    el.removeEventListener("mouseenter", el._tipHandler);
  }
  if (el._tipMouseleaveHandler) {
    el.removeEventListener("mouseleave", el._tipMouseleaveHandler);
  }
  delete el._tipHandler;
  delete el._tipMouseleaveHandler;
  delete el._tipOptions;
  delete el._tipInstance;
}
function calculationLocation(el, target, placements2) {
  if (!el || !target)
    return;
  el.tooltipPostiton.y = 0;
  el.tooltipPostiton.x = 0;
  let el_dom = el.$el.nextElementSibling.getBoundingClientRect();
  let target_dom = target.getBoundingClientRect();
  if (placements2 === "left") {
    el.tooltipPostiton.x = target_dom.x - el_dom.width - 10;
    el.tooltipPostiton.y = target_dom.y - el_dom.height / 2 + target_dom.height / 2;
  } else if (placements2 === "bottom") {
    el.tooltipPostiton.x = target_dom.x + target_dom.width / 2 - el_dom.width / 2;
    el.tooltipPostiton.y = target_dom.y + el_dom.height + 10;
  } else if (placements2 === "right") {
    el.tooltipPostiton.x = target_dom.x + target_dom.width + 10;
    el.tooltipPostiton.y = target_dom.y - el_dom.height / 2 + target_dom.height / 2;
  } else if (placements2 === "top") {
    el.tooltipPostiton.x = target_dom.x + target_dom.width / 2 - el_dom.width / 2;
    el.tooltipPostiton.y = target_dom.y - el_dom.height - 10;
  }
}
const allPlacements = ["left", "bottom", "right", "top"];
const Tooltip = {
  install(app) {
    app.directive("tooltip", {
      mounted(el, binding) {
        clearEvent(el);
        el._tipOptions = binding.value;
        el._tipHandler = () => {
          const limitPlacementQueue = allPlacements.filter((placement) => binding.modifiers[placement]);
          const placements2 = limitPlacementQueue.length ? limitPlacementQueue : allPlacements;
          if (!el._tipInstance) {
            el._synopsis = createApp(Tooltip$1);
            el._root = document.createElement("div");
            document.body.appendChild(el._root);
            el._root.id = `tooltip_${tokenFun()}`;
            el._tipInstance = el._synopsis.mount(el._root);
          }
          el._tipInstance.placements = placements2[0];
          el._tipInstance.showTip();
          el._tipInstance.text = el._tipOptions;
          nextTick(() => {
            calculationLocation(el._tipInstance, el, placements2[0]);
          });
          el._scrollHandler = () => {
            if (el._tipInstance.tooltipShow)
              calculationLocation(el._tipInstance, el, placements2[0]);
          };
          window.addEventListener("scroll", el._scrollHandler);
        };
        el._tipMouseleaveHandler = () => {
          if (el._tipInstance) {
            el._tipInstance.hiddenTip();
          }
        };
        el.addEventListener("mouseenter", el._tipHandler);
        el.addEventListener("mouseleave", el._tipMouseleaveHandler);
      },
      updated(el, binding) {
        el._tipOptions = binding.value;
      },
      unmounted(el) {
        if (el._tipInstance) {
          el._synopsis.unmount();
          document.body.removeChild(el._root);
        }
        window.removeEventListener("scroll", el._scrollHandler);
      }
    });
  }
};
const qzoneSvg = '<svg t="1697206091997" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6494" width="18" height="18"><path d="M753.755136 657.139c-98.162688-7.774-196.35712-15.548-294.519808-23.321 5.306368-2.592 10.614784-5.181 15.919104-7.772 90.203136-64.772 180.436992-129.563 270.640128-194.335-5.306368 0-10.614784 0-15.921152 0-97.455104-42.083-397.549568-32.699-485.557248 7.772 116.732928 7.774 233.504768 15.547 350.237696 23.321-2.654208 5.181-5.306368 10.365-7.959552 15.546-95.511552 62.179-191.046656 124.381-286.558208 186.562 0 2.592 0 5.18 0 7.773 174.162944 23.443 364.192768 2.403 525.357056-15.547 0 2.592 0 5.182 0 7.773-5.30432 0-10.614784 0-15.919104 0-29.503488 23.218-34.161664 10.548-39.800832 62.188 13.26592 64.771 26.534912 129.563 39.800832 194.333-2.654208 2.595-5.306368 5.182-7.959552 7.773-10.611712 0-21.228544 0-31.84128 0-63.724544-53.829-178.624512-131.244-278.597632-139.921-82.246656 46.638-164.512768 93.285-246.759424 139.921-10.610688-5.179-21.228544-10.365-31.840256-15.545 18.57024-101.045 37.148672-202.121 55.719936-303.164-74.28608-67.363-148.59264-134.744-222.87872-202.107 1.789952-5.242 3.577856-10.483 5.366784-15.724 0.287744-0.844 0.576512-1.688 0.864256-2.531 0.576512-1.688 1.152-3.377 1.728512-5.065 98.162688-12.954 196.356096-25.913 294.518784-38.868 53.061632-93.273 106.138624-186.568 159.199232-279.842 5.306368 0 10.614784 0 15.921152 0 45.101056 95.862 90.217472 191.754 135.319552 287.616 103.467008 10.362 206.968832 20.731 310.436864 31.094 2.656256 5.181 5.306368 10.366 7.959552 15.546-74.285056 72.545-148.59264 145.11-222.877696 217.656C753.755136 631.226 753.755136 644.184 753.755136 657.139z" fill="currentColor" p-id="6495"></path></svg>';
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
const IN_BROWSER = typeof window !== "undefined";
function convertToUnit(str, unit = "px") {
  if (str == null || str === "")
    return void 0;
  else if (isNaN(+str))
    return String(str);
  else if (!isFinite(+str))
    return void 0;
  else
    return `${Number(str)}${unit}`;
}
const hasScrollbar = (el) => {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style2 = window.getComputedStyle(el);
  return ["auto", "scroll"].includes(style2.overflowY) && el.scrollHeight > el.clientHeight;
};
const shouldScroll = (el, delta) => {
  if (el.scrollTop === 0 && delta < 0)
    return true;
  return el.scrollTop + el.clientHeight === el.scrollHeight && delta > 0;
};
const noScrollableParent = (event, content) => {
  const path = event.composedPath();
  const delta = event.deltaY;
  for (let index2 = 0; index2 < path.length; index2++) {
    const el = path[index2];
    if (el === document)
      return true;
    if (el === document.documentElement)
      return true;
    if (el === content)
      return true;
    if (hasScrollbar(el))
      return shouldScroll(el, delta);
  }
  return true;
};
const getScrollbarWidth = () => {
  const container = document.createElement("div");
  container.style.visibility = "hidden";
  container.style.overflow = "scroll";
  const inner = document.createElement("div");
  container.appendChild(inner);
  document.body.appendChild(container);
  const scrollbarWidth = container.offsetWidth - inner.offsetWidth;
  document.body.removeChild(container);
  return scrollbarWidth;
};
const stack = ref([]);
function useStack(isActive) {
  const vm = getCurrentInstance();
  let scope;
  watch(isActive, (val) => {
    if (val) {
      scope = effectScope();
      scope.run(() => {
        stack.value.push(vm);
        onScopeDispose(() => {
          const idx = stack.value.indexOf(vm);
          stack.value.splice(idx, 1);
        });
      });
    } else {
      scope == null ? void 0 : scope.stop();
    }
  }, { immediate: true });
  const isTop = computed(() => {
    return toRaw(stack.value[stack.value.length - 1]) === vm;
  });
  return {
    isTop
  };
}
const overlays = ref([]);
const MIN_Z_INDEX = 1e3;
function useOverlay(isActive) {
  const id = getCurrentInstance().uid;
  const zIndex = ref(0);
  watch(isActive, (value) => {
    if (value) {
      overlays.value.push(id);
      zIndex.value = MIN_Z_INDEX + (overlays.value.indexOf(id) + 1) * 2;
    } else {
      overlays.value = overlays.value.filter((x2) => x2 !== id);
    }
  }, {
    immediate: true
  });
  return { zIndex };
}
const useLazyActivation = (baseState) => {
  const activatedOnce = ref(false);
  const active = ref(false);
  if (baseState.value) {
    activatedOnce.value = true;
    nextTick(() => {
      active.value = true;
    });
  }
  watch(baseState, (value) => {
    if (!activatedOnce.value) {
      activatedOnce.value = true;
      nextTick(() => {
        active.value = value;
      });
      return;
    }
    active.value = value;
  });
  return {
    activatedOnce,
    active
  };
};
const useScroll = ({
  overlay,
  content,
  contentActiveClass,
  fullscreen,
  contentFullscreenClass
}) => {
  if (!IN_BROWSER) {
    return {
      disableScroll: () => {
      },
      enableScroll: () => {
      }
    };
  }
  let disabled = false;
  let disableType;
  const eventListener = (event) => {
    if (event.target === overlay.value || event.target === document.body || noScrollableParent(event, content.value))
      event.preventDefault();
  };
  const scrollbarWidth = getScrollbarWidth();
  const zeroScrollBar = scrollbarWidth === 0;
  const disableScroll = () => {
    if (disabled)
      return;
    if (zeroScrollBar || fullscreen) {
      disableType = "byOverflow";
      document.documentElement.classList.add("overflow-y-hidden");
    } else {
      disableType = "byEvents";
      window.addEventListener("wheel", eventListener, {
        passive: false
      });
    }
    disabled = true;
  };
  const enableScroll = () => {
    if (!disabled)
      return;
    if (disableType === "byEvents") {
      window.removeEventListener("wheel", eventListener);
    } else if (disableType === "byOverflow") {
      const activeContentElements = document.getElementsByClassName(contentActiveClass);
      const activeFullscreenContentElements = document.getElementsByClassName(contentFullscreenClass);
      if (!zeroScrollBar && fullscreen && activeFullscreenContentElements.length === 1 || activeContentElements.length === 1)
        document.documentElement.classList.remove("overflow-y-hidden");
    }
    disabled = false;
  };
  return {
    disableScroll,
    enableScroll
  };
};
function useWindowEventListener(event, listener, options) {
  onMounted(() => {
    window.addEventListener(event, listener, options);
  });
  onUnmounted(() => {
    window.removeEventListener(event, listener);
  });
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const __default__$1 = defineComponent({
  name: "GDialogOverlay",
  props: {
    active: {
      type: Boolean,
      required: true
    },
    zIndex: {
      type: Number,
      required: true
    },
    background: {
      type: [Boolean, String],
      required: true
    },
    local: {
      type: Boolean,
      required: true
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const styles = computed(() => ({
      zIndex: props.zIndex - 1
    }));
    const activeProxy = ref(props.active);
    const deactivating = ref(false);
    watch(() => props.active, (value) => {
      deactivating.value = !value;
      if (value) {
        activeProxy.value = true;
        return;
      }
      nextTick(() => {
        activeProxy.value = false;
      });
    });
    const classes = computed(() => [
      "g-dialog-overlay",
      {
        "g-dialog-overlay--active": !deactivating.value,
        "g-dialog-overlay--local": props.local
      }
    ]);
    const computedBackground = computed(() => {
      if (typeof props.background === "string")
        return props.background;
      else if (props.background)
        return "var(--overlay-bg)";
      return "transparent";
    });
    const onClick = () => {
      emit("click");
    };
    return {
      activeProxy,
      styles,
      classes,
      computedBackground,
      onClick
    };
  }
});
const __injectCSSVars__$1 = () => {
  useCssVars((_ctx) => ({
    "6eaca59a": _ctx.computedBackground
  }));
};
const __setup__$1 = __default__$1.setup;
__default__$1.setup = __setup__$1 ? (props, ctx) => {
  __injectCSSVars__$1();
  return __setup__$1(props, ctx);
} : __injectCSSVars__$1;
const _sfc_main$4 = __default__$1;
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "fade" }, {
    default: withCtx(() => [
      _ctx.activeProxy ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle(_ctx.styles),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
      }, null, 6)) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
var GDialogOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const useSizeStyle = (props) => {
  const sizeStyles = computed(() => ({
    maxWidth: props.maxWidth === "none" ? void 0 : convertToUnit(props.maxWidth),
    width: props.width === "auto" ? void 0 : convertToUnit(props.width),
    height: props.height === "auto" ? void 0 : convertToUnit(props.height)
  }));
  return {
    sizeStyles
  };
};
const __default__ = defineComponent({
  name: "GDialogContent",
  props: {
    background: {
      type: [Boolean, String],
      required: true
    },
    borderRadius: {
      type: [Boolean, Number, String],
      required: true
    },
    class: {
      type: String,
      required: true
    },
    depressed: {
      type: Boolean,
      required: true
    },
    fullscreen: Boolean,
    height: {
      type: [String, Number],
      required: true
    },
    maxWidth: {
      type: [String, Number],
      required: true
    },
    scrollable: {
      type: Boolean,
      required: true
    },
    width: {
      type: [String, Number],
      required: true
    }
  },
  setup(props) {
    const { sizeStyles: styles } = useSizeStyle(props);
    const classes = computed(() => [
      "g-dialog-content",
      props.class,
      {
        "g-dialog-content--scrollable": props.scrollable,
        "g-dialog-content--depressed": props.depressed,
        "g-dialog-content--fullscreen": props.fullscreen
      }
    ]);
    const computedBackground = computed(() => {
      if (typeof props.background === "string")
        return props.background;
      else if (props.background)
        return "var(--content-bg)";
      return "transparent";
    });
    const computedBorderRadius = computed(() => {
      if (typeof props.borderRadius === "string")
        return convertToUnit(props.borderRadius);
      else if (props.borderRadius)
        return "var(--content-border-radius)";
      return "0";
    });
    return {
      styles,
      classes,
      computedBackground,
      computedBorderRadius
    };
  }
});
const __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "889a571a": _ctx.computedBackground,
    "023a843a": _ctx.computedBorderRadius
  }));
};
const __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
const _sfc_main$3 = __default__;
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var GDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = defineComponent({
  name: "GDialogFrame",
  components: {
    GDialogContent
  },
  inheritAttrs: false,
  props: {
    isActive: {
      type: Boolean,
      required: true
    },
    zIndex: {
      type: Number,
      required: true
    },
    background: {
      type: [Boolean, String],
      required: true
    },
    borderRadius: {
      type: [Boolean, Number, String],
      required: true
    },
    contentClass: {
      type: String,
      required: true
    },
    depressed: {
      type: Boolean,
      required: true
    },
    fullscreen: {
      type: Boolean,
      required: true
    },
    height: {
      type: [String, Number],
      required: true
    },
    local: {
      type: Boolean,
      required: true
    },
    maxWidth: {
      type: [String, Number],
      required: true
    },
    scrollable: {
      type: Boolean,
      required: true
    },
    transition: {
      type: String,
      required: true
    },
    width: {
      type: [String, Number],
      required: true
    }
  },
  setup(props) {
    const frameElement = ref();
    const animateClick = () => {
      var _a3, _b2;
      (_b2 = (_a3 = frameElement.value) == null ? void 0 : _a3.animate) == null ? void 0 : _b2.call(_a3, [
        { transformOrigin: "center" },
        { transform: "scale(1.03)" },
        { transformOrigin: "center" }
      ], {
        duration: 150,
        easing: "cubic-bezier(0.4, 0, 0.2, 1)"
      });
    };
    const classes = computed(() => [
      "g-dialog-frame",
      {
        "g-dialog-frame--active": props.isActive,
        "g-dialog-frame--local": props.local
      }
    ]);
    const styles = computed(() => ({
      zIndex: props.zIndex
    }));
    return {
      frameElement,
      classes,
      styles,
      animateClick
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GDialogContent = resolveComponent("GDialogContent");
  return openBlock(), createBlock(Transition, { name: _ctx.transition }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "frameElement",
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle(_ctx.styles)
      }, [
        createVNode(_component_GDialogContent, {
          class: normalizeClass(_ctx.contentClass),
          "max-width": _ctx.maxWidth,
          width: _ctx.width,
          height: _ctx.height,
          scrollable: _ctx.scrollable,
          depressed: _ctx.depressed,
          fullscreen: _ctx.fullscreen,
          background: _ctx.background,
          "border-radius": _ctx.borderRadius
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "max-width", "width", "height", "scrollable", "depressed", "fullscreen", "background", "border-radius"])
      ], 6), [
        [vShow, _ctx.isActive]
      ])
    ]),
    _: 3
  }, 8, ["name"]);
}
var GDialogFrame = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = defineComponent({
  name: "GDialog",
  components: {
    GDialogOverlay,
    GDialogFrame
  },
  inheritAttrs: false,
  props: {
    background: {
      type: [Boolean, String],
      default: true
    },
    borderRadius: {
      type: [Boolean, Number, String],
      default: true
    },
    contentClass: {
      type: String,
      default: ""
    },
    depressed: Boolean,
    fullscreen: Boolean,
    height: {
      type: [String, Number],
      default: "auto"
    },
    local: Boolean,
    maxWidth: {
      type: [String, Number],
      default: "none"
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    noClickAnimation: Boolean,
    overlayBackground: {
      type: [Boolean, String],
      default: true
    },
    persistent: Boolean,
    scrollable: Boolean,
    teleportTo: {
      type: String,
      default: "body"
    },
    disableTeleport: Boolean,
    transition: {
      type: String,
      default: "g-dialog-transition"
    },
    width: {
      type: [String, Number],
      default: "auto"
    },
    closeOnBack: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, { emit }) {
    const overlayComponent = ref(null);
    const frameComponent = ref(null);
    const overlayElement = computed(() => {
      var _a3;
      return (_a3 = overlayComponent.value) == null ? void 0 : _a3.$el;
    });
    const frameElement = computed(() => {
      var _a3;
      return (_a3 = frameComponent.value) == null ? void 0 : _a3.$el;
    });
    const withModelValue = props.modelValue !== void 0;
    const scopedModelValue = ref(false);
    watch(() => props.modelValue, (val) => {
      scopedModelValue.value = !!val;
    });
    const { isTop } = useStack(scopedModelValue);
    if (IN_BROWSER && props.modelValue) {
      nextTick(() => {
        scopedModelValue.value = true;
      });
    }
    const onClose = () => {
      if (!withModelValue)
        scopedModelValue.value = false;
      emit("update:modelValue", false);
    };
    const onOpen = () => {
      if (!withModelValue)
        scopedModelValue.value = false;
      emit("update:modelValue", true);
    };
    const { activatedOnce, active: isActive } = useLazyActivation(scopedModelValue);
    const { zIndex } = useOverlay(isActive);
    const animateClick = () => {
      var _a3;
      if (props.noClickAnimation)
        return;
      (_a3 = frameComponent.value) == null ? void 0 : _a3.animateClick();
    };
    useWindowEventListener("keyup", (ev) => {
      if (ev.key === "Escape" && isTop.value) {
        if (!props.persistent)
          onClose();
        else
          animateClick();
      }
    }, { passive: true });
    const { enableScroll, disableScroll } = useScroll({
      overlay: overlayElement,
      content: frameElement,
      contentActiveClass: "g-dialog-frame--active",
      fullscreen: props.fullscreen,
      contentFullscreenClass: "g-dialog-frame--fullscreen"
    });
    watch(isActive, (active) => {
      if (props.local)
        return;
      if (active)
        disableScroll();
      else
        enableScroll();
    });
    onBeforeUnmount(() => {
      enableScroll();
    });
    const onClickOutside = () => {
      if (!props.persistent)
        onClose();
      else
        animateClick();
    };
    if (IN_BROWSER && props.closeOnBack) {
      const instace = getCurrentInstance();
      let currentDialogHash = `dialog-${instace.uid}`;
      if (window.location.hash)
        currentDialogHash = `${window.location.hash.slice(1)}-${currentDialogHash}`;
      const popstateListener = () => {
        if (window.location.hash.includes(currentDialogHash) || !scopedModelValue.value)
          return;
        onClose();
      };
      onMounted(() => {
        if (scopedModelValue.value)
          window.location.hash = currentDialogHash;
        window.addEventListener("popstate", popstateListener);
      });
      onUnmounted(() => {
        window.removeEventListener("popstate", popstateListener);
      });
      watch(scopedModelValue, (value) => {
        if (!value && window.location.hash.includes(currentDialogHash)) {
          window.history.back();
        } else if (value) {
          if (window.location.hash)
            currentDialogHash = `${window.location.hash.slice(1)}-${`dialog-${instace.uid}`}`;
          else
            currentDialogHash = `dialog-${instace.uid}`;
          window.location.hash = `#${currentDialogHash}`;
        }
      });
    }
    const activatorAttrs = {
      onClick() {
        onOpen();
      }
    };
    return {
      overlayComponent,
      frameComponent,
      activatedOnce,
      zIndex,
      isActive,
      activatorAttrs,
      onClickOutside,
      onClose
    };
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GDialogOverlay = resolveComponent("GDialogOverlay");
  const _component_GDialogFrame = resolveComponent("GDialogFrame");
  return openBlock(), createElementBlock(Fragment, null, [
    renderSlot(_ctx.$slots, "activator", normalizeProps(guardReactiveProps(_ctx.activatorAttrs))),
    _ctx.activatedOnce ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      (openBlock(), createBlock(Teleport, {
        to: _ctx.teleportTo,
        disabled: _ctx.local || _ctx.disableTeleport
      }, [
        !_ctx.fullscreen ? (openBlock(), createBlock(_component_GDialogOverlay, {
          key: 0,
          ref: "overlayComponent",
          active: _ctx.isActive,
          "z-index": _ctx.zIndex,
          background: _ctx.overlayBackground,
          local: _ctx.local,
          onClick: _ctx.onClickOutside
        }, null, 8, ["active", "z-index", "background", "local", "onClick"])) : createCommentVNode("", true)
      ], 8, ["to", "disabled"])),
      (openBlock(), createBlock(Teleport, {
        to: _ctx.teleportTo,
        disabled: _ctx.local || _ctx.disableTeleport
      }, [
        createVNode(_component_GDialogFrame, {
          ref: "frameComponent",
          "is-active": _ctx.isActive,
          "z-index": _ctx.zIndex,
          "max-width": _ctx.maxWidth,
          width: _ctx.width,
          height: _ctx.height,
          scrollable: _ctx.scrollable,
          transition: _ctx.transition,
          depressed: _ctx.depressed,
          fullscreen: _ctx.fullscreen,
          background: _ctx.background,
          "border-radius": _ctx.borderRadius,
          "content-class": _ctx.contentClass,
          local: _ctx.local,
          persistent: _ctx.persistent
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", { onClose: _ctx.onClose })
          ]),
          _: 3
        }, 8, ["is-active", "z-index", "max-width", "width", "height", "scrollable", "transition", "depressed", "fullscreen", "background", "border-radius", "content-class", "local", "persistent"])
      ], 8, ["to", "disabled"]))
    ], 64)) : createCommentVNode("", true)
  ], 64);
}
var GDialog = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const dialogs = shallowReactive([]);
const errorLogger = {
  pluginIsNotInitialized() {
  }
};
const dialogInjectionKey = Symbol("GDialog");
const dialogInjectionFallback = {
  dialogs: [],
  addDialog: () => {
    errorLogger.pluginIsNotInitialized();
    return null;
  },
  removeDialog: () => {
    errorLogger.pluginIsNotInitialized();
  }
};
const plugin = {
  install: (app, options) => {
    var _a3, _b2;
    const defaultCloseDelay = (_a3 = options == null ? void 0 : options.closeDelay) != null ? _a3 : 500;
    const defaultProps = (_b2 = options == null ? void 0 : options.props) != null ? _b2 : {};
    const $dialog = {
      dialogs,
      addDialog: ({ component, props, id }, hooks) => {
        const dialogId = id != null ? id : Date.now() + Math.random();
        dialogs.push({
          component,
          id: dialogId,
          props: reactive(__spreadValues(__spreadValues({
            modelValue: true
          }, defaultProps), props)),
          onClose: hooks == null ? void 0 : hooks.onClose
        });
        return dialogId;
      },
      removeDialog: (id, closeDelay) => {
        const dialog = dialogs.find((d2) => d2.id === id);
        if (!dialog || !dialog.props.modelValue)
          return;
        let canceled = false;
        const event = {
          id,
          cancel: () => {
            canceled = true;
          },
          item: dialog
        };
        if (dialog.onClose) {
          dialog.onClose(event);
          if (canceled)
            return;
        }
        dialog.props.modelValue = false;
        setTimeout(() => {
          dialogs.splice(dialogs.indexOf(dialog), 1);
        }, closeDelay != null ? closeDelay : defaultCloseDelay);
      }
    };
    app.provide(dialogInjectionKey, $dialog);
    app.config.globalProperties.$dialog = $dialog;
  }
};
defineComponent({
  name: "GDialogRoot",
  setup() {
    const {
      dialogs: dialogs2,
      removeDialog
    } = inject(dialogInjectionKey, dialogInjectionFallback);
    if (dialogs2 === dialogInjectionFallback.dialogs)
      errorLogger.pluginIsNotInitialized();
    function onClose(id) {
      removeDialog(id);
    }
    return {
      dialogs: dialogs2,
      onClose
    };
  }
});
const style$1 = "";
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction2, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction2 === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d2) => {
        const alignment2 = getAlignment(d2.placement);
        return [d2.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d2.overflows.slice(0, 2).reduce((acc, v3) => acc + v3, 0)
        ) : (
          // Check only the mainAxis.
          d2.overflows[0]
        ), d2.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d2[0]) ? 2 : 3
      ).every((v3) => v3 <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y3
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x2 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y4
            } = _ref;
            return {
              x: x3,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y3
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function n$1(t2) {
  var e2;
  return (null == (e2 = t2.ownerDocument) ? void 0 : e2.defaultView) || window;
}
function o(t2) {
  return n$1(t2).getComputedStyle(t2);
}
const i2 = Math.min, r = Math.max, l = Math.round;
function c(t2) {
  const e2 = o(t2);
  let n2 = parseFloat(e2.width), i3 = parseFloat(e2.height);
  const r2 = t2.offsetWidth, c2 = t2.offsetHeight, s2 = l(n2) !== r2 || l(i3) !== c2;
  return s2 && (n2 = r2, i3 = c2), { width: n2, height: i3, fallback: s2 };
}
function s(t2) {
  return h(t2) ? (t2.nodeName || "").toLowerCase() : "";
}
let f$1;
function u$1() {
  if (f$1)
    return f$1;
  const t2 = navigator.userAgentData;
  return t2 && Array.isArray(t2.brands) ? (f$1 = t2.brands.map((t3) => t3.brand + "/" + t3.version).join(" "), f$1) : navigator.userAgent;
}
function a(t2) {
  return t2 instanceof n$1(t2).HTMLElement;
}
function d$1(t2) {
  return t2 instanceof n$1(t2).Element;
}
function h(t2) {
  return t2 instanceof n$1(t2).Node;
}
function p(t2) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t2 instanceof n$1(t2).ShadowRoot || t2 instanceof ShadowRoot;
}
function g$1(t2) {
  const { overflow: e2, overflowX: n2, overflowY: i3, display: r2 } = o(t2);
  return /auto|scroll|overlay|hidden|clip/.test(e2 + i3 + n2) && !["inline", "contents"].includes(r2);
}
function m$1(t2) {
  return ["table", "td", "th"].includes(s(t2));
}
function y$1(t2) {
  const e2 = /firefox/i.test(u$1()), n2 = o(t2), i3 = n2.backdropFilter || n2.WebkitBackdropFilter;
  return "none" !== n2.transform || "none" !== n2.perspective || !!i3 && "none" !== i3 || e2 && "filter" === n2.willChange || e2 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some((t3) => n2.willChange.includes(t3)) || ["paint", "layout", "strict", "content"].some((t3) => {
    const e3 = n2.contain;
    return null != e3 && e3.includes(t3);
  });
}
function x() {
  return !/^((?!chrome|android).)*safari/i.test(u$1());
}
function w(t2) {
  return ["html", "body", "#document"].includes(s(t2));
}
function v$1(t2) {
  return d$1(t2) ? t2 : t2.contextElement;
}
const b$1 = { x: 1, y: 1 };
function L$1(t2) {
  const e2 = v$1(t2);
  if (!a(e2))
    return b$1;
  const n2 = e2.getBoundingClientRect(), { width: o2, height: i3, fallback: r2 } = c(e2);
  let s2 = (r2 ? l(n2.width) : n2.width) / o2, f2 = (r2 ? l(n2.height) : n2.height) / i3;
  return s2 && Number.isFinite(s2) || (s2 = 1), f2 && Number.isFinite(f2) || (f2 = 1), { x: s2, y: f2 };
}
function E$1(t2, e2, o2, i3) {
  var r2, l2;
  void 0 === e2 && (e2 = false), void 0 === o2 && (o2 = false);
  const c2 = t2.getBoundingClientRect(), s2 = v$1(t2);
  let f2 = b$1;
  e2 && (i3 ? d$1(i3) && (f2 = L$1(i3)) : f2 = L$1(t2));
  const u3 = s2 ? n$1(s2) : window, a2 = !x() && o2;
  let h2 = (c2.left + (a2 && (null == (r2 = u3.visualViewport) ? void 0 : r2.offsetLeft) || 0)) / f2.x, p2 = (c2.top + (a2 && (null == (l2 = u3.visualViewport) ? void 0 : l2.offsetTop) || 0)) / f2.y, g2 = c2.width / f2.x, m2 = c2.height / f2.y;
  if (s2) {
    const t3 = n$1(s2), e3 = i3 && d$1(i3) ? n$1(i3) : i3;
    let o3 = t3.frameElement;
    for (; o3 && i3 && e3 !== t3; ) {
      const t4 = L$1(o3), e4 = o3.getBoundingClientRect(), i4 = getComputedStyle(o3);
      e4.x += (o3.clientLeft + parseFloat(i4.paddingLeft)) * t4.x, e4.y += (o3.clientTop + parseFloat(i4.paddingTop)) * t4.y, h2 *= t4.x, p2 *= t4.y, g2 *= t4.x, m2 *= t4.y, h2 += e4.x, p2 += e4.y, o3 = n$1(o3).frameElement;
    }
  }
  return { width: g2, height: m2, top: p2, right: h2 + g2, bottom: p2 + m2, left: h2, x: h2, y: p2 };
}
function R(t2) {
  return ((h(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
}
function T(t2) {
  return d$1(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
}
function C$1(t2) {
  return E$1(R(t2)).left + T(t2).scrollLeft;
}
function F(t2) {
  if ("html" === s(t2))
    return t2;
  const e2 = t2.assignedSlot || t2.parentNode || p(t2) && t2.host || R(t2);
  return p(e2) ? e2.host : e2;
}
function W$1(t2) {
  const e2 = F(t2);
  return w(e2) ? e2.ownerDocument.body : a(e2) && g$1(e2) ? e2 : W$1(e2);
}
function D(t2, e2) {
  var o2;
  void 0 === e2 && (e2 = []);
  const i3 = W$1(t2), r2 = i3 === (null == (o2 = t2.ownerDocument) ? void 0 : o2.body), l2 = n$1(i3);
  return r2 ? e2.concat(l2, l2.visualViewport || [], g$1(i3) ? i3 : []) : e2.concat(i3, D(i3));
}
function S$1(e2, i3, l2) {
  return "viewport" === i3 ? rectToClientRect(function(t2, e3) {
    const o2 = n$1(t2), i4 = R(t2), r2 = o2.visualViewport;
    let l3 = i4.clientWidth, c2 = i4.clientHeight, s2 = 0, f2 = 0;
    if (r2) {
      l3 = r2.width, c2 = r2.height;
      const t3 = x();
      (t3 || !t3 && "fixed" === e3) && (s2 = r2.offsetLeft, f2 = r2.offsetTop);
    }
    return { width: l3, height: c2, x: s2, y: f2 };
  }(e2, l2)) : d$1(i3) ? rectToClientRect(function(t2, e3) {
    const n2 = E$1(t2, true, "fixed" === e3), o2 = n2.top + t2.clientTop, i4 = n2.left + t2.clientLeft, r2 = a(t2) ? L$1(t2) : { x: 1, y: 1 };
    return { width: t2.clientWidth * r2.x, height: t2.clientHeight * r2.y, x: i4 * r2.x, y: o2 * r2.y };
  }(i3, l2)) : rectToClientRect(function(t2) {
    const e3 = R(t2), n2 = T(t2), i4 = t2.ownerDocument.body, l3 = r(e3.scrollWidth, e3.clientWidth, i4.scrollWidth, i4.clientWidth), c2 = r(e3.scrollHeight, e3.clientHeight, i4.scrollHeight, i4.clientHeight);
    let s2 = -n2.scrollLeft + C$1(t2);
    const f2 = -n2.scrollTop;
    return "rtl" === o(i4).direction && (s2 += r(e3.clientWidth, i4.clientWidth) - l3), { width: l3, height: c2, x: s2, y: f2 };
  }(R(e2)));
}
function A(t2) {
  return a(t2) && "fixed" !== o(t2).position ? t2.offsetParent : null;
}
function H(t2) {
  const e2 = n$1(t2);
  let i3 = A(t2);
  for (; i3 && m$1(i3) && "static" === o(i3).position; )
    i3 = A(i3);
  return i3 && ("html" === s(i3) || "body" === s(i3) && "static" === o(i3).position && !y$1(i3)) ? e2 : i3 || function(t3) {
    let e3 = F(t3);
    for (; a(e3) && !w(e3); ) {
      if (y$1(e3))
        return e3;
      e3 = F(e3);
    }
    return null;
  }(t2) || e2;
}
function O(t2, e2, n2) {
  const o2 = a(e2), i3 = R(e2), r2 = E$1(t2, true, "fixed" === n2, e2);
  let l2 = { scrollLeft: 0, scrollTop: 0 };
  const c2 = { x: 0, y: 0 };
  if (o2 || !o2 && "fixed" !== n2)
    if (("body" !== s(e2) || g$1(i3)) && (l2 = T(e2)), a(e2)) {
      const t3 = E$1(e2, true);
      c2.x = t3.x + e2.clientLeft, c2.y = t3.y + e2.clientTop;
    } else
      i3 && (c2.x = C$1(i3));
  return { x: r2.left + l2.scrollLeft - c2.x, y: r2.top + l2.scrollTop - c2.y, width: r2.width, height: r2.height };
}
const P = { getClippingRect: function(t2) {
  let { element: e2, boundary: n2, rootBoundary: l2, strategy: c2 } = t2;
  const f2 = "clippingAncestors" === n2 ? function(t3, e3) {
    const n3 = e3.get(t3);
    if (n3)
      return n3;
    let i3 = D(t3).filter((t4) => d$1(t4) && "body" !== s(t4)), r2 = null;
    const l3 = "fixed" === o(t3).position;
    let c3 = l3 ? F(t3) : t3;
    for (; d$1(c3) && !w(c3); ) {
      const t4 = o(c3), e4 = y$1(c3);
      (l3 ? e4 || r2 : e4 || "static" !== t4.position || !r2 || !["absolute", "fixed"].includes(r2.position)) ? r2 = t4 : i3 = i3.filter((t5) => t5 !== c3), c3 = F(c3);
    }
    return e3.set(t3, i3), i3;
  }(e2, this._c) : [].concat(n2), u3 = [...f2, l2], a2 = u3[0], h2 = u3.reduce((t3, n3) => {
    const o2 = S$1(e2, n3, c2);
    return t3.top = r(o2.top, t3.top), t3.right = i2(o2.right, t3.right), t3.bottom = i2(o2.bottom, t3.bottom), t3.left = r(o2.left, t3.left), t3;
  }, S$1(e2, a2, c2));
  return { width: h2.right - h2.left, height: h2.bottom - h2.top, x: h2.left, y: h2.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
  let { rect: e2, offsetParent: n2, strategy: o2 } = t2;
  const i3 = a(n2), r2 = R(n2);
  if (n2 === r2)
    return e2;
  let l2 = { scrollLeft: 0, scrollTop: 0 }, c2 = { x: 1, y: 1 };
  const f2 = { x: 0, y: 0 };
  if ((i3 || !i3 && "fixed" !== o2) && (("body" !== s(n2) || g$1(r2)) && (l2 = T(n2)), a(n2))) {
    const t3 = E$1(n2);
    c2 = L$1(n2), f2.x = t3.x + n2.clientLeft, f2.y = t3.y + n2.clientTop;
  }
  return { width: e2.width * c2.x, height: e2.height * c2.y, x: e2.x * c2.x - l2.scrollLeft * c2.x + f2.x, y: e2.y * c2.y - l2.scrollTop * c2.y + f2.y };
}, isElement: d$1, getDimensions: function(t2) {
  return a(t2) ? c(t2) : t2.getBoundingClientRect();
}, getOffsetParent: H, getDocumentElement: R, getScale: L$1, async getElementRects(t2) {
  let { reference: e2, floating: n2, strategy: o2 } = t2;
  const i3 = this.getOffsetParent || H, r2 = this.getDimensions;
  return { reference: O(e2, await i3(n2), o2), floating: { x: 0, y: 0, ...await r2(n2) } };
}, getClientRects: (t2) => Array.from(t2.getClientRects()), isRTL: (t2) => "rtl" === o(t2).direction };
const B = (t2, n2, o2) => {
  const i3 = /* @__PURE__ */ new Map(), r2 = { platform: P, ...o2 }, l2 = { ...r2.platform, _c: i3 };
  return computePosition(t2, n2, { ...r2, platform: l2 });
};
function fe(e2, t2) {
  for (const o2 in t2)
    Object.prototype.hasOwnProperty.call(t2, o2) && (typeof t2[o2] == "object" && e2[o2] ? fe(e2[o2], t2[o2]) : e2[o2] = t2[o2]);
}
const u2 = {
  // Disable popper components
  disabled: false,
  // Default position offset along main axis (px)
  distance: 5,
  // Default position offset along cross axis (px)
  skidding: 0,
  // Default container where the tooltip will be appended
  container: "body",
  // Element used to compute position and size boundaries
  boundary: void 0,
  // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
  instantMove: false,
  // Auto destroy tooltip DOM nodes (ms)
  disposeTimeout: 5e3,
  // Triggers on the popper itself
  popperTriggers: [],
  // Positioning strategy
  strategy: "absolute",
  // Prevent overflow
  preventOverflow: true,
  // Flip to the opposite placement if needed
  flip: true,
  // Shift on the cross axis to prevent the popper from overflowing
  shift: true,
  // Overflow padding (px)
  overflowPadding: 0,
  // Arrow padding (px)
  arrowPadding: 0,
  // Compute arrow overflow (useful to hide it)
  arrowOverflow: true,
  // Themes
  themes: {
    tooltip: {
      // Default tooltip placement relative to target element
      placement: "top",
      // Default events that trigger the tooltip
      triggers: ["hover", "focus", "touch"],
      // Close tooltip on click on tooltip target
      hideTriggers: (e2) => [...e2, "click"],
      // Delay (ms)
      delay: {
        show: 200,
        hide: 0
      },
      // Update popper on content resize
      handleResize: false,
      // Enable HTML content in directive
      html: false,
      // Displayed when tooltip content is loading
      loadingContent: "..."
    },
    dropdown: {
      // Default dropdown placement relative to target element
      placement: "bottom",
      // Default events that trigger the dropdown
      triggers: ["click"],
      // Delay (ms)
      delay: 0,
      // Update popper on content resize
      handleResize: true,
      // Hide on clock outside
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function b(e2, t2) {
  let o2 = u2.themes[e2] || {}, i3;
  do
    i3 = o2[t2], typeof i3 > "u" ? o2.$extend ? o2 = u2.themes[o2.$extend] || {} : (o2 = null, i3 = u2[t2]) : o2 = null;
  while (o2);
  return i3;
}
function Je(e2) {
  const t2 = [e2];
  let o2 = u2.themes[e2] || {};
  do
    o2.$extend && !o2.$resetCss ? (t2.push(o2.$extend), o2 = u2.themes[o2.$extend] || {}) : o2 = null;
  while (o2);
  return t2.map((i3) => `v-popper--theme-${i3}`);
}
function oe(e2) {
  const t2 = [e2];
  let o2 = u2.themes[e2] || {};
  do
    o2.$extend ? (t2.push(o2.$extend), o2 = u2.themes[o2.$extend] || {}) : o2 = null;
  while (o2);
  return t2;
}
let _ = false;
if (typeof window < "u") {
  _ = false;
  try {
    const e2 = Object.defineProperty({}, "passive", {
      get() {
        _ = true;
      }
    });
    window.addEventListener("test", null, e2);
  } catch {
  }
}
let me = false;
typeof window < "u" && typeof navigator < "u" && (me = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
const ge = ["auto", "top", "bottom", "left", "right"].reduce((e2, t2) => e2.concat([
  t2,
  `${t2}-start`,
  `${t2}-end`
]), []), ie = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart",
  pointer: "pointerdown"
}, se = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend",
  pointer: "pointerup"
};
function ne(e2, t2) {
  const o2 = e2.indexOf(t2);
  o2 !== -1 && e2.splice(o2, 1);
}
function W() {
  return new Promise((e2) => requestAnimationFrame(() => {
    requestAnimationFrame(e2);
  }));
}
const d = [];
let g = null;
const re = {};
function pe(e2) {
  let t2 = re[e2];
  return t2 || (t2 = re[e2] = []), t2;
}
let X = function() {
};
typeof window < "u" && (X = window.Element);
function n(e2) {
  return function(t2) {
    return b(t2.theme, e2);
  };
}
const G = "__floating-vue__popper", K = () => defineComponent({
  name: "VPopper",
  provide() {
    return {
      [G]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [G]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      default: null
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    // eslint-disable-next-line vue/require-prop-types
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: n("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: n("positioningDisabled")
    },
    placement: {
      type: String,
      default: n("placement"),
      validator: (e2) => ge.includes(e2)
    },
    delay: {
      type: [String, Number, Object],
      default: n("delay")
    },
    distance: {
      type: [Number, String],
      default: n("distance")
    },
    skidding: {
      type: [Number, String],
      default: n("skidding")
    },
    triggers: {
      type: Array,
      default: n("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: n("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: n("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: n("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: n("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: n("popperHideTriggers")
    },
    container: {
      type: [String, Object, X, Boolean],
      default: n("container")
    },
    boundary: {
      type: [String, X],
      default: n("boundary")
    },
    strategy: {
      type: String,
      validator: (e2) => ["absolute", "fixed"].includes(e2),
      default: n("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: n("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: n("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: n("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: n("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: n("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: n("computeTransformOrigin")
    },
    /**
     * @deprecated
     */
    autoMinSize: {
      type: Boolean,
      default: n("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: n("autoSize")
    },
    /**
     * @deprecated
     */
    autoMaxSize: {
      type: Boolean,
      default: n("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: n("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: n("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: n("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: n("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: n("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: n("flip")
    },
    shift: {
      type: Boolean,
      default: n("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: n("shiftCrossAxis")
    },
    noAutoFocus: {
      type: Boolean,
      default: n("noAutoFocus")
    },
    disposeTimeout: {
      type: Number,
      default: n("disposeTimeout")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: {
          ...this.classes,
          popperClass: this.popperClass
        },
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var e2;
      return (e2 = this[G]) == null ? void 0 : e2.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var e2, t2;
      return ((e2 = this.popperTriggers) == null ? void 0 : e2.includes("hover")) || ((t2 = this.popperShowTriggers) == null ? void 0 : t2.includes("hover"));
    }
  },
  watch: {
    shown: "$_autoShowHide",
    disabled(e2) {
      e2 ? this.dispose() : this.init();
    },
    async container() {
      this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());
    },
    ...[
      "triggers",
      "positioningDisabled"
    ].reduce((e2, t2) => (e2[t2] = "$_refreshListeners", e2), {}),
    ...[
      "placement",
      "distance",
      "skidding",
      "boundary",
      "strategy",
      "overflowPadding",
      "arrowPadding",
      "preventOverflow",
      "shift",
      "shiftCrossAxis",
      "flip"
    ].reduce((e2, t2) => (e2[t2] = "$_computePosition", e2), {})
  },
  created() {
    this.$_isDisposed = true, this.randomId = `popper_${[Math.random(), Date.now()].map((e2) => e2.toString(36).substring(2, 10)).join("_")}`, this.autoMinSize && void 0, this.autoMaxSize && void 0;
  },
  mounted() {
    this.init(), this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event: e2 = null, skipDelay: t2 = false, force: o2 = false } = {}) {
      var i3, s2;
      (i3 = this.parentPopper) != null && i3.lockedChild && this.parentPopper.lockedChild !== this || (this.$_pendingHide = false, (o2 || !this.disabled) && (((s2 = this.parentPopper) == null ? void 0 : s2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e2, t2), this.$emit("show"), this.$_showFrameLocked = true, requestAnimationFrame(() => {
        this.$_showFrameLocked = false;
      })), this.$emit("update:shown", true));
    },
    hide({ event: e2 = null, skipDelay: t2 = false } = {}) {
      var o2;
      if (!this.$_hideInProgress) {
        if (this.shownChildren.size > 0) {
          this.$_pendingHide = true;
          return;
        }
        if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
          this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
            this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t2 }), this.parentPopper.lockedChild = null);
          }, 1e3));
          return;
        }
        ((o2 = this.parentPopper) == null ? void 0 : o2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_pendingHide = false, this.$_scheduleHide(e2, t2), this.$emit("hide"), this.$emit("update:shown", false);
      }
    },
    init() {
      var e2;
      this.$_isDisposed && (this.$_isDisposed = false, this.isMounted = false, this.$_events = [], this.$_preventShow = false, this.$_referenceNode = ((e2 = this.referenceNode) == null ? void 0 : e2.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((t2) => t2.nodeType === t2.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner"), this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container"), this.$_swapTargetAttrs("title", "data-original-title"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
    },
    dispose() {
      this.$_isDisposed || (this.$_isDisposed = true, this.$_removeEventListeners(), this.hide({ skipDelay: true }), this.$_detachPopperNode(), this.isMounted = false, this.isShown = false, this.$_updateParentShownChildren(false), this.$_swapTargetAttrs("data-original-title", "title"), this.$emit("dispose"));
    },
    async onResize() {
      this.isShown && (await this.$_computePosition(), this.$emit("resize"));
    },
    async $_computePosition() {
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const e2 = {
        strategy: this.strategy,
        middleware: []
      };
      (this.distance || this.skidding) && e2.middleware.push(offset({
        mainAxis: this.distance,
        crossAxis: this.skidding
      }));
      const t2 = this.placement.startsWith("auto");
      if (t2 ? e2.middleware.push(autoPlacement({
        alignment: this.placement.split("-")[1] ?? ""
      })) : e2.placement = this.placement, this.preventOverflow && (this.shift && e2.middleware.push(shift({
        padding: this.overflowPadding,
        boundary: this.boundary,
        crossAxis: this.shiftCrossAxis
      })), !t2 && this.flip && e2.middleware.push(flip({
        padding: this.overflowPadding,
        boundary: this.boundary
      }))), e2.middleware.push(arrow({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      })), this.arrowOverflow && e2.middleware.push({
        name: "arrowOverflow",
        fn: ({ placement: i3, rects: s2, middlewareData: r2 }) => {
          let p2;
          const { centerOffset: a2 } = r2.arrow;
          return i3.startsWith("top") || i3.startsWith("bottom") ? p2 = Math.abs(a2) > s2.reference.width / 2 : p2 = Math.abs(a2) > s2.reference.height / 2, {
            data: {
              overflow: p2
            }
          };
        }
      }), this.autoMinSize || this.autoSize) {
        const i3 = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        e2.middleware.push({
          name: "autoSize",
          fn: ({ rects: s2, placement: r2, middlewareData: p2 }) => {
            var h2;
            if ((h2 = p2.autoSize) != null && h2.skip)
              return {};
            let a2, l2;
            return r2.startsWith("top") || r2.startsWith("bottom") ? a2 = s2.reference.width : l2 = s2.reference.height, this.$_innerNode.style[i3 === "min" ? "minWidth" : i3 === "max" ? "maxWidth" : "width"] = a2 != null ? `${a2}px` : null, this.$_innerNode.style[i3 === "min" ? "minHeight" : i3 === "max" ? "maxHeight" : "height"] = l2 != null ? `${l2}px` : null, {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e2.middleware.push(size({
        boundary: this.boundary,
        padding: this.overflowPadding,
        apply: ({ availableWidth: i3, availableHeight: s2 }) => {
          this.$_innerNode.style.maxWidth = i3 != null ? `${i3}px` : null, this.$_innerNode.style.maxHeight = s2 != null ? `${s2}px` : null;
        }
      })));
      const o2 = await B(this.$_referenceNode, this.$_popperNode, e2);
      Object.assign(this.result, {
        x: o2.x,
        y: o2.y,
        placement: o2.placement,
        strategy: o2.strategy,
        arrow: {
          ...o2.middlewareData.arrow,
          ...o2.middlewareData.arrowOverflow
        }
      });
    },
    $_scheduleShow(e2 = null, t2 = false) {
      if (this.$_updateParentShownChildren(true), this.$_hideInProgress = false, clearTimeout(this.$_scheduleTimer), g && this.instantMove && g.instantMove && g !== this.parentPopper) {
        g.$_applyHide(true), this.$_applyShow(true);
        return;
      }
      t2 ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
    },
    $_scheduleHide(e2 = null, t2 = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false), this.$_hideInProgress = true, clearTimeout(this.$_scheduleTimer), this.isShown && (g = this), t2 ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
    },
    $_computeDelay(e2) {
      const t2 = this.delay;
      return parseInt(t2 && t2[e2] || t2 || 0);
    },
    async $_applyShow(e2 = false) {
      clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e2, !this.isShown && (this.$_ensureTeleport(), await W(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([
        ...D(this.$_referenceNode),
        ...D(this.$_popperNode)
      ], "scroll", () => {
        this.$_computePosition();
      }));
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const t2 = this.$_referenceNode.getBoundingClientRect(), o2 = this.$_popperNode.querySelector(".v-popper__wrapper"), i3 = o2.parentNode.getBoundingClientRect(), s2 = t2.x + t2.width / 2 - (i3.left + o2.offsetLeft), r2 = t2.y + t2.height / 2 - (i3.top + o2.offsetTop);
        this.result.transformOrigin = `${s2}px ${r2}px`;
      }
      this.isShown = true, this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const e2 = this.showGroup;
      if (e2) {
        let t2;
        for (let o2 = 0; o2 < d.length; o2++)
          t2 = d[o2], t2.showGroup !== e2 && (t2.hide(), t2.$emit("close-group"));
      }
      d.push(this), document.body.classList.add("v-popper--some-open");
      for (const t2 of oe(this.theme))
        pe(t2).push(this), document.body.classList.add(`v-popper--some-open--${t2}`);
      this.$emit("apply-show"), this.classes.showFrom = true, this.classes.showTo = false, this.classes.hideFrom = false, this.classes.hideTo = false, await W(), this.classes.showFrom = false, this.classes.showTo = true, this.noAutoFocus || this.$_popperNode.focus();
    },
    async $_applyHide(e2 = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true, this.$_hideInProgress = false;
        return;
      }
      if (clearTimeout(this.$_scheduleTimer), !this.isShown)
        return;
      this.skipTransition = e2, ne(d, this), d.length === 0 && document.body.classList.remove("v-popper--some-open");
      for (const o2 of oe(this.theme)) {
        const i3 = pe(o2);
        ne(i3, this), i3.length === 0 && document.body.classList.remove(`v-popper--some-open--${o2}`);
      }
      g === this && (g = null), this.isShown = false, this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      }), clearTimeout(this.$_disposeTimer);
      const t2 = this.disposeTimeout;
      t2 !== null && (this.$_disposeTimer = setTimeout(() => {
        this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = false);
      }, t2)), this.$_removeEventListeners("scroll"), this.$emit("apply-hide"), this.classes.showFrom = false, this.classes.showTo = false, this.classes.hideFrom = true, this.classes.hideTo = false, await W(), this.classes.hideFrom = false, this.classes.hideTo = true;
    },
    $_autoShowHide() {
      this.shown ? this.show() : this.hide();
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let e2 = this.container;
      if (typeof e2 == "string" ? e2 = window.document.querySelector(e2) : e2 === false && (e2 = this.$_targetNodes[0].parentNode), !e2)
        throw new Error("No container for popover: " + this.container);
      e2.appendChild(this.$_popperNode), this.isMounted = true;
    },
    $_addEventListeners() {
      const e2 = (o2) => {
        this.isShown && !this.$_hideInProgress || (o2.usedByTooltip = true, !this.$_preventShow && this.show({ event: o2 }));
      };
      this.$_registerTriggerListeners(this.$_targetNodes, ie, this.triggers, this.showTriggers, e2), this.$_registerTriggerListeners([this.$_popperNode], ie, this.popperTriggers, this.popperShowTriggers, e2);
      const t2 = (o2) => {
        o2.usedByTooltip || this.hide({ event: o2 });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, se, this.triggers, this.hideTriggers, t2), this.$_registerTriggerListeners([this.$_popperNode], se, this.popperTriggers, this.popperHideTriggers, t2);
    },
    $_registerEventListeners(e2, t2, o2) {
      this.$_events.push({ targetNodes: e2, eventType: t2, handler: o2 }), e2.forEach((i3) => i3.addEventListener(t2, o2, _ ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(e2, t2, o2, i3, s2) {
      let r2 = o2;
      i3 != null && (r2 = typeof i3 == "function" ? i3(r2) : i3), r2.forEach((p2) => {
        const a2 = t2[p2];
        a2 && this.$_registerEventListeners(e2, a2, s2);
      });
    },
    $_removeEventListeners(e2) {
      const t2 = [];
      this.$_events.forEach((o2) => {
        const { targetNodes: i3, eventType: s2, handler: r2 } = o2;
        !e2 || e2 === s2 ? i3.forEach((p2) => p2.removeEventListener(s2, r2)) : t2.push(o2);
      }), this.$_events = t2;
    },
    $_refreshListeners() {
      this.$_isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
    },
    $_handleGlobalClose(e2, t2 = false) {
      this.$_showFrameLocked || (this.hide({ event: e2 }), e2.closePopover ? this.$emit("close-directive") : this.$emit("auto-hide"), t2 && (this.$_preventShow = true, setTimeout(() => {
        this.$_preventShow = false;
      }, 300)));
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(e2, t2) {
      for (const o2 of this.$_targetNodes) {
        const i3 = o2.getAttribute(e2);
        i3 && (o2.removeAttribute(e2), o2.setAttribute(t2, i3));
      }
    },
    $_applyAttrsToTarget(e2) {
      for (const t2 of this.$_targetNodes)
        for (const o2 in e2) {
          const i3 = e2[o2];
          i3 == null ? t2.removeAttribute(o2) : t2.setAttribute(o2, i3);
        }
    },
    $_updateParentShownChildren(e2) {
      let t2 = this.parentPopper;
      for (; t2; )
        e2 ? t2.shownChildren.add(this.randomId) : (t2.shownChildren.delete(this.randomId), t2.$_pendingHide && t2.hide()), t2 = t2.parentPopper;
    },
    $_isAimingPopper() {
      const e2 = this.$_referenceNode.getBoundingClientRect();
      if (v2 >= e2.left && v2 <= e2.right && y2 >= e2.top && y2 <= e2.bottom) {
        const t2 = this.$_popperNode.getBoundingClientRect(), o2 = v2 - f, i3 = y2 - m, r2 = t2.left + t2.width / 2 - f + (t2.top + t2.height / 2) - m + t2.width + t2.height, p2 = f + o2 * r2, a2 = m + i3 * r2;
        return S(f, m, p2, a2, t2.left, t2.top, t2.left, t2.bottom) || // Left edge
        S(f, m, p2, a2, t2.left, t2.top, t2.right, t2.top) || // Top edge
        S(f, m, p2, a2, t2.right, t2.top, t2.right, t2.bottom) || // Right edge
        S(f, m, p2, a2, t2.left, t2.bottom, t2.right, t2.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
typeof document < "u" && typeof window < "u" && (me ? (document.addEventListener("touchstart", ae, _ ? {
  passive: true,
  capture: true
} : true), document.addEventListener("touchend", Ze, _ ? {
  passive: true,
  capture: true
} : true)) : (window.addEventListener("mousedown", ae, true), window.addEventListener("click", Qe, true)), window.addEventListener("resize", ot));
function ae(e2) {
  for (let t2 = 0; t2 < d.length; t2++) {
    const o2 = d[t2];
    try {
      const i3 = o2.popperNode();
      o2.$_mouseDownContains = i3.contains(e2.target);
    } catch {
    }
  }
}
function Qe(e2) {
  $e(e2);
}
function Ze(e2) {
  $e(e2, true);
}
function $e(e2, t2 = false) {
  const o2 = {};
  for (let i3 = d.length - 1; i3 >= 0; i3--) {
    const s2 = d[i3];
    try {
      const r2 = s2.$_containsGlobalTarget = et2(s2, e2);
      s2.$_pendingHide = false, requestAnimationFrame(() => {
        if (s2.$_pendingHide = false, !o2[s2.randomId] && de(s2, r2, e2)) {
          if (s2.$_handleGlobalClose(e2, t2), !e2.closeAllPopover && e2.closePopover && r2) {
            let a2 = s2.parentPopper;
            for (; a2; )
              o2[a2.randomId] = true, a2 = a2.parentPopper;
            return;
          }
          let p2 = s2.parentPopper;
          for (; p2 && de(p2, p2.$_containsGlobalTarget, e2); ) {
            p2.$_handleGlobalClose(e2, t2);
            p2 = p2.parentPopper;
          }
        }
      });
    } catch {
    }
  }
}
function et2(e2, t2) {
  const o2 = e2.popperNode();
  return e2.$_mouseDownContains || o2.contains(t2.target);
}
function de(e2, t2, o2) {
  return o2.closeAllPopover || o2.closePopover && t2 || tt(e2, o2) && !t2;
}
function tt(e2, t2) {
  if (typeof e2.autoHide == "function") {
    const o2 = e2.autoHide(t2);
    return e2.lastAutoHide = o2, o2;
  }
  return e2.autoHide;
}
function ot(e2) {
  for (let t2 = 0; t2 < d.length; t2++)
    d[t2].$_computePosition(e2);
}
let f = 0, m = 0, v2 = 0, y2 = 0;
typeof window < "u" && window.addEventListener("mousemove", (e2) => {
  f = v2, m = y2, v2 = e2.clientX, y2 = e2.clientY;
}, _ ? {
  passive: true
} : void 0);
function S(e2, t2, o2, i3, s2, r2, p2, a2) {
  const l2 = ((p2 - s2) * (t2 - r2) - (a2 - r2) * (e2 - s2)) / ((a2 - r2) * (o2 - e2) - (p2 - s2) * (i3 - t2)), h2 = ((o2 - e2) * (t2 - r2) - (i3 - t2) * (e2 - s2)) / ((a2 - r2) * (o2 - e2) - (p2 - s2) * (i3 - t2));
  return l2 >= 0 && l2 <= 1 && h2 >= 0 && h2 <= 1;
}
const it = {
  extends: K()
}, k = (e2, t2) => {
  const o2 = e2.__vccOpts || e2;
  for (const [i3, s2] of t2)
    o2[i3] = s2;
  return o2;
};
function st(e2, t2, o2, i3, s2, r2) {
  return openBlock(), createElementBlock("div", {
    ref: "reference",
    class: normalizeClass(["v-popper", {
      "v-popper--shown": e2.slotData.isShown
    }])
  }, [
    renderSlot(e2.$slots, "default", normalizeProps(guardReactiveProps(e2.slotData)))
  ], 2);
}
const nt = /* @__PURE__ */ k(it, [["render", st]]);
function rt() {
  var e2 = window.navigator.userAgent, t2 = e2.indexOf("MSIE ");
  if (t2 > 0)
    return parseInt(e2.substring(t2 + 5, e2.indexOf(".", t2)), 10);
  var o2 = e2.indexOf("Trident/");
  if (o2 > 0) {
    var i3 = e2.indexOf("rv:");
    return parseInt(e2.substring(i3 + 3, e2.indexOf(".", i3)), 10);
  }
  var s2 = e2.indexOf("Edge/");
  return s2 > 0 ? parseInt(e2.substring(s2 + 5, e2.indexOf(".", s2)), 10) : -1;
}
let z;
function U() {
  U.init || (U.init = true, z = rt() !== -1);
}
var E = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    U(), nextTick(() => {
      this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
    });
    const e2 = document.createElement("object");
    this._resizeObject = e2, e2.setAttribute("aria-hidden", "true"), e2.setAttribute("tabindex", -1), e2.onload = this.addResizeHandlers, e2.type = "text/html", z && this.$el.appendChild(e2), e2.data = "about:blank", z || this.$el.appendChild(e2);
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify();
    },
    removeResizeHandlers() {
      this._resizeObject && this._resizeObject.onload && (!z && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
    }
  }
};
const pt = /* @__PURE__ */ withScopeId("data-v-b329ee4c");
pushScopeId("data-v-b329ee4c");
const at = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const dt = /* @__PURE__ */ pt((e2, t2, o2, i3, s2, r2) => (openBlock(), createBlock("div", at)));
E.render = dt;
E.__scopeId = "data-v-b329ee4c";
E.__file = "src/components/ResizeObserver.vue";
const J = (e2 = "theme") => ({
  computed: {
    themeClass() {
      return Je(this[e2]);
    }
  }
}), ht = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: E
  },
  mixins: [
    J()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(e2) {
      return e2 != null && !isNaN(e2) ? `${e2}px` : null;
    }
  }
});
const lt = ["id", "aria-hidden", "tabindex", "data-popper-placement"], ut = {
  ref: "inner",
  class: "v-popper__inner"
}, ct = /* @__PURE__ */ createElementVNode("div", { class: "v-popper__arrow-outer" }, null, -1), ft = /* @__PURE__ */ createElementVNode("div", { class: "v-popper__arrow-inner" }, null, -1), mt = [
  ct,
  ft
];
function gt(e2, t2, o2, i3, s2, r2) {
  const p2 = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: e2.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      e2.themeClass,
      e2.classes.popperClass,
      {
        "v-popper__popper--shown": e2.shown,
        "v-popper__popper--hidden": !e2.shown,
        "v-popper__popper--show-from": e2.classes.showFrom,
        "v-popper__popper--show-to": e2.classes.showTo,
        "v-popper__popper--hide-from": e2.classes.hideFrom,
        "v-popper__popper--hide-to": e2.classes.hideTo,
        "v-popper__popper--skip-transition": e2.skipTransition,
        "v-popper__popper--arrow-overflow": e2.result && e2.result.arrow.overflow,
        "v-popper__popper--no-positioning": !e2.result
      }
    ]]),
    style: normalizeStyle(e2.result ? {
      position: e2.result.strategy,
      transform: `translate3d(${Math.round(e2.result.x)}px,${Math.round(e2.result.y)}px,0)`
    } : void 0),
    "aria-hidden": e2.shown ? "false" : "true",
    tabindex: e2.autoHide ? 0 : void 0,
    "data-popper-placement": e2.result ? e2.result.placement : void 0,
    onKeyup: t2[2] || (t2[2] = withKeys((a2) => e2.autoHide && e2.$emit("hide"), ["esc"]))
  }, [
    createElementVNode("div", {
      class: "v-popper__backdrop",
      onClick: t2[0] || (t2[0] = (a2) => e2.autoHide && e2.$emit("hide"))
    }),
    createElementVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(e2.result ? {
        transformOrigin: e2.result.transformOrigin
      } : void 0)
    }, [
      createElementVNode("div", ut, [
        e2.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("div", null, [
            renderSlot(e2.$slots, "default")
          ]),
          e2.handleResize ? (openBlock(), createBlock(p2, {
            key: 0,
            onNotify: t2[1] || (t2[1] = (a2) => e2.$emit("resize", a2))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createElementVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(e2.result ? {
          left: e2.toPx(e2.result.arrow.x),
          top: e2.toPx(e2.result.arrow.y)
        } : void 0)
      }, mt, 4)
    ], 4)
  ], 46, lt);
}
const Q = /* @__PURE__ */ k(ht, [["render", gt]]), Z = {
  methods: {
    show(...e2) {
      return this.$refs.popper.show(...e2);
    },
    hide(...e2) {
      return this.$refs.popper.hide(...e2);
    },
    dispose(...e2) {
      return this.$refs.popper.dispose(...e2);
    },
    onResize(...e2) {
      return this.$refs.popper.onResize(...e2);
    }
  }
}, $t = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: nt,
    PopperContent: Q
  },
  mixins: [
    Z,
    J("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      return this.theme ?? this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$el.children).filter((e2) => e2 !== this.$refs.popperContent.$el);
    }
  }
});
function _t(e2, t2, o2, i3, s2, r2) {
  const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
  return openBlock(), createBlock(a2, {
    ref: "popper",
    theme: e2.finalTheme,
    "target-nodes": e2.getTargetNodes,
    "popper-node": () => e2.$refs.popperContent.$el,
    class: normalizeClass([
      e2.themeClass
    ])
  }, {
    default: withCtx(({
      popperId: l2,
      isShown: h2,
      shouldMountContent: B2,
      skipTransition: D2,
      autoHide: I2,
      show: R2,
      hide: w2,
      handleResize: F2,
      onResize: V2,
      classes: j2,
      result: Oe
    }) => [
      renderSlot(e2.$slots, "default", {
        shown: h2,
        show: R2,
        hide: w2
      }),
      createVNode(p2, {
        ref: "popperContent",
        "popper-id": l2,
        theme: e2.finalTheme,
        shown: h2,
        mounted: B2,
        "skip-transition": D2,
        "auto-hide": I2,
        "handle-resize": F2,
        classes: j2,
        result: Oe,
        onHide: w2,
        onResize: V2
      }, {
        default: withCtx(() => [
          renderSlot(e2.$slots, "popper", {
            shown: h2,
            hide: w2
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 8, ["theme", "target-nodes", "popper-node", "class"]);
}
const L = /* @__PURE__ */ k($t, [["render", _t]]), _e = {
  ...L,
  name: "VDropdown",
  vPopperTheme: "dropdown"
};
const we = {
  ...L,
  name: "VMenu",
  vPopperTheme: "menu"
}, ve = {
  ...L,
  name: "VTooltip",
  vPopperTheme: "tooltip"
};
const wt = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: K(),
    PopperContent: Q
  },
  mixins: [
    Z
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (e2) => b(e2.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (e2) => b(e2.theme, "loadingContent")
    },
    targetNodes: {
      type: Function,
      required: true
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content == "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick(), this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(e2) {
      if (typeof this.content == "function" && this.$_isShown && (e2 || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null, this.$_loading = true;
        const t2 = ++this.$_fetchId, o2 = this.content(this);
        o2.then ? o2.then((i3) => this.onResult(t2, i3)) : this.onResult(t2, o2);
      }
    },
    onResult(e2, t2) {
      e2 === this.$_fetchId && (this.$_loading = false, this.asyncContent = t2);
    },
    onShow() {
      this.$_isShown = true, this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
}), vt = ["innerHTML"], yt = ["textContent"];
function Pt(e2, t2, o2, i3, s2, r2) {
  const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
  return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e2.$attrs, {
    theme: e2.theme,
    "target-nodes": e2.targetNodes,
    "popper-node": () => e2.$refs.popperContent.$el,
    onApplyShow: e2.onShow,
    onApplyHide: e2.onHide
  }), {
    default: withCtx(({
      popperId: l2,
      isShown: h2,
      shouldMountContent: B2,
      skipTransition: D2,
      autoHide: I2,
      hide: R2,
      handleResize: w2,
      onResize: F2,
      classes: V2,
      result: j2
    }) => [
      createVNode(p2, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": e2.loading
        }),
        "popper-id": l2,
        theme: e2.theme,
        shown: h2,
        mounted: B2,
        "skip-transition": D2,
        "auto-hide": I2,
        "handle-resize": w2,
        classes: V2,
        result: j2,
        onHide: R2,
        onResize: F2
      }, {
        default: withCtx(() => [
          e2.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: e2.finalContent
          }, null, 8, vt)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(e2.finalContent)
          }, null, 8, yt))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
}
const ye = /* @__PURE__ */ k(wt, [["render", Pt]]), Pe = "v-popper--has-tooltip";
function Tt(e2, t2) {
  let o2 = e2.placement;
  if (!o2 && t2)
    for (const i3 of ge)
      t2[i3] && (o2 = i3);
  return o2 || (o2 = b(e2.theme || "tooltip", "placement")), o2;
}
function Te(e2, t2, o2) {
  let i3;
  const s2 = typeof t2;
  return s2 === "string" ? i3 = { content: t2 } : t2 && s2 === "object" ? i3 = t2 : i3 = { content: false }, i3.placement = Tt(i3, o2), i3.targetNodes = () => [e2], i3.referenceNode = () => e2, i3;
}
let q, C, bt = 0;
function Ct() {
  if (q)
    return;
  C = ref([]), q = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives: C
      };
    },
    render() {
      return this.directives.map((t2) => h$5(ye, {
        ...t2.options,
        shown: t2.shown || t2.options.shown,
        key: t2.id
      }));
    },
    devtools: {
      hide: true
    }
  });
  const e2 = document.createElement("div");
  document.body.appendChild(e2), q.mount(e2);
}
function St(e2, t2, o2) {
  Ct();
  const i3 = ref(Te(e2, t2, o2)), s2 = ref(false), r2 = {
    id: bt++,
    options: i3,
    shown: s2
  };
  return C.value.push(r2), e2.classList && e2.classList.add(Pe), e2.$_popper = {
    options: i3,
    item: r2,
    show() {
      s2.value = true;
    },
    hide() {
      s2.value = false;
    }
  };
}
function be(e2) {
  if (e2.$_popper) {
    const t2 = C.value.indexOf(e2.$_popper.item);
    t2 !== -1 && C.value.splice(t2, 1), delete e2.$_popper, delete e2.$_popperOldShown, delete e2.$_popperMountTarget;
  }
  e2.classList && e2.classList.remove(Pe);
}
function he(e2, { value: t2, modifiers: o2 }) {
  const i3 = Te(e2, t2, o2);
  if (!i3.content || b(i3.theme || "tooltip", "disabled"))
    be(e2);
  else {
    let s2;
    e2.$_popper ? (s2 = e2.$_popper, s2.options.value = i3) : s2 = St(e2, t2, o2), typeof t2.shown < "u" && t2.shown !== e2.$_popperOldShown && (e2.$_popperOldShown = t2.shown, t2.shown ? s2.show() : s2.hide());
  }
}
const Ce = {
  beforeMount: he,
  updated: he,
  beforeUnmount(e2) {
    be(e2);
  }
};
function le(e2) {
  e2.addEventListener("click", Se), e2.addEventListener("touchstart", ze, _ ? {
    passive: true
  } : false);
}
function ue(e2) {
  e2.removeEventListener("click", Se), e2.removeEventListener("touchstart", ze), e2.removeEventListener("touchend", Ne), e2.removeEventListener("touchcancel", Ae);
}
function Se(e2) {
  const t2 = e2.currentTarget;
  e2.closePopover = !t2.$_vclosepopover_touch, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
}
function ze(e2) {
  if (e2.changedTouches.length === 1) {
    const t2 = e2.currentTarget;
    t2.$_vclosepopover_touch = true;
    const o2 = e2.changedTouches[0];
    t2.$_vclosepopover_touchPoint = o2, t2.addEventListener("touchend", Ne), t2.addEventListener("touchcancel", Ae);
  }
}
function Ne(e2) {
  const t2 = e2.currentTarget;
  if (t2.$_vclosepopover_touch = false, e2.changedTouches.length === 1) {
    const o2 = e2.changedTouches[0], i3 = t2.$_vclosepopover_touchPoint;
    e2.closePopover = Math.abs(o2.screenY - i3.screenY) < 20 && Math.abs(o2.screenX - i3.screenX) < 20, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
  }
}
function Ae(e2) {
  const t2 = e2.currentTarget;
  t2.$_vclosepopover_touch = false;
}
const He = {
  beforeMount(e2, { value: t2, modifiers: o2 }) {
    e2.$_closePopoverModifiers = o2, (typeof t2 > "u" || t2) && le(e2);
  },
  updated(e2, { value: t2, oldValue: o2, modifiers: i3 }) {
    e2.$_closePopoverModifiers = i3, t2 !== o2 && (typeof t2 > "u" || t2 ? le(e2) : ue(e2));
  },
  beforeUnmount(e2) {
    ue(e2);
  }
};
function zt(e2, t2 = {}) {
  e2.$_vTooltipInstalled || (e2.$_vTooltipInstalled = true, fe(u2, t2), e2.directive("tooltip", Ce), e2.directive("close-popper", He), e2.component("VTooltip", ve), e2.component("VDropdown", _e), e2.component("VMenu", we));
}
const xt = {
  // eslint-disable-next-line no-undef
  version: "2.0.0-beta.24",
  install: zt,
  options: u2
};
const style = "";
const clientConfig19 = defineClientConfig({
  enhance({
    app,
    router
  }) {
    app.component("MyBanner", MyBanner);
    app.component("MidBanner", MidBanner);
    app.component("GDialog", GDialog);
    app.use(plugin, {});
    app.use(Tooltip);
    app.use(xt);
    app.config.globalProperties.$api = serverApi;
    app.config.globalProperties.$msg = Message;
    app.config.globalProperties.$imgCache = useImageCache();
    app.config.globalProperties.$signUrl = useSignUrl();
    addPhotoRoutes(router);
  },
  layouts: {
    Album: Layout$1,
    Layout,
    Timeline
  },
  setup() {
    const {
      proxy: proxy2
    } = getCurrentInstance();
    const msg = () => proxy2 == null ? void 0 : proxy2.$msg({
      type: "info",
      text: "登录已过期，请重新登录哟(⊙_⊙)~"
    });
    onMounted(() => {
      var _a3;
      window.addEventListener("autologout", msg);
      (_a3 = document.querySelector('.navbar-links a[aria-label="QQ空间"] .xicon-container')) == null ? void 0 : _a3.insertAdjacentHTML("afterbegin", qzoneSvg);
    });
    onUnmounted(() => {
      window.removeEventListener("autologout", msg);
    });
  }
});
const clientConfigs = [clientConfig0, clientConfig1, clientConfig2, clientConfig3, clientConfig4, clientConfig5, clientConfig6, clientConfig7, clientConfig8, clientConfig9, clientConfig10, clientConfig11, clientConfig12, clientConfig13, M$3, clientConfig15, clientConfig16, clientConfig17, clientConfig18, clientConfig19, clientConfig20];
const pagesRoutes = [["v-01560935", "/timeline/", {
  "title": ""
}, []], ["v-e1e3da16", "/posts/", {
  "title": ""
}, []], ["v-53355ebb", "/friendship-link/", {
  "title": ""
}, []], ["v-03d52fd3", "/posts/1/", {
  "title": ""
}, []], ["v-8daa1a0e", "/", {
  "title": ""
}, ["/home.html", "/home.md"]], ["v-33291fb2", "/albums/", {
  "title": "画册"
}, ["/albums/README.md"]], ["v-71cbb60e", "/blogs/blogtest.html", {
  "title": "音乐播放器测试"
}, [":md"]], ["v-4cab04d2", "/blogs/shuoshuotest.html", {
  "title": "9月8日"
}, [":md"]], ["v-926a34b0", "/albums/test_album_1/psb.png.html", {
  "title": "梯田"
}, [":md"]], ["v-1f71f6ee", "/albums/test_album_1/", {
  "title": "测试相册1"
}, ["/albums/test_album_1/README.md"]], ["v-1f71f6b0", "/albums/test_album_2/", {
  "title": "测试相册2"
}, ["/albums/test_album_2/README.md"]], ["v-1d051c9f", "/docs/tech/flowers.html", {
  "title": "前端实现 - 木棉花落"
}, [":md"]], ["v-dc8a1012", "/docs/tech/homebg.html", {
  "title": "前端实现 - 分层背景"
}, [":md"]], ["v-06ec5813", "/docs/test/articletest.html", {
  "title": "文章测试"
}, [":md"]], ["v-23390c64", "/docs/test/mdtest.html", {
  "title": "markdown测试"
}, [":md"]], ["v-3706649a", "/404.html", {
  "title": ""
}, []]];
var Vuepress = defineComponent({
  name: "Vuepress",
  setup() {
    const layout = usePageLayout();
    return () => h$5(layout.value);
  }
});
var createRoutes = () => pagesRoutes.reduce((result, [name2, path, meta, redirects]) => {
  result.push({
    name: name2,
    path,
    component: Vuepress,
    meta
  }, {
    path: path.endsWith("/") ? (
      // redirect from `/index.html` to `/`
      path + "index.html"
    ) : (
      // redirect from `/foo` to `/foo.html`
      path.substring(0, path.length - 5)
    ),
    redirect: path
  }, ...redirects.map((item) => ({
    path: item === ":md" ? (
      // redirect from `/foo.md` to `/foo.html`
      path.substring(0, path.length - 5) + ".md"
    ) : item,
    redirect: path
  })));
  return result;
}, [{
  name: "404",
  path: "/:catchAll(.*)",
  component: Vuepress
}]);
var historyCreator = createWebHistory;
var createVueRouter = () => {
  const router = createRouter({
    // it might be an issue of vue-router that have to remove the ending slash
    history: historyCreator(removeEndingSlash("/")),
    routes: createRoutes(),
    scrollBehavior: (to, from, savedPosition) => {
      if (savedPosition)
        return savedPosition;
      if (to.hash)
        return {
          el: to.hash
        };
      return {
        top: 0
      };
    }
  });
  router.beforeResolve(async (to, from) => {
    var _a3;
    if (to.path !== from.path || from === START_LOCATION) {
      [to.meta._data] = await Promise.all([resolvers.resolvePageData(to.name), (_a3 = pagesComponents[to.name]) == null ? void 0 : _a3.__asyncLoader()]);
    }
  });
  return router;
};
var setupGlobalComponents = (app) => {
  app.component("ClientOnly", ClientOnly);
  app.component("Content", Content);
};
var setupGlobalComputed = (app, router, clientConfigs2) => {
  const routePath = computedEager(() => router.currentRoute.value.path);
  const routeLocale = computedEager(() => resolvers.resolveRouteLocale(siteData$2.value.locales, routePath.value));
  const pageData = computedWithControl(routePath, () => router.currentRoute.value.meta._data);
  const layouts2 = computed(() => resolvers.resolveLayouts(clientConfigs2));
  const siteLocaleData = computed(() => resolvers.resolveSiteLocaleData(siteData$2.value, routeLocale.value));
  const pageFrontmatter = computed(() => resolvers.resolvePageFrontmatter(pageData.value));
  const pageHeadTitle = computed(() => resolvers.resolvePageHeadTitle(pageData.value, siteLocaleData.value));
  const pageHead = computed(() => resolvers.resolvePageHead(pageHeadTitle.value, pageFrontmatter.value, siteLocaleData.value));
  const pageLang = computed(() => resolvers.resolvePageLang(pageData.value, siteLocaleData.value));
  const pageLayout = computed(() => resolvers.resolvePageLayout(pageData.value, layouts2.value));
  app.provide(layoutsSymbol, layouts2);
  app.provide(pageDataSymbol, pageData);
  app.provide(pageFrontmatterSymbol, pageFrontmatter);
  app.provide(pageHeadTitleSymbol, pageHeadTitle);
  app.provide(pageHeadSymbol, pageHead);
  app.provide(pageLangSymbol, pageLang);
  app.provide(pageLayoutSymbol, pageLayout);
  app.provide(routeLocaleSymbol, routeLocale);
  app.provide(siteLocaleDataSymbol, siteLocaleData);
  Object.defineProperties(app.config.globalProperties, {
    $frontmatter: {
      get: () => pageFrontmatter.value
    },
    $head: {
      get: () => pageHead.value
    },
    $headTitle: {
      get: () => pageHeadTitle.value
    },
    $lang: {
      get: () => pageLang.value
    },
    $page: {
      get: () => pageData.value
    },
    $routeLocale: {
      get: () => routeLocale.value
    },
    $site: {
      get: () => siteData$2.value
    },
    $siteLocale: {
      get: () => siteLocaleData.value
    },
    $withBase: {
      get: () => withBase
    }
  });
  return {
    layouts: layouts2,
    pageData,
    pageFrontmatter,
    pageHead,
    pageHeadTitle,
    pageLang,
    pageLayout,
    routeLocale,
    siteData: siteData$2,
    siteLocaleData
  };
};
var setupUpdateHead = () => {
  const head = usePageHead();
  const lang = usePageLang();
  const headTags = ref([]);
  const loadHead = () => {
    head.value.forEach((item) => {
      const tag = queryHeadTag(item);
      if (tag) {
        headTags.value.push(tag);
      }
    });
  };
  const updateHead = () => {
    document.documentElement.lang = lang.value;
    headTags.value.forEach((item) => {
      if (item.parentNode === document.head) {
        document.head.removeChild(item);
      }
    });
    headTags.value.splice(0, headTags.value.length);
    head.value.forEach((item) => {
      const tag = createHeadTag(item);
      if (tag !== null) {
        document.head.appendChild(tag);
        headTags.value.push(tag);
      }
    });
  };
  provide(updateHeadSymbol, updateHead);
  onMounted(() => {
    loadHead();
    updateHead();
    watch(() => head.value, updateHead);
  });
};
var queryHeadTag = ([tagName, attrs, content = ""]) => {
  const attrsSelector = Object.entries(attrs).map(([key, value]) => {
    if (isString$1(value)) {
      return `[${key}=${JSON.stringify(value)}]`;
    }
    if (value === true) {
      return `[${key}]`;
    }
    return "";
  }).join("");
  const selector = `head > ${tagName}${attrsSelector}`;
  const tags = Array.from(document.querySelectorAll(selector));
  const matchedTag = tags.find((item) => item.innerText === content);
  return matchedTag || null;
};
var createHeadTag = ([tagName, attrs, content]) => {
  if (!isString$1(tagName)) {
    return null;
  }
  const tag = document.createElement(tagName);
  if (isPlainObject$1(attrs)) {
    Object.entries(attrs).forEach(([key, value]) => {
      if (isString$1(value)) {
        tag.setAttribute(key, value);
      } else if (value === true) {
        tag.setAttribute(key, "");
      }
    });
  }
  if (isString$1(content)) {
    tag.appendChild(document.createTextNode(content));
  }
  return tag;
};
var appCreator = createSSRApp;
var createVueApp = async () => {
  var _a3;
  const app = appCreator({
    name: "VuepressApp",
    setup() {
      var _a4;
      setupUpdateHead();
      for (const clientConfig of clientConfigs) {
        (_a4 = clientConfig.setup) == null ? void 0 : _a4.call(clientConfig);
      }
      return () => [h$5(RouterView), ...clientConfigs.flatMap(({
        rootComponents = []
      }) => rootComponents.map((component) => h$5(component)))];
    }
  });
  const router = createVueRouter();
  setupGlobalComponents(app);
  const globalComputed = setupGlobalComputed(app, router, clientConfigs);
  {
    const {
      setupDevtools
    } = await __vitePreload(() => import("./setupDevtools-X4YFRK4B-42835d31.js"), true ? [] : void 0);
    setupDevtools(app, globalComputed);
  }
  for (const clientConfig of clientConfigs) {
    await ((_a3 = clientConfig.enhance) == null ? void 0 : _a3.call(clientConfig, {
      app,
      router,
      siteData: siteData$2
    }));
  }
  app.use(router);
  return {
    app,
    router
  };
};
{
  createVueApp().then(({
    app,
    router
  }) => {
    router.isReady().then(() => {
      app.mount("#app");
    });
  });
}
export {
  Api as A,
  C$5 as C,
  _export_sfc$1 as _,
  __vitePreload as a,
  createVueApp,
  getAugmentedNamespace as g,
  r$4 as r,
  setupDevtoolsPlugin as s,
  v$5 as v
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a2;
import { defineAsyncComponent, readonly, ref, reactive, defineComponent, onMounted, computed, h as h$5, inject, resolveComponent, unref, openBlock, createElementBlock, normalizeStyle, createElementVNode, createVNode, createCommentVNode, toRefs, watch, getCurrentScope, onScopeDispose, getCurrentInstance, nextTick, isRef, shallowRef, watchEffect, customRef, onUnmounted, toDisplayString, Fragment, renderList, normalizeClass, createBlock, pushScopeId, popScopeId, createTextVNode, withCtx, withDirectives, vModelText, Transition, onBeforeUnmount, vModelCheckbox, vShow, provide, onUpdated, renderSlot, useSlots, resolveDynamicComponent, onBeforeUpdate, mergeProps, toRef, camelize, capitalize, withModifiers, TransitionGroup, onBeforeMount, render, createApp, shallowReactive, effectScope, toRaw, useCssVars, normalizeProps, guardReactiveProps, Teleport, withScopeId, withKeys, createSSRApp } from "vue";
import katex$1 from "katex";
import { useRouter, useRoute, RouterView, createRouter, START_LOCATION, createWebHistory } from "vue-router";
import * as icons from "@vicons/carbon";
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i3 = links.length - 1; i3 >= 0; i3--) {
        const link2 = links[i3];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err2) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err2;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err2;
    }
  });
};
const pagesData$1 = {
  // path: /timeline/
  "v-01560935": () => __vitePreload(() => import(
    /* webpackChunkName: "v-01560935" */
    "./index.html-d7b3fa74.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /posts/
  "v-e1e3da16": () => __vitePreload(() => import(
    /* webpackChunkName: "v-e1e3da16" */
    "./index.html-7ef429f3.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /friendship-link/
  "v-53355ebb": () => __vitePreload(() => import(
    /* webpackChunkName: "v-53355ebb" */
    "./index.html-652c3680.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /posts/1/
  "v-03d52fd3": () => __vitePreload(() => import(
    /* webpackChunkName: "v-03d52fd3" */
    "./index.html-2f34d830.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /
  "v-8daa1a0e": () => __vitePreload(() => import(
    /* webpackChunkName: "v-8daa1a0e" */
    "./index.html-f8d54bfe.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/
  "v-33291fb2": () => __vitePreload(() => import(
    /* webpackChunkName: "v-33291fb2" */
    "./index.html-ae9564c1.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /blogs/blogtest.html
  "v-71cbb60e": () => __vitePreload(() => import(
    /* webpackChunkName: "v-71cbb60e" */
    "./blogtest.html-2d094e09.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /blogs/shuoshuotest.html
  "v-4cab04d2": () => __vitePreload(() => import(
    /* webpackChunkName: "v-4cab04d2" */
    "./shuoshuotest.html-fabe9378.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/test_album_1/psb.png.html
  "v-926a34b0": () => __vitePreload(() => import(
    /* webpackChunkName: "v-926a34b0" */
    "./psb.png.html-b76aff71.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/test_album_1/
  "v-1f71f6ee": () => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6ee" */
    "./index.html-389fb609.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /albums/test_album_2/
  "v-1f71f6b0": () => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6b0" */
    "./index.html-1f60d8a5.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/tech/flowers.html
  "v-1d051c9f": () => __vitePreload(() => import(
    /* webpackChunkName: "v-1d051c9f" */
    "./flowers.html-ef35759e.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/tech/homebg.html
  "v-dc8a1012": () => __vitePreload(() => import(
    /* webpackChunkName: "v-dc8a1012" */
    "./homebg.html-9b8ad34d.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/test/articletest.html
  "v-06ec5813": () => __vitePreload(() => import(
    /* webpackChunkName: "v-06ec5813" */
    "./articletest.html-e1fc6420.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /docs/test/mdtest.html
  "v-23390c64": () => __vitePreload(() => import(
    /* webpackChunkName: "v-23390c64" */
    "./mdtest.html-95a89950.js"
  ), true ? [] : void 0).then(({
    data
  }) => data),
  // path: /404.html
  "v-3706649a": () => __vitePreload(() => import(
    /* webpackChunkName: "v-3706649a" */
    "./404.html-7e543c16.js"
  ), true ? [] : void 0).then(({
    data
  }) => data)
};
const siteData$3 = JSON.parse('{"base":"/","lang":"zh-CN","title":"八桂世界的歌姬","description":"还在调试中","head":[],"locales":{},"pageIdMap":{"albums":{"id":"albums","key":"v-33291fb2","path":"/albums/","title":"画册","frontmatter":{"id":"albums","title":"画册","layout":"Album"}},"blog-2023-09-08_1":{"id":"blog-2023-09-08_1","key":"v-4cab04d2","path":"/blogs/shuoshuotest.html","title":"9月8日","frontmatter":{"id":"blog-2023-09-08_1","title":"9月8日","date":"2023-09-08T00:00:00.000Z"}},"test_album_1:psb.png":{"id":"test_album_1:psb.png","key":"v-926a34b0","path":"/albums/test_album_1/psb.png.html","title":"梯田","frontmatter":{"id":"test_album_1:psb.png","title":"梯田","description":"这是一张梯田的画"}},"blog_1":{"id":"blog_1","key":"v-71cbb60e","path":"/blogs/blogtest.html","title":"音乐播放器测试","frontmatter":{"id":"blog_1","title":"音乐播放器测试","date":"2023-09-08T00:00:00.000Z"}},"test_album_1":{"id":"test_album_1","key":"v-1f71f6ee","path":"/albums/test_album_1/","title":"测试相册1","frontmatter":{"id":"test_album_1","title":"测试相册1","description":"这是对测试相册1的描述","layout":"Album","cover":"MY52-2.png"}},"test_album_2":{"id":"test_album_2","key":"v-1f71f6b0","path":"/albums/test_album_2/","title":"测试相册2","frontmatter":{"id":"test_album_2","title":"测试相册2","description":"这是对测试相册2的描述","layout":"Album","cover":"MY55-4.png"}},"docs_test_2":{"id":"docs_test_2","key":"v-06ec5813","path":"/docs/test/articletest.html","title":"文章测试","frontmatter":{"id":"docs_test_2","title":"文章测试","date":"2023-09-08T00:00:00.000Z"}},"docs_tech_flowers":{"id":"docs_tech_flowers","key":"v-1d051c9f","path":"/docs/tech/flowers.html","title":"前端实现 - 木棉花落","frontmatter":{"id":"docs_tech_flowers","title":"前端实现 - 木棉花落","date":"2023-09-16T00:00:00.000Z"}},"docs_tech_homebg":{"id":"docs_tech_homebg","key":"v-dc8a1012","path":"/docs/tech/homebg.html","title":"前端实现 - 分层背景","frontmatter":{"id":"docs_tech_homebg","title":"前端实现 - 分层背景","date":"2023-09-13T00:00:00.000Z"}},"docs_test_1":{"id":"docs_test_1","key":"v-23390c64","path":"/docs/test/mdtest.html","title":"markdown测试","frontmatter":{"id":"docs_test_1","title":"markdown测试","date":"2023-09-08T16:18:00.000Z"}}}}');
const isArray$1 = Array.isArray;
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
var resolveHeadIdentifier = ([tag, attrs, content]) => {
  if (tag === "meta" && attrs.name) {
    return `${tag}.${attrs.name}`;
  }
  if (["title", "base"].includes(tag)) {
    return tag;
  }
  if (tag === "template" && attrs.id) {
    return `${tag}.${attrs.id}`;
  }
  return JSON.stringify([tag, attrs, content]);
};
var dedupeHead = (head) => {
  const identifierSet = /* @__PURE__ */ new Set();
  const result = [];
  head.forEach((item) => {
    const identifier = resolveHeadIdentifier(item);
    if (!identifierSet.has(identifier)) {
      identifierSet.add(identifier);
      result.push(item);
    }
  });
  return result;
};
var isLinkFtp = (link) => link.startsWith("ftp://");
var isLinkHttp$1 = (link) => /^(https?:)?\/\//.test(link);
var markdownLinkRegexp = /.md((\?|#).*)?$/;
var isLinkExternal = (link, base = "/") => {
  if (isLinkHttp$1(link) || isLinkFtp(link)) {
    return true;
  }
  if (link.startsWith("/") && !link.startsWith(base) && !markdownLinkRegexp.test(link)) {
    return true;
  }
  return false;
};
var isLinkMailto = (link) => /^mailto:/.test(link);
var isLinkTel = (link) => /^tel:/.test(link);
var isPlainObject$1 = (val) => Object.prototype.toString.call(val) === "[object Object]";
var removeEndingSlash = (str) => str[str.length - 1] === "/" ? str.slice(0, -1) : str;
var removeLeadingSlash = (str) => str[0] === "/" ? str.slice(1) : str;
var resolveLocalePath = (locales2, routePath) => {
  const localePaths = Object.keys(locales2).sort((a2, b2) => {
    const levelDelta = b2.split("/").length - a2.split("/").length;
    if (levelDelta !== 0) {
      return levelDelta;
    }
    return b2.length - a2.length;
  });
  for (const localePath of localePaths) {
    if (routePath.startsWith(localePath)) {
      return localePath;
    }
  }
  return "/";
};
const pagesComponents = {
  // path: /timeline/
  "v-01560935": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-01560935" */
    "./index.html-8874abe0.js"
  ), true ? [] : void 0)),
  // path: /posts/
  "v-e1e3da16": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-e1e3da16" */
    "./index.html-706f3864.js"
  ), true ? [] : void 0)),
  // path: /friendship-link/
  "v-53355ebb": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-53355ebb" */
    "./index.html-81e735cf.js"
  ), true ? [] : void 0)),
  // path: /posts/1/
  "v-03d52fd3": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-03d52fd3" */
    "./index.html-c1182d2b.js"
  ), true ? [] : void 0)),
  // path: /
  "v-8daa1a0e": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-8daa1a0e" */
    "./index.html-d447349f.js"
  ), true ? [] : void 0)),
  // path: /albums/
  "v-33291fb2": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-33291fb2" */
    "./index.html-91952a42.js"
  ), true ? [] : void 0)),
  // path: /blogs/blogtest.html
  "v-71cbb60e": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-71cbb60e" */
    "./blogtest.html-1409c1e7.js"
  ), true ? [] : void 0)),
  // path: /blogs/shuoshuotest.html
  "v-4cab04d2": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-4cab04d2" */
    "./shuoshuotest.html-e9b26cc3.js"
  ), true ? [] : void 0)),
  // path: /albums/test_album_1/psb.png.html
  "v-926a34b0": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-926a34b0" */
    "./psb.png.html-030700fd.js"
  ), true ? [] : void 0)),
  // path: /albums/test_album_1/
  "v-1f71f6ee": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6ee" */
    "./index.html-a5d7a9de.js"
  ), true ? [] : void 0)),
  // path: /albums/test_album_2/
  "v-1f71f6b0": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-1f71f6b0" */
    "./index.html-6e5d6ef4.js"
  ), true ? [] : void 0)),
  // path: /docs/tech/flowers.html
  "v-1d051c9f": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-1d051c9f" */
    "./flowers.html-fb40a8f4.js"
  ), true ? [] : void 0)),
  // path: /docs/tech/homebg.html
  "v-dc8a1012": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-dc8a1012" */
    "./homebg.html-72e6568f.js"
  ), true ? [] : void 0)),
  // path: /docs/test/articletest.html
  "v-06ec5813": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-06ec5813" */
    "./articletest.html-4144f087.js"
  ), true ? [] : void 0)),
  // path: /docs/test/mdtest.html
  "v-23390c64": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-23390c64" */
    "./mdtest.html-6b00dba1.js"
  ), true ? [] : void 0)),
  // path: /404.html
  "v-3706649a": defineAsyncComponent(() => __vitePreload(() => import(
    /* webpackChunkName: "v-3706649a" */
    "./404.html-f96ea447.js"
  ), true ? [] : void 0))
};
var layoutsSymbol = Symbol("");
var pageDataSymbol = Symbol("");
var pageDataEmpty = readonly({
  key: "",
  path: "",
  title: "",
  lang: "",
  frontmatter: {},
  headers: []
});
var usePageData$1 = () => {
  const pageData = inject(pageDataSymbol);
  if (!pageData) {
    throw new Error("pageData() is called without provider.");
  }
  return pageData;
};
var pageFrontmatterSymbol = Symbol("");
var usePageFrontmatter = () => {
  const pageFrontmatter = inject(pageFrontmatterSymbol);
  if (!pageFrontmatter) {
    throw new Error("usePageFrontmatter() is called without provider.");
  }
  return pageFrontmatter;
};
var pageHeadSymbol = Symbol("");
var usePageHead = () => {
  const pageHead = inject(pageHeadSymbol);
  if (!pageHead) {
    throw new Error("usePageHead() is called without provider.");
  }
  return pageHead;
};
var pageHeadTitleSymbol = Symbol("");
var pageLangSymbol = Symbol("");
var usePageLang = () => {
  const pageLang = inject(pageLangSymbol);
  if (!pageLang) {
    throw new Error("usePageLang() is called without provider.");
  }
  return pageLang;
};
var pageLayoutSymbol = Symbol("");
var usePageLayout = () => {
  const pageLayout = inject(pageLayoutSymbol);
  if (!pageLayout) {
    throw new Error("usePageLayout() is called without provider.");
  }
  return pageLayout;
};
var pagesData = ref(pagesData$1);
var routeLocaleSymbol = Symbol("");
var useRouteLocale = () => {
  const routeLocale = inject(routeLocaleSymbol);
  if (!routeLocale) {
    throw new Error("useRouteLocale() is called without provider.");
  }
  return routeLocale;
};
var siteData$2 = ref(siteData$3);
var useSiteData = () => siteData$2;
var siteLocaleDataSymbol = Symbol("");
var useSiteLocaleData = () => {
  const siteLocaleData = inject(siteLocaleDataSymbol);
  if (!siteLocaleData) {
    throw new Error("useSiteLocaleData() is called without provider.");
  }
  return siteLocaleData;
};
var updateHeadSymbol = Symbol("");
var LAYOUT_NAME_DEFAULT = "Layout";
var LAYOUT_NAME_NOT_FOUND = "NotFound";
var resolvers = reactive({
  /**
   * Resolve layouts component map
   */
  resolveLayouts: (clientConfigs2) => clientConfigs2.reduce((prev, item) => ({
    ...prev,
    ...item.layouts
  }), {}),
  /**
   * Resolve page data according to page key
   */
  resolvePageData: async (pageKey) => {
    const pageDataResolver = pagesData.value[pageKey];
    const pageData = await (pageDataResolver == null ? void 0 : pageDataResolver());
    return pageData ?? pageDataEmpty;
  },
  /**
   * Resolve page frontmatter from page data
   */
  resolvePageFrontmatter: (pageData) => pageData.frontmatter,
  /**
   * Merge the head config in frontmatter and site locale
   *
   * Frontmatter should take priority over site locale
   */
  resolvePageHead: (headTitle, frontmatter, siteLocale) => {
    const description2 = isString$1(frontmatter.description) ? frontmatter.description : siteLocale.description;
    const head = [...isArray$1(frontmatter.head) ? frontmatter.head : [], ...siteLocale.head, ["title", {}, headTitle], ["meta", {
      name: "description",
      content: description2
    }]];
    return dedupeHead(head);
  },
  /**
   * Resolve the content of page head title
   *
   * It would be used as the content of the `<title>` tag
   */
  resolvePageHeadTitle: (page, siteLocale) => [page.title, siteLocale.title].filter((item) => !!item).join(" | "),
  /**
   * Resolve page language from page data
   *
   * It would be used as the `lang` attribute of `<html>` tag
   */
  resolvePageLang: (page, siteLocale) => page.lang || siteLocale.lang || "en-US",
  /**
   * Resolve layout component of current page
   */
  resolvePageLayout: (page, layouts2) => {
    let layoutName;
    if (page.path) {
      const frontmatterLayout = page.frontmatter.layout;
      if (isString$1(frontmatterLayout)) {
        layoutName = frontmatterLayout;
      } else {
        layoutName = LAYOUT_NAME_DEFAULT;
      }
    } else {
      layoutName = LAYOUT_NAME_NOT_FOUND;
    }
    return layouts2[layoutName];
  },
  /**
   * Resolve locale path according to route path and locales config
   */
  resolveRouteLocale: (locales2, routePath) => resolveLocalePath(locales2, routePath),
  /**
   * Resolve site data for specific locale
   *
   * It would merge the locales fields to the root fields
   */
  resolveSiteLocaleData: (site, routeLocale) => ({
    ...site,
    ...site.locales[routeLocale]
  })
});
var ClientOnly = defineComponent({
  name: "ClientOnly",
  setup(_2, ctx) {
    const isMounted = ref(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return () => {
      var _a3, _b2;
      return isMounted.value ? (_b2 = (_a3 = ctx.slots).default) == null ? void 0 : _b2.call(_a3) : null;
    };
  }
});
var Content = defineComponent({
  // eslint-disable-next-line vue/no-reserved-component-names
  name: "Content",
  props: {
    pageKey: {
      type: String,
      required: false,
      default: ""
    }
  },
  setup(props) {
    const page = usePageData$1();
    const pageComponent = computed(() => pagesComponents[props.pageKey || page.value.key]);
    return () => pageComponent.value ? (
      // use page component
      h$5(pageComponent.value)
    ) : (
      // fallback content
      h$5("div", "404 Not Found")
    );
  }
});
var defineClientConfig = (clientConfig = {}) => clientConfig;
var withBase = (url) => {
  if (isLinkHttp$1(url))
    return url;
  return `${"/"}${removeLeadingSlash(url)}`;
};
const themeData$1 = JSON.parse('{"home":"/","catalogTitle":"导航","docsDir":"/","series":{"/docs":[{"text":"技术小记","children":["/docs/tech/flowers","/docs/tech/homebg"]},{"text":"测试页面","children":["/docs/test/mdtest","/docs/test/articletest"],"collapsible":true}]},"navbar":[{"icon":"BlochSphere","text":"首页","link":"/"},{"icon":"Image","text":"画册","link":"/albums"},{"icon":"Book","text":"文章","link":"/docs/test/mdtest"},{"icon":"Idea","text":"随想","link":"/posts"},{"icon":"Forum","text":"说说","link":"/comingSoon"},{"icon":"ChangeCatalog","text":"迭代","link":"/timeline"},{"text":"QQ空间","link":"https://user.qzone.qq.com/841745697/main"}],"colorMode":"dark","primaryColor":"rgb(104, 173, 173)","author":"触虐の羊明","authorAvatar":"/images/avatar.png"}');
const themeData = ref(themeData$1);
const useThemeData = () => themeData;
const themeLocaleDataSymbol = Symbol("");
const useThemeLocaleData$1 = () => {
  const themeLocaleData = inject(themeLocaleDataSymbol);
  if (!themeLocaleData) {
    throw new Error("useThemeLocaleData() is called without provider.");
  }
  return themeLocaleData;
};
const resolveThemeLocaleData = (theme, routeLocale) => {
  const {
    locales: locales2,
    ...baseOptions
  } = theme;
  return {
    ...baseOptions,
    ...locales2 == null ? void 0 : locales2[routeLocale]
  };
};
function useVisible() {
  const themeLocal = useThemeLocaleData$1();
  const bulletin = computed(() => {
    var _a3;
    return (_a3 = themeLocal === null || themeLocal === void 0 ? void 0 : themeLocal.value) === null || _a3 === void 0 ? void 0 : _a3.bulletin;
  });
  const visible = ref(false);
  const bulletinPopoverKey = "__CLOSE_BULLETIN_POPOVER__";
  onMounted(() => {
    var _a3;
    const closeNote = sessionStorage.getItem(bulletinPopoverKey);
    visible.value = closeNote !== "true" && !!((_a3 = bulletin === null || bulletin === void 0 ? void 0 : bulletin.value) === null || _a3 === void 0 ? void 0 : _a3.body);
  });
  const closeBulletinPopover = () => {
    visible.value = false;
    sessionStorage.setItem(bulletinPopoverKey, "true");
  };
  return {
    visible,
    bulletin,
    closeBulletinPopover
  };
}
const nodeHandler = {
  handleImage(node2) {
    return `<img style="${node2.style || ""}" src="${node2.src}" />`;
  },
  handleText(node2) {
    return `<div style="${node2.style || ""}">${node2.content}</div>`;
  },
  handleTitle(node2) {
    return `<h5 style="${node2.style || ""}">${node2.content}</h5>`;
  },
  handleButton(node2) {
    return `<a style="${node2.style || ""}" class="btn" href="${node2.link}">${node2.text}</a>`;
  },
  handleButtongroup(node2) {
    const btnChildren = (node2.children || []).reduce((total, next) => {
      return total += `<a style="${next.style || node2.style || ""}" class="btn" href="${next.link}">${next.text}</a>`;
    }, "");
    return `<div class="btn-group">${btnChildren}</div>`;
  },
  handleHr(node2) {
    return `<hr />`;
  }
};
function useHandleNodes() {
  const themeLocal = useThemeLocaleData$1();
  function handleNode(nodes) {
    if (!Array.isArray(nodes)) {
      let type2 = nodes.type;
      type2 = type2.slice(0, 1).toUpperCase() + type2.slice(1);
      return nodeHandler[`handle${type2}`](nodes);
    } else {
      return nodes.map((node2) => handleNode(node2));
    }
  }
  const bodyNodes = computed(() => {
    var _a3, _b2;
    return handleNode((_b2 = (_a3 = themeLocal === null || themeLocal === void 0 ? void 0 : themeLocal.value) === null || _a3 === void 0 ? void 0 : _a3.bulletin) === null || _b2 === void 0 ? void 0 : _b2.body).join("");
  });
  return {
    bodyNodes,
    handleNode
  };
}
const _hoisted_1$1l = { class: "bulletin-title" };
const _hoisted_2$Z = /* @__PURE__ */ createElementVNode(
  "path",
  {
    d: "M512 34.133333a486.4 486.4 0 1 0 486.4 486.4A486.4 486.4 0 0 0 512 34.133333z m209.4848 632.8064l-55.6032 55.466667-151.517867-151.125333-151.517866 151.1168-55.6032-55.466667 151.517866-151.108267L307.242667 364.714667l55.6032-55.466667 151.517866 151.125333 151.517867-151.1168 55.6032 55.466667-151.517867 151.099733z m0 0",
    "p-id": "4449"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$P = [
  _hoisted_2$Z
];
const _hoisted_4$E = ["innerHTML"];
const _sfc_main$1E = /* @__PURE__ */ defineComponent({
  __name: "Bulletin",
  setup(__props) {
    const { visible, bulletin, closeBulletinPopover } = useVisible();
    const { bodyNodes } = useHandleNodes();
    return (_ctx, _cache) => {
      var _a3, _b2;
      const _component_Xicons = resolveComponent("Xicons");
      return unref(visible) ? (openBlock(), createElementBlock(
        "div",
        {
          key: 0,
          class: "bulletin-wrapper",
          style: normalizeStyle({ width: ((_a3 = unref(bulletin)) == null ? void 0 : _a3.width) || "300px" })
        },
        [
          createElementVNode("div", _hoisted_1$1l, [
            createVNode(_component_Xicons, {
              icon: "VolumeUp",
              "icon-size": "20",
              text: ((_b2 = unref(bulletin)) == null ? void 0 : _b2.title) || "公告",
              color: "#fff",
              "text-size": "16"
            }, null, 8, ["text"]),
            (openBlock(), createElementBlock("svg", {
              class: "btn-close icon",
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeBulletinPopover) && unref(closeBulletinPopover)(...args)),
              t: "1573745677073",
              viewBox: "0 0 1024 1024",
              version: "1.1",
              xmlns: "http://www.w3.org/2000/svg",
              "p-id": "4448",
              width: "22",
              height: "22"
            }, _hoisted_3$P))
          ]),
          createElementVNode("div", {
            class: "bulletin-content",
            innerHTML: unref(bodyNodes)
          }, null, 8, _hoisted_4$E)
        ],
        4
        /* STYLE */
      )) : createCommentVNode("v-if", true);
    };
  }
});
const Bulletin_vue_vue_type_style_index_0_lang = "";
const _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const Bulletin = /* @__PURE__ */ _export_sfc$1(_sfc_main$1E, [["__file", "Bulletin.vue"]]);
const clientConfig0 = defineClientConfig({
  rootComponents: [defineComponent(() => {
    return () => h$5(Bulletin);
  })]
});
function useComment() {
  const themeLocal = useThemeLocaleData$1();
  const solution = computed(() => {
    var _a3;
    switch ((_a3 = themeLocal.value.commentConfig) === null || _a3 === void 0 ? void 0 : _a3.type) {
      case "valine":
        return "valine";
      case "waline":
        return "waline";
      case "giscus":
        return "giscus";
      default:
        return "";
    }
  });
  const options = computed(() => {
    var _a3, _b2;
    return ((_b2 = (_a3 = themeLocal.value) === null || _a3 === void 0 ? void 0 : _a3.commentConfig) === null || _b2 === void 0 ? void 0 : _b2.options) || {};
  });
  return {
    solution,
    options
  };
}
const valine = "";
const Valine = defineComponent({
  name: "Valine",
  props: {
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props) {
    const router = useRouter();
    const {
      options
    } = toRefs(props);
    let valineInstance = null;
    onMounted(async () => {
      const {
        Valine: Valine2
      } = await __vitePreload(() => import("./reco-valine-3208faae.js"), true ? [] : void 0);
      const initValine = async () => {
        if (valineInstance)
          return;
        const valineOptions = {
          el: "#valine",
          placeholder: "just go go",
          notify: false,
          verify: false,
          avatar: "retro",
          visitor: true,
          recordIP: false,
          path: window.location.pathname,
          ...options.value
        };
        valineInstance = new Valine2(valineOptions);
      };
      initValine();
      watch(() => router.currentRoute.value.path, (toPath) => {
        initValine();
      }, {
        immediate: true,
        deep: true
      });
    });
  },
  render() {
    return h$5("div", {
      class: "reco-valine-wrapper"
    }, h$5("div", {
      id: "valine"
    }));
  }
});
function computedEager(fn, options) {
  var _a3;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options,
    flush: (_a3 = options == null ? void 0 : options.flush) != null ? _a3 : "sync"
  });
  return readonly(result);
}
function computedWithControl(source, fn) {
  let v3 = void 0;
  let track;
  let trigger;
  const dirty = ref(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  watch(source, update, { flush: "sync" });
  const get = typeof fn === "function" ? fn : fn.get;
  const set = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v3 = get();
          dirty.value = false;
        }
        track();
        return v3;
      },
      set(v22) {
        set == null ? void 0 : set(v22);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const toString$1 = Object.prototype.toString;
const isObject$1 = (val) => toString$1.call(val) === "[object Object]";
const noop$1 = () => {
};
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop$1;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop$1;
  };
  const filter2 = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter2;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter2,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function tryOnUnmounted(fn) {
  if (getCurrentInstance())
    onUnmounted(fn);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function unrefElement(elRef) {
  var _a3;
  const plain = toValue(elRef);
  return (_a3 = plain == null ? void 0 : plain.$el) != null ? _a3 : plain;
}
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop$1;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref(false);
  if (getCurrentInstance()) {
    onMounted(() => {
      isMounted.value = true;
    });
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref(false);
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp) {
    if (!isActive.value || !window2)
      return;
    const delta = timestamp - (previousFrameTimestamp || timestamp);
    fn({ delta, timestamp });
    previousFrameTimestamp = timestamp;
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
const defaults$3 = {
  array: (v3) => JSON.stringify(v3),
  object: (v3) => JSON.stringify(v3),
  set: (v3) => JSON.stringify(Array.from(v3)),
  map: (v3) => JSON.stringify(Object.fromEntries(v3)),
  null: () => ""
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults$3.null;
  if (target instanceof Map)
    return defaults$3.map;
  else if (target instanceof Set)
    return defaults$3.set;
  else if (Array.isArray(target))
    return defaults$3.array;
  else
    return defaults$3.object;
}
function useBase64(target, options) {
  const base64 = ref("");
  const promise2 = ref();
  function execute() {
    if (!isClient)
      return;
    promise2.value = new Promise((resolve, reject) => {
      try {
        const _target = toValue(target);
        if (_target == null) {
          resolve("");
        } else if (typeof _target === "string") {
          resolve(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));
          }).catch(reject);
        } else if (typeof _target === "object") {
          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject(error);
      }
    });
    promise2.value.then((res) => base64.value = res);
    return promise2.value;
  }
  if (isRef(target) || typeof target === "function")
    watch(target, execute, { immediate: true });
  else
    execute();
  return {
    base64,
    promise: promise2,
    execute
  };
}
function imgLoaded(img) {
  return new Promise((resolve, reject) => {
    if (!img.complete) {
      img.onload = () => {
        resolve();
      };
      img.onerror = reject;
    } else {
      resolve();
    }
  });
}
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = (e2) => {
      resolve(e2.target.result);
    };
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global$1))
    _global$1[globalKey] = _global$1[globalKey] || {};
  return _global$1[globalKey];
}
function getSSRHandler(key, fallback2) {
  return handlers[key] || fallback2;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v3) => v3 === "true",
    write: (v3) => String(v3)
  },
  object: {
    read: (v3) => JSON.parse(v3),
    write: (v3) => JSON.stringify(v3)
  },
  number: {
    read: (v3) => Number.parseFloat(v3),
    write: (v3) => String(v3)
  },
  any: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  string: {
    read: (v3) => v3,
    write: (v3) => String(v3)
  },
  map: {
    read: (v3) => new Map(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3.entries()))
  },
  set: {
    read: (v3) => new Set(JSON.parse(v3)),
    write: (v3) => JSON.stringify(Array.from(v3))
  },
  date: {
    read: (v3) => new Date(v3),
    write: (v3) => v3.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a3;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError: onError2 = (e2) => {
      console.error(e2);
    }
  } = options;
  const data = (shallow ? shallowRef : ref)(defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e2) {
      onError2(e2);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults2);
  const type2 = guessSerializerType(rawInit);
  const serializer = (_a3 = options.serializer) != null ? _a3 : StorageSerializers[type2];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    useEventListener(window2, "storage", update);
    useEventListener(window2, customStorageEventName, updateFromCustomEvent);
  }
  update();
  return data;
  function write(v3) {
    try {
      if (v3 == null) {
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v3);
        const oldValue = storage.getItem(key);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          if (window2) {
            window2.dispatchEvent(new CustomEvent(customStorageEventName, {
              detail: {
                key,
                oldValue,
                newValue: serialized,
                storageArea: storage
              }
            }));
          }
        }
      }
    } catch (e2) {
      onError2(e2);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit !== null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value, rawInit);
      else if (type2 === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read(event);
    } catch (e2) {
      onError2(e2);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(
    () => unrefElement(target),
    (el) => {
      cleanup();
      if (isSupported.value && window2 && el) {
        observer = new MutationObserver(callback);
        observer.observe(el, mutationOptions);
      }
    },
    { immediate: true }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
const eventHandlers = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function useFullscreen(target, options = {}) {
  const {
    document: document2 = defaultDocument,
    autoExit = false
  } = options;
  const targetRef = computed(() => {
    var _a3;
    return (_a3 = unrefElement(target)) != null ? _a3 : document2 == null ? void 0 : document2.querySelector("html");
  });
  const isFullscreen = ref(false);
  const requestMethod = computed(() => {
    return [
      "requestFullscreen",
      "webkitRequestFullscreen",
      "webkitEnterFullscreen",
      "webkitEnterFullScreen",
      "webkitRequestFullScreen",
      "mozRequestFullScreen",
      "msRequestFullscreen"
    ].find((m2) => document2 && m2 in document2 || targetRef.value && m2 in targetRef.value);
  });
  const exitMethod = computed(() => {
    return [
      "exitFullscreen",
      "webkitExitFullscreen",
      "webkitExitFullScreen",
      "webkitCancelFullScreen",
      "mozCancelFullScreen",
      "msExitFullscreen"
    ].find((m2) => document2 && m2 in document2 || targetRef.value && m2 in targetRef.value);
  });
  const fullscreenEnabled = computed(() => {
    return [
      "fullScreen",
      "webkitIsFullScreen",
      "webkitDisplayingFullscreen",
      "mozFullScreen",
      "msFullscreenElement"
    ].find((m2) => document2 && m2 in document2 || targetRef.value && m2 in targetRef.value);
  });
  const fullscreenElementMethod = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((m2) => document2 && m2 in document2);
  const isSupported = useSupported(
    () => targetRef.value && document2 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0
  );
  const isCurrentElementFullScreen = () => {
    if (fullscreenElementMethod)
      return (document2 == null ? void 0 : document2[fullscreenElementMethod]) === targetRef.value;
    return false;
  };
  const isElementFullScreen = () => {
    if (fullscreenEnabled.value) {
      if (document2 && document2[fullscreenEnabled.value] != null) {
        return document2[fullscreenEnabled.value];
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {
          return Boolean(target2[fullscreenEnabled.value]);
        }
      }
    }
    return false;
  };
  async function exit() {
    if (!isSupported.value || !isFullscreen.value)
      return;
    if (exitMethod.value) {
      if ((document2 == null ? void 0 : document2[exitMethod.value]) != null) {
        await document2[exitMethod.value]();
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)
          await target2[exitMethod.value]();
      }
    }
    isFullscreen.value = false;
  }
  async function enter() {
    if (!isSupported.value || isFullscreen.value)
      return;
    if (isElementFullScreen())
      await exit();
    const target2 = targetRef.value;
    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
      await target2[requestMethod.value]();
      isFullscreen.value = true;
    }
  }
  async function toggle() {
    await (isFullscreen.value ? exit() : enter());
  }
  const handlerCallback = () => {
    const isElementFullScreenValue = isElementFullScreen();
    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())
      isFullscreen.value = isElementFullScreenValue;
  };
  useEventListener(document2, eventHandlers, handlerCallback, false);
  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);
  if (autoExit)
    tryOnScopeDispose(exit);
  return {
    isSupported,
    isFullscreen,
    enter,
    exit,
    toggle
  };
}
function useNow(options = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame"
  } = options;
  const now2 = ref(/* @__PURE__ */ new Date());
  const update = () => now2.value = /* @__PURE__ */ new Date();
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });
  if (exposeControls) {
    return {
      now: now2,
      ...controls
    };
  } else {
    return now2;
  }
}
function useScriptTag(src, onLoaded = noop$1, options = {}) {
  const {
    immediate = true,
    manual = false,
    type: type2 = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs = {}
  } = options;
  const scriptTag = ref(null);
  let _promise = null;
  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      scriptTag.value = el2;
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type2;
      el.async = async;
      el.src = toValue(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs).forEach(([name2, value]) => el == null ? void 0 : el.setAttribute(name2, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    el.addEventListener("error", (event) => reject(event));
    el.addEventListener("abort", (event) => reject(event));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  });
  const load = (waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  };
  const unload = () => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag.value)
      scriptTag.value = null;
    const el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnUnmounted(unload);
  return { scriptTag, load, unload };
}
let _id = 0;
function useStyleTag(css2, options = {}) {
  const isLoaded = ref(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `vueuse_styletag_${++_id}`
  } = options;
  const cssRef = ref(css2);
  let stop = () => {
  };
  const load = () => {
    if (!document2)
      return;
    const el = document2.getElementById(id) || document2.createElement("style");
    if (!el.isConnected) {
      el.id = id;
      if (options.media)
        el.media = options.media;
      document2.head.appendChild(el);
    }
    if (isLoaded.value)
      return;
    stop = watch(
      cssRef,
      (value) => {
        el.textContent = value;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  };
  const unload = () => {
    if (!document2 || !isLoaded.value)
      return;
    stop();
    document2.head.removeChild(document2.getElementById(id));
    isLoaded.value = false;
  };
  if (immediate && !manual)
    tryOnMounted(load);
  if (!manual)
    tryOnScopeDispose(unload);
  return {
    id,
    css: cssRef,
    unload,
    load,
    isLoaded: readonly(isLoaded)
  };
}
const CloseIcon = ({
  size: size2
}) => h$5("svg", {
  class: "wl-close-icon",
  viewBox: "0 0 1024 1024",
  width: size2,
  height: size2
}, [h$5("path", {
  d: "M697.173 85.333h-369.92c-144.64 0-241.92 101.547-241.92 252.587v348.587c0 150.613 97.28 252.16 241.92 252.16h369.92c144.64 0 241.494-101.547 241.494-252.16V337.92c0-151.04-96.854-252.587-241.494-252.587z",
  fill: "currentColor"
}), h$5("path", {
  d: "m640.683 587.52-75.947-75.861 75.904-75.862a37.29 37.29 0 0 0 0-52.778 37.205 37.205 0 0 0-52.779 0l-75.946 75.818-75.862-75.946a37.419 37.419 0 0 0-52.821 0 37.419 37.419 0 0 0 0 52.821l75.947 75.947-75.776 75.733a37.29 37.29 0 1 0 52.778 52.821l75.776-75.776 75.947 75.947a37.376 37.376 0 0 0 52.779-52.821z",
  fill: "#888"
})]);
const DeleteIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "m341.013 394.667 27.755 393.45h271.83l27.733-393.45h64.106l-28.01 397.952a64 64 0 0 1-63.83 59.498H368.768a64 64 0 0 1-63.83-59.52l-28.053-397.93h64.128zm139.307 19.818v298.667h-64V414.485h64zm117.013 0v298.667h-64V414.485h64zM181.333 288h640v64h-640v-64zm453.483-106.667v64h-256v-64h256z",
  fill: "red"
}));
const EmojiIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z",
  fill: "currentColor"
}));
const ImageIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, [h$5("path", {
  d: "M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z",
  fill: "currentColor"
}), h$5("path", {
  d: "M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z",
  fill: "currentColor"
})]);
const LikeIcon = ({
  active = false
}) => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, [h$5("path", {
  d: `M850.654 323.804c-11.042-25.625-26.862-48.532-46.885-68.225-20.022-19.61-43.258-34.936-69.213-45.73-26.78-11.124-55.124-16.727-84.375-16.727-40.622 0-80.256 11.123-114.698 32.135A214.79 214.79 0 0 0 512 241.819a214.79 214.79 0 0 0-23.483-16.562c-34.442-21.012-74.076-32.135-114.698-32.135-29.25 0-57.595 5.603-84.375 16.727-25.872 10.711-49.19 26.12-69.213 45.73-20.105 19.693-35.843 42.6-46.885 68.225-11.453 26.615-17.303 54.877-17.303 83.963 0 27.439 5.603 56.03 16.727 85.117 9.31 24.307 22.659 49.52 39.715 74.981 27.027 40.293 64.188 82.316 110.33 124.915 76.465 70.615 152.189 119.394 155.402 121.371l19.528 12.525c8.652 5.52 19.776 5.52 28.427 0l19.529-12.525c3.213-2.06 78.854-50.756 155.401-121.371 46.143-42.6 83.304-84.622 110.33-124.915 17.057-25.46 30.487-50.674 39.716-74.981 11.124-29.087 16.727-57.678 16.727-85.117.082-29.086-5.768-57.348-17.221-83.963z${active ? "" : "M512 761.5S218.665 573.55 218.665 407.767c0-83.963 69.461-152.023 155.154-152.023 60.233 0 112.473 33.618 138.181 82.727 25.708-49.109 77.948-82.727 138.18-82.727 85.694 0 155.155 68.06 155.155 152.023C805.335 573.551 512 761.5 512 761.5z"}`,
  fill: active ? "red" : "currentColor"
})]);
const PreviewIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, [h$5("path", {
  d: "M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0",
  fill: "currentColor"
}), h$5("path", {
  d: "M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0",
  fill: "currentColor"
})]);
const MarkdownIcon = () => h$5("svg", {
  width: "16",
  height: "16",
  ariaHidden: "true"
}, h$5("path", {
  d: "M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z",
  fill: "currentColor"
}));
const ReplyIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "M810.667 213.333a64 64 0 0 1 64 64V704a64 64 0 0 1-64 64H478.336l-146.645 96.107a21.333 21.333 0 0 1-33.024-17.856V768h-85.334a64 64 0 0 1-64-64V277.333a64 64 0 0 1 64-64h597.334zm0 64H213.333V704h149.334v63.296L459.243 704h351.424V277.333zm-271.36 213.334v64h-176.64v-64h176.64zm122.026-128v64H362.667v-64h298.666z",
  fill: "currentColor"
}));
const EditIcon = () => h$5("svg", {
  viewBox: "0 0 1024 1024",
  width: "24",
  height: "24"
}, h$5("path", {
  d: "M813.039 318.772L480.53 651.278H360.718V531.463L693.227 198.961C697.904 194.284 704.027 192 710.157 192C716.302 192 722.436 194.284 727.114 198.961L813.039 284.88C817.72 289.561 820 295.684 820 301.825C820 307.95 817.72 314.093 813.039 318.772ZM710.172 261.888L420.624 551.431V591.376H460.561L750.109 301.825L710.172 261.888ZM490.517 291.845H240.906V771.09H720.156V521.479C720.156 504.947 733.559 491.529 750.109 491.529C766.653 491.529 780.063 504.947 780.063 521.479V791.059C780.063 813.118 762.18 831 740.125 831H220.937C198.882 831 181 813.118 181 791.059V271.872C181 249.817 198.882 231.935 220.937 231.935H490.517C507.06 231.935 520.47 245.352 520.47 261.888C520.47 278.424 507.06 291.845 490.517 291.845Z",
  fill: "currentColor"
}));
const VerifiedIcon = () => h$5("svg", {
  class: "verified-icon",
  viewBox: "0 0 1024 1024",
  width: "14",
  height: "14"
}, h$5("path", {
  d: "m894.4 461.56-54.4-63.2c-10.4-12-18.8-34.4-18.8-50.4v-68c0-42.4-34.8-77.2-77.2-77.2h-68c-15.6 0-38.4-8.4-50.4-18.8l-63.2-54.4c-27.6-23.6-72.8-23.6-100.8 0l-62.8 54.8c-12 10-34.8 18.4-50.4 18.4h-69.2c-42.4 0-77.2 34.8-77.2 77.2v68.4c0 15.6-8.4 38-18.4 50l-54 63.6c-23.2 27.6-23.2 72.4 0 100l54 63.6c10 12 18.4 34.4 18.4 50v68.4c0 42.4 34.8 77.2 77.2 77.2h69.2c15.6 0 38.4 8.4 50.4 18.8l63.2 54.4c27.6 23.6 72.8 23.6 100.8 0l63.2-54.4c12-10.4 34.4-18.8 50.4-18.8h68c42.4 0 77.2-34.8 77.2-77.2v-68c0-15.6 8.4-38.4 18.8-50.4l54.4-63.2c23.2-27.6 23.2-73.2-.4-100.8zm-216-25.2-193.2 193.2a30 30 0 0 1-42.4 0l-96.8-96.8a30.16 30.16 0 0 1 0-42.4c11.6-11.6 30.8-11.6 42.4 0l75.6 75.6 172-172c11.6-11.6 30.8-11.6 42.4 0 11.6 11.6 11.6 30.8 0 42.4z",
  fill: "#27ae60"
}));
const LoadingIcon = ({
  size: size2 = 100
}) => h$5("svg", {
  width: size2,
  height: size2,
  viewBox: "0 0 100 100",
  preserveAspectRatio: "xMidYMid"
}, h$5("circle", {
  cx: 50,
  cy: 50,
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "4",
  r: "40",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  "stroke-dasharray": "85 30"
}, h$5("animateTransform", {
  attributeName: "transform",
  type: "rotate",
  repeatCount: "indefinite",
  dur: "1s",
  values: "0 50 50;360 50 50",
  keyTimes: "0;1"
})));
const GifIcon = () => h$5("svg", {
  width: 24,
  height: 24,
  fill: "currentcolor",
  viewBox: "0 0 24 24"
}, [h$5("path", {
  style: "transform: translateY(0.5px)",
  d: "M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z"
}), h$5("path", {
  d: "M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z"
})]);
const DefaultUserAvatar = ({
  size: size2 = 100
}) => h$5("svg", {
  width: size2,
  height: size2,
  viewBox: "0 0 1032 1280",
  preserveAspectRatio: "xMidYMid meet"
}, [h$5("g", {
  transform: "translate(0, 1280) scale(0.1, -0.1)",
  fill: "currentcolor",
  stroke: "none"
}, [h$5("path", {
  d: "M4935 12793 c-439 -35 -764 -108 -1140 -255 -848 -333 -1574 -1014 -1964 -1840 -567 -1201 -452 -2603 303 -3690 61 -87 177 -235 271 -344 l34 -40 -106 -120 c-1013 -1138 -1867 -2566 -2183 -3655 -225 -775 -194 -1343 93 -1705 129 -162 320 -303 602 -444 236 -119 240 -120 327 -90 211 72 451 303 658 635 34 55 66 104 70 109 5 4 -21 -81 -56 -190 -68 -209 -224 -730 -224 -748 0 -6 76 -30 170 -54 732 -184 1503 -288 2545 -344 356 -19 1374 -16 1735 5 717 42 1299 107 1825 203 187 34 623 129 632 137 6 7 -126 460 -216 742 -44 137 -79 251 -77 252 1 2 29 -40 62 -93 263 -425 548 -664 814 -681 83 -5 92 -4 166 27 111 46 320 151 401 202 357 222 533 456 607 803 169 793 -298 2136 -1242 3570 -294 447 -595 846 -943 1250 -80 94 -156 179 -168 189 -11 11 -21 23 -21 28 0 5 28 41 63 81 190 219 372 498 511 789 190 394 301 790 348 1238 16 161 16 549 0 710 -124 1192 -786 2224 -1816 2829 -555 327 -1231 506 -1880 499 -89 -1 -179 -3 -201 -5z"
})])]);
const useUserMeta = () => useStorage("WALINE_USER_META", {
  nick: "",
  mail: "",
  link: ""
});
const useEditor = () => useStorage("WALINE_COMMENT_BOX_EDITOR", "");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", {
    value: true
  });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var ReCaptcha = {};
var ReCaptchaLoader$1 = {};
var ReCaptchaInstance$1 = {};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = {
    label: 0,
    sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y3, t2, g2;
  return g2 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
          return t2;
        if (y3 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y3 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
Object.defineProperty(ReCaptchaInstance$1, "__esModule", {
  value: true
});
ReCaptchaInstance$1.ReCaptchaInstance = void 0;
var ReCaptchaInstance = function() {
  function ReCaptchaInstance2(siteKey, recaptchaID, recaptcha) {
    this.siteKey = siteKey;
    this.recaptchaID = recaptchaID;
    this.recaptcha = recaptcha;
    this.styleContainer = null;
  }
  ReCaptchaInstance2.prototype.execute = function(action) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a3) {
        return [2, this.recaptcha.enterprise ? this.recaptcha.enterprise.execute(this.recaptchaID, {
          action
        }) : this.recaptcha.execute(this.recaptchaID, {
          action
        })];
      });
    });
  };
  ReCaptchaInstance2.prototype.getSiteKey = function() {
    return this.siteKey;
  };
  ReCaptchaInstance2.prototype.hideBadge = function() {
    if (this.styleContainer !== null) {
      return;
    }
    this.styleContainer = document.createElement("style");
    this.styleContainer.innerHTML = ".grecaptcha-badge{visibility:hidden !important;}";
    document.head.appendChild(this.styleContainer);
  };
  ReCaptchaInstance2.prototype.showBadge = function() {
    if (this.styleContainer === null) {
      return;
    }
    document.head.removeChild(this.styleContainer);
    this.styleContainer = null;
  };
  return ReCaptchaInstance2;
}();
ReCaptchaInstance$1.ReCaptchaInstance = ReCaptchaInstance;
Object.defineProperty(ReCaptchaLoader$1, "__esModule", {
  value: true
});
ReCaptchaLoader$1.getInstance = ReCaptchaLoader$1.load = void 0;
var ReCaptchaInstance_1 = ReCaptchaInstance$1;
var ELoadingState;
(function(ELoadingState2) {
  ELoadingState2[ELoadingState2["NOT_LOADED"] = 0] = "NOT_LOADED";
  ELoadingState2[ELoadingState2["LOADING"] = 1] = "LOADING";
  ELoadingState2[ELoadingState2["LOADED"] = 2] = "LOADED";
})(ELoadingState || (ELoadingState = {}));
var ReCaptchaLoader = function() {
  function ReCaptchaLoader2() {
  }
  ReCaptchaLoader2.load = function(siteKey, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      return Promise.reject(new Error("This is a library for the browser!"));
    }
    if (ReCaptchaLoader2.getLoadingState() === ELoadingState.LOADED) {
      if (ReCaptchaLoader2.instance.getSiteKey() === siteKey) {
        return Promise.resolve(ReCaptchaLoader2.instance);
      } else {
        return Promise.reject(new Error("reCAPTCHA already loaded with different site key!"));
      }
    }
    if (ReCaptchaLoader2.getLoadingState() === ELoadingState.LOADING) {
      if (siteKey !== ReCaptchaLoader2.instanceSiteKey) {
        return Promise.reject(new Error("reCAPTCHA already loaded with different site key!"));
      }
      return new Promise(function(resolve, reject) {
        ReCaptchaLoader2.successfulLoadingConsumers.push(function(instance) {
          return resolve(instance);
        });
        ReCaptchaLoader2.errorLoadingRunnable.push(function(reason) {
          return reject(reason);
        });
      });
    }
    ReCaptchaLoader2.instanceSiteKey = siteKey;
    ReCaptchaLoader2.setLoadingState(ELoadingState.LOADING);
    var loader = new ReCaptchaLoader2();
    return new Promise(function(resolve, reject) {
      loader.loadScript(siteKey, options.useRecaptchaNet || false, options.useEnterprise || false, options.renderParameters ? options.renderParameters : {}, options.customUrl).then(function() {
        ReCaptchaLoader2.setLoadingState(ELoadingState.LOADED);
        var widgetID = loader.doExplicitRender(grecaptcha, siteKey, options.explicitRenderParameters ? options.explicitRenderParameters : {}, options.useEnterprise || false);
        var instance = new ReCaptchaInstance_1.ReCaptchaInstance(siteKey, widgetID, grecaptcha);
        ReCaptchaLoader2.successfulLoadingConsumers.forEach(function(v3) {
          return v3(instance);
        });
        ReCaptchaLoader2.successfulLoadingConsumers = [];
        if (options.autoHideBadge) {
          instance.hideBadge();
        }
        ReCaptchaLoader2.instance = instance;
        resolve(instance);
      }).catch(function(error) {
        ReCaptchaLoader2.errorLoadingRunnable.forEach(function(v3) {
          return v3(error);
        });
        ReCaptchaLoader2.errorLoadingRunnable = [];
        reject(error);
      });
    });
  };
  ReCaptchaLoader2.getInstance = function() {
    return ReCaptchaLoader2.instance;
  };
  ReCaptchaLoader2.setLoadingState = function(state) {
    ReCaptchaLoader2.loadingState = state;
  };
  ReCaptchaLoader2.getLoadingState = function() {
    if (ReCaptchaLoader2.loadingState === null) {
      return ELoadingState.NOT_LOADED;
    } else {
      return ReCaptchaLoader2.loadingState;
    }
  };
  ReCaptchaLoader2.prototype.loadScript = function(siteKey, useRecaptchaNet, useEnterprise, renderParameters, customUrl) {
    var _this = this;
    if (useRecaptchaNet === void 0) {
      useRecaptchaNet = false;
    }
    if (useEnterprise === void 0) {
      useEnterprise = false;
    }
    if (renderParameters === void 0) {
      renderParameters = {};
    }
    if (customUrl === void 0) {
      customUrl = "";
    }
    var scriptElement = document.createElement("script");
    scriptElement.setAttribute("recaptcha-v3-script", "");
    var scriptBase = "https://www.google.com/recaptcha/api.js";
    if (useRecaptchaNet) {
      if (useEnterprise) {
        scriptBase = "https://recaptcha.net/recaptcha/enterprise.js";
      } else {
        scriptBase = "https://recaptcha.net/recaptcha/api.js";
      }
    }
    if (useEnterprise) {
      scriptBase = "https://www.google.com/recaptcha/enterprise.js";
    }
    if (customUrl) {
      scriptBase = customUrl;
    }
    if (renderParameters.render) {
      renderParameters.render = void 0;
    }
    var parametersQuery = this.buildQueryString(renderParameters);
    scriptElement.src = scriptBase + "?render=explicit" + parametersQuery;
    return new Promise(function(resolve, reject) {
      scriptElement.addEventListener("load", _this.waitForScriptToLoad(function() {
        resolve(scriptElement);
      }, useEnterprise), false);
      scriptElement.onerror = function(error) {
        ReCaptchaLoader2.setLoadingState(ELoadingState.NOT_LOADED);
        reject(error);
      };
      document.head.appendChild(scriptElement);
    });
  };
  ReCaptchaLoader2.prototype.buildQueryString = function(parameters) {
    var parameterKeys = Object.keys(parameters);
    if (parameterKeys.length < 1) {
      return "";
    }
    return "&" + Object.keys(parameters).filter(function(parameterKey) {
      return !!parameters[parameterKey];
    }).map(function(parameterKey) {
      return parameterKey + "=" + parameters[parameterKey];
    }).join("&");
  };
  ReCaptchaLoader2.prototype.waitForScriptToLoad = function(callback, useEnterprise) {
    var _this = this;
    return function() {
      if (window.grecaptcha === void 0) {
        setTimeout(function() {
          _this.waitForScriptToLoad(callback, useEnterprise);
        }, ReCaptchaLoader2.SCRIPT_LOAD_DELAY);
      } else {
        if (useEnterprise) {
          window.grecaptcha.enterprise.ready(function() {
            callback();
          });
        } else {
          window.grecaptcha.ready(function() {
            callback();
          });
        }
      }
    };
  };
  ReCaptchaLoader2.prototype.doExplicitRender = function(grecaptcha2, siteKey, parameters, isEnterprise) {
    var augmentedParameters = {
      sitekey: siteKey,
      badge: parameters.badge,
      size: parameters.size,
      tabindex: parameters.tabindex
    };
    if (parameters.container) {
      if (isEnterprise) {
        return grecaptcha2.enterprise.render(parameters.container, augmentedParameters);
      } else {
        return grecaptcha2.render(parameters.container, augmentedParameters);
      }
    } else {
      if (isEnterprise) {
        return grecaptcha2.enterprise.render(augmentedParameters);
      } else {
        return grecaptcha2.render(augmentedParameters);
      }
    }
  };
  ReCaptchaLoader2.loadingState = null;
  ReCaptchaLoader2.instance = null;
  ReCaptchaLoader2.instanceSiteKey = null;
  ReCaptchaLoader2.successfulLoadingConsumers = [];
  ReCaptchaLoader2.errorLoadingRunnable = [];
  ReCaptchaLoader2.SCRIPT_LOAD_DELAY = 25;
  return ReCaptchaLoader2;
}();
ReCaptchaLoader$1.load = ReCaptchaLoader.load;
ReCaptchaLoader$1.getInstance = ReCaptchaLoader.getInstance;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ReCaptchaInstance = exports.getInstance = exports.load = void 0;
  var ReCaptchaLoader_1 = ReCaptchaLoader$1;
  Object.defineProperty(exports, "load", {
    enumerable: true,
    get: function() {
      return ReCaptchaLoader_1.load;
    }
  });
  Object.defineProperty(exports, "getInstance", {
    enumerable: true,
    get: function() {
      return ReCaptchaLoader_1.getInstance;
    }
  });
  var ReCaptchaInstance_12 = ReCaptchaInstance$1;
  Object.defineProperty(exports, "ReCaptchaInstance", {
    enumerable: true,
    get: function() {
      return ReCaptchaInstance_12.ReCaptchaInstance;
    }
  });
})(ReCaptcha);
const recaptchaStore = {};
const useReCaptcha = (key) => {
  const init = recaptchaStore[key] ?? (recaptchaStore[key] = ReCaptcha.load(key, {
    useRecaptchaNet: true,
    autoHideBadge: true
  }));
  return {
    execute: (action) => init.then((instance) => instance.execute(action))
  };
};
const useTurnstile = (key) => {
  const execute = async (action) => {
    const {
      load
    } = useScriptTag("https://challenges.cloudflare.com/turnstile/v0/api.js", void 0, {
      async: false
    });
    await load();
    const turnstile = window == null ? void 0 : window.turnstile;
    return new Promise((resolve) => {
      turnstile == null ? void 0 : turnstile.ready(() => {
        turnstile == null ? void 0 : turnstile.render(".wl-captcha-container", {
          sitekey: key,
          action,
          size: "compact",
          callback: resolve
        });
      });
    });
  };
  return {
    execute
  };
};
const USER_INFO_KEY = "USER_INFO";
let userInfoStorage = null;
const useUserInfo = () => userInfoStorage ?? (userInfoStorage = useStorage(USER_INFO_KEY, {}));
const ACCESS_TOKEN_KEY = "Access-Token";
let accessTokenStorage = null;
const useAccessToken = () => accessTokenStorage ?? (accessTokenStorage = useStorage(ACCESS_TOKEN_KEY, ref("")));
const decodePath = (path) => {
  try {
    path = decodeURI(path);
  } catch (err2) {
  }
  return path;
};
const removeEndingSplash = (content = "") => content.replace(/\/$/u, "");
const isLinkHttp = (link) => /^(https?:)?\/\//.test(link);
const DEFAULT_LANG = "en-US";
const defaultUploadImage = (file) => new Promise((resolve, reject) => {
  if (file.size > 128 * 1e3)
    return reject(new Error("File too large! File size limit 128KB"));
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onload = () => {
    var _a3;
    return resolve(((_a3 = reader.result) == null ? void 0 : _a3.toString()) || "");
  };
  reader.onerror = reject;
});
const defaultTeXRenderer = (blockMode) => blockMode === true ? '<p class="wl-tex">TeX is not available in preview</p>' : '<span class="wl-tex">TeX is not available in preview</span>';
const getDefaultSearchOptions = (lang) => {
  const fetchGiphy = async (url, params = {}) => fetch(`https://api.giphy.com/v1/gifs/${url}?${new URLSearchParams({
    lang,
    limit: "20",
    rating: "g",
    // eslint-disable-next-line @typescript-eslint/naming-convention
    api_key: "6CIMLkNMMOhRcXPoMCPkFy4Ybk2XUiMp",
    ...params
  }).toString()}`).then((resp) => resp.json()).then(({
    data
  }) => data.map((gif) => ({
    title: gif.title,
    src: gif.images.downsized_medium.url
  })));
  return {
    search: (word) => fetchGiphy("search", {
      q: word,
      offset: "0"
    }),
    default: () => fetchGiphy("trending", {}),
    more: (word, offset2 = 0) => fetchGiphy("search", {
      q: word,
      offset: offset2.toString()
    })
  };
};
const WORD_REGEXP = /[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/;
const LEFT_ANGLE_REGEXP = /</;
const LINE_COMMENT_REGEXP = /(?:^|\s)\/\/(.+?)$/gm;
const BLOCK_COMMENT_REGEXP = /\/\*([\S\s]*?)\*\//gm;
const REGEXP = new RegExp(`(${WORD_REGEXP.source}|${LEFT_ANGLE_REGEXP.source})|((?:${LINE_COMMENT_REGEXP.source})|(?:${BLOCK_COMMENT_REGEXP.source}))`, "gmi");
const COLORS = ["23AC69", "91C132", "F19726", "E8552D", "1AAB8E", "E1147F", "2980C1", "1BA1E6", "9FA0A0", "F19726", "E30B20", "E30B20", "A3338B"];
const cache = {};
const defaultHighlighter = (input) => {
  let index2 = 0;
  return input.replace(REGEXP, (_match, word, comment) => {
    if (comment)
      return `<span style="color: slategray">${comment}</span>`;
    if (word === "<")
      return "&lt;";
    let color;
    if (cache[word])
      color = cache[word];
    else {
      color = COLORS[index2];
      cache[word] = color;
    }
    const out = `<span style="color: #${color}">${word}</span>`;
    index2 = ++index2 % COLORS.length;
    return out;
  });
};
const localeKeys = ["nick", "nickError", "mail", "mailError", "link", "optional", "placeholder", "sofa", "submit", "like", "cancelLike", "reply", "cancelReply", "comment", "refresh", "more", "preview", "emoji", "uploadImage", "seconds", "minutes", "hours", "days", "now", "uploading", "login", "logout", "admin", "sticky", "word", "wordHint", "anonymous", "level0", "level1", "level2", "level3", "level4", "level5", "gif", "gifSearchPlaceholder", "profile", "approved", "waiting", "spam", "unsticky", "oldest", "latest", "hottest", "reactionTitle"];
const generateLocale = (locale) => Object.fromEntries(locale.map((item, index2) => [localeKeys[index2], item]));
const en = generateLocale(["NickName", "NickName cannot be less than 3 bytes.", "E-Mail", "Please confirm your email address.", "Website", "Optional", "Comment here...", "No comment yet.", "Submit", "Like", "Cancel like", "Reply", "Cancel reply", "Comments", "Refresh", "Load More...", "Preview", "Emoji", "Upload Image", "seconds ago", "minutes ago", "hours ago", "days ago", "just now", "Uploading", "Login", "logout", "Admin", "Sticky", "Words", "Please input comments between $0 and $1 words!\n Current word number: $2", "Anonymous", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Search GIF", "Profile", "Approved", "Waiting", "Spam", "Unsticky", "Oldest", "Latest", "Hottest", "What do you think?"]);
const jp = generateLocale(["ニックネーム", "3バイト以上のニックネームをご入力ください.", "メールアドレス", "メールアドレスをご確認ください.", "サイト", "オプション", "ここにコメント", "コメントしましょう~", "提出する", "Like", "Cancel like", "返信する", "キャンセル", "コメント", "更新", "さらに読み込む", "プレビュー", "絵文字", "画像をアップロード", "秒前", "分前", "時間前", "日前", "たっだ今", "アップロード", "ログインする", "ログアウト", "管理者", "トップに置く", "ワード", "コメントは $0 から $1 ワードの間でなければなりません!\n 現在の単語番号: $2", "匿名", "うえにん", "なかにん", "しもおし", "特にしもおし", "かげ", "なぬし", "GIF", "探す GIF", "個人情報", "承認済み", "待っている", "スパム", "べたつかない", "逆順", "正順", "人気順", "どう思いますか？"]);
const ptBR = generateLocale(["Apelido", "Apelido não pode ser menor que 3 bytes.", "E-Mail", "Por favor, confirme seu endereço de e-mail.", "Website", "Opcional", "Comente aqui...", "Nenhum comentário, ainda.", "Enviar", "Like", "Cancel like", "Responder", "Cancelar resposta", "Comentários", "Refrescar", "Carregar Mais...", "Visualizar", "Emoji", "Enviar Imagem", "segundos atrás", "minutos atrás", "horas atrás", "dias atrás", "agora mesmo", "Enviando", "Entrar", "Sair", "Admin", "Sticky", "Palavras", "Favor enviar comentário com $0 a $1 palavras!\n Número de palavras atuais: $2", "Anônimo", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Pesquisar GIF", "informação pessoal", "Aprovado", "Espera", "Spam", "Unsticky", "Mais velho", "Mais recentes", "Mais quente", "O que você acha?"]);
const ru = generateLocale(["Псевдоним", "Никнейм не может быть меньше 3 байт.", "Эл. адрес", "Пожалуйста, подтвердите адрес вашей электронной почты.", "Веб-сайт", "Необязательный", "Комментарий здесь...", "Пока нет комментариев.", "Отправить", "Like", "Cancel like", "Отвечать", "Отменить ответ", "Комментарии", "Обновить", "Загрузи больше...", "Превью", "эмодзи", "Загрузить изображение", "секунд назад", "несколько минут назад", "несколько часов назад", "дней назад", "прямо сейчас", "Загрузка", "Авторизоваться", "Выход из системы", "Админ", "Липкий", "Слова", "Пожалуйста, введите комментарии от $0 до $1 слов!\nНомер текущего слова: $2", "Анонимный", "Dwarves", "Hobbits", "Ents", "Wizards", "Elves", "Maiar", "GIF", "Поиск GIF", "Персональные данные", "Одобренный", "Ожидающий", "Спам", "Нелипкий", "самый старый", "последний", "самый горячий", "Что вы думаете?"]);
const zhCN = generateLocale(["昵称", "昵称不能少于3个字符", "邮箱", "请填写正确的邮件地址", "网址", "可选", "欢迎评论", "还没有评论哦~ 快来抢一个沙发吧！", "提交", "喜欢", "取消喜欢", "回复", "取消回复", "评论", "刷新", "加载更多...", "预览", "表情", "上传图片", "秒前", "分钟前", "小时前", "天前", "刚刚", "正在上传", "登录", "退出", "博主", "置顶", "字", "评论字数应在 $0 到 $1 字之间！\n当前字数：$2", "匿名", "潜水", "冒泡", "吐槽", "活跃", "话痨", "传说", "表情包", "搜索表情包", "个人资料", "通过", "待审核", "垃圾", "取消置顶", "按最早", "按最新", "按热度", "发表下你的态度吧~"]);
const zhTW = generateLocale(["暱稱", "暱稱不能少於3個字元", "郵箱", "請填寫正確的郵件地址", "網址", "可選", "歡迎留言", "來發留言吧~", "送出", "喜歡", "取消喜歡", "回覆", "取消回覆", "留言", "重整", "載入更多...", "預覽", "表情", "上傳圖片", "秒前", "分鐘前", "小時前", "天前", "剛剛", "正在上傳", "登入", "登出", "管理者", "置頂", "字", "留言字數應在 $0 到 $1 字之間！\n目前字數：$2", "匿名", "潛水", "冒泡", "吐槽", "活躍", "多話", "傳說", "表情包", "搜尋表情包", "個人資料", "通過", "待審核", "垃圾", "取消置頂", "最早", "最新", "熱門", "你認為這篇文章怎麼樣？"]);
const DEFAULT_LOCALES = {
  zh: zhCN,
  "zh-cn": zhCN,
  "zh-CN": zhCN,
  "zh-tw": zhTW,
  "zh-TW": zhTW,
  en,
  "en-US": en,
  "en-us": en,
  jp,
  ja: jp,
  "jp-jp": jp,
  "jp-JP": jp,
  "pt-br": ptBR,
  "pt-BR": ptBR,
  ru,
  "ru-ru": ru,
  "ru-RU": ru
};
const getServerURL = (serverURL) => {
  const result = removeEndingSplash(serverURL);
  return isLinkHttp(result) ? result : `https://${result}`;
};
const getWordLimit = (wordLimit) => Array.isArray(wordLimit) ? wordLimit : wordLimit ? [0, wordLimit] : false;
const fallback = (value, fallback2) => typeof value === "function" ? value : value === false ? false : fallback2;
const getConfig = ({
  // serverURL,
  id,
  path = location.pathname,
  lang = typeof navigator === "undefined" ? "en-US" : navigator.language,
  locale,
  // emoji = DEFAULT_EMOJI,
  // meta = ['nick', 'mail', 'link'],
  // requiredMeta = [],
  dark = false,
  pageSize = 10,
  wordLimit,
  imageUploader,
  highlighter: highlighter2,
  texRenderer: texRenderer2,
  copyright = true,
  login = "enable",
  search: search2,
  // reaction,
  recaptchaV3Key = "",
  turnstileKey = "",
  commentSorting = "latest",
  ...more
}) => ({
  // serverURL: getServerURL(serverURL),
  id: id || decodePath(path),
  locale: {
    ...DEFAULT_LOCALES[lang] || DEFAULT_LOCALES[DEFAULT_LANG],
    ...typeof locale === "object" ? locale : {}
  },
  wordLimit: getWordLimit(wordLimit),
  // meta: getMeta(meta),
  // requiredMeta: getMeta(requiredMeta),
  imageUploader: fallback(imageUploader, defaultUploadImage),
  highlighter: fallback(highlighter2, defaultHighlighter),
  texRenderer: fallback(texRenderer2, defaultTeXRenderer),
  lang: Object.keys(DEFAULT_LOCALES).includes(lang) ? lang : "en-US",
  dark,
  // emoji: typeof emoji === 'boolean' ? (emoji ? DEFAULT_EMOJI : []) : emoji,
  pageSize,
  login,
  copyright,
  search: search2 === false ? false : typeof search2 === "object" ? search2 : getDefaultSearchOptions(lang),
  recaptchaV3Key,
  turnstileKey,
  // reaction: Array.isArray(reaction)
  //   ? reaction
  //   : reaction === true
  //   ? DEFAULT_REACTION
  //   : [],
  commentSorting,
  ...more
});
const style$2 = `{--waline-white:#000;--waline-light-grey:#666;--waline-dark-grey:#999;--waline-color:#888;--waline-bgcolor:#1e1e1e;--waline-bgcolor-light:#272727;--waline-bgcolor-hover: #444;--waline-border-color:#333;--waline-disable-bgcolor:#444;--waline-disable-color:#272727;--waline-bq-color:#272727;--waline-info-bgcolor:#272727;--waline-info-color:#666}`;
const getDarkStyle = (selector) => {
  if (typeof selector === "string") {
    return selector === "auto" ? `@media(prefers-color-scheme:dark){body${style$2}}` : `${selector}${style$2}`;
  }
  return selector === true ? `:root${style$2}` : "";
};
const padWithZeros = (vNumber, width) => {
  let numAsString = vNumber.toString();
  while (numAsString.length < width) {
    numAsString = "0" + numAsString;
  }
  return numAsString;
};
const dateFormat = (date) => {
  const vDay = padWithZeros(date.getDate(), 2);
  const vMonth = padWithZeros(date.getMonth() + 1, 2);
  const vYear = padWithZeros(date.getFullYear(), 2);
  return `${vYear}-${vMonth}-${vDay}`;
};
const getTimeAgo = (date, now2, locale) => {
  if (!date)
    return "";
  const time = typeof date === "string" ? new Date(date.indexOf(" ") !== -1 ? date.replace(/-/g, "/") : date) : date;
  const timePassed = now2.getTime() - time.getTime();
  const days = Math.floor(timePassed / (24 * 3600 * 1e3));
  if (days === 0) {
    const leave1 = timePassed % (24 * 3600 * 1e3);
    const hours = Math.floor(leave1 / (3600 * 1e3));
    if (hours === 0) {
      const leave2 = leave1 % (3600 * 1e3);
      const minutes = Math.floor(leave2 / (60 * 1e3));
      if (minutes === 0) {
        const leave3 = leave2 % (60 * 1e3);
        const seconds = Math.round(leave3 / 1e3);
        return `${seconds} ${locale.seconds}`;
      }
      return `${minutes} ${locale.minutes}`;
    }
    return `${hours} ${locale.hours}`;
  }
  if (days < 0)
    return locale.now;
  if (days < 8)
    return `${days} ${locale.days}`;
  return dateFormat(time);
};
const hasVersion = (url) => Boolean(/@[0-9]+\.[0-9]+\.[0-9]+/.test(url));
const fetchEmoji = (link) => {
  const emojiStore = useStorage("WALINE_EMOJI", {});
  const result = hasVersion(link);
  if (result) {
    const info = emojiStore.value[link];
    if (info)
      return Promise.resolve(info);
  }
  return fetch(`${link}/info.json`).then((resp) => resp.json()).then((emojiInfo) => {
    const info = {
      folder: link,
      ...emojiInfo
    };
    if (result)
      emojiStore.value[link] = info;
    return info;
  });
};
const getLink = (name2, folder = "", prefix = "", type2 = "") => `${folder ? `${folder}/` : ""}${prefix}${name2}${type2 ? `.${type2}` : ""}`;
const getEmojis = (emojis) => Promise.all(emojis.map((emoji2) => typeof emoji2 === "string" ? fetchEmoji(removeEndingSplash(emoji2)) : Promise.resolve(emoji2))).then((emojiInfos) => {
  const emojiConfig = {
    tabs: [],
    map: {}
  };
  emojiInfos.forEach((emojiInfo) => {
    const {
      name: name2,
      folder,
      icon,
      prefix,
      type: type2,
      items
    } = emojiInfo;
    emojiConfig.tabs.push({
      name: name2,
      icon: getLink(icon, folder, prefix, type2),
      items: items.map((item) => {
        const key = `${prefix || ""}${item}`;
        emojiConfig.map[key] = getLink(item, folder, prefix, type2);
        return key;
      })
    });
  });
  return emojiConfig;
});
const isImage = (item) => item.type.includes("image");
const getImageFromDataTransfer = (items) => {
  const image = Array.from(items).find(isImage);
  return image ? image.getAsFile() : null;
};
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults$2 = getDefaults();
function changeDefaults(newDefaults) {
  defaults$2 = newDefaults;
}
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, "g");
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape$1(html2, encode2) {
  if (encode2) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(html2) {
  return html2.replace(unescapeTest, (_2, n2) => {
    n2 = n2.toLowerCase();
    if (n2 === "colon")
      return ":";
    if (n2.charAt(0) === "#") {
      return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e2) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e2) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
const noopTest = {
  exec: function noopTest2() {
  }
};
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset2, str) => {
    let escaped = false, curr = offset2;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i3 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i3 < cells.length; i3++) {
    cells[i3] = cells[i3].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c2, invert) {
  const l2 = str.length;
  if (l2 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l2) {
    const currChar = str.charAt(l2 - suffLen - 1);
    if (currChar === c2 && !invert) {
      suffLen++;
    } else if (currChar !== c2 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l2 - suffLen);
}
function findClosingBracket(str, b2) {
  if (str.indexOf(b2[1]) === -1) {
    return -1;
  }
  const l2 = str.length;
  let level = 0, i3 = 0;
  for (; i3 < l2; i3++) {
    if (str[i3] === "\\") {
      i3++;
    } else if (str[i3] === b2[0]) {
      level++;
    } else if (str[i3] === b2[1]) {
      level--;
      if (level < 0) {
        return i3;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape$1(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token2 = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer.inlineTokens(text2)
    };
    lexer.state.inLink = false;
    return token2;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape$1(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node2) => {
    const matchIndentInNode = node2.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node2;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node2.slice(indentToCode.length);
    }
    return node2;
  }).join("\n");
}
class Tokenizer {
  constructor(options) {
    this.options = options || defaults$2;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i3, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t2) => " ".repeat(3 * t2.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l2 = list.items.length;
      for (i3 = 0; i3 < l2; i3++) {
        this.lexer.state.top = false;
        list.items[i3].tokens = this.lexer.blockTokens(list.items[i3].text, []);
        if (!list.loose) {
          const spacers = list.items[i3].tokens.filter((t2) => t2.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t2) => /\n.*\n/.test(t2.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i3 = 0; i3 < l2; i3++) {
          list.items[i3].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token2 = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0]);
        token2.type = "paragraph";
        token2.text = text2;
        token2.tokens = this.lexer.inline(text2);
      }
      return token2;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c2) => {
          return {
            text: c2
          };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l2 = item.align.length;
        let i3, j2, k2, row;
        for (i3 = 0; i3 < l2; i3++) {
          if (/^ *-+: *$/.test(item.align[i3])) {
            item.align[i3] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i3])) {
            item.align[i3] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i3])) {
            item.align[i3] = "left";
          } else {
            item.align[i3] = null;
          }
        }
        l2 = item.rows.length;
        for (i3 = 0; i3 < l2; i3++) {
          item.rows[i3] = splitCells(item.rows[i3], item.header.length).map((c2) => {
            return {
              text: c2
            };
          });
        }
        l2 = item.header.length;
        for (j2 = 0; j2 < l2; j2++) {
          item.header[j2].tokens = this.lexer.inline(item.header[j2].text);
        }
        l2 = item.rows.length;
        for (j2 = 0; j2 < l2; j2++) {
          row = item.rows[j2];
          for (k2 = 0; k2 < row.length; k2++) {
            row[k2].tokens = this.lexer.inline(row[k2].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape$1(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape$1(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape$1(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape$1(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [{
          type: "text",
          raw: text2,
          text: text2
        }]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape$1(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape$1(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [{
          type: "text",
          raw: text2,
          text: text2
        }]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0]) : cap[0];
      } else {
        text2 = escape$1(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = {
  ...block
};
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = {
  ...inline
};
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text2) {
  return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text2) {
  let out = "", i3, ch;
  const l2 = text2.length;
  for (i3 = 0; i3 < l2; i3++) {
    ch = text2.charCodeAt(i3);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options || defaults$2;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_2, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token2, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token2 = extTokenizer.call({
          lexer: this
        }, src, tokens)) {
          src = src.substring(token2.raw.length);
          tokens.push(token2);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token2 = this.tokenizer.space(src)) {
        src = src.substring(token2.raw.length);
        if (token2.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.code(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.fences(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.heading(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.hr(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.blockquote(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.list(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.html(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.def(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token2.tag]) {
          this.tokens.links[token2.tag] = {
            href: token2.href,
            title: token2.title
          };
        }
        continue;
      }
      if (token2 = this.tokenizer.table(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.lheading(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({
            lexer: this
          }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token2 = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token2.raw.length);
        continue;
      }
      if (token2 = this.tokenizer.text(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token2.raw;
          lastToken.text += "\n" + token2.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({
      src,
      tokens
    });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token2, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token2 = extTokenizer.call({
          lexer: this
        }, src, tokens)) {
          src = src.substring(token2.raw.length);
          tokens.push(token2);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token2 = this.tokenizer.escape(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.tag(src)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token2.type === "text" && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.link(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token2.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token2.type === "text" && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (token2 = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.codespan(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.br(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.del(src)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (token2 = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      if (!this.state.inLink && (token2 = this.tokenizer.url(src, mangle))) {
        src = src.substring(token2.raw.length);
        tokens.push(token2);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({
            lexer: this
          }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token2 = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token2.raw.length);
        if (token2.raw.slice(-1) !== "_") {
          prevChar = token2.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token2.raw;
          lastToken.text += token2.text;
        } else {
          tokens.push(token2);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
class Renderer {
  constructor(options) {
    this.options = options || defaults$2;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape$1(lang) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html2) {
    return html2;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text2, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text2}</h${level}>
`;
    }
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type2 = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type2 + startatt + ">\n" + body + "</" + type2 + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text2) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type2 = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type2} align="${flags.align}">` : `<${type2}>`;
    return tag + content + `</${type2}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text2) {
    return `<em>${text2}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text2) {
    return `<del>${text2}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text2) {
    return text2;
  }
}
class TextRenderer {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
}
class Parser {
  constructor(options) {
    this.options = options || defaults$2;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new Parser(options);
    return parser.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i3, j2, k2, l2, l3, row, cell, header, body, token2, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l4 = tokens.length;
    for (i3 = 0; i3 < l4; i3++) {
      token2 = tokens[i3];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
        ret = this.options.extensions.renderers[token2.type].call({
          parser: this
        }, token2);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token2.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token2.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(this.parseInline(token2.tokens), token2.depth, unescape$1(this.parseInline(token2.tokens, this.textRenderer)), this.slugger);
          continue;
        }
        case "code": {
          out += this.renderer.code(token2.text, token2.lang, token2.escaped);
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token2.header.length;
          for (j2 = 0; j2 < l2; j2++) {
            cell += this.renderer.tablecell(this.parseInline(token2.header[j2].tokens), {
              header: true,
              align: token2.align[j2]
            });
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token2.rows.length;
          for (j2 = 0; j2 < l2; j2++) {
            row = token2.rows[j2];
            cell = "";
            l3 = row.length;
            for (k2 = 0; k2 < l3; k2++) {
              cell += this.renderer.tablecell(this.parseInline(row[k2].tokens), {
                header: false,
                align: token2.align[k2]
              });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token2.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token2.ordered;
          start = token2.start;
          loose = token2.loose;
          l2 = token2.items.length;
          body = "";
          for (j2 = 0; j2 < l2; j2++) {
            item = token2.items[j2];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token2.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token2.tokens));
          continue;
        }
        case "text": {
          body = token2.tokens ? this.parseInline(token2.tokens) : token2.text;
          while (i3 + 1 < l4 && tokens[i3 + 1].type === "text") {
            token2 = tokens[++i3];
            body += "\n" + (token2.tokens ? this.parseInline(token2.tokens) : token2.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token2.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i3, token2, ret;
    const l2 = tokens.length;
    for (i3 = 0; i3 < l2; i3++) {
      token2 = tokens[i3];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
        ret = this.options.extensions.renderers[token2.type].call({
          parser: this
        }, token2);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token2.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token2.type) {
        case "escape": {
          out += renderer.text(token2.text);
          break;
        }
        case "html": {
          out += renderer.html(token2.text);
          break;
        }
        case "link": {
          out += renderer.link(token2.href, token2.title, this.parseInline(token2.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token2.href, token2.title, token2.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token2.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token2.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token2.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token2.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token2.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token2.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
class Hooks {
  constructor(options) {
    this.options = options || defaults$2;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
}
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess"]));
function onError(silent, async, callback) {
  return (e2) => {
    e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape$1(e2.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e2);
    }
    if (callback) {
      callback(e2);
      return;
    }
    throw e2;
  };
}
function parseMarkdown$1(lexer, parser) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = {
      ...opt
    };
    opt = {
      ...marked.defaults,
      ...origOpt
    };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer(src, opt);
      } catch (e2) {
        return throwError(e2);
      }
      const done = function(err2) {
        let out;
        if (!err2) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e2) {
            err2 = e2;
          }
        }
        opt.highlight = highlight;
        return err2 ? throwError(err2) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token2) {
        if (token2.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token2.text, token2.lang, function(err2, code) {
              if (err2) {
                return done(err2);
              }
              if (code != null && code !== token2.text) {
                token2.text = code;
                token2.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html2 = parser(tokens, opt);
      if (opt.hooks) {
        html2 = opt.hooks.postprocess(html2);
      }
      return html2;
    } catch (e2) {
      return throwError(e2);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown$1(Lexer.lex, Parser.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = {
    ...marked.defaults,
    ...opt
  };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults$2;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || {
    renderers: {},
    childTokens: {}
  };
  args.forEach((pack) => {
    const opts = {
      ...pack
    };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token2) {
        let values = [];
        values.push(pack.walkTokens.call(this, token2));
        if (walkTokens) {
          values = values.concat(walkTokens.call(this, token2));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values = [];
  for (const token2 of tokens) {
    values = values.concat(callback.call(marked, token2));
    switch (token2.type) {
      case "table": {
        for (const cell of token2.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token2.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values = values.concat(marked.walkTokens(token2.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token2.type]) {
          marked.defaults.extensions.childTokens[token2.type].forEach(function(childTokens) {
            values = values.concat(marked.walkTokens(token2[childTokens], callback));
          });
        } else if (token2.tokens) {
          values = values.concat(marked.walkTokens(token2.tokens, callback));
        }
      }
    }
  }
  return values;
};
marked.parseInline = parseMarkdown$1(Lexer.lexInline, Parser.parseInline);
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser.parse;
Lexer.lex;
var prismCore = { exports: {} };
(function(module) {
  var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _2 = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self2.Prism && _self2.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function encode2(tokens) {
          if (tokens instanceof Token) {
            return new Token(tokens.type, encode2(tokens.content), tokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(encode2);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(o2) {
          return Object.prototype.toString.call(o2).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", {
              value: ++uniqueId
            });
          }
          return obj["__id"];
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o2, visited) {
          visited = visited || {};
          var clone2;
          var id;
          switch (_2.util.type(o2)) {
            case "Object":
              id = _2.util.objId(o2);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = /** @type {Record<string, any>} */
              {};
              visited[id] = clone2;
              for (var key in o2) {
                if (o2.hasOwnProperty(key)) {
                  clone2[key] = deepClone(o2[key], visited);
                }
              }
              return (
                /** @type {any} */
                clone2
              );
            case "Array":
              id = _2.util.objId(o2);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = [];
              visited[id] = clone2;
              o2.forEach(function(v3, i3) {
                clone2[i3] = deepClone(v3, visited);
              });
              return (
                /** @type {any} */
                clone2
              );
            default:
              return o2;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(element) {
          while (element) {
            var m2 = lang.exec(element.className);
            if (m2) {
              return m2[1].toLowerCase();
            }
            element = element.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(element, language) {
          element.className = element.className.replace(RegExp(lang, "gi"), "");
          element.classList.add("language-" + language);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document === "undefined") {
            return null;
          }
          if ("currentScript" in document && 1 < 2) {
            return (
              /** @type {any} */
              document.currentScript
            );
          }
          try {
            throw new Error();
          } catch (err2) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err2.stack) || [])[1];
            if (src) {
              var scripts2 = document.getElementsByTagName("script");
              for (var i3 in scripts2) {
                if (scripts2[i3].src == src) {
                  return scripts2[i3];
                }
              }
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(element, className, defaultActivation) {
          var no = "no-" + className;
          while (element) {
            var classList2 = element.classList;
            if (classList2.contains(className)) {
              return true;
            }
            if (classList2.contains(no)) {
              return false;
            }
            element = element.parentElement;
          }
          return !!defaultActivation;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(id, redef) {
          var lang2 = _2.util.clone(_2.languages[id]);
          for (var key in redef) {
            lang2[key] = redef[key];
          }
          return lang2;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(inside, before, insert, root) {
          root = root || /** @type {any} */
          _2.languages;
          var grammar = root[inside];
          var ret = {};
          for (var token2 in grammar) {
            if (grammar.hasOwnProperty(token2)) {
              if (token2 == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token2)) {
                ret[token2] = grammar[token2];
              }
            }
          }
          var old = root[inside];
          root[inside] = ret;
          _2.languages.DFS(_2.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o2, callback, type2, visited) {
          visited = visited || {};
          var objId = _2.util.objId;
          for (var i3 in o2) {
            if (o2.hasOwnProperty(i3)) {
              callback.call(o2, i3, o2[i3], type2 || i3);
              var property = o2[i3];
              var propertyType = _2.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i3, visited);
              }
            }
          }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(async, callback) {
        _2.highlightAllUnder(document, async, callback);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _2.hooks.run("before-highlightall", env);
        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
        _2.hooks.run("before-all-elements-highlight", env);
        for (var i3 = 0, element; element = env.elements[i3++]; ) {
          _2.highlightElement(element, async === true, env.callback);
        }
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(element, async, callback) {
        var language = _2.util.getLanguage(element);
        var grammar = _2.languages[language];
        _2.util.setLanguage(element, language);
        var parent = element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre") {
          _2.util.setLanguage(parent, language);
        }
        var code = element.textContent;
        var env = {
          element,
          language,
          grammar,
          code
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;
          _2.hooks.run("before-insert", env);
          env.element.innerHTML = env.highlightedCode;
          _2.hooks.run("after-highlight", env);
          _2.hooks.run("complete", env);
          callback && callback.call(env.element);
        }
        _2.hooks.run("before-sanity-check", env);
        parent = env.element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
          parent.setAttribute("tabindex", "0");
        }
        if (!env.code) {
          _2.hooks.run("complete", env);
          callback && callback.call(env.element);
          return;
        }
        _2.hooks.run("before-highlight", env);
        if (!env.grammar) {
          insertHighlightedCode(_2.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_2.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          };
          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else {
          insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
        }
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(text2, grammar, language) {
        var env = {
          code: text2,
          grammar,
          language
        };
        _2.hooks.run("before-tokenize", env);
        if (!env.grammar) {
          throw new Error('The language "' + env.language + '" has no grammar.');
        }
        env.tokens = _2.tokenize(env.code, env.grammar);
        _2.hooks.run("after-tokenize", env);
        return Token.stringify(_2.util.encode(env.tokens), env.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(text2, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token2 in rest) {
            grammar[token2] = rest[token2];
          }
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text2);
        matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
        return toArray2(tokenList);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(name2, callback) {
          var hooks = _2.hooks.all;
          hooks[name2] = hooks[name2] || [];
          hooks[name2].push(callback);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(name2, env) {
          var callbacks = _2.hooks.all[name2];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i3 = 0, callback; callback = callbacks[i3++]; ) {
            callback(env);
          }
        }
      },
      Token
    };
    _self2.Prism = _2;
    function Token(type2, content, alias, matchedStr) {
      this.type = type2;
      this.content = content;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify(o2, language) {
      if (typeof o2 == "string") {
        return o2;
      }
      if (Array.isArray(o2)) {
        var s2 = "";
        o2.forEach(function(e2) {
          s2 += stringify(e2, language);
        });
        return s2;
      }
      var env = {
        type: o2.type,
        content: stringify(o2.content, language),
        tag: "span",
        classes: ["token", o2.type],
        attributes: {},
        language
      };
      var aliases = o2.alias;
      if (aliases) {
        if (Array.isArray(aliases)) {
          Array.prototype.push.apply(env.classes, aliases);
        } else {
          env.classes.push(aliases);
        }
      }
      _2.hooks.run("wrap", env);
      var attributes = "";
      for (var name2 in env.attributes) {
        attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
      }
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text2, lookbehind) {
      pattern.lastIndex = pos;
      var match = pattern.exec(text2);
      if (match && lookbehind && match[1]) {
        var lookbehindLength = match[1].length;
        match.index += lookbehindLength;
        match[0] = match[0].slice(lookbehindLength);
      }
      return match;
    }
    function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
      for (var token2 in grammar) {
        if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
          continue;
        }
        var patterns = grammar[token2];
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        for (var j2 = 0; j2 < patterns.length; ++j2) {
          if (rematch && rematch.cause == token2 + "," + j2) {
            return;
          }
          var patternObj = patterns[j2];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
          }
          var pattern = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }
            var str = currentNode.value;
            if (tokenList.length > text2.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            var removeCount = 1;
            var match;
            if (greedy) {
              match = matchPattern(pattern, pos, text2, lookbehind);
              if (!match || match.index >= text2.length) {
                break;
              }
              var from = match.index;
              var to = match.index + match[0].length;
              var p2 = pos;
              p2 += currentNode.value.length;
              while (from >= p2) {
                currentNode = currentNode.next;
                p2 += currentNode.value.length;
              }
              p2 -= currentNode.value.length;
              pos = p2;
              if (currentNode.value instanceof Token) {
                continue;
              }
              for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                removeCount++;
                p2 += k2.value.length;
              }
              removeCount--;
              str = text2.slice(pos, p2);
              match.index -= pos;
            } else {
              match = matchPattern(pattern, 0, str, lookbehind);
              if (!match) {
                continue;
              }
            }
            var from = match.index;
            var matchStr = match[0];
            var before = str.slice(0, from);
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after) {
              addAfter(tokenList, currentNode, after);
            }
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token2 + "," + j2,
                reach
              };
              matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
              if (rematch && nestedRematch.reach > rematch.reach) {
                rematch.reach = nestedRematch.reach;
              }
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = {
        value: null,
        prev: null,
        next: null
      };
      var tail = {
        value: null,
        prev: head,
        next: null
      };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list, node2, value) {
      var next = node2.next;
      var newNode = {
        value,
        prev: node2,
        next
      };
      node2.next = newNode;
      next.prev = newNode;
      list.length++;
      return newNode;
    }
    function removeRange(list, node2, count) {
      var next = node2.next;
      for (var i3 = 0; i3 < count && next !== list.tail; i3++) {
        next = next.next;
      }
      node2.next = next;
      next.prev = node2;
      list.length -= i3;
    }
    function toArray2(list) {
      var array = [];
      var node2 = list.head.next;
      while (node2 !== list.tail) {
        array.push(node2.value);
        node2 = node2.next;
      }
      return array;
    }
    if (!_self2.document) {
      if (!_self2.addEventListener) {
        return _2;
      }
      if (!_2.disableWorkerMessageHandler) {
        _self2.addEventListener("message", function(evt) {
          var message = JSON.parse(evt.data);
          var lang2 = message.language;
          var code = message.code;
          var immediateClose = message.immediateClose;
          _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
          if (immediateClose) {
            _self2.close();
          }
        }, false);
      }
      return _2;
    }
    var script = _2.util.currentScript();
    if (script) {
      _2.filename = script.src;
      if (script.hasAttribute("data-manual")) {
        _2.manual = true;
      }
    }
    function highlightAutomaticallyCallback() {
      if (!_2.manual) {
        _2.highlightAll();
      }
    }
    if (!_2.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }
    return _2;
  }(_self);
  if (module.exports) {
    module.exports = Prism2;
  }
  if (typeof commonjsGlobal !== "undefined") {
    commonjsGlobal.Prism = Prism2;
  }
})(prismCore);
var prismCoreExports = prismCore.exports;
const Prism$1 = /* @__PURE__ */ getDefaultExportFromCjs(prismCoreExports);
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: "keyword"
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        "code-block": {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        "code-language": {
          pattern: /^(```).+/,
          lookbehind: true
        },
        "punctuation": /```/
      }
    }],
    "title": [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: "important",
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: "important",
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token2 !== inside) {
        Prism2.languages.markdown[token2].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i3 = 0, l2 = tokens.length; i3 < l2; i3++) {
        var token2 = tokens[i3];
        if (token2.type !== "code") {
          walkTokens(token2.content);
          continue;
        }
        var codeLang = token2.content[1];
        var codeBlock = token2.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i3 = 0, l2 = env.classes.length; i3 < l2; i3++) {
      var cls = env.classes[i3];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html2) {
    var text2 = html2.replace(tagPattern, "");
    text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code) {
      code = code.toLowerCase();
      if (code[0] === "#") {
        var value;
        if (code[1] === "x") {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        }
        return m2;
      }
    });
    return text2;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, Prism.languages.c["string"]],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: "function"
      }],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
        return modName;
      }) + ")"),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
(function(Prism2) {
  function replace(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
      return "(?:" + replacements[+index2] + ")";
    });
  }
  function re2(pattern, replacements, flags) {
    return RegExp(replace(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i3 = 0; i3 < depthLog2; i3++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
  var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [{
      pattern: re2(/(^|[^$\\])<<0>>/.source, [verbatimString]),
      lookbehind: true,
      greedy: true
    }, {
      pattern: re2(/(^|[^@$\\])<<0>>/.source, [regularString]),
      lookbehind: true,
      greedy: true
    }],
    "class-name": [{
      // Using static
      // using static System.Math;
      pattern: re2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (type)
      // using Project = PC.MyCompany.Project;
      pattern: re2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (alias)
      // using Project = PC.MyCompany.Project;
      pattern: re2(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
      lookbehind: true
    }, {
      // Type declarations
      // class Foo<A, B>
      // interface Foo<out A, B>
      pattern: re2(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Single catch exception declaration
      // catch(Foo)
      // (things like catch(Foo e) is covered by variable declaration)
      pattern: re2(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Name of the type parameter of generic constraints
      // where Foo : class
      pattern: re2(/(\bwhere\s+)<<0>>/.source, [name2]),
      lookbehind: true
    }, {
      // Casts and checks via as and is.
      // as Foo<A>, is Bar<B>
      // (things like if(a is Foo b) is covered by variable declaration)
      pattern: re2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Variable, field and parameter declaration
      // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
      pattern: re2(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
      inside: typeInside
    }],
    "keyword": keywords,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re2(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re2(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re2(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re2(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re2(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re2(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re2(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [typeDeclarationKeywords, genericName, name2, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re2(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re2(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re2(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [{
      pattern: re2(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(mInterpolation, mInterpolationRound)
    }, {
      pattern: re2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(sInterpolation, sInterpolationRound)
    }],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [className, {
      // variables, parameters, and constructor references
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
      lookbehind: true,
      inside: className.inside
    }, {
      // class names based on keyword
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
      lookbehind: true,
      inside: className.inside
    }],
    "keyword": keywords,
    "function": [Prism2.languages.clike.function, {
      pattern: /(::\s*)[a-z_]\w*/,
      lookbehind: true
    }],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [{
      pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
      lookbehind: true,
      inside: {
        "namespace": className.inside.namespace,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }, {
      pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
      lookbehind: true,
      alias: "static",
      inside: {
        "namespace": className.inside.namespace,
        "static": /\b\w+$/,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }],
    "namespace": {
      pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
        return keywords.source;
      })),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  Prism2.languages.ruby = Prism2.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism2.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism2.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism2.languages.ruby.function;
  var percentExpression = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [{
      pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }, {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [{
      pattern: RegExp(/(^|[^:]):/.source + symbolName),
      lookbehind: true,
      greedy: true
    }, {
      pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
      lookbehind: true,
      greedy: true
    }],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism2.languages.insertBefore("ruby", "string", {
    "string-literal": [{
      pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?/
          }
        },
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?'|'$/
          }
        },
        "string": /[\s\S]+/
      }
    }],
    "command-literal": [{
      pattern: RegExp(/%x/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }, {
      pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }]
  });
  delete Prism2.languages.ruby.string;
  Prism2.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism2.languages.rb = Prism2.languages.ruby;
})(Prism);
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i3 = 0; i3 < 2; i3++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [{
      pattern: RegExp(/(^|[^\\])/.source + multilineComment),
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [{
      pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
      lookbehind: true,
      alias: "namespace"
    }, {
      pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
      lookbehind: true,
      alias: "namespace",
      inside: {
        "punctuation": /::/
      }
    }],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: true
          }, /^\$\(\(/],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
  var inside = insideString.variable[1].inside;
  for (var i3 = 0; i3 < toBeCopied.length; i3++) {
    inside[toBeCopied[i3]] = Prism2.languages.bash[toBeCopied[i3]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
Prism.languages.cmake = {
  "comment": /#.*/,
  "string": {
    pattern: /"(?:[^\\"]|\\.)*"/,
    greedy: true,
    inside: {
      "interpolation": {
        pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
        inside: {
          "punctuation": /\$\{|\}/,
          "variable": /\w+/
        }
      }
    }
  },
  "variable": /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_NAME|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE))\b/,
  "property": /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
  "keyword": /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
  "boolean": /\b(?:FALSE|OFF|ON|TRUE)\b/,
  "namespace": /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
  "operator": /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
  "inserted": {
    pattern: /\b\w+::\w+\b/,
    alias: "class-name"
  },
  "number": /\b\d+(?:\.\d+)*\b/,
  "function": /\b[a-z_]\w*(?=\s*\()\b/i,
  "punctuation": /[()>}]|\$[<{]/
};
(function(Prism2) {
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+)/,
    lookbehind: true
  };
  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  var inside = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    "url": {
      pattern: /\burl\((["']?).*?\1\)/i,
      greedy: true
    },
    "string": {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    "interpolation": null,
    // See below
    "func": null,
    // See below
    "important": /\B!(?:important|optional)\b/i,
    "keyword": {
      pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
      lookbehind: true
    },
    "hexcode": /#[\da-f]{3,6}/i,
    "color": [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        "unit": unit,
        "number": number,
        "function": /[\w-]+(?=\()/,
        "punctuation": /[(),]/
      }
    }],
    "entity": /\\[\da-f]{1,8}/i,
    "unit": unit,
    "boolean": /\b(?:false|true)\b/,
    "operator": [
      // We want non-word chars around "-" because it is
      // accepted in property names.
      /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
    ],
    "number": number,
    "punctuation": /[{}()\[\];:,]/
  };
  inside["interpolation"] = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: "variable",
    inside: {
      "delimiter": {
        pattern: /^\{|\}$/,
        alias: "punctuation"
      },
      rest: inside
    }
  };
  inside["func"] = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: {
      "function": /^[^(]+/,
      rest: inside
    }
  };
  Prism2.languages.stylus = {
    "atrule-declaration": {
      pattern: /(^[ \t]*)@.+/m,
      lookbehind: true,
      inside: {
        "atrule": /^@[\w-]+/,
        rest: inside
      }
    },
    "variable-declaration": {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
      lookbehind: true,
      inside: {
        "variable": /^\S+/,
        rest: inside
      }
    },
    "statement": {
      pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
      lookbehind: true,
      inside: {
        "keyword": /^\S+/,
        rest: inside
      }
    },
    // A property/value pair cannot end with a comma or a brace
    // It cannot have indented content unless it ended with a semicolon
    "property-declaration": {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
      lookbehind: true,
      inside: {
        "property": {
          pattern: /^[^\s:]+/,
          inside: {
            "interpolation": inside.interpolation
          }
        },
        rest: inside
      }
    },
    // A selector can contain parentheses only as part of a pseudo-element
    // It can span multiple lines.
    // It must end with a comma or an accolade or have indented content.
    "selector": {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
      lookbehind: true,
      inside: {
        "interpolation": inside.interpolation,
        "comment": inside.comment,
        "punctuation": /[{},]/
      }
    },
    "func": inside.func,
    "string": inside.string,
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true,
      greedy: true
    },
    "interpolation": inside.interpolation,
    "punctuation": /[{}()\[\];:.]/
  };
})(Prism);
(function(Prism2) {
  var powershell = Prism2.languages.powershell = {
    "comment": [{
      pattern: /(^|[^`])<#[\s\S]*?#>/,
      lookbehind: true
    }, {
      pattern: /(^|[^`])#.*/,
      lookbehind: true
    }],
    "string": [{
      pattern: /"(?:`[\s\S]|[^`"])*"/,
      greedy: true,
      inside: null
      // see below
    }, {
      pattern: /'(?:[^']|'')*'/,
      greedy: true
    }],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    "boolean": /\$(?:false|true)\b/i,
    "variable": /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    "function": [/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i, /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    "operator": {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    "punctuation": /[|{}[\];(),.]/
  };
  powershell.string[0].inside = {
    "function": {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: powershell
    },
    "boolean": powershell.boolean,
    "variable": powershell.variable
  };
})(Prism);
(function(Prism2) {
  var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
  var insideEqu = {
    "equation-command": {
      pattern: funcPattern,
      alias: "regex"
    }
  };
  Prism2.languages.latex = {
    "comment": /%.*/,
    // the verbatim environment prints whitespace to the document
    "cdata": {
      pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true
    },
    /*
     * equations can be between $$ $$ or $ $ or \( \) or \[ \]
     * (all are multiline)
     */
    "equation": [{
      pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
      inside: insideEqu,
      alias: "string"
    }, {
      pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true,
      inside: insideEqu,
      alias: "string"
    }],
    /*
     * arguments which are keywords or references are highlighted
     * as keywords
     */
    "keyword": {
      pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true
    },
    "url": {
      pattern: /(\\url\{)[^}]+(?=\})/,
      lookbehind: true
    },
    /*
     * section or chapter headlines are highlighted as bold so that
     * they stand out more
     */
    "headline": {
      pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true,
      alias: "class-name"
    },
    "function": {
      pattern: funcPattern,
      alias: "selector"
    },
    "punctuation": /[[\]{}&]/
  };
  Prism2.languages.tex = Prism2.languages.latex;
  Prism2.languages.context = Prism2.languages.latex;
})(Prism);
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
  Prism2.languages.nginx = {
    "comment": {
      pattern: /(^|[\s{};])#.*/,
      lookbehind: true,
      greedy: true
    },
    "directive": {
      pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: {
        "string": {
          pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
          lookbehind: true,
          greedy: true,
          inside: {
            "escape": {
              pattern: /\\["'\\nrt]/,
              alias: "entity"
            },
            "variable": variable
          }
        },
        "comment": {
          pattern: /(\s)#.*/,
          lookbehind: true,
          greedy: true
        },
        "keyword": {
          pattern: /^\S+/,
          greedy: true
        },
        // other patterns
        "boolean": {
          pattern: /(\s)(?:off|on)(?!\S)/,
          lookbehind: true
        },
        "number": {
          pattern: /(\s)\d+[a-z]*(?!\S)/i,
          lookbehind: true
        },
        "variable": variable
      }
    },
    "punctuation": /[{};]/
  };
})(Prism);
Prism.languages.vim = {
  "string": /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
  "comment": /".*/,
  "function": /\b\w+(?=\()/,
  "keyword": /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
  "builtin": /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
  "number": /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
  "operator": /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
  "punctuation": /[{}[\](),;:]/
};
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  var PLUGIN_NAME = "line-numbers";
  var NEW_LINE_EXP = /\n(?!$)/g;
  var config = Prism.plugins.lineNumbers = {
    /**
     * Get node for provided line number
     *
     * @param {Element} element pre element
     * @param {number} number line number
     * @returns {Element|undefined}
     */
    getLine: function(element, number) {
      if (element.tagName !== "PRE" || !element.classList.contains(PLUGIN_NAME)) {
        return;
      }
      var lineNumberRows = element.querySelector(".line-numbers-rows");
      if (!lineNumberRows) {
        return;
      }
      var lineNumberStart = parseInt(element.getAttribute("data-start"), 10) || 1;
      var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);
      if (number < lineNumberStart) {
        number = lineNumberStart;
      }
      if (number > lineNumberEnd) {
        number = lineNumberEnd;
      }
      var lineIndex = number - lineNumberStart;
      return lineNumberRows.children[lineIndex];
    },
    /**
     * Resizes the line numbers of the given element.
     *
     * This function will not add line numbers. It will only resize existing ones.
     *
     * @param {HTMLElement} element A `<pre>` element with line numbers.
     * @returns {void}
     */
    resize: function(element) {
      resizeElements([element]);
    },
    /**
     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
     * the current viewport.
     *
     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
     *
     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
     *
     * @type {boolean}
     */
    assumeViewportIndependence: true
  };
  function resizeElements(elements) {
    elements = elements.filter(function(e2) {
      var codeStyles = getStyles(e2);
      var whiteSpace = codeStyles["white-space"];
      return whiteSpace === "pre-wrap" || whiteSpace === "pre-line";
    });
    if (elements.length == 0) {
      return;
    }
    var infos = elements.map(function(element) {
      var codeElement = element.querySelector("code");
      var lineNumbersWrapper = element.querySelector(".line-numbers-rows");
      if (!codeElement || !lineNumbersWrapper) {
        return void 0;
      }
      var lineNumberSizer = element.querySelector(".line-numbers-sizer");
      var codeLines = codeElement.textContent.split(NEW_LINE_EXP);
      if (!lineNumberSizer) {
        lineNumberSizer = document.createElement("span");
        lineNumberSizer.className = "line-numbers-sizer";
        codeElement.appendChild(lineNumberSizer);
      }
      lineNumberSizer.innerHTML = "0";
      lineNumberSizer.style.display = "block";
      var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
      lineNumberSizer.innerHTML = "";
      return {
        element,
        lines: codeLines,
        lineHeights: [],
        oneLinerHeight,
        sizer: lineNumberSizer
      };
    }).filter(Boolean);
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var lines = info.lines;
      var lineHeights = info.lineHeights;
      var oneLinerHeight = info.oneLinerHeight;
      lineHeights[lines.length - 1] = void 0;
      lines.forEach(function(line, index2) {
        if (line && line.length > 1) {
          var e2 = lineNumberSizer.appendChild(document.createElement("span"));
          e2.style.display = "block";
          e2.textContent = line;
        } else {
          lineHeights[index2] = oneLinerHeight;
        }
      });
    });
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var lineHeights = info.lineHeights;
      var childIndex = 0;
      for (var i3 = 0; i3 < lineHeights.length; i3++) {
        if (lineHeights[i3] === void 0) {
          lineHeights[i3] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
        }
      }
    });
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var wrapper = info.element.querySelector(".line-numbers-rows");
      lineNumberSizer.style.display = "none";
      lineNumberSizer.innerHTML = "";
      info.lineHeights.forEach(function(height, lineNumber) {
        wrapper.children[lineNumber].style.height = height + "px";
      });
    });
  }
  function getStyles(element) {
    if (!element) {
      return null;
    }
    return window.getComputedStyle ? getComputedStyle(element) : element.currentStyle || null;
  }
  var lastWidth = void 0;
  window.addEventListener("resize", function() {
    if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
      return;
    }
    lastWidth = window.innerWidth;
    resizeElements(Array.prototype.slice.call(document.querySelectorAll("pre." + PLUGIN_NAME)));
  });
  Prism.hooks.add("complete", function(env) {
    if (!env.code) {
      return;
    }
    var code = (
      /** @type {Element} */
      env.element
    );
    var pre = (
      /** @type {HTMLElement} */
      code.parentNode
    );
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (code.querySelector(".line-numbers-rows")) {
      return;
    }
    if (!Prism.util.isActive(code, PLUGIN_NAME)) {
      return;
    }
    code.classList.remove(PLUGIN_NAME);
    pre.classList.add(PLUGIN_NAME);
    var match = env.code.match(NEW_LINE_EXP);
    var linesNum = match ? match.length + 1 : 1;
    var lineNumbersWrapper;
    var lines = new Array(linesNum + 1).join("<span></span>");
    lineNumbersWrapper = document.createElement("span");
    lineNumbersWrapper.setAttribute("aria-hidden", "true");
    lineNumbersWrapper.className = "line-numbers-rows";
    lineNumbersWrapper.innerHTML = lines;
    if (pre.hasAttribute("data-start")) {
      pre.style.counterReset = "linenumber " + (parseInt(pre.getAttribute("data-start"), 10) - 1);
    }
    env.element.appendChild(lineNumbersWrapper);
    resizeElements([pre]);
    Prism.hooks.run("line-numbers", env);
  });
  Prism.hooks.add("line-numbers", function(env) {
    env.plugins = env.plugins || {};
    env.plugins.lineNumbers = true;
  });
})();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  var callbacks = [];
  var map = {};
  var noop2 = function() {
  };
  Prism.plugins.toolbar = {};
  var registerButton = Prism.plugins.toolbar.registerButton = function(key, opts) {
    var callback;
    if (typeof opts === "function") {
      callback = opts;
    } else {
      callback = function(env) {
        var element;
        if (typeof opts.onClick === "function") {
          element = document.createElement("button");
          element.type = "button";
          element.addEventListener("click", function() {
            opts.onClick.call(this, env);
          });
        } else if (typeof opts.url === "string") {
          element = document.createElement("a");
          element.href = opts.url;
        } else {
          element = document.createElement("span");
        }
        if (opts.className) {
          element.classList.add(opts.className);
        }
        element.textContent = opts.text;
        return element;
      };
    }
    if (key in map) {
      console.warn('There is a button with the key "' + key + '" registered already.');
      return;
    }
    callbacks.push(map[key] = callback);
  };
  function getOrder(element) {
    while (element) {
      var order = element.getAttribute("data-toolbar-order");
      if (order != null) {
        order = order.trim();
        if (order.length) {
          return order.split(/\s*,\s*/g);
        } else {
          return [];
        }
      }
      element = element.parentElement;
    }
  }
  var hook = Prism.plugins.toolbar.hook = function(env) {
    var pre = env.element.parentNode;
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (pre.parentNode.classList.contains("code-toolbar")) {
      return;
    }
    var wrapper = document.createElement("div");
    wrapper.classList.add("code-toolbar");
    pre.parentNode.insertBefore(wrapper, pre);
    wrapper.appendChild(pre);
    var toolbar = document.createElement("div");
    toolbar.classList.add("toolbar");
    var elementCallbacks = callbacks;
    var order = getOrder(env.element);
    if (order) {
      elementCallbacks = order.map(function(key) {
        return map[key] || noop2;
      });
    }
    elementCallbacks.forEach(function(callback) {
      var element = callback(env);
      if (!element) {
        return;
      }
      var item = document.createElement("div");
      item.classList.add("toolbar-item");
      item.appendChild(element);
      toolbar.appendChild(item);
    });
    wrapper.appendChild(toolbar);
  };
  registerButton("label", function(env) {
    var pre = env.element.parentNode;
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (!pre.hasAttribute("data-label")) {
      return;
    }
    var element;
    var template;
    var text2 = pre.getAttribute("data-label");
    try {
      template = document.querySelector("template#" + text2);
    } catch (e2) {
    }
    if (template) {
      element = template.content;
    } else {
      if (pre.hasAttribute("data-url")) {
        element = document.createElement("a");
        element.href = pre.getAttribute("data-url");
      } else {
        element = document.createElement("span");
      }
      element.textContent = text2;
    }
    return element;
  });
  Prism.hooks.add("complete", hook);
})();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Prism.plugins.toolbar) {
    console.warn("Copy to Clipboard plugin loaded before Toolbar plugin.");
    return;
  }
  function registerClipboard(element, copyInfo) {
    element.addEventListener("click", function() {
      copyTextToClipboard(copyInfo);
    });
  }
  function fallbackCopyTextToClipboard(copyInfo) {
    var textArea = document.createElement("textarea");
    textArea.value = copyInfo.getText();
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      var successful = document.execCommand("copy");
      setTimeout(function() {
        if (successful) {
          copyInfo.success();
        } else {
          copyInfo.error();
        }
      }, 1);
    } catch (err2) {
      setTimeout(function() {
        copyInfo.error(err2);
      }, 1);
    }
    document.body.removeChild(textArea);
  }
  function copyTextToClipboard(copyInfo) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(copyInfo.getText()).then(copyInfo.success, function() {
        fallbackCopyTextToClipboard(copyInfo);
      });
    } else {
      fallbackCopyTextToClipboard(copyInfo);
    }
  }
  function selectElementText(element) {
    window.getSelection().selectAllChildren(element);
  }
  function getSettings(startElement) {
    var settings = {
      "copy": "Copy",
      "copy-error": "Press Ctrl+C to copy",
      "copy-success": "Copied!",
      "copy-timeout": 5e3
    };
    var prefix = "data-prismjs-";
    for (var key in settings) {
      var attr = prefix + key;
      var element = startElement;
      while (element && !element.hasAttribute(attr)) {
        element = element.parentElement;
      }
      if (element) {
        settings[key] = element.getAttribute(attr);
      }
    }
    return settings;
  }
  Prism.plugins.toolbar.registerButton("copy-to-clipboard", function(env) {
    var element = env.element;
    var settings = getSettings(element);
    var linkCopy = document.createElement("button");
    linkCopy.className = "copy-to-clipboard-button";
    linkCopy.setAttribute("type", "button");
    var linkSpan = document.createElement("span");
    linkCopy.appendChild(linkSpan);
    setState("copy");
    registerClipboard(linkCopy, {
      getText: function() {
        return element.textContent;
      },
      success: function() {
        setState("copy-success");
        resetText();
      },
      error: function() {
        setState("copy-error");
        setTimeout(function() {
          selectElementText(element);
        }, 1);
        resetText();
      }
    });
    return linkCopy;
    function resetText() {
      setTimeout(function() {
        setState("copy");
      }, settings["copy-timeout"]);
    }
    function setState(state) {
      linkSpan.textContent = settings[state];
      linkCopy.setAttribute("data-copy-state", state);
    }
  });
})();
/*! @license DOMPurify 3.0.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.5/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf: getPrototypeOf$1,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array, transformCaseFunc) {
  var _transformCaseFunc;
  transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l2 = array.length;
  while (l2--) {
    let element = array[l2];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    newObject[property] = value;
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$1(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
const svg$2 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = () => typeof window === "undefined" ? null : window;
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.0.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  const originalDocument = window2.document;
  const currentScript = originalDocument.currentScript;
  let {
    document: document2
  } = window2;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element2,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = {};
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg$2, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let PARSER_MEDIA_TYPE;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [...text]);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  const ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  const ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, {
      element: node2
    });
    try {
      node2.parentNode.removeChild(node2);
    } catch (_2) {
      node2.remove();
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, node2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node2.getAttributeNode(name2),
        from: node2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node2
      });
    }
    node2.removeAttribute(name2);
    if (name2 === "is" && !ALLOWED_ATTR[name2]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node2);
        } catch (_2) {
        }
      } else {
        try {
          node2.setAttribute(name2, "");
        } catch (_2) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc;
    let leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_2) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  const _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(object) {
    return typeof Node2 === "object" ? object instanceof Node2 : object && typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  const _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i3 = childCount - 1; i3 >= 0; --i3) {
            parentNode.insertBefore(cloneNode(childNodes[i3], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR2, " ");
      content = stringReplace(content, ERB_EXPR2, " ");
      content = stringReplace(content, TMPLIT_EXPR2, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      )
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, "")))
      ;
    else if (value) {
      return false;
    } else
      ;
    return true;
  };
  const _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    let attr;
    let value;
    let lcName;
    let l2;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr = attributes[l2];
      const {
        name: name2,
        namespaceURI
      } = attr;
      value = name2 === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name2);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR2, " ");
        value = stringReplace(value, ERB_EXPR2, " ");
        value = stringReplace(value, TMPLIT_EXPR2, " ");
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode;
    const shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body;
    let importedNode;
    let currentNode;
    let returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR2, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
const inlineMathStart = /\$.*?\$/;
const inlineMathReg = /^\$(.*?)\$/;
const blockMathReg = /^(?:\s{0,3})\$\$((?:[^\n]|\n[^\n])+?)\n{0,1}\$\$/;
const markedTeXExtensions = (texRenderer2) => {
  const blockMathExtension = {
    name: "blockMath",
    level: "block",
    tokenizer(src) {
      const cap = blockMathReg.exec(src);
      if (cap !== null) {
        return {
          type: "html",
          raw: cap[0],
          text: texRenderer2(true, cap[1])
        };
      }
      return void 0;
    }
  };
  const inlineMathExtension = {
    name: "inlineMath",
    level: "inline",
    start(src) {
      const idx = src.search(inlineMathStart);
      return idx !== -1 ? idx : src.length;
    },
    tokenizer(src) {
      const cap = inlineMathReg.exec(src);
      if (cap !== null) {
        return {
          type: "html",
          raw: cap[0],
          text: texRenderer2(false, cap[1])
        };
      }
      return void 0;
    }
  };
  return [blockMathExtension, inlineMathExtension];
};
const parseEmoji = (text2 = "", emojiMap = {}) => text2.replace(/:(.+?):/g, (placeholder, key) => emojiMap[key] ? `<img class="wl-emoji" src="${emojiMap[key]}" alt="${key}">` : placeholder);
const texRenderer = (blockMode, tex) => {
  return katex$1.renderToString(tex, {
    throwOnError: false,
    displayMode: blockMode
  });
};
const highlighter = (code, lang) => {
  lang = Prism$1.languages[lang] ? lang : "plaintext";
  return Prism$1.highlight(code, Prism$1.languages[lang] ?? "plaintext", lang);
};
const parseMarkdown = (content, opts) => {
  const {
    emojiMap = false,
    highlight: enHl = true,
    texRender: enTex = true
  } = opts ?? {};
  marked.setOptions({
    highlight: enHl ? highlighter : void 0,
    breaks: true,
    smartLists: true,
    smartypants: true
  });
  if (enTex) {
    const extensions = markedTeXExtensions(texRenderer);
    marked.use({
      extensions
    });
  }
  if (emojiMap) {
    content = parseEmoji(content, emojiMap);
  }
  content = marked.parse(content);
  content = purify.sanitize(content);
  return content;
};
const getQuery = (element) => element.dataset.path || element.getAttribute("id");
const getWords = (content) => (
  // \u00C0-\u024F are Latin Supplement letters, maybe used in language like french
  // \u0400-\u04FF are Cyrillic letters, used in russian
  content.match(/[\w\d\s,.\u00C0-\u024F\u0400-\u04FF]+/giu)
);
const getChinese = (content) => content.match(/[\u4E00-\u9FD5]/gu);
const getWordNumber = (content) => {
  var _a3, _b2;
  return (((_a3 = getWords(content)) == null ? void 0 : _a3.reduce((accumulator, word) => accumulator + (word.trim() === "" ? 0 : word.trim().split(/\s+/u).length), 0)) || 0) + (((_b2 = getChinese(content)) == null ? void 0 : _b2.length) || 0);
};
const userAgent = async () => {
  if (!navigator) {
    return "";
  }
  const {
    userAgentData
  } = navigator;
  let ua = navigator.userAgent;
  if (!userAgentData || userAgentData.platform !== "Windows") {
    return ua;
  }
  const {
    platformVersion
  } = await userAgentData.getHighEntropyValues(["platformVersion"]);
  if (!platformVersion) {
    return ua;
  }
  const isWindows11Later = parseInt(platformVersion.split(".")[0]) >= 13;
  if (isWindows11Later) {
    ua = ua.replace("Windows NT 10.0", "Windows NT 11.0");
  }
  return ua;
};
const emoji = ref({
  tabs: [],
  map: {}
});
const emojiOrgs = ref(["https://unpkg.com/@waline/emojis@1.2.0/bmoji", "https://unpkg.com/@waline/emojis@1.2.0/bilibili", "https://unpkg.com/@waline/emojis@1.2.0/qq", "https://unpkg.com/@waline/emojis@1.2.0/weibo"]);
watch(emojiOrgs, (newOrgs) => getEmojis(newOrgs).then((config) => {
  emoji.value = config;
}), {
  immediate: true
});
const useEmoji = () => emoji;
const getAbsolutePos = (element) => {
  if (!element) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  let {
    offsetLeft: x2,
    offsetTop: y3
  } = element;
  let p2 = element.offsetParent;
  const {
    offsetWidth: width,
    offsetHeight: height
  } = element;
  while (p2) {
    x2 += p2.offsetLeft;
    y3 += p2.offsetTop;
    p2 = p2.offsetParent;
  }
  return {
    x: x2,
    y: y3,
    width,
    height
  };
};
function inViewport(el) {
  if (!el || false)
    return false;
  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
  const {
    y: offsetTop,
    height
  } = getAbsolutePos(el);
  const offsetBottom = offsetTop + height;
  const scrollTop = document.documentElement.scrollTop;
  const top = offsetTop - scrollTop, bottom = offsetBottom - scrollTop;
  return top <= viewPortHeight && bottom >= 0;
}
const throttle$1 = (func, wait = 500) => {
  let timer;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      func.apply(func, args);
      timer = null;
    }, wait);
  };
};
function randFloat(p1 = 0, p2 = 100) {
  let max2, min2;
  if (typeof p1 === "number") {
    [max2, min2] = [p2, p1];
  } else {
    [max2, min2] = [p1.max, p1.min];
  }
  return Math.random() * (max2 - min2) + min2;
}
function randInt(p1 = 0, p2 = 100) {
  if (typeof p1 === "number") {
    return Math.floor(randFloat(p1, p2));
  } else {
    return Math.floor(randFloat(p1));
  }
}
function randElem(array) {
  return array[Math.floor(Math.random() * array.length)];
}
function inRange(val, p1 = -Infinity, p2 = Infinity) {
  let max2, min2;
  if (typeof p1 === "number") {
    [max2, min2] = [p2, p1];
  } else {
    [max2, min2] = [p1.max, p1.min];
  }
  return val >= min2 && val <= max2;
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const {
  toString
} = Object.prototype;
const {
  getPrototypeOf
} = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const {
  isArray
} = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, {
  allOwnKeys = false
} = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i3;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i3 = 0, l2 = obj.length; i3 < l2; i3++) {
      fn.call(null, obj[i3], i3, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i3 = 0; i3 < len; i3++) {
      key = keys[i3];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i3 = keys.length;
  let _key;
  while (i3-- > 0) {
    _key = keys[i3];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const {
    caseless
  } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    arguments[i3] && forEach(arguments[i3], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, {
  allOwnKeys
} = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, {
    allOwnKeys
  });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i3;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i3 = props.length;
    while (i3-- > 0) {
      prop = props[i3];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i3 = thing.length;
  if (!isNumber(i3))
    return null;
  const arr = new Array(i3);
  while (i3-- > 0) {
    arr[i3] = thing[i3];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m2, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
const hasOwnProperty = (({
  hasOwnProperty: hasOwnProperty2
}) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const {
    length
  } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack2 = new Array(10);
  const visit = (source, i3) => {
    if (isObject(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack2[i3] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i3 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack2[i3] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
  value: true
});
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token2, i3) {
    token2 = removeBrackets(token2);
    return !dots && i3 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack2.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value);
    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack2.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i3;
  const len = keys.length;
  let key;
  for (i3 = 0; i3 < len; i3++) {
    key = keys[i3];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: platform.isNode ? "http" : "xhr",
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(isFileList2 ? {
          "files[]": data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i3;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i3 = line.indexOf(":");
    key = line.substring(0, i3).trim().toLowerCase();
    val = line.substring(i3 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i3 = keys.length;
    let deleted = false;
    while (i3--) {
      const key = keys[i3];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.reduceDescriptors(AxiosHeaders.prototype, ({
  value
}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError("Request failed with status code " + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain2, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain2)) {
          cookie.push("domain=" + domain2);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i3 = tail;
    let bytesCount = 0;
    while (i3 !== head) {
      bytesCount += bytes[i3++];
      i3 = i3 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err2) {
        reject(err2);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(fullPath);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", {
        value
      });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", {
      value
    });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const {
      length
    } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i3 = 0; i3 < length; i3++) {
      nameOrAdapter = adapters2[i3];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`, "ERR_NOT_SUPPORT");
      }
      throw new Error(utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({
        caseless
      }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.5.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i3) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i3 < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError.ERR_DEPRECATED);
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i3 = keys.length;
  while (i3-- > 0) {
    const opt = keys[i3];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const {
      transitional: transitional2,
      paramsSerializer,
      headers
    } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils.merge(headers.common, headers[config.method]);
    headers && utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i3 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i3 < len) {
        promise2 = promise2.then(chain[i3++], chain[i3++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i3 = 0;
    while (i3 < len) {
      const onFulfilled = requestInterceptorChain[i3++];
      const onRejected = requestInterceptorChain[i3++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i3 = 0;
    len = responseInterceptorChain.length;
    while (i3 < len) {
      promise2 = promise2.then(responseInterceptorChain[i3++], responseInterceptorChain[i3++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i3 = token2._listeners.length;
      while (i3-- > 0) {
        token2._listeners[i3](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, {
    allOwnKeys: true
  });
  utils.extend(instance, context, null, {
    allOwnKeys: true
  });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
const isMobile = (window2) => {
  if (!window2) {
    return null;
  }
  const {
    userAgent: userAgent2
  } = window2.navigator;
  return /Android|webOS|iPhone|iPod|BlackBerry/i.test(userAgent2);
};
async function getClientIP() {
  const res = await axios$1.get("https://ip.useragentinfo.com/json");
  return res.data.ip;
}
const bedURL = "/upload";
const imageReq = axios$1.create({
  // baseURL: "https://www.imagehub.cc"
  baseURL: bedURL
});
const imageUpload = async (file, filename) => {
  const uploadUrl = "/";
  const form = new FormData();
  form.append("source", file, filename);
  form.append("nsfw", "0");
  form.append("format", "txt");
  const headers = {
    "X-API-Key": "chv_gs0d_58903bb19f9ecfdd4b20ff3be5bfdf6f28630a7d838c8c5b6af4a0e8a4a9a42b16988d62d780c10d7d3ff526cc6bef282f8d2042335ea850e57253ba73000263"
  };
  const res = await imageReq.request({
    method: "post",
    url: uploadUrl,
    data: form,
    headers
  });
  console.log("UPLOAD IMAGE RESP", res.data);
  return res.data;
};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var aliyunOssSdk = { exports: {} };
(function(module, exports) {
  (function(global2) {
    (function(f2) {
      {
        module.exports = f2();
      }
    })(function() {
      return function() {
        function r2(e2, n2, t2) {
          function o2(i4, f2) {
            if (!n2[i4]) {
              if (!e2[i4]) {
                var c2 = "function" == typeof commonjsRequire && commonjsRequire;
                if (!f2 && c2)
                  return c2(i4, true);
                if (u3)
                  return u3(i4, true);
                var a2 = new Error("Cannot find module '" + i4 + "'");
                throw a2.code = "MODULE_NOT_FOUND", a2;
              }
              var p2 = n2[i4] = { exports: {} };
              e2[i4][0].call(p2.exports, function(r3) {
                var n3 = e2[i4][1][r3];
                return o2(n3 || r3);
              }, p2, p2.exports, r2, e2, n2, t2);
            }
            return n2[i4].exports;
          }
          for (var u3 = "function" == typeof commonjsRequire && commonjsRequire, i3 = 0; i3 < t2.length; i3++)
            o2(t2[i3]);
          return o2;
        }
        return r2;
      }()({ 1: [function(require2, module2, exports2) {
        var OSS2 = require2("./browser/client");
        OSS2.Buffer = require2("buffer").Buffer;
        OSS2.urllib = require2("../shims/xhr");
        OSS2.version = require2("./browser/version").version;
        module2.exports = OSS2;
      }, { "../shims/xhr": 475, "./browser/client": 3, "./browser/version": 6, "buffer": 90 }], 2: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.slice.js");
        var assert = require2("assert");
        var _require = require2("../common/utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports2;
        function isArray2(arr) {
          if (Array.isArray)
            return Array.isArray(arr);
          return Object.prototype.toString.call(arr) === "[object Array]";
        }
        function toArray2(obj) {
          if (!obj)
            return [];
          if (isArray2(obj))
            return obj;
          return [obj];
        }
        proto.useBucket = function useBucket(name2) {
          _checkBucketName(name2);
          this.options.bucket = name2;
          return this;
        };
        proto.setBucket = function useBucket(name2) {
          _checkBucketName(name2);
          this.options.bucket = name2;
          return this;
        };
        proto.getBucket = function getBucket() {
          return this.options.bucket;
        };
        proto.deleteBucket = /* @__PURE__ */ function() {
          var _deleteBucket = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    params = this._bucketRequestParams("DELETE", name2, "", options);
                    _context.next = 3;
                    return this.request(params);
                  case 3:
                    result = _context.sent;
                    if (!(result.status === 200 || result.status === 204)) {
                      _context.next = 6;
                      break;
                    }
                    return _context.abrupt("return", { res: result.res });
                  case 6:
                    _context.next = 8;
                    return this.requestError(result);
                  case 8:
                    throw _context.sent;
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function deleteBucket(_x, _x2) {
            return _deleteBucket.apply(this, arguments);
          }
          return deleteBucket;
        }();
        proto.putBucketACL = /* @__PURE__ */ function() {
          var _putBucketACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name2, acl, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    params = this._bucketRequestParams("PUT", name2, "acl", options);
                    params.headers = { "x-oss-acl": acl };
                    params.successStatuses = [200];
                    _context2.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context2.sent;
                    return _context2.abrupt("return", { bucket: result.headers.location && result.headers.location.substring(1) || null, res: result.res });
                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function putBucketACL(_x3, _x4, _x5) {
            return _putBucketACL.apply(this, arguments);
          }
          return putBucketACL;
        }();
        proto.getBucketACL = /* @__PURE__ */ function() {
          var _getBucketACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name2, "acl", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context3.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context3.sent;
                    return _context3.abrupt("return", { acl: result.data.AccessControlList.Grant, owner: { id: result.data.Owner.ID, displayName: result.data.Owner.DisplayName }, res: result.res });
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function getBucketACL(_x6, _x7) {
            return _getBucketACL.apply(this, arguments);
          }
          return getBucketACL;
        }();
        proto.putBucketLogging = /* @__PURE__ */ function() {
          var _putBucketLogging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(name2, prefix, options) {
            var params, xml2, result;
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    params = this._bucketRequestParams("PUT", name2, "logging", options);
                    xml2 = '<?xml version="1.0" encoding="UTF-8"?>\n<BucketLoggingStatus>\n<LoggingEnabled>\n<TargetBucket>'.concat(name2, "</TargetBucket>\n");
                    if (prefix) {
                      xml2 += "<TargetPrefix>".concat(prefix, "</TargetPrefix>\n");
                    }
                    xml2 += "</LoggingEnabled>\n</BucketLoggingStatus>";
                    params.content = xml2;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context4.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context4.sent;
                    return _context4.abrupt("return", { res: result.res });
                  case 11:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function putBucketLogging(_x8, _x9, _x10) {
            return _putBucketLogging.apply(this, arguments);
          }
          return putBucketLogging;
        }();
        proto.getBucketLogging = /* @__PURE__ */ function() {
          var _getBucketLogging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(name2, options) {
            var params, result, enable;
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name2, "logging", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context5.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context5.sent;
                    enable = result.data.LoggingEnabled;
                    return _context5.abrupt("return", { enable: !!enable, prefix: enable && enable.TargetPrefix || null, res: result.res });
                  case 8:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getBucketLogging(_x11, _x12) {
            return _getBucketLogging.apply(this, arguments);
          }
          return getBucketLogging;
        }();
        proto.deleteBucketLogging = /* @__PURE__ */ function() {
          var _deleteBucketLogging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    params = this._bucketRequestParams("DELETE", name2, "logging", options);
                    params.successStatuses = [204, 200];
                    _context6.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context6.sent;
                    return _context6.abrupt("return", { res: result.res });
                  case 6:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function deleteBucketLogging(_x13, _x14) {
            return _deleteBucketLogging.apply(this, arguments);
          }
          return deleteBucketLogging;
        }();
        proto.putBucketCORS = /* @__PURE__ */ function() {
          var _putBucketCORS = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name2, rules, options) {
            var params, xml2, parseOrigin, parseMethod, parseHeader, parseExposeHeader, i3, l2, rule, result;
            return _regenerator.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    rules = rules || [];
                    assert(rules.length, "rules is required");
                    rules.forEach(function(rule2) {
                      assert(rule2.allowedOrigin, "allowedOrigin is required");
                      assert(rule2.allowedMethod, "allowedMethod is required");
                    });
                    params = this._bucketRequestParams("PUT", name2, "cors", options);
                    xml2 = '<?xml version="1.0" encoding="UTF-8"?>\n<CORSConfiguration>';
                    parseOrigin = function parseOrigin2(val) {
                      xml2 += "<AllowedOrigin>".concat(val, "</AllowedOrigin>");
                    };
                    parseMethod = function parseMethod2(val) {
                      xml2 += "<AllowedMethod>".concat(val, "</AllowedMethod>");
                    };
                    parseHeader = function parseHeader2(val) {
                      xml2 += "<AllowedHeader>".concat(val, "</AllowedHeader>");
                    };
                    parseExposeHeader = function parseExposeHeader2(val) {
                      xml2 += "<ExposeHeader>".concat(val, "</ExposeHeader>");
                    };
                    for (i3 = 0, l2 = rules.length; i3 < l2; i3++) {
                      rule = rules[i3];
                      xml2 += "<CORSRule>";
                      toArray2(rule.allowedOrigin).forEach(parseOrigin);
                      toArray2(rule.allowedMethod).forEach(parseMethod);
                      toArray2(rule.allowedHeader).forEach(parseHeader);
                      toArray2(rule.exposeHeader).forEach(parseExposeHeader);
                      if (rule.maxAgeSeconds) {
                        xml2 += "<MaxAgeSeconds>".concat(rule.maxAgeSeconds, "</MaxAgeSeconds>");
                      }
                      xml2 += "</CORSRule>";
                    }
                    xml2 += "</CORSConfiguration>";
                    params.content = xml2;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context7.next = 16;
                    return this.request(params);
                  case 16:
                    result = _context7.sent;
                    return _context7.abrupt("return", { res: result.res });
                  case 18:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function putBucketCORS(_x15, _x16, _x17) {
            return _putBucketCORS.apply(this, arguments);
          }
          return putBucketCORS;
        }();
        proto.getBucketCORS = /* @__PURE__ */ function() {
          var _getBucketCORS = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee8(name2, options) {
            var params, result, rules, CORSRule;
            return _regenerator.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name2, "cors", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context8.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context8.sent;
                    rules = [];
                    if (result.data && result.data.CORSRule) {
                      CORSRule = result.data.CORSRule;
                      if (!isArray2(CORSRule))
                        CORSRule = [CORSRule];
                      CORSRule.forEach(function(rule) {
                        var r2 = {};
                        Object.keys(rule).forEach(function(key) {
                          r2[key.slice(0, 1).toLowerCase() + key.slice(1, key.length)] = rule[key];
                        });
                        rules.push(r2);
                      });
                    }
                    return _context8.abrupt("return", { rules, res: result.res });
                  case 9:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function getBucketCORS(_x18, _x19) {
            return _getBucketCORS.apply(this, arguments);
          }
          return getBucketCORS;
        }();
        proto.deleteBucketCORS = /* @__PURE__ */ function() {
          var _deleteBucketCORS = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee9(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    params = this._bucketRequestParams("DELETE", name2, "cors", options);
                    params.successStatuses = [204];
                    _context9.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context9.sent;
                    return _context9.abrupt("return", { res: result.res });
                  case 6:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function deleteBucketCORS(_x20, _x21) {
            return _deleteBucketCORS.apply(this, arguments);
          }
          return deleteBucketCORS;
        }();
        proto.putBucketReferer = /* @__PURE__ */ function() {
          var _putBucketReferer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee10(name2, allowEmpty, referers, options) {
            var params, xml2, i3, result;
            return _regenerator.default.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    params = this._bucketRequestParams("PUT", name2, "referer", options);
                    xml2 = '<?xml version="1.0" encoding="UTF-8"?>\n<RefererConfiguration>\n';
                    xml2 += "  <AllowEmptyReferer>".concat(allowEmpty ? "true" : "false", "</AllowEmptyReferer>\n");
                    if (referers && referers.length > 0) {
                      xml2 += "  <RefererList>\n";
                      for (i3 = 0; i3 < referers.length; i3++) {
                        xml2 += "    <Referer>".concat(referers[i3], "</Referer>\n");
                      }
                      xml2 += "  </RefererList>\n";
                    } else {
                      xml2 += "  <RefererList />\n";
                    }
                    xml2 += "</RefererConfiguration>";
                    params.content = xml2;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context10.next = 10;
                    return this.request(params);
                  case 10:
                    result = _context10.sent;
                    return _context10.abrupt("return", { res: result.res });
                  case 12:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function putBucketReferer(_x22, _x23, _x24, _x25) {
            return _putBucketReferer.apply(this, arguments);
          }
          return putBucketReferer;
        }();
        proto.getBucketReferer = /* @__PURE__ */ function() {
          var _getBucketReferer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee11(name2, options) {
            var params, result, referers;
            return _regenerator.default.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name2, "referer", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context11.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context11.sent;
                    referers = result.data.RefererList.Referer || null;
                    if (referers) {
                      if (!isArray2(referers)) {
                        referers = [referers];
                      }
                    }
                    return _context11.abrupt("return", { allowEmpty: result.data.AllowEmptyReferer === "true", referers, res: result.res });
                  case 9:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function getBucketReferer(_x26, _x27) {
            return _getBucketReferer.apply(this, arguments);
          }
          return getBucketReferer;
        }();
        proto.deleteBucketReferer = /* @__PURE__ */ function() {
          var _deleteBucketReferer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee12(name2, options) {
            return _regenerator.default.wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return this.putBucketReferer(name2, true, null, options);
                  case 2:
                    return _context12.abrupt("return", _context12.sent);
                  case 3:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));
          function deleteBucketReferer(_x28, _x29) {
            return _deleteBucketReferer.apply(this, arguments);
          }
          return deleteBucketReferer;
        }();
        proto._bucketRequestParams = function _bucketRequestParams(method, bucket2, subres, options) {
          return { method, bucket: bucket2, subres, timeout: options && options.timeout, ctx: options && options.ctx };
        };
      }, { "../common/utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "assert": 82, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/web.dom-collections.for-each.js": 339 }], 3: [function(require2, module2, exports2) {
        (function(Buffer2, process) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.split.js");
            require2("core-js/modules/es.object.assign.js");
            require2("core-js/modules/es.array.includes.js");
            require2("core-js/modules/es.string.replace.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.symbol.js");
            require2("core-js/modules/es.symbol.description.js");
            require2("core-js/modules/es.array.slice.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var debug = require2("debug")("ali-oss");
            var xml2 = require2("xml2js");
            var AgentKeepalive = require2("agentkeepalive");
            var merge2 = require2("merge-descriptors");
            var platform2 = require2("platform");
            var utility = require2("utility");
            var urllib = require2("urllib");
            var pkg = require2("./version");
            var bowser = require2("bowser");
            var signUtils = require2("../common/signUtils");
            var _initOptions = require2("../common/client/initOptions");
            var _require = require2("../common/utils/createRequest"), createRequest = _require.createRequest;
            var _require2 = require2("../common/utils/encoder"), encoder = _require2.encoder;
            var _require3 = require2("../common/client/getReqUrl"), getReqUrl = _require3.getReqUrl;
            var _require4 = require2("../common/utils/setSTSToken"), setSTSToken = _require4.setSTSToken;
            var _require5 = require2("../common/utils/retry"), retry = _require5.retry;
            var _require6 = require2("../common/utils/isFunction"), isFunction2 = _require6.isFunction;
            var globalHttpAgent = new AgentKeepalive();
            function _unSupportBrowserTip() {
              var name2 = platform2.name, version2 = platform2.version;
              if (name2 && name2.toLowerCase && name2.toLowerCase() === "ie" && version2.split(".")[0] < 10) {
                console.warn("ali-oss does not support the current browser");
              }
            }
            function isHttpsWebProtocol() {
              return location && location.protocol === "https:";
            }
            function Client(options, ctx) {
              _unSupportBrowserTip();
              if (!(this instanceof Client)) {
                return new Client(options, ctx);
              }
              if (options && options.inited) {
                this.options = options;
              } else {
                this.options = Client.initOptions(options);
              }
              this.options.cancelFlag = false;
              if (this.options.urllib) {
                this.urllib = this.options.urllib;
              } else {
                this.urllib = urllib;
                this.agent = this.options.agent || globalHttpAgent;
              }
              this.ctx = ctx;
              this.userAgent = this._getUserAgent();
              this.stsTokenFreshTime = /* @__PURE__ */ new Date();
              this.options.amendTimeSkewed = 0;
            }
            module2.exports = Client;
            Client.initOptions = function initOptions(options) {
              if (!options.stsToken) {
                console.warn("Please use STS Token for safety, see more details at https://help.aliyun.com/document_detail/32077.html");
              }
              var opts = Object.assign({
                secure: isHttpsWebProtocol(),
                // for browser compatibility disable fetch.
                useFetch: false
              }, options);
              return _initOptions(opts);
            };
            var proto = Client.prototype;
            proto.debug = debug;
            merge2(proto, require2("./object"));
            merge2(proto, require2("./bucket"));
            merge2(proto, require2("../common/bucket/getBucketWebsite"));
            merge2(proto, require2("../common/bucket/putBucketWebsite"));
            merge2(proto, require2("../common/bucket/deleteBucketWebsite"));
            merge2(proto, require2("../common/bucket/getBucketLifecycle"));
            merge2(proto, require2("../common/bucket/putBucketLifecycle"));
            merge2(proto, require2("../common/bucket/deleteBucketLifecycle"));
            merge2(proto, require2("../common/bucket/putBucketVersioning"));
            merge2(proto, require2("../common/bucket/getBucketVersioning"));
            merge2(proto, require2("../common/bucket/getBucketInventory"));
            merge2(proto, require2("../common/bucket/deleteBucketInventory"));
            merge2(proto, require2("../common/bucket/listBucketInventory"));
            merge2(proto, require2("../common/bucket/putBucketInventory"));
            merge2(proto, require2("../common/bucket/abortBucketWorm"));
            merge2(proto, require2("../common/bucket/completeBucketWorm"));
            merge2(proto, require2("../common/bucket/extendBucketWorm"));
            merge2(proto, require2("../common/bucket/getBucketWorm"));
            merge2(proto, require2("../common/bucket/initiateBucketWorm"));
            merge2(proto, require2("./managed-upload"));
            merge2(proto, require2("../common/multipart-copy"));
            merge2(proto, require2("../common/multipart"));
            merge2(proto, require2("../common/parallel"));
            proto.signature = function signature(stringToSign) {
              this.debug("authorization stringToSign: %s", stringToSign, "info");
              return signUtils.computeSignature(this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
            };
            proto._getReqUrl = getReqUrl;
            proto.authorization = function authorization(method, resource, subres, headers) {
              var stringToSign = signUtils.buildCanonicalString(method.toUpperCase(), resource, { headers, parameters: subres });
              return signUtils.authorization(this.options.accessKeyId, this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
            };
            proto.request = /* @__PURE__ */ function() {
              var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(params) {
                var _this = this;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!this.options.retryMax) {
                          _context.next = 6;
                          break;
                        }
                        _context.next = 3;
                        return retry(request.bind(this), this.options.retryMax, { errorHandler: function errorHandler(err2) {
                          var _errHandle = function _errHandle2(_err) {
                            if (params.stream)
                              return false;
                            var statusErr = [-1, -2].includes(_err.status);
                            var requestErrorRetryHandle = _this.options.requestErrorRetryHandle || function() {
                              return true;
                            };
                            return statusErr && requestErrorRetryHandle(_err);
                          };
                          if (_errHandle(err2))
                            return true;
                          return false;
                        } })(params);
                      case 3:
                        return _context.abrupt("return", _context.sent);
                      case 6:
                        return _context.abrupt("return", request.call(this, params));
                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));
              return function(_x) {
                return _ref.apply(this, arguments);
              };
            }();
            function request(_x2) {
              return _request.apply(this, arguments);
            }
            function _request() {
              _request = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(params) {
                var reqParams, result, reqErr, useStream, err2, parseData;
                return _regenerator.default.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        if (!(this.options.stsToken && isFunction2(this.options.refreshSTSToken))) {
                          _context3.next = 3;
                          break;
                        }
                        _context3.next = 3;
                        return setSTSToken.call(this);
                      case 3:
                        reqParams = createRequest.call(this, params);
                        if (!this.options.useFetch) {
                          reqParams.params.mode = "disable-fetch";
                        }
                        useStream = !!params.stream;
                        _context3.prev = 6;
                        _context3.next = 9;
                        return this.urllib.request(reqParams.url, reqParams.params);
                      case 9:
                        result = _context3.sent;
                        this.debug("response %s %s, got %s, headers: %j", params.method, reqParams.url, result.status, result.headers, "info");
                        _context3.next = 16;
                        break;
                      case 13:
                        _context3.prev = 13;
                        _context3.t0 = _context3["catch"](6);
                        reqErr = _context3.t0;
                      case 16:
                        if (!(result && params.successStatuses && params.successStatuses.indexOf(result.status) === -1)) {
                          _context3.next = 28;
                          break;
                        }
                        _context3.next = 19;
                        return this.requestError(result);
                      case 19:
                        err2 = _context3.sent;
                        if (!(err2.code === "RequestTimeTooSkewed" && !useStream)) {
                          _context3.next = 25;
                          break;
                        }
                        this.options.amendTimeSkewed = +new Date(err2.serverTime) - /* @__PURE__ */ new Date();
                        _context3.next = 24;
                        return this.request(params);
                      case 24:
                        return _context3.abrupt("return", _context3.sent);
                      case 25:
                        err2.params = params;
                        _context3.next = 32;
                        break;
                      case 28:
                        if (!reqErr) {
                          _context3.next = 32;
                          break;
                        }
                        _context3.next = 31;
                        return this.requestError(reqErr);
                      case 31:
                        err2 = _context3.sent;
                      case 32:
                        if (!err2) {
                          _context3.next = 34;
                          break;
                        }
                        throw err2;
                      case 34:
                        if (!params.xmlResponse) {
                          _context3.next = 39;
                          break;
                        }
                        _context3.next = 37;
                        return this.parseXML(result.data);
                      case 37:
                        parseData = _context3.sent;
                        result.data = parseData;
                      case 39:
                        return _context3.abrupt("return", result);
                      case 40:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3, this, [[6, 13]]);
              }));
              return _request.apply(this, arguments);
            }
            proto._getResource = function _getResource(params) {
              var resource = "/";
              if (params.bucket)
                resource += "".concat(params.bucket, "/");
              if (params.object)
                resource += encoder(params.object, this.options.headerEncoding);
              return resource;
            };
            proto._escape = function _escape(name2) {
              return utility.encodeURIComponent(name2).replace(/%2F/g, "/");
            };
            proto._getUserAgent = function _getUserAgent() {
              var agent = process && process.browser ? "js" : "nodejs";
              var sdk = "aliyun-sdk-".concat(agent, "/").concat(pkg.version);
              var plat = platform2.description;
              if (!plat && process) {
                plat = "Node.js ".concat(process.version.slice(1), " on ").concat(process.platform, " ").concat(process.arch);
              }
              return this._checkUserAgent("".concat(sdk, " ").concat(plat));
            };
            proto._checkUserAgent = function _checkUserAgent(ua) {
              var userAgent2 = ua.replace(/\u03b1/, "alpha").replace(/\u03b2/, "beta");
              return userAgent2;
            };
            proto.checkBrowserAndVersion = function checkBrowserAndVersion(name2, version2) {
              return bowser.name === name2 && bowser.version.split(".")[0] === version2;
            };
            proto.parseXML = function parseXMLThunk(str) {
              return new Promise(function(resolve, reject) {
                if (Buffer2.isBuffer(str)) {
                  str = str.toString();
                }
                xml2.parseString(str, { explicitRoot: false, explicitArray: false }, function(err2, result) {
                  if (err2) {
                    reject(err2);
                  } else {
                    resolve(result);
                  }
                });
              });
            };
            proto.requestError = /* @__PURE__ */ function() {
              var _requestError = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(result) {
                var err2, message, info, msg;
                return _regenerator.default.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        err2 = null;
                        if (!(!result.data || !result.data.length)) {
                          _context2.next = 5;
                          break;
                        }
                        if (result.status === -1 || result.status === -2) {
                          err2 = new Error(result.message);
                          err2.name = result.name;
                          err2.status = result.status;
                          err2.code = result.name;
                        } else {
                          if (result.status === 404) {
                            err2 = new Error("Object not exists");
                            err2.name = "NoSuchKeyError";
                            err2.status = 404;
                            err2.code = "NoSuchKey";
                          } else if (result.status === 412) {
                            err2 = new Error("Pre condition failed");
                            err2.name = "PreconditionFailedError";
                            err2.status = 412;
                            err2.code = "PreconditionFailed";
                          } else {
                            err2 = new Error("Unknow error, status: ".concat(result.status));
                            err2.name = "UnknownError";
                            err2.status = result.status;
                          }
                          err2.requestId = result.headers["x-oss-request-id"];
                          err2.host = "";
                        }
                        _context2.next = 32;
                        break;
                      case 5:
                        message = String(result.data);
                        this.debug("request response error data: %s", message, "error");
                        _context2.prev = 7;
                        _context2.next = 10;
                        return this.parseXML(message);
                      case 10:
                        _context2.t0 = _context2.sent;
                        if (_context2.t0) {
                          _context2.next = 13;
                          break;
                        }
                        _context2.t0 = {};
                      case 13:
                        info = _context2.t0;
                        _context2.next = 23;
                        break;
                      case 16:
                        _context2.prev = 16;
                        _context2.t1 = _context2["catch"](7);
                        this.debug(message, "error");
                        _context2.t1.message += "\nraw xml: ".concat(message);
                        _context2.t1.status = result.status;
                        _context2.t1.requestId = result.headers["x-oss-request-id"];
                        return _context2.abrupt("return", _context2.t1);
                      case 23:
                        msg = info.Message || "unknow request error, status: ".concat(result.status);
                        if (info.Condition) {
                          msg += " (condition: ".concat(info.Condition, ")");
                        }
                        err2 = new Error(msg);
                        err2.name = info.Code ? "".concat(info.Code, "Error") : "UnknownError";
                        err2.status = result.status;
                        err2.code = info.Code;
                        err2.requestId = info.RequestId;
                        err2.hostId = info.HostId;
                        err2.serverTime = info.ServerTime;
                      case 32:
                        this.debug("generate error %j", err2, "error");
                        return _context2.abrupt("return", err2);
                      case 34:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, this, [[7, 16]]);
              }));
              function requestError(_x3) {
                return _requestError.apply(this, arguments);
              }
              return requestError;
            }();
          }).call(this);
        }).call(this, { "isBuffer": require2("../../node_modules/is-buffer/index.js") }, require2("_process"));
      }, { "../../node_modules/is-buffer/index.js": 366, "../common/bucket/abortBucketWorm": 7, "../common/bucket/completeBucketWorm": 8, "../common/bucket/deleteBucketInventory": 9, "../common/bucket/deleteBucketLifecycle": 10, "../common/bucket/deleteBucketWebsite": 11, "../common/bucket/extendBucketWorm": 12, "../common/bucket/getBucketInventory": 13, "../common/bucket/getBucketLifecycle": 14, "../common/bucket/getBucketVersioning": 15, "../common/bucket/getBucketWebsite": 16, "../common/bucket/getBucketWorm": 17, "../common/bucket/initiateBucketWorm": 18, "../common/bucket/listBucketInventory": 19, "../common/bucket/putBucketInventory": 20, "../common/bucket/putBucketLifecycle": 21, "../common/bucket/putBucketVersioning": 22, "../common/bucket/putBucketWebsite": 23, "../common/client/getReqUrl": 25, "../common/client/initOptions": 26, "../common/multipart": 30, "../common/multipart-copy": 29, "../common/parallel": 49, "../common/signUtils": 50, "../common/utils/createRequest": 56, "../common/utils/encoder": 59, "../common/utils/isFunction": 68, "../common/utils/retry": 74, "../common/utils/setSTSToken": 76, "./bucket": 2, "./managed-upload": 4, "./object": 5, "./version": 6, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "_process": 467, "agentkeepalive": 81, "bowser": 88, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.replace.js": 305, "core-js/modules/es.string.split.js": 307, "core-js/modules/es.symbol.description.js": 310, "core-js/modules/es.symbol.js": 313, "debug": 465, "merge-descriptors": 372, "platform": 379, "urllib": 475, "utility": 474, "xml2js": 426 }], 4: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.array.from.js");
            require2("core-js/modules/es.string.iterator.js");
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.array.filter.js");
            require2("core-js/modules/es.array.find.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.regexp.to-string.js");
            require2("core-js/modules/es.array.slice.js");
            require2("core-js/modules/es.array.iterator.js");
            require2("core-js/modules/es.array-buffer.slice.js");
            require2("core-js/modules/es.typed-array.uint8-array.js");
            require2("core-js/modules/es.typed-array.copy-within.js");
            require2("core-js/modules/es.typed-array.every.js");
            require2("core-js/modules/es.typed-array.fill.js");
            require2("core-js/modules/es.typed-array.filter.js");
            require2("core-js/modules/es.typed-array.find.js");
            require2("core-js/modules/es.typed-array.find-index.js");
            require2("core-js/modules/es.typed-array.for-each.js");
            require2("core-js/modules/es.typed-array.includes.js");
            require2("core-js/modules/es.typed-array.index-of.js");
            require2("core-js/modules/es.typed-array.iterator.js");
            require2("core-js/modules/es.typed-array.join.js");
            require2("core-js/modules/es.typed-array.last-index-of.js");
            require2("core-js/modules/es.typed-array.map.js");
            require2("core-js/modules/es.typed-array.reduce.js");
            require2("core-js/modules/es.typed-array.reduce-right.js");
            require2("core-js/modules/es.typed-array.reverse.js");
            require2("core-js/modules/es.typed-array.set.js");
            require2("core-js/modules/es.typed-array.slice.js");
            require2("core-js/modules/es.typed-array.some.js");
            require2("core-js/modules/es.typed-array.sort.js");
            require2("core-js/modules/es.typed-array.subarray.js");
            require2("core-js/modules/es.typed-array.to-locale-string.js");
            require2("core-js/modules/es.typed-array.to-string.js");
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            var util = require2("util");
            var path = require2("path");
            var mime = require2("mime");
            var copy = require2("copy-to");
            var _require = require2("../common/utils/isBlob"), isBlob2 = _require.isBlob;
            var _require2 = require2("../common/utils/isFile"), isFile2 = _require2.isFile;
            var _require3 = require2("../common/utils/isBuffer"), isBuffer2 = _require3.isBuffer;
            var proto = exports2;
            proto.multipartUpload = /* @__PURE__ */ function() {
              var _multipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, file) {
                var options, minPartSize, fileSize, result, ret, initResult, uploadId, partSize, checkpoint, _args = arguments;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                        this.resetCancelFlag();
                        options.disabledMD5 = options.disabledMD5 === void 0 ? true : !!options.disabledMD5;
                        if (!(options.checkpoint && options.checkpoint.uploadId)) {
                          _context.next = 8;
                          break;
                        }
                        if (file && isFile2(file))
                          options.checkpoint.file = file;
                        _context.next = 7;
                        return this._resumeMultipart(options.checkpoint, options);
                      case 7:
                        return _context.abrupt("return", _context.sent);
                      case 8:
                        minPartSize = 100 * 1024;
                        if (!options.mime) {
                          if (isFile2(file)) {
                            options.mime = mime.getType(path.extname(file.name));
                          } else if (isBlob2(file)) {
                            options.mime = file.type;
                          } else if (isBuffer2(file)) {
                            options.mime = "";
                          } else {
                            options.mime = mime.getType(path.extname(file));
                          }
                        }
                        options.headers = options.headers || {};
                        this._convertMetaToHeaders(options.meta, options.headers);
                        _context.next = 14;
                        return this._getFileSize(file);
                      case 14:
                        fileSize = _context.sent;
                        if (!(fileSize < minPartSize)) {
                          _context.next = 26;
                          break;
                        }
                        options.contentLength = fileSize;
                        _context.next = 19;
                        return this.put(name2, file, options);
                      case 19:
                        result = _context.sent;
                        if (!(options && options.progress)) {
                          _context.next = 23;
                          break;
                        }
                        _context.next = 23;
                        return options.progress(1);
                      case 23:
                        ret = { res: result.res, bucket: this.options.bucket, name: name2, etag: result.res.headers.etag };
                        if (options.headers && options.headers["x-oss-callback"] || options.callback) {
                          ret.data = result.data;
                        }
                        return _context.abrupt("return", ret);
                      case 26:
                        if (!(options.partSize && !(parseInt(options.partSize, 10) === options.partSize))) {
                          _context.next = 28;
                          break;
                        }
                        throw new Error("partSize must be int number");
                      case 28:
                        if (!(options.partSize && options.partSize < minPartSize)) {
                          _context.next = 30;
                          break;
                        }
                        throw new Error("partSize must not be smaller than ".concat(minPartSize));
                      case 30:
                        _context.next = 32;
                        return this.initMultipartUpload(name2, options);
                      case 32:
                        initResult = _context.sent;
                        uploadId = initResult.uploadId;
                        partSize = this._getPartSize(fileSize, options.partSize);
                        checkpoint = { file, name: name2, fileSize, partSize, uploadId, doneParts: [] };
                        if (!(options && options.progress)) {
                          _context.next = 39;
                          break;
                        }
                        _context.next = 39;
                        return options.progress(0, checkpoint, initResult.res);
                      case 39:
                        _context.next = 41;
                        return this._resumeMultipart(checkpoint, options);
                      case 41:
                        return _context.abrupt("return", _context.sent);
                      case 42:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));
              function multipartUpload(_x, _x2) {
                return _multipartUpload.apply(this, arguments);
              }
              return multipartUpload;
            }();
            proto._resumeMultipart = /* @__PURE__ */ function() {
              var _resumeMultipart2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(checkpoint, options) {
                var that, file, fileSize, partSize, uploadId, doneParts, name2, internalDoneParts, partOffs, numParts, multipartFinish, uploadPartJob, all2, done, todo, defaultParallel, parallel, jobErr, abortEvent;
                return _regenerator.default.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        that = this;
                        if (!this.isCancel()) {
                          _context3.next = 3;
                          break;
                        }
                        throw this._makeCancelEvent();
                      case 3:
                        file = checkpoint.file, fileSize = checkpoint.fileSize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name2 = checkpoint.name;
                        internalDoneParts = [];
                        if (doneParts.length > 0) {
                          copy(doneParts).to(internalDoneParts);
                        }
                        partOffs = this._divideParts(fileSize, partSize);
                        numParts = partOffs.length;
                        multipartFinish = false;
                        uploadPartJob = function uploadPartJob2(self2, partNo) {
                          return new Promise(/* @__PURE__ */ function() {
                            var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(resolve, reject) {
                              var pi, content, data, result, tempErr;
                              return _regenerator.default.wrap(function _callee2$(_context2) {
                                while (1) {
                                  switch (_context2.prev = _context2.next) {
                                    case 0:
                                      _context2.prev = 0;
                                      if (self2.isCancel()) {
                                        _context2.next = 29;
                                        break;
                                      }
                                      pi = partOffs[partNo - 1];
                                      _context2.next = 5;
                                      return self2._createBuffer(file, pi.start, pi.end);
                                    case 5:
                                      content = _context2.sent;
                                      data = { content, size: pi.end - pi.start };
                                      _context2.prev = 7;
                                      _context2.next = 10;
                                      return self2._uploadPart(name2, uploadId, partNo, data, options);
                                    case 10:
                                      result = _context2.sent;
                                      _context2.next = 18;
                                      break;
                                    case 13:
                                      _context2.prev = 13;
                                      _context2.t0 = _context2["catch"](7);
                                      if (!(_context2.t0.status === 404)) {
                                        _context2.next = 17;
                                        break;
                                      }
                                      throw self2._makeAbortEvent();
                                    case 17:
                                      throw _context2.t0;
                                    case 18:
                                      if (!(!self2.isCancel() && !multipartFinish)) {
                                        _context2.next = 26;
                                        break;
                                      }
                                      checkpoint.doneParts.push({ number: partNo, etag: result.res.headers.etag });
                                      if (!options.progress) {
                                        _context2.next = 23;
                                        break;
                                      }
                                      _context2.next = 23;
                                      return options.progress(doneParts.length / (numParts + 1), checkpoint, result.res);
                                    case 23:
                                      resolve({ number: partNo, etag: result.res.headers.etag });
                                      _context2.next = 27;
                                      break;
                                    case 26:
                                      resolve();
                                    case 27:
                                      _context2.next = 30;
                                      break;
                                    case 29:
                                      resolve();
                                    case 30:
                                      _context2.next = 41;
                                      break;
                                    case 32:
                                      _context2.prev = 32;
                                      _context2.t1 = _context2["catch"](0);
                                      tempErr = new Error();
                                      tempErr.name = _context2.t1.name;
                                      tempErr.message = _context2.t1.message;
                                      tempErr.stack = _context2.t1.stack;
                                      tempErr.partNum = partNo;
                                      copy(_context2.t1).to(tempErr);
                                      reject(tempErr);
                                    case 41:
                                    case "end":
                                      return _context2.stop();
                                  }
                                }
                              }, _callee2, null, [[0, 32], [7, 13]]);
                            }));
                            return function(_x5, _x6) {
                              return _ref.apply(this, arguments);
                            };
                          }());
                        };
                        all2 = Array.from(new Array(numParts), function(x2, i3) {
                          return i3 + 1;
                        });
                        done = internalDoneParts.map(function(p2) {
                          return p2.number;
                        });
                        todo = all2.filter(function(p2) {
                          return done.indexOf(p2) < 0;
                        });
                        defaultParallel = 5;
                        parallel = options.parallel || defaultParallel;
                        _context3.next = 17;
                        return this._parallel(todo, parallel, function(value) {
                          return new Promise(function(resolve, reject) {
                            uploadPartJob(that, value).then(function(result) {
                              if (result) {
                                internalDoneParts.push(result);
                              }
                              resolve();
                            }).catch(function(err2) {
                              reject(err2);
                            });
                          });
                        });
                      case 17:
                        jobErr = _context3.sent;
                        multipartFinish = true;
                        abortEvent = jobErr.find(function(err2) {
                          return err2.name === "abort";
                        });
                        if (!abortEvent) {
                          _context3.next = 22;
                          break;
                        }
                        throw abortEvent;
                      case 22:
                        if (!this.isCancel()) {
                          _context3.next = 25;
                          break;
                        }
                        uploadPartJob = null;
                        throw this._makeCancelEvent();
                      case 25:
                        if (!(jobErr && jobErr.length > 0)) {
                          _context3.next = 28;
                          break;
                        }
                        jobErr[0].message = "Failed to upload some parts with error: ".concat(jobErr[0].toString(), " part_num: ").concat(jobErr[0].partNum);
                        throw jobErr[0];
                      case 28:
                        _context3.next = 30;
                        return this.completeMultipartUpload(name2, uploadId, internalDoneParts, options);
                      case 30:
                        return _context3.abrupt("return", _context3.sent);
                      case 31:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3, this);
              }));
              function _resumeMultipart(_x3, _x4) {
                return _resumeMultipart2.apply(this, arguments);
              }
              return _resumeMultipart;
            }();
            proto._getFileSize = /* @__PURE__ */ function() {
              var _getFileSize2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(file) {
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!isBuffer2(file)) {
                          _context4.next = 4;
                          break;
                        }
                        return _context4.abrupt("return", file.length);
                      case 4:
                        if (!(isBlob2(file) || isFile2(file))) {
                          _context4.next = 6;
                          break;
                        }
                        return _context4.abrupt("return", file.size);
                      case 6:
                        throw new Error("_getFileSize requires Buffer/File/Blob.");
                      case 7:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));
              function _getFileSize(_x7) {
                return _getFileSize2.apply(this, arguments);
              }
              return _getFileSize;
            }();
            var _require4 = require2("stream"), Readable = _require4.Readable;
            function WebFileReadStream(file, options) {
              if (!(this instanceof WebFileReadStream)) {
                return new WebFileReadStream(file, options);
              }
              Readable.call(this, options);
              this.file = file;
              this.reader = new FileReader();
              this.start = 0;
              this.finish = false;
              this.fileBuffer = null;
            }
            util.inherits(WebFileReadStream, Readable);
            WebFileReadStream.prototype.readFileAndPush = function readFileAndPush(size2) {
              if (this.fileBuffer) {
                var pushRet = true;
                while (pushRet && this.fileBuffer && this.start < this.fileBuffer.length) {
                  var start = this.start;
                  var end = start + size2;
                  end = end > this.fileBuffer.length ? this.fileBuffer.length : end;
                  this.start = end;
                  pushRet = this.push(this.fileBuffer.slice(start, end));
                }
              }
            };
            WebFileReadStream.prototype._read = function _read(size2) {
              if (this.file && this.start >= this.file.size || this.fileBuffer && this.start >= this.fileBuffer.length || this.finish || this.start === 0 && !this.file) {
                if (!this.finish) {
                  this.fileBuffer = null;
                  this.finish = true;
                }
                this.push(null);
                return;
              }
              var defaultReadSize = 16 * 1024;
              size2 = size2 || defaultReadSize;
              var that = this;
              this.reader.onload = function onload(e2) {
                that.fileBuffer = Buffer2.from(new Uint8Array(e2.target.result));
                that.file = null;
                that.readFileAndPush(size2);
              };
              if (this.start === 0) {
                this.reader.readAsArrayBuffer(this.file);
              } else {
                this.readFileAndPush(size2);
              }
            };
            function getBuffer(file) {
              if (file.arrayBuffer)
                return file.arrayBuffer();
              return new Promise(function(resolve, reject) {
                var reader = new FileReader();
                reader.onload = function(e2) {
                  resolve(e2.target.result);
                };
                reader.onerror = function(e2) {
                  reject(e2);
                };
                reader.readAsArrayBuffer(file);
              });
            }
            proto._createBuffer = /* @__PURE__ */ function() {
              var _createBuffer2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(file, start, end) {
                var _file, fileContent;
                return _regenerator.default.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!(isBlob2(file) || isFile2(file))) {
                          _context5.next = 8;
                          break;
                        }
                        _file = file.slice(start, end);
                        _context5.next = 4;
                        return getBuffer(_file);
                      case 4:
                        fileContent = _context5.sent;
                        return _context5.abrupt("return", Buffer2.from(fileContent));
                      case 8:
                        if (!isBuffer2(file)) {
                          _context5.next = 12;
                          break;
                        }
                        return _context5.abrupt("return", file.subarray(start, end));
                      case 12:
                        throw new Error("_createBuffer requires File/Blob/Buffer.");
                      case 13:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));
              function _createBuffer(_x8, _x9, _x10) {
                return _createBuffer2.apply(this, arguments);
              }
              return _createBuffer;
            }();
            proto._getPartSize = function _getPartSize(fileSize, partSize) {
              var maxNumParts = 10 * 1e3;
              var defaultPartSize = 1 * 1024 * 1024;
              if (!partSize)
                partSize = defaultPartSize;
              var safeSize = Math.ceil(fileSize / maxNumParts);
              if (partSize < safeSize) {
                partSize = safeSize;
                console.warn("partSize has been set to ".concat(partSize, ", because the partSize you provided causes partNumber to be greater than 10,000"));
              }
              return partSize;
            };
            proto._divideParts = function _divideParts(fileSize, partSize) {
              var numParts = Math.ceil(fileSize / partSize);
              var partOffs = [];
              for (var i3 = 0; i3 < numParts; i3++) {
                var start = partSize * i3;
                var end = Math.min(start + partSize, fileSize);
                partOffs.push({ start, end });
              }
              return partOffs;
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../common/utils/isBlob": 64, "../common/utils/isBuffer": 65, "../common/utils/isFile": 67, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "buffer": 90, "copy-to": 94, "core-js/modules/es.array-buffer.slice.js": 271, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.filter.js": 274, "core-js/modules/es.array.find.js": 275, "core-js/modules/es.array.from.js": 276, "core-js/modules/es.array.iterator.js": 278, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.iterator.js": 303, "core-js/modules/es.typed-array.copy-within.js": 315, "core-js/modules/es.typed-array.every.js": 316, "core-js/modules/es.typed-array.fill.js": 317, "core-js/modules/es.typed-array.filter.js": 318, "core-js/modules/es.typed-array.find-index.js": 319, "core-js/modules/es.typed-array.find.js": 320, "core-js/modules/es.typed-array.for-each.js": 321, "core-js/modules/es.typed-array.includes.js": 322, "core-js/modules/es.typed-array.index-of.js": 323, "core-js/modules/es.typed-array.iterator.js": 324, "core-js/modules/es.typed-array.join.js": 325, "core-js/modules/es.typed-array.last-index-of.js": 326, "core-js/modules/es.typed-array.map.js": 327, "core-js/modules/es.typed-array.reduce-right.js": 328, "core-js/modules/es.typed-array.reduce.js": 329, "core-js/modules/es.typed-array.reverse.js": 330, "core-js/modules/es.typed-array.set.js": 331, "core-js/modules/es.typed-array.slice.js": 332, "core-js/modules/es.typed-array.some.js": 333, "core-js/modules/es.typed-array.sort.js": 334, "core-js/modules/es.typed-array.subarray.js": 335, "core-js/modules/es.typed-array.to-locale-string.js": 336, "core-js/modules/es.typed-array.to-string.js": 337, "core-js/modules/es.typed-array.uint8-array.js": 338, "mime": 374, "path": 378, "stream": 398, "util": 419 }], 5: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        require2("core-js/modules/es.function.name.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.number.constructor.js");
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.promise.js");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var fs = require2("fs");
        var copy = require2("copy-to");
        var path = require2("path");
        var mime = require2("mime");
        var callback = require2("../common/callback");
        var merge2 = require2("merge-descriptors");
        var _require = require2("../common/utils/isBlob"), isBlob2 = _require.isBlob;
        var _require2 = require2("../common/utils/isFile"), isFile2 = _require2.isFile;
        var _require3 = require2("../common/utils/isBuffer"), isBuffer2 = _require3.isBuffer;
        var _require4 = require2("../common/utils/obj2xml"), obj2xml = _require4.obj2xml;
        var proto = exports2;
        proto.append = /* @__PURE__ */ function() {
          var _append = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, file, options) {
            var result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    if (options.position === void 0)
                      options.position = "0";
                    options.subres = { append: "", position: options.position };
                    options.method = "POST";
                    _context.next = 6;
                    return this.put(name2, file, options);
                  case 6:
                    result = _context.sent;
                    result.nextAppendPosition = result.res.headers["x-oss-next-append-position"];
                    return _context.abrupt("return", result);
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function append2(_x, _x2, _x3) {
            return _append.apply(this, arguments);
          }
          return append2;
        }();
        proto.put = /* @__PURE__ */ function() {
          var _put = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name2, file, options) {
            var content, method, params, result, ret;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    options = options || {};
                    options.disabledMD5 = options.disabledMD5 === void 0 ? true : !!options.disabledMD5;
                    options.headers = options.headers || {};
                    name2 = this._objectName(name2);
                    if (!isBuffer2(file)) {
                      _context2.next = 8;
                      break;
                    }
                    content = file;
                    _context2.next = 19;
                    break;
                  case 8:
                    if (!(isBlob2(file) || isFile2(file))) {
                      _context2.next = 18;
                      break;
                    }
                    if (!options.mime) {
                      if (isFile2(file)) {
                        options.mime = mime.getType(path.extname(file.name));
                      } else {
                        options.mime = file.type;
                      }
                    }
                    _context2.next = 12;
                    return this._createBuffer(file, 0, file.size);
                  case 12:
                    content = _context2.sent;
                    _context2.next = 15;
                    return this._getFileSize(file);
                  case 15:
                    options.contentLength = _context2.sent;
                    _context2.next = 19;
                    break;
                  case 18:
                    throw new TypeError("Must provide Buffer/Blob/File for put.");
                  case 19:
                    this._convertMetaToHeaders(options.meta, options.headers);
                    method = options.method || "PUT";
                    params = this._objectRequestParams(method, name2, options);
                    callback.encodeCallback(params, options);
                    params.mime = options.mime;
                    params.disabledMD5 = options.disabledMD5;
                    params.content = content;
                    params.successStatuses = [200];
                    _context2.next = 29;
                    return this.request(params);
                  case 29:
                    result = _context2.sent;
                    ret = { name: name2, url: this._objectUrl(name2), res: result.res };
                    if (params.headers && params.headers["x-oss-callback"]) {
                      ret.data = JSON.parse(result.data.toString());
                    }
                    return _context2.abrupt("return", ret);
                  case 33:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function put(_x4, _x5, _x6) {
            return _put.apply(this, arguments);
          }
          return put;
        }();
        proto.putStream = /* @__PURE__ */ function() {
          var _putStream = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(name2, stream, options) {
            var method, params, result, ret;
            return _regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    options = options || {};
                    options.headers = options.headers || {};
                    name2 = this._objectName(name2);
                    if (options.contentLength) {
                      options.headers["Content-Length"] = options.contentLength;
                    } else {
                      options.headers["Transfer-Encoding"] = "chunked";
                    }
                    this._convertMetaToHeaders(options.meta, options.headers);
                    method = options.method || "PUT";
                    params = this._objectRequestParams(method, name2, options);
                    callback.encodeCallback(params, options);
                    params.mime = options.mime;
                    params.stream = stream;
                    params.successStatuses = [200];
                    _context3.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context3.sent;
                    ret = { name: name2, url: this._objectUrl(name2), res: result.res };
                    if (params.headers && params.headers["x-oss-callback"]) {
                      ret.data = JSON.parse(result.data.toString());
                    }
                    return _context3.abrupt("return", ret);
                  case 17:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function putStream(_x7, _x8, _x9) {
            return _putStream.apply(this, arguments);
          }
          return putStream;
        }();
        merge2(proto, require2("../common/object/copyObject"));
        merge2(proto, require2("../common/object/getObjectTagging"));
        merge2(proto, require2("../common/object/putObjectTagging"));
        merge2(proto, require2("../common/object/deleteObjectTagging"));
        merge2(proto, require2("../common/image"));
        merge2(proto, require2("../common/object/getBucketVersions"));
        merge2(proto, require2("../common/object/getACL"));
        merge2(proto, require2("../common/object/putACL"));
        merge2(proto, require2("../common/object/head"));
        merge2(proto, require2("../common/object/delete"));
        merge2(proto, require2("../common/object/get"));
        merge2(proto, require2("../common/object/putSymlink"));
        merge2(proto, require2("../common/object/getSymlink"));
        merge2(proto, require2("../common/object/deleteMulti"));
        merge2(proto, require2("../common/object/getObjectMeta"));
        merge2(proto, require2("../common/object/getObjectUrl"));
        merge2(proto, require2("../common/object/generateObjectUrl"));
        merge2(proto, require2("../common/object/signatureUrl"));
        merge2(proto, require2("../common/object/asyncSignatureUrl"));
        proto.putMeta = /* @__PURE__ */ function() {
          var _putMeta = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(name2, meta, options) {
            var copyResult;
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.copy(name2, name2, { meta: meta || {}, timeout: options && options.timeout, ctx: options && options.ctx });
                  case 2:
                    copyResult = _context4.sent;
                    return _context4.abrupt("return", copyResult);
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function putMeta(_x10, _x11, _x12) {
            return _putMeta.apply(this, arguments);
          }
          return putMeta;
        }();
        proto.list = /* @__PURE__ */ function() {
          var _list = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(query, options) {
            var params, result, objects, that, prefixes;
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    params = this._objectRequestParams("GET", "", options);
                    params.query = query;
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context5.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context5.sent;
                    objects = result.data.Contents || [];
                    that = this;
                    if (objects) {
                      if (!Array.isArray(objects)) {
                        objects = [objects];
                      }
                      objects = objects.map(function(obj) {
                        return { name: obj.Key, url: that._objectUrl(obj.Key), lastModified: obj.LastModified, etag: obj.ETag, type: obj.Type, size: Number(obj.Size), storageClass: obj.StorageClass, owner: { id: obj.Owner.ID, displayName: obj.Owner.DisplayName } };
                      });
                    }
                    prefixes = result.data.CommonPrefixes || null;
                    if (prefixes) {
                      if (!Array.isArray(prefixes)) {
                        prefixes = [prefixes];
                      }
                      prefixes = prefixes.map(function(item) {
                        return item.Prefix;
                      });
                    }
                    return _context5.abrupt("return", { res: result.res, objects, prefixes, nextMarker: result.data.NextMarker || null, isTruncated: result.data.IsTruncated === "true" });
                  case 13:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function list(_x13, _x14) {
            return _list.apply(this, arguments);
          }
          return list;
        }();
        proto.listV2 = /* @__PURE__ */ function() {
          var _listV = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(query) {
            var options, continuation_token, params, result, objects, that, prefixes, _args6 = arguments;
            return _regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    options = _args6.length > 1 && _args6[1] !== void 0 ? _args6[1] : {};
                    continuation_token = query["continuation-token"] || query.continuationToken;
                    if (continuation_token) {
                      options.subres = Object.assign({ "continuation-token": continuation_token }, options.subres);
                    }
                    params = this._objectRequestParams("GET", "", options);
                    params.query = Object.assign({ "list-type": 2 }, query);
                    delete params.query["continuation-token"];
                    delete params.query.continuationToken;
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context6.next = 11;
                    return this.request(params);
                  case 11:
                    result = _context6.sent;
                    objects = result.data.Contents || [];
                    that = this;
                    if (objects) {
                      if (!Array.isArray(objects)) {
                        objects = [objects];
                      }
                      objects = objects.map(function(obj) {
                        var owner = null;
                        if (obj.Owner) {
                          owner = { id: obj.Owner.ID, displayName: obj.Owner.DisplayName };
                        }
                        return { name: obj.Key, url: that._objectUrl(obj.Key), lastModified: obj.LastModified, etag: obj.ETag, type: obj.Type, size: Number(obj.Size), storageClass: obj.StorageClass, owner };
                      });
                    }
                    prefixes = result.data.CommonPrefixes || null;
                    if (prefixes) {
                      if (!Array.isArray(prefixes)) {
                        prefixes = [prefixes];
                      }
                      prefixes = prefixes.map(function(item) {
                        return item.Prefix;
                      });
                    }
                    return _context6.abrupt("return", { res: result.res, objects, prefixes, isTruncated: result.data.IsTruncated === "true", keyCount: +result.data.KeyCount, continuationToken: result.data.ContinuationToken || null, nextContinuationToken: result.data.NextContinuationToken || null });
                  case 18:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function listV2(_x15) {
            return _listV.apply(this, arguments);
          }
          return listV2;
        }();
        proto.restore = /* @__PURE__ */ function() {
          var _restore = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name2) {
            var options, params, paramsXMLObj, result, _args7 = arguments;
            return _regenerator.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    options = _args7.length > 1 && _args7[1] !== void 0 ? _args7[1] : { type: "Archive" };
                    options = options || {};
                    options.subres = Object.assign({ restore: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("POST", name2, options);
                    if (options.type === "ColdArchive") {
                      paramsXMLObj = { RestoreRequest: { Days: options.Days ? options.Days : 2, JobParameters: { Tier: options.JobParameters ? options.JobParameters : "Standard" } } };
                      params.content = obj2xml(paramsXMLObj, { headers: true });
                      params.mime = "xml";
                    }
                    params.successStatuses = [202];
                    _context7.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context7.sent;
                    return _context7.abrupt("return", { res: result.res });
                  case 11:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function restore(_x16) {
            return _restore.apply(this, arguments);
          }
          return restore;
        }();
        proto._objectUrl = function _objectUrl(name2) {
          return this._getReqUrl({ bucket: this.options.bucket, object: name2 });
        };
        proto._objectRequestParams = function _objectRequestParams(method, name2, options) {
          if (!this.options.bucket && !this.options.cname) {
            throw new Error("Please create a bucket first");
          }
          options = options || {};
          name2 = this._objectName(name2);
          var params = { object: name2, bucket: this.options.bucket, method, subres: options && options.subres, timeout: options && options.timeout, ctx: options && options.ctx };
          if (options.headers) {
            params.headers = {};
            copy(options.headers).to(params.headers);
          }
          return params;
        };
        proto._objectName = function _objectName(name2) {
          return name2.replace(/^\/+/, "");
        };
        proto._convertMetaToHeaders = function _convertMetaToHeaders(meta, headers) {
          if (!meta) {
            return;
          }
          Object.keys(meta).forEach(function(k2) {
            headers["x-oss-meta-".concat(k2)] = meta[k2];
          });
        };
        proto._deleteFileSafe = function _deleteFileSafe(filepath) {
          var _this = this;
          return new Promise(function(resolve) {
            fs.exists(filepath, function(exists) {
              if (!exists) {
                resolve();
              } else {
                fs.unlink(filepath, function(err2) {
                  if (err2) {
                    _this.debug("unlink %j error: %s", filepath, err2, "error");
                  }
                  resolve();
                });
              }
            });
          });
        };
      }, { "../common/callback": 24, "../common/image": 27, "../common/object/asyncSignatureUrl": 31, "../common/object/copyObject": 32, "../common/object/delete": 33, "../common/object/deleteMulti": 34, "../common/object/deleteObjectTagging": 35, "../common/object/generateObjectUrl": 36, "../common/object/get": 37, "../common/object/getACL": 38, "../common/object/getBucketVersions": 39, "../common/object/getObjectMeta": 40, "../common/object/getObjectTagging": 41, "../common/object/getObjectUrl": 42, "../common/object/getSymlink": 43, "../common/object/head": 44, "../common/object/putACL": 45, "../common/object/putObjectTagging": 46, "../common/object/putSymlink": 47, "../common/object/signatureUrl": 48, "../common/utils/isBlob": 64, "../common/utils/isBuffer": 65, "../common/utils/isFile": 67, "../common/utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "copy-to": 94, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.number.constructor.js": 286, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339, "fs": 89, "merge-descriptors": 372, "mime": 374, "path": 378 }], 6: [function(require2, module2, exports2) {
        exports2.version = "6.18.1";
      }, {}], 7: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.abortBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function abortBucketWorm(_x, _x2) {
          return _abortBucketWorm.apply(this, arguments);
        }
        function _abortBucketWorm() {
          _abortBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name2);
                    params = this._bucketRequestParams("DELETE", name2, "worm", options);
                    _context.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, status: result.status });
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _abortBucketWorm.apply(this, arguments);
        }
        exports2.abortBucketWorm = abortBucketWorm;
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 8: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.completeBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function completeBucketWorm(_x, _x2, _x3) {
          return _completeBucketWorm.apply(this, arguments);
        }
        function _completeBucketWorm() {
          _completeBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, wormId, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name2);
                    params = this._bucketRequestParams("POST", name2, { wormId }, options);
                    _context.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, status: result.status });
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _completeBucketWorm.apply(this, arguments);
        }
        exports2.completeBucketWorm = completeBucketWorm;
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 9: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.deleteBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function deleteBucketInventory(_x, _x2) {
          return _deleteBucketInventory.apply(this, arguments);
        }
        function _deleteBucketInventory() {
          _deleteBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, inventoryId) {
            var options, subres, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    subres = Object.assign({ inventory: "", inventoryId }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    params = this._bucketRequestParams("DELETE", bucketName, subres, options);
                    params.successStatuses = [204];
                    _context.next = 7;
                    return this.request(params);
                  case 7:
                    result = _context.sent;
                    return _context.abrupt("return", { status: result.status, res: result.res });
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _deleteBucketInventory.apply(this, arguments);
        }
        exports2.deleteBucketInventory = deleteBucketInventory;
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 10: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports2;
        proto.deleteBucketLifecycle = /* @__PURE__ */ function() {
          var _deleteBucketLifecycle = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name2);
                    params = this._bucketRequestParams("DELETE", name2, "lifecycle", options);
                    params.successStatuses = [204];
                    _context.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function deleteBucketLifecycle(_x, _x2) {
            return _deleteBucketLifecycle.apply(this, arguments);
          }
          return deleteBucketLifecycle;
        }();
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 11: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports2;
        proto.deleteBucketWebsite = /* @__PURE__ */ function() {
          var _deleteBucketWebsite = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name2);
                    params = this._bucketRequestParams("DELETE", name2, "website", options);
                    params.successStatuses = [204];
                    _context.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function deleteBucketWebsite(_x, _x2) {
            return _deleteBucketWebsite.apply(this, arguments);
          }
          return deleteBucketWebsite;
        }();
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 12: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.extendBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var obj2xml_1 = require2("../utils/obj2xml");
        function extendBucketWorm(_x, _x2, _x3, _x4) {
          return _extendBucketWorm.apply(this, arguments);
        }
        function _extendBucketWorm() {
          _extendBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, wormId, days, options) {
            var params, paramlXMLObJ, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name2);
                    params = this._bucketRequestParams("POST", name2, { wormExtend: "", wormId }, options);
                    paramlXMLObJ = { ExtendWormConfiguration: { RetentionPeriodInDays: days } };
                    params.mime = "xml";
                    params.content = obj2xml_1.obj2xml(paramlXMLObJ, { headers: true });
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, status: result.status });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _extendBucketWorm.apply(this, arguments);
        }
        exports2.extendBucketWorm = extendBucketWorm;
      }, { "../utils/checkBucketName": 51, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 13: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.getBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var formatInventoryConfig_1 = require2("../utils/formatInventoryConfig");
        function getBucketInventory(_x, _x2) {
          return _getBucketInventory.apply(this, arguments);
        }
        function _getBucketInventory() {
          _getBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, inventoryId) {
            var options, subres, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    subres = Object.assign({ inventory: "", inventoryId }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    params = this._bucketRequestParams("GET", bucketName, subres, options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", { status: result.status, res: result.res, inventory: formatInventoryConfig_1.formatInventoryConfig(result.data) });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _getBucketInventory.apply(this, arguments);
        }
        exports2.getBucketInventory = getBucketInventory;
      }, { "../utils/checkBucketName": 51, "../utils/formatInventoryConfig": 60, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 14: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.map.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/isArray"), isArray2 = _require2.isArray;
        var _require3 = require2("../utils/formatObjKey"), formatObjKey = _require3.formatObjKey;
        var proto = exports2;
        proto.getBucketLifecycle = /* @__PURE__ */ function() {
          var _getBucketLifecycle = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result, rules;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name2);
                    params = this._bucketRequestParams("GET", name2, "lifecycle", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    rules = result.data.Rule || null;
                    if (rules) {
                      if (!isArray2(rules)) {
                        rules = [rules];
                      }
                      rules = rules.map(function(_2) {
                        if (_2.ID) {
                          _2.id = _2.ID;
                          delete _2.ID;
                        }
                        if (_2.Tag && !isArray2(_2.Tag)) {
                          _2.Tag = [_2.Tag];
                        }
                        return formatObjKey(_2, "firstLowerCase");
                      });
                    }
                    return _context.abrupt("return", { rules, res: result.res });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getBucketLifecycle(_x, _x2) {
            return _getBucketLifecycle.apply(this, arguments);
          }
          return getBucketLifecycle;
        }();
      }, { "../utils/checkBucketName": 51, "../utils/formatObjKey": 61, "../utils/isArray": 63, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.map.js": 280 }], 15: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports2;
        proto.getBucketVersioning = /* @__PURE__ */ function() {
          var _getBucketVersioning = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, options) {
            var params, result, versionStatus;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(bucketName);
                    params = this._bucketRequestParams("GET", bucketName, "versioning", options);
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    versionStatus = result.data.Status;
                    return _context.abrupt("return", { status: result.status, versionStatus, res: result.res });
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getBucketVersioning(_x, _x2) {
            return _getBucketVersioning.apply(this, arguments);
          }
          return getBucketVersioning;
        }();
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 16: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/isObject"), isObject2 = _require2.isObject;
        var proto = exports2;
        proto.getBucketWebsite = /* @__PURE__ */ function() {
          var _getBucketWebsite = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result, routingRules;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name2);
                    params = this._bucketRequestParams("GET", name2, "website", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    routingRules = [];
                    if (result.data.RoutingRules && result.data.RoutingRules.RoutingRule) {
                      if (isObject2(result.data.RoutingRules.RoutingRule)) {
                        routingRules = [result.data.RoutingRules.RoutingRule];
                      } else {
                        routingRules = result.data.RoutingRules.RoutingRule;
                      }
                    }
                    return _context.abrupt("return", { index: result.data.IndexDocument && result.data.IndexDocument.Suffix || "", supportSubDir: result.data.IndexDocument && result.data.IndexDocument.SupportSubDir || "false", type: result.data.IndexDocument && result.data.IndexDocument.Type, routingRules, error: result.data.ErrorDocument && result.data.ErrorDocument.Key || null, res: result.res });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getBucketWebsite(_x, _x2) {
            return _getBucketWebsite.apply(this, arguments);
          }
          return getBucketWebsite;
        }();
      }, { "../utils/checkBucketName": 51, "../utils/isObject": 70, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 17: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.getBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var dataFix_1 = require2("../utils/dataFix");
        function getBucketWorm(_x, _x2) {
          return _getBucketWorm.apply(this, arguments);
        }
        function _getBucketWorm() {
          _getBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name2);
                    params = this._bucketRequestParams("GET", name2, "worm", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    dataFix_1.dataFix(result.data, { lowerFirst: true, rename: { RetentionPeriodInDays: "days" } });
                    return _context.abrupt("return", Object.assign(Object.assign({}, result.data), { res: result.res, status: result.status }));
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _getBucketWorm.apply(this, arguments);
        }
        exports2.getBucketWorm = getBucketWorm;
      }, { "../utils/checkBucketName": 51, "../utils/dataFix": 57, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 18: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.initiateBucketWorm = void 0;
        var obj2xml_1 = require2("../utils/obj2xml");
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function initiateBucketWorm(_x, _x2, _x3) {
          return _initiateBucketWorm.apply(this, arguments);
        }
        function _initiateBucketWorm() {
          _initiateBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, days, options) {
            var params, paramlXMLObJ, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name2);
                    params = this._bucketRequestParams("POST", name2, "worm", options);
                    paramlXMLObJ = { InitiateWormConfiguration: { RetentionPeriodInDays: days } };
                    params.mime = "xml";
                    params.content = obj2xml_1.obj2xml(paramlXMLObJ, { headers: true });
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, wormId: result.res.headers["x-oss-worm-id"], status: result.status });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _initiateBucketWorm.apply(this, arguments);
        }
        exports2.initiateBucketWorm = initiateBucketWorm;
      }, { "../utils/checkBucketName": 51, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 19: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.listBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var formatInventoryConfig_1 = require2("../utils/formatInventoryConfig");
        function listBucketInventory(_x) {
          return _listBucketInventory.apply(this, arguments);
        }
        function _listBucketInventory() {
          _listBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName) {
            var options, continuationToken, subres, params, result, data, res, status, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    continuationToken = options.continuationToken;
                    subres = Object.assign({ inventory: "" }, continuationToken && { "continuation-token": continuationToken }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    params = this._bucketRequestParams("GET", bucketName, subres, options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context.sent;
                    data = result.data, res = result.res, status = result.status;
                    return _context.abrupt("return", { isTruncated: data.IsTruncated === "true", nextContinuationToken: data.NextContinuationToken, inventoryList: formatInventoryConfig_1.formatInventoryConfig(data.InventoryConfiguration, true), status, res });
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _listBucketInventory.apply(this, arguments);
        }
        exports2.listBucketInventory = listBucketInventory;
      }, { "../utils/checkBucketName": 51, "../utils/formatInventoryConfig": 60, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 20: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.concat.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.putBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var obj2xml_1 = require2("../utils/obj2xml");
        function putBucketInventory(_x, _x2) {
          return _putBucketInventory.apply(this, arguments);
        }
        function _putBucketInventory() {
          _putBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, inventory) {
            var options, subres, OSSBucketDestination, optionalFields, includedObjectVersions, destinationBucketPrefix, rolePrefix, paramXMLObj, paramXML, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    subres = Object.assign({ inventory: "", inventoryId: inventory.id }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    OSSBucketDestination = inventory.OSSBucketDestination, optionalFields = inventory.optionalFields, includedObjectVersions = inventory.includedObjectVersions;
                    destinationBucketPrefix = "acs:oss:::";
                    rolePrefix = "acs:ram::".concat(OSSBucketDestination.accountId, ":role/");
                    paramXMLObj = { InventoryConfiguration: { Id: inventory.id, IsEnabled: inventory.isEnabled, Filter: { Prefix: inventory.prefix || "" }, Destination: { OSSBucketDestination: { Format: OSSBucketDestination.format, AccountId: OSSBucketDestination.accountId, RoleArn: "".concat(rolePrefix).concat(OSSBucketDestination.rolename), Bucket: "".concat(destinationBucketPrefix).concat(OSSBucketDestination.bucket), Prefix: OSSBucketDestination.prefix || "", Encryption: OSSBucketDestination.encryption || "" } }, Schedule: { Frequency: inventory.frequency }, IncludedObjectVersions: includedObjectVersions, OptionalFields: { Field: (optionalFields === null || optionalFields === void 0 ? void 0 : optionalFields.field) || [] } } };
                    paramXML = obj2xml_1.obj2xml(paramXMLObj, { headers: true, firstUpperCase: true });
                    params = this._bucketRequestParams("PUT", bucketName, subres, options);
                    params.successStatuses = [200];
                    params.mime = "xml";
                    params.content = paramXML;
                    _context.next = 14;
                    return this.request(params);
                  case 14:
                    result = _context.sent;
                    return _context.abrupt("return", { status: result.status, res: result.res });
                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _putBucketInventory.apply(this, arguments);
        }
        exports2.putBucketInventory = putBucketInventory;
      }, { "../utils/checkBucketName": 51, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.object.assign.js": 287 }], 21: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.array.includes.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/isArray"), isArray2 = _require2.isArray;
        var _require3 = require2("../utils/deepCopy"), deepCopy = _require3.deepCopy;
        var _require4 = require2("../utils/isObject"), isObject2 = _require4.isObject;
        var _require5 = require2("../utils/obj2xml"), obj2xml = _require5.obj2xml;
        var _require6 = require2("../utils/checkObjectTag"), checkObjectTag = _require6.checkObjectTag;
        var _require7 = require2("../utils/getStrBytesCount"), getStrBytesCount = _require7.getStrBytesCount;
        var proto = exports2;
        proto.putBucketLifecycle = /* @__PURE__ */ function() {
          var _putBucketLifecycle = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, rules, options) {
            var params, Rule, paramXMLObj, paramXML, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name2);
                    if (isArray2(rules)) {
                      _context.next = 3;
                      break;
                    }
                    throw new Error("rules must be Array");
                  case 3:
                    params = this._bucketRequestParams("PUT", name2, "lifecycle", options);
                    Rule = [];
                    paramXMLObj = { LifecycleConfiguration: { Rule } };
                    rules.forEach(function(_2) {
                      defaultDaysAndDate2Expiration(_2);
                      checkRule(_2);
                      if (_2.id) {
                        _2.ID = _2.id;
                        delete _2.id;
                      }
                      Rule.push(_2);
                    });
                    paramXML = obj2xml(paramXMLObj, { headers: true, firstUpperCase: true });
                    params.content = paramXML;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putBucketLifecycle(_x, _x2, _x3) {
            return _putBucketLifecycle.apply(this, arguments);
          }
          return putBucketLifecycle;
        }();
        function defaultDaysAndDate2Expiration(obj) {
          if (obj.days) {
            obj.expiration = { days: obj.days };
          }
          if (obj.date) {
            obj.expiration = { createdBeforeDate: obj.date };
          }
        }
        function checkDaysAndDate(obj, key) {
          var days = obj.days, createdBeforeDate = obj.createdBeforeDate;
          if (!days && !createdBeforeDate) {
            throw new Error("".concat(key, " must includes days or createdBeforeDate"));
          } else if (days && !/^[1-9][0-9]*$/.test(days)) {
            throw new Error("days must be a positive integer");
          } else if (createdBeforeDate && !/\d{4}-\d{2}-\d{2}T00:00:00.000Z/.test(createdBeforeDate)) {
            throw new Error("createdBeforeDate must be date and conform to iso8601 format");
          }
        }
        function handleCheckTag(tag) {
          if (!isArray2(tag) && !isObject2(tag)) {
            throw new Error("tag must be Object or Array");
          }
          tag = isObject2(tag) ? [tag] : tag;
          var tagObj = {};
          var tagClone = deepCopy(tag);
          tagClone.forEach(function(v3) {
            tagObj[v3.key] = v3.value;
          });
          checkObjectTag(tagObj);
        }
        function checkRule(rule) {
          if (rule.id && getStrBytesCount(rule.id) > 255)
            throw new Error("ID is composed of 255 bytes at most");
          if (rule.prefix === void 0)
            throw new Error("Rule must includes prefix");
          if (!["Enabled", "Disabled"].includes(rule.status))
            throw new Error("Status must be  Enabled or Disabled");
          if (rule.transition) {
            if (!["IA", "Archive"].includes(rule.transition.storageClass))
              throw new Error("StorageClass must be  IA or Archive");
            checkDaysAndDate(rule.transition, "Transition");
          }
          if (rule.expiration) {
            if (!rule.expiration.expiredObjectDeleteMarker) {
              checkDaysAndDate(rule.expiration, "Expiration");
            } else if (rule.expiration.days || rule.expiration.createdBeforeDate) {
              throw new Error("expiredObjectDeleteMarker cannot be used with days or createdBeforeDate");
            }
          }
          if (rule.abortMultipartUpload) {
            checkDaysAndDate(rule.abortMultipartUpload, "AbortMultipartUpload");
          }
          if (!rule.expiration && !rule.abortMultipartUpload && !rule.transition && !rule.noncurrentVersionTransition) {
            throw new Error("Rule must includes expiration or abortMultipartUpload or transition or noncurrentVersionTransition");
          }
          if (rule.tag) {
            if (rule.abortMultipartUpload) {
              throw new Error("Tag cannot be used with abortMultipartUpload");
            }
            handleCheckTag(rule.tag);
          }
        }
      }, { "../utils/checkBucketName": 51, "../utils/checkObjectTag": 54, "../utils/deepCopy": 58, "../utils/getStrBytesCount": 62, "../utils/isArray": 63, "../utils/isObject": 70, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/web.dom-collections.for-each.js": 339 }], 22: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.includes.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/obj2xml"), obj2xml = _require2.obj2xml;
        var proto = exports2;
        proto.putBucketVersioning = /* @__PURE__ */ function() {
          var _putBucketVersioning = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, status) {
            var options, params, paramXMLObj, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    _checkBucketName(name2);
                    if (["Enabled", "Suspended"].includes(status)) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("status must be Enabled or Suspended");
                  case 4:
                    params = this._bucketRequestParams("PUT", name2, "versioning", options);
                    paramXMLObj = { VersioningConfiguration: { Status: status } };
                    params.mime = "xml";
                    params.content = obj2xml(paramXMLObj, { headers: true });
                    _context.next = 10;
                    return this.request(params);
                  case 10:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, status: result.status });
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putBucketVersioning(_x, _x2) {
            return _putBucketVersioning.apply(this, arguments);
          }
          return putBucketVersioning;
        }();
      }, { "../utils/checkBucketName": 51, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.includes.js": 277 }], 23: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/obj2xml"), obj2xml = _require2.obj2xml;
        var _require3 = require2("../utils/isArray"), isArray2 = _require3.isArray;
        var proto = exports2;
        proto.putBucketWebsite = /* @__PURE__ */ function() {
          var _putBucketWebsite = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var config, options, params, IndexDocument, WebsiteConfiguration, website, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    config = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options = _args.length > 2 ? _args[2] : void 0;
                    _checkBucketName(name2);
                    params = this._bucketRequestParams("PUT", name2, "website", options);
                    IndexDocument = { Suffix: config.index || "index.html" };
                    WebsiteConfiguration = { IndexDocument };
                    website = { WebsiteConfiguration };
                    if (config.supportSubDir) {
                      IndexDocument.SupportSubDir = config.supportSubDir;
                    }
                    if (config.type) {
                      IndexDocument.Type = config.type;
                    }
                    if (config.error) {
                      WebsiteConfiguration.ErrorDocument = { Key: config.error };
                    }
                    if (!(config.routingRules !== void 0)) {
                      _context.next = 14;
                      break;
                    }
                    if (isArray2(config.routingRules)) {
                      _context.next = 13;
                      break;
                    }
                    throw new Error("RoutingRules must be Array");
                  case 13:
                    WebsiteConfiguration.RoutingRules = { RoutingRule: config.routingRules };
                  case 14:
                    website = obj2xml(website);
                    params.content = website;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context.next = 20;
                    return this.request(params);
                  case 20:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 22:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putBucketWebsite(_x) {
            return _putBucketWebsite.apply(this, arguments);
          }
          return putBucketWebsite;
        }();
      }, { "../utils/checkBucketName": 51, "../utils/isArray": 63, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80 }], 24: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.keys.js");
            exports2.encodeCallback = function encodeCallback(reqParams, options) {
              reqParams.headers = reqParams.headers || {};
              if (!Object.prototype.hasOwnProperty.call(reqParams.headers, "x-oss-callback")) {
                if (options.callback) {
                  var json = { callbackUrl: encodeURI(options.callback.url), callbackBody: options.callback.body };
                  if (options.callback.host) {
                    json.callbackHost = options.callback.host;
                  }
                  if (options.callback.contentType) {
                    json.callbackBodyType = options.callback.contentType;
                  }
                  var callback = Buffer2.from(JSON.stringify(json)).toString("base64");
                  reqParams.headers["x-oss-callback"] = callback;
                  if (options.callback.customValue) {
                    var callbackVar = {};
                    Object.keys(options.callback.customValue).forEach(function(key) {
                      callbackVar["x:".concat(key)] = options.callback.customValue[key].toString();
                    });
                    reqParams.headers["x-oss-callback-var"] = Buffer2.from(JSON.stringify(callbackVar)).toString("base64");
                  }
                }
              }
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 90, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/web.dom-collections.for-each.js": 339 }], 25: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        var __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.getReqUrl = void 0;
        var copy_to_1 = __importDefault(require2("copy-to"));
        var url_1 = __importDefault(require2("url"));
        var merge_descriptors_1 = __importDefault(require2("merge-descriptors"));
        var is_type_of_1 = __importDefault(require2("is-type-of"));
        var isIP_1 = require2("../utils/isIP");
        var checkConfigValid_1 = require2("../utils/checkConfigValid");
        function getReqUrl(params) {
          var ep = {};
          var isCname = this.options.cname;
          checkConfigValid_1.checkConfigValid(this.options.endpoint, "endpoint");
          copy_to_1.default(this.options.endpoint, false).to(ep);
          if (params.bucket && !isCname && !isIP_1.isIP(ep.hostname) && !this.options.sldEnable) {
            ep.host = "".concat(params.bucket, ".").concat(ep.host);
          }
          var resourcePath = "/";
          if (params.bucket && this.options.sldEnable) {
            resourcePath += "".concat(params.bucket, "/");
          }
          if (params.object) {
            resourcePath += this._escape(params.object).replace(/\+/g, "%2B");
          }
          ep.pathname = resourcePath;
          var query = {};
          if (params.query) {
            merge_descriptors_1.default(query, params.query);
          }
          if (params.subres) {
            var subresAsQuery = {};
            if (is_type_of_1.default.string(params.subres)) {
              subresAsQuery[params.subres] = "";
            } else if (is_type_of_1.default.array(params.subres)) {
              params.subres.forEach(function(k2) {
                subresAsQuery[k2] = "";
              });
            } else {
              subresAsQuery = params.subres;
            }
            merge_descriptors_1.default(query, subresAsQuery);
          }
          ep.query = query;
          return url_1.default.format(ep);
        }
        exports2.getReqUrl = getReqUrl;
      }, { "../utils/checkConfigValid": 52, "../utils/isIP": 69, "copy-to": 94, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339, "is-type-of": 466, "merge-descriptors": 372, "url": 472 }], 26: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.string.trim.js");
        var ms = require2("humanize-ms");
        var urlutil = require2("url");
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/setRegion"), setRegion = _require2.setRegion;
        var _require3 = require2("../utils/checkConfigValid"), checkConfigValid = _require3.checkConfigValid;
        function setEndpoint(endpoint, secure) {
          checkConfigValid(endpoint, "endpoint");
          var url = urlutil.parse(endpoint);
          if (!url.protocol) {
            url = urlutil.parse("http".concat(secure ? "s" : "", "://").concat(endpoint));
          }
          if (url.protocol !== "http:" && url.protocol !== "https:") {
            throw new Error("Endpoint protocol must be http or https.");
          }
          return url;
        }
        module2.exports = function(options) {
          if (!options || !options.accessKeyId || !options.accessKeySecret) {
            throw new Error("require accessKeyId, accessKeySecret");
          }
          if (options.stsToken && !options.refreshSTSToken && !options.refreshSTSTokenInterval) {
            console.warn("It's recommended to set 'refreshSTSToken' and 'refreshSTSTokenInterval' to refresh stsToken、accessKeyId、accessKeySecret automatically when sts token has expired");
          }
          if (options.bucket) {
            _checkBucketName(options.bucket);
          }
          var opts = Object.assign({ region: "oss-cn-hangzhou", internal: false, secure: false, timeout: 6e4, bucket: null, endpoint: null, cname: false, isRequestPay: false, sldEnable: false, headerEncoding: "utf-8", refreshSTSToken: null, refreshSTSTokenInterval: 6e4 * 5, retryMax: 0 }, options);
          opts.accessKeyId = opts.accessKeyId.trim();
          opts.accessKeySecret = opts.accessKeySecret.trim();
          if (opts.timeout) {
            opts.timeout = ms(opts.timeout);
          }
          if (opts.endpoint) {
            opts.endpoint = setEndpoint(opts.endpoint, opts.secure);
          } else if (opts.region) {
            opts.endpoint = setRegion(opts.region, opts.internal, opts.secure);
          } else {
            throw new Error("require options.endpoint or options.region");
          }
          opts.inited = true;
          return opts;
        };
      }, { "../utils/checkBucketName": 51, "../utils/checkConfigValid": 52, "../utils/setRegion": 75, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.string.trim.js": 308, "humanize-ms": 356, "url": 472 }], 27: [function(require2, module2, exports2) {
        var merge2 = require2("merge-descriptors");
        var proto = exports2;
        merge2(proto, require2("./processObjectSave"));
      }, { "./processObjectSave": 28, "merge-descriptors": 372 }], 28: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.concat.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var querystring2 = require2("querystring");
        var _require2 = require2("js-base64"), str2Base64 = _require2.Base64.encode;
        var proto = exports2;
        proto.processObjectSave = /* @__PURE__ */ function() {
          var _processObjectSave = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(sourceObject, targetObject, process, targetBucket) {
            var params, bucketParam, content, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    checkArgs(sourceObject, "sourceObject");
                    checkArgs(targetObject, "targetObject");
                    checkArgs(process, "process");
                    targetObject = this._objectName(targetObject);
                    if (targetBucket) {
                      _checkBucketName(targetBucket);
                    }
                    params = this._objectRequestParams("POST", sourceObject, { subres: "x-oss-process" });
                    bucketParam = targetBucket ? ",b_".concat(str2Base64(targetBucket)) : "";
                    targetObject = str2Base64(targetObject);
                    content = { "x-oss-process": "".concat(process, "|sys/saveas,o_").concat(targetObject).concat(bucketParam) };
                    params.content = querystring2.stringify(content);
                    _context.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, status: result.res.status });
                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function processObjectSave(_x, _x2, _x3, _x4) {
            return _processObjectSave.apply(this, arguments);
          }
          return processObjectSave;
        }();
        function checkArgs(name2, key) {
          if (!name2) {
            throw new Error("".concat(key, " is required"));
          }
          if (typeof name2 !== "string") {
            throw new Error("".concat(key, " must be String"));
          }
        }
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.concat.js": 272, "js-base64": 371, "querystring": 385 }], 29: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.function.name.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.promise.js");
        require2("core-js/modules/es.array.from.js");
        require2("core-js/modules/es.string.iterator.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.array.filter.js");
        require2("core-js/modules/es.array.find.js");
        require2("core-js/modules/es.regexp.to-string.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var debug = require2("debug")("ali-oss:multipart-copy");
        var copy = require2("copy-to");
        var proto = exports2;
        proto.uploadPartCopy = /* @__PURE__ */ function() {
          var _uploadPartCopy = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, uploadId, partNo, range, sourceData) {
            var options, versionId, copySource, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 5 && _args[5] !== void 0 ? _args[5] : {};
                    options.headers = options.headers || {};
                    versionId = options.versionId || options.subres && options.subres.versionId || null;
                    if (versionId) {
                      copySource = "/".concat(sourceData.sourceBucketName, "/").concat(encodeURIComponent(sourceData.sourceKey), "?versionId=").concat(versionId);
                    } else {
                      copySource = "/".concat(sourceData.sourceBucketName, "/").concat(encodeURIComponent(sourceData.sourceKey));
                    }
                    options.headers["x-oss-copy-source"] = copySource;
                    if (range) {
                      options.headers["x-oss-copy-source-range"] = "bytes=".concat(range);
                    }
                    options.subres = { partNumber: partNo, uploadId };
                    params = this._objectRequestParams("PUT", name2, options);
                    params.mime = options.mime;
                    params.successStatuses = [200];
                    _context.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context.sent;
                    return _context.abrupt("return", { name: name2, etag: result.res.headers.etag, res: result.res });
                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function uploadPartCopy(_x, _x2, _x3, _x4, _x5) {
            return _uploadPartCopy.apply(this, arguments);
          }
          return uploadPartCopy;
        }();
        proto.multipartUploadCopy = /* @__PURE__ */ function() {
          var _multipartUploadCopy = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name2, sourceData) {
            var options, _options$versionId, versionId, metaOpt, objectMeta, fileSize, minPartSize, copySize, init, uploadId, partSize, checkpoint, _args2 = arguments;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    options = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : {};
                    this.resetCancelFlag();
                    _options$versionId = options.versionId, versionId = _options$versionId === void 0 ? null : _options$versionId;
                    metaOpt = { versionId };
                    _context2.next = 6;
                    return this._getObjectMeta(sourceData.sourceBucketName, sourceData.sourceKey, metaOpt);
                  case 6:
                    objectMeta = _context2.sent;
                    fileSize = objectMeta.res.headers["content-length"];
                    sourceData.startOffset = sourceData.startOffset || 0;
                    sourceData.endOffset = sourceData.endOffset || fileSize;
                    if (!(options.checkpoint && options.checkpoint.uploadId)) {
                      _context2.next = 14;
                      break;
                    }
                    _context2.next = 13;
                    return this._resumeMultipartCopy(options.checkpoint, sourceData, options);
                  case 13:
                    return _context2.abrupt("return", _context2.sent);
                  case 14:
                    minPartSize = 100 * 1024;
                    copySize = sourceData.endOffset - sourceData.startOffset;
                    if (!(copySize < minPartSize)) {
                      _context2.next = 18;
                      break;
                    }
                    throw new Error("copySize must not be smaller than ".concat(minPartSize));
                  case 18:
                    if (!(options.partSize && options.partSize < minPartSize)) {
                      _context2.next = 20;
                      break;
                    }
                    throw new Error("partSize must not be smaller than ".concat(minPartSize));
                  case 20:
                    _context2.next = 22;
                    return this.initMultipartUpload(name2, options);
                  case 22:
                    init = _context2.sent;
                    uploadId = init.uploadId;
                    partSize = this._getPartSize(copySize, options.partSize);
                    checkpoint = { name: name2, copySize, partSize, uploadId, doneParts: [] };
                    if (!(options && options.progress)) {
                      _context2.next = 29;
                      break;
                    }
                    _context2.next = 29;
                    return options.progress(0, checkpoint, init.res);
                  case 29:
                    _context2.next = 31;
                    return this._resumeMultipartCopy(checkpoint, sourceData, options);
                  case 31:
                    return _context2.abrupt("return", _context2.sent);
                  case 32:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function multipartUploadCopy(_x6, _x7) {
            return _multipartUploadCopy.apply(this, arguments);
          }
          return multipartUploadCopy;
        }();
        proto._resumeMultipartCopy = /* @__PURE__ */ function() {
          var _resumeMultipartCopy2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(checkpoint, sourceData, options) {
            var _options$versionId2, versionId, metaOpt, copySize, partSize, uploadId, doneParts, name2, partOffs, numParts, uploadPartCopyOptions, uploadPartJob, all2, done, todo, defaultParallel, parallel, i3, errors, abortEvent, err2;
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!this.isCancel()) {
                      _context4.next = 2;
                      break;
                    }
                    throw this._makeCancelEvent();
                  case 2:
                    _options$versionId2 = options.versionId, versionId = _options$versionId2 === void 0 ? null : _options$versionId2;
                    metaOpt = { versionId };
                    copySize = checkpoint.copySize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name2 = checkpoint.name;
                    partOffs = this._divideMultipartCopyParts(copySize, partSize, sourceData.startOffset);
                    numParts = partOffs.length;
                    uploadPartCopyOptions = { headers: {} };
                    if (options.copyheaders) {
                      copy(options.copyheaders).to(uploadPartCopyOptions.headers);
                    }
                    if (versionId) {
                      copy(metaOpt).to(uploadPartCopyOptions);
                    }
                    uploadPartJob = function uploadPartJob2(self2, partNo, source) {
                      return new Promise(/* @__PURE__ */ function() {
                        var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(resolve, reject) {
                          var pi, range, result;
                          return _regenerator.default.wrap(function _callee3$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  _context3.prev = 0;
                                  if (self2.isCancel()) {
                                    _context3.next = 22;
                                    break;
                                  }
                                  pi = partOffs[partNo - 1];
                                  range = "".concat(pi.start, "-").concat(pi.end - 1);
                                  _context3.prev = 4;
                                  _context3.next = 7;
                                  return self2.uploadPartCopy(name2, uploadId, partNo, range, source, uploadPartCopyOptions);
                                case 7:
                                  result = _context3.sent;
                                  _context3.next = 15;
                                  break;
                                case 10:
                                  _context3.prev = 10;
                                  _context3.t0 = _context3["catch"](4);
                                  if (!(_context3.t0.status === 404)) {
                                    _context3.next = 14;
                                    break;
                                  }
                                  throw self2._makeAbortEvent();
                                case 14:
                                  throw _context3.t0;
                                case 15:
                                  if (self2.isCancel()) {
                                    _context3.next = 22;
                                    break;
                                  }
                                  debug("content-range ".concat(result.res.headers["content-range"]));
                                  doneParts.push({ number: partNo, etag: result.res.headers.etag });
                                  checkpoint.doneParts = doneParts;
                                  if (!(options && options.progress)) {
                                    _context3.next = 22;
                                    break;
                                  }
                                  _context3.next = 22;
                                  return options.progress(doneParts.length / numParts, checkpoint, result.res);
                                case 22:
                                  resolve();
                                  _context3.next = 29;
                                  break;
                                case 25:
                                  _context3.prev = 25;
                                  _context3.t1 = _context3["catch"](0);
                                  _context3.t1.partNum = partNo;
                                  reject(_context3.t1);
                                case 29:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _callee3, null, [[0, 25], [4, 10]]);
                        }));
                        return function(_x11, _x12) {
                          return _ref.apply(this, arguments);
                        };
                      }());
                    };
                    all2 = Array.from(new Array(numParts), function(x2, i4) {
                      return i4 + 1;
                    });
                    done = doneParts.map(function(p2) {
                      return p2.number;
                    });
                    todo = all2.filter(function(p2) {
                      return done.indexOf(p2) < 0;
                    });
                    defaultParallel = 5;
                    parallel = options.parallel || defaultParallel;
                    if (!(this.checkBrowserAndVersion("Internet Explorer", "10") || parallel === 1)) {
                      _context4.next = 28;
                      break;
                    }
                    i3 = 0;
                  case 18:
                    if (!(i3 < todo.length)) {
                      _context4.next = 26;
                      break;
                    }
                    if (!this.isCancel()) {
                      _context4.next = 21;
                      break;
                    }
                    throw this._makeCancelEvent();
                  case 21:
                    _context4.next = 23;
                    return uploadPartJob(this, todo[i3], sourceData);
                  case 23:
                    i3++;
                    _context4.next = 18;
                    break;
                  case 26:
                    _context4.next = 40;
                    break;
                  case 28:
                    _context4.next = 30;
                    return this._parallelNode(todo, parallel, uploadPartJob, sourceData);
                  case 30:
                    errors = _context4.sent;
                    abortEvent = errors.find(function(err3) {
                      return err3.name === "abort";
                    });
                    if (!abortEvent) {
                      _context4.next = 34;
                      break;
                    }
                    throw abortEvent;
                  case 34:
                    if (!this.isCancel()) {
                      _context4.next = 36;
                      break;
                    }
                    throw this._makeCancelEvent();
                  case 36:
                    if (!(errors && errors.length > 0)) {
                      _context4.next = 40;
                      break;
                    }
                    err2 = errors[0];
                    err2.message = "Failed to copy some parts with error: ".concat(err2.toString(), " part_num: ").concat(err2.partNum);
                    throw err2;
                  case 40:
                    _context4.next = 42;
                    return this.completeMultipartUpload(name2, uploadId, doneParts, options);
                  case 42:
                    return _context4.abrupt("return", _context4.sent);
                  case 43:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function _resumeMultipartCopy(_x8, _x9, _x10) {
            return _resumeMultipartCopy2.apply(this, arguments);
          }
          return _resumeMultipartCopy;
        }();
        proto._divideMultipartCopyParts = function _divideMultipartCopyParts(fileSize, partSize, startOffset) {
          var numParts = Math.ceil(fileSize / partSize);
          var partOffs = [];
          for (var i3 = 0; i3 < numParts; i3++) {
            var start = partSize * i3 + startOffset;
            var end = Math.min(start + partSize, fileSize + startOffset);
            partOffs.push({ start, end });
          }
          return partOffs;
        };
        proto._getObjectMeta = /* @__PURE__ */ function() {
          var _getObjectMeta2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(bucket2, name2, options) {
            var currentBucket, data;
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    currentBucket = this.getBucket();
                    this.setBucket(bucket2);
                    _context5.next = 4;
                    return this.head(name2, options);
                  case 4:
                    data = _context5.sent;
                    this.setBucket(currentBucket);
                    return _context5.abrupt("return", data);
                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function _getObjectMeta(_x13, _x14, _x15) {
            return _getObjectMeta2.apply(this, arguments);
          }
          return _getObjectMeta;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "copy-to": 94, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.filter.js": 274, "core-js/modules/es.array.find.js": 275, "core-js/modules/es.array.from.js": 276, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.iterator.js": 303, "debug": 465 }], 30: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.array.filter.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.array.sort.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            var copy = require2("copy-to");
            var callback = require2("./callback");
            var _require = require2("./utils/deepCopy"), deepCopyWith = _require.deepCopyWith;
            var _require2 = require2("./utils/isBuffer"), isBuffer2 = _require2.isBuffer;
            var _require3 = require2("./utils/omit"), omit = _require3.omit;
            var proto = exports2;
            proto.listUploads = /* @__PURE__ */ function() {
              var _listUploads = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(query, options) {
                var opt, params, result, uploads;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.subres = "uploads";
                        params = this._objectRequestParams("GET", "", opt);
                        params.query = query;
                        params.xmlResponse = true;
                        params.successStatuses = [200];
                        _context.next = 10;
                        return this.request(params);
                      case 10:
                        result = _context.sent;
                        uploads = result.data.Upload || [];
                        if (!Array.isArray(uploads)) {
                          uploads = [uploads];
                        }
                        uploads = uploads.map(function(up) {
                          return { name: up.Key, uploadId: up.UploadId, initiated: up.Initiated };
                        });
                        return _context.abrupt("return", { res: result.res, uploads, bucket: result.data.Bucket, nextKeyMarker: result.data.NextKeyMarker, nextUploadIdMarker: result.data.NextUploadIdMarker, isTruncated: result.data.IsTruncated === "true" });
                      case 15:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));
              function listUploads(_x, _x2) {
                return _listUploads.apply(this, arguments);
              }
              return listUploads;
            }();
            proto.listParts = /* @__PURE__ */ function() {
              var _listParts = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name2, uploadId, query, options) {
                var opt, params, result;
                return _regenerator.default.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.subres = { uploadId };
                        params = this._objectRequestParams("GET", name2, opt);
                        params.query = query;
                        params.xmlResponse = true;
                        params.successStatuses = [200];
                        _context2.next = 10;
                        return this.request(params);
                      case 10:
                        result = _context2.sent;
                        return _context2.abrupt("return", { res: result.res, uploadId: result.data.UploadId, bucket: result.data.Bucket, name: result.data.Key, partNumberMarker: result.data.PartNumberMarker, nextPartNumberMarker: result.data.NextPartNumberMarker, maxParts: result.data.MaxParts, isTruncated: result.data.IsTruncated, parts: result.data.Part || [] });
                      case 12:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, this);
              }));
              function listParts(_x3, _x4, _x5, _x6) {
                return _listParts.apply(this, arguments);
              }
              return listParts;
            }();
            proto.abortMultipartUpload = /* @__PURE__ */ function() {
              var _abortMultipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(name2, uploadId, options) {
                var opt, params, result;
                return _regenerator.default.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        this._stop();
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.subres = { uploadId };
                        params = this._objectRequestParams("DELETE", name2, opt);
                        params.successStatuses = [204];
                        _context3.next = 9;
                        return this.request(params);
                      case 9:
                        result = _context3.sent;
                        return _context3.abrupt("return", { res: result.res });
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3, this);
              }));
              function abortMultipartUpload(_x7, _x8, _x9) {
                return _abortMultipartUpload.apply(this, arguments);
              }
              return abortMultipartUpload;
            }();
            proto.initMultipartUpload = /* @__PURE__ */ function() {
              var _initMultipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(name2, options) {
                var opt, params, result;
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.headers = opt.headers || {};
                        this._convertMetaToHeaders(options.meta, opt.headers);
                        opt.subres = "uploads";
                        params = this._objectRequestParams("POST", name2, opt);
                        params.mime = options.mime;
                        params.xmlResponse = true;
                        params.successStatuses = [200];
                        _context4.next = 12;
                        return this.request(params);
                      case 12:
                        result = _context4.sent;
                        return _context4.abrupt("return", { res: result.res, bucket: result.data.Bucket, name: result.data.Key, uploadId: result.data.UploadId });
                      case 14:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4, this);
              }));
              function initMultipartUpload(_x10, _x11) {
                return _initMultipartUpload.apply(this, arguments);
              }
              return initMultipartUpload;
            }();
            proto.uploadPart = /* @__PURE__ */ function() {
              var _uploadPart2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(name2, uploadId, partNo, file, start, end, options) {
                var data, isBrowserEnv;
                return _regenerator.default.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        data = { size: end - start };
                        isBrowserEnv = process && process.browser;
                        if (!isBrowserEnv) {
                          _context5.next = 8;
                          break;
                        }
                        _context5.next = 5;
                        return this._createBuffer(file, start, end);
                      case 5:
                        data.content = _context5.sent;
                        _context5.next = 11;
                        break;
                      case 8:
                        _context5.next = 10;
                        return this._createStream(file, start, end);
                      case 10:
                        data.stream = _context5.sent;
                      case 11:
                        _context5.next = 13;
                        return this._uploadPart(name2, uploadId, partNo, data, options);
                      case 13:
                        return _context5.abrupt("return", _context5.sent);
                      case 14:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5, this);
              }));
              function uploadPart(_x12, _x13, _x14, _x15, _x16, _x17, _x18) {
                return _uploadPart2.apply(this, arguments);
              }
              return uploadPart;
            }();
            proto.completeMultipartUpload = /* @__PURE__ */ function() {
              var _completeMultipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(name2, uploadId, parts, options) {
                var completeParts, xml2, i3, p2, opt, params, result, ret;
                return _regenerator.default.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        completeParts = parts.concat().sort(function(a2, b2) {
                          return a2.number - b2.number;
                        }).filter(function(item, index2, arr) {
                          return !index2 || item.number !== arr[index2 - 1].number;
                        });
                        xml2 = '<?xml version="1.0" encoding="UTF-8"?>\n<CompleteMultipartUpload>\n';
                        for (i3 = 0; i3 < completeParts.length; i3++) {
                          p2 = completeParts[i3];
                          xml2 += "<Part>\n";
                          xml2 += "<PartNumber>".concat(p2.number, "</PartNumber>\n");
                          xml2 += "<ETag>".concat(p2.etag, "</ETag>\n");
                          xml2 += "</Part>\n";
                        }
                        xml2 += "</CompleteMultipartUpload>";
                        options = options || {};
                        opt = {};
                        opt = deepCopyWith(options, function(_2) {
                          if (isBuffer2(_2))
                            return null;
                        });
                        opt.subres = { uploadId };
                        opt.headers = omit(opt.headers, ["x-oss-server-side-encryption", "x-oss-storage-class"]);
                        params = this._objectRequestParams("POST", name2, opt);
                        callback.encodeCallback(params, opt);
                        params.mime = "xml";
                        params.content = xml2;
                        if (!(params.headers && params.headers["x-oss-callback"])) {
                          params.xmlResponse = true;
                        }
                        params.successStatuses = [200];
                        _context6.next = 17;
                        return this.request(params);
                      case 17:
                        result = _context6.sent;
                        if (!options.progress) {
                          _context6.next = 21;
                          break;
                        }
                        _context6.next = 21;
                        return options.progress(1, null, result.res);
                      case 21:
                        ret = { res: result.res, bucket: params.bucket, name: name2, etag: result.res.headers.etag };
                        if (params.headers && params.headers["x-oss-callback"]) {
                          ret.data = JSON.parse(result.data.toString());
                        }
                        return _context6.abrupt("return", ret);
                      case 24:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6, this);
              }));
              function completeMultipartUpload(_x19, _x20, _x21, _x22) {
                return _completeMultipartUpload.apply(this, arguments);
              }
              return completeMultipartUpload;
            }();
            proto._uploadPart = /* @__PURE__ */ function() {
              var _uploadPart3 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name2, uploadId, partNo, data, options) {
                var opt, params, isBrowserEnv, result;
                return _regenerator.default.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.headers = opt.headers || {};
                        opt.headers["Content-Length"] = data.size;
                        opt.headers = omit(opt.headers, ["x-oss-server-side-encryption"]);
                        opt.subres = { partNumber: partNo, uploadId };
                        params = this._objectRequestParams("PUT", name2, opt);
                        params.mime = opt.mime;
                        isBrowserEnv = process && process.browser;
                        isBrowserEnv ? params.content = data.content : params.stream = data.stream;
                        params.successStatuses = [200];
                        params.disabledMD5 = options.disabledMD5;
                        _context7.next = 15;
                        return this.request(params);
                      case 15:
                        result = _context7.sent;
                        if (result.res.headers.etag) {
                          _context7.next = 18;
                          break;
                        }
                        throw new Error("Please set the etag of expose-headers in OSS \n https://help.aliyun.com/document_detail/32069.html");
                      case 18:
                        if (data.stream) {
                          data.stream = null;
                          params.stream = null;
                        }
                        return _context7.abrupt("return", { name: name2, etag: result.res.headers.etag, res: result.res });
                      case 20:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7, this);
              }));
              function _uploadPart(_x23, _x24, _x25, _x26, _x27) {
                return _uploadPart3.apply(this, arguments);
              }
              return _uploadPart;
            }();
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./callback": 24, "./utils/deepCopy": 58, "./utils/isBuffer": 65, "./utils/omit": 73, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "_process": 467, "copy-to": 94, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.filter.js": 274, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.array.sort.js": 282, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.to-string.js": 301 }], 31: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var urlutil = require2("url");
        var utility = require2("utility");
        var copy = require2("copy-to");
        var signHelper = require2("../../common/signUtils");
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var _require2 = require2("../utils/setSTSToken"), setSTSToken = _require2.setSTSToken;
        var _require3 = require2("../utils/isFunction"), isFunction2 = _require3.isFunction;
        var proto = exports2;
        proto.asyncSignatureUrl = /* @__PURE__ */ function() {
          var _asyncSignatureUrl = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var expires, params, resource, signRes, url;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!isIP(this.options.endpoint.hostname)) {
                      _context.next = 2;
                      break;
                    }
                    throw new Error("can not get the object URL when endpoint is IP");
                  case 2:
                    options = options || {};
                    name2 = this._objectName(name2);
                    options.method = options.method || "GET";
                    expires = utility.timestamp() + (options.expires || 1800);
                    params = { bucket: this.options.bucket, object: name2 };
                    resource = this._getResource(params);
                    if (!(this.options.stsToken && isFunction2(this.options.refreshSTSToken))) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 11;
                    return setSTSToken.call(this);
                  case 11:
                    if (this.options.stsToken) {
                      options["security-token"] = this.options.stsToken;
                    }
                    signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);
                    url = urlutil.parse(this._getReqUrl(params));
                    url.query = { OSSAccessKeyId: this.options.accessKeyId, Expires: expires, Signature: signRes.Signature };
                    copy(signRes.subResource).to(url.query);
                    return _context.abrupt("return", url.format());
                  case 17:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function asyncSignatureUrl(_x, _x2) {
            return _asyncSignatureUrl.apply(this, arguments);
          }
          return asyncSignatureUrl;
        }();
      }, { "../../common/signUtils": 50, "../utils/isFunction": 68, "../utils/isIP": 69, "../utils/setSTSToken": 76, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "copy-to": 94, "url": 472, "utility": 474 }], 32: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.find.js");
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports2;
        var REPLACE_HEDERS = ["content-type", "content-encoding", "content-language", "content-disposition", "cache-control", "expires"];
        proto.copy = /* @__PURE__ */ function() {
          var _copy = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, sourceName, bucketName, options) {
            var params, result, data;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if ((0, _typeof2.default)(bucketName) === "object") {
                      options = bucketName;
                    }
                    options = options || {};
                    options.headers = options.headers || {};
                    Object.keys(options.headers).forEach(function(key) {
                      options.headers["x-oss-copy-source-".concat(key.toLowerCase())] = options.headers[key];
                    });
                    if (options.meta || Object.keys(options.headers).find(function(_2) {
                      return REPLACE_HEDERS.includes(_2.toLowerCase());
                    })) {
                      options.headers["x-oss-metadata-directive"] = "REPLACE";
                    }
                    this._convertMetaToHeaders(options.meta, options.headers);
                    sourceName = this._getSourceName(sourceName, bucketName);
                    if (options.versionId) {
                      sourceName = "".concat(sourceName, "?versionId=").concat(options.versionId);
                    }
                    options.headers["x-oss-copy-source"] = sourceName;
                    params = this._objectRequestParams("PUT", name2, options);
                    params.xmlResponse = true;
                    params.successStatuses = [200, 304];
                    _context.next = 14;
                    return this.request(params);
                  case 14:
                    result = _context.sent;
                    data = result.data;
                    if (data) {
                      data = { etag: data.ETag, lastModified: data.LastModified };
                    }
                    return _context.abrupt("return", { data, res: result.res });
                  case 18:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function copy(_x, _x2, _x3, _x4) {
            return _copy.apply(this, arguments);
          }
          return copy;
        }();
        proto._getSourceName = function _getSourceName(sourceName, bucketName) {
          if (typeof bucketName === "string") {
            sourceName = this._objectName(sourceName);
          } else if (sourceName[0] !== "/") {
            bucketName = this.options.bucket;
          } else {
            bucketName = sourceName.replace(/\/(.+?)(\/.*)/, "$1");
            sourceName = sourceName.replace(/(\/.+?\/)(.*)/, "$2");
          }
          _checkBucketName(bucketName);
          sourceName = encodeURIComponent(sourceName);
          sourceName = "/".concat(bucketName, "/").concat(sourceName);
          return sourceName;
        };
      }, { "../utils/checkBucketName": 51, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.find.js": 275, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339 }], 33: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.delete = /* @__PURE__ */ function() {
          var _delete2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var options, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({}, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("DELETE", name2, options);
                    params.successStatuses = [204];
                    _context.next = 7;
                    return this.request(params);
                  case 7:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function _delete(_x) {
            return _delete2.apply(this, arguments);
          }
          return _delete;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 34: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var utility = require2("utility");
        var _require = require2("../utils/obj2xml"), obj2xml = _require.obj2xml;
        var proto = exports2;
        proto.deleteMulti = /* @__PURE__ */ function() {
          var _deleteMulti = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(names) {
            var options, objects, i3, object, _names$i, key, versionId, paramXMLObj, paramXML, params, result, r2, deleted, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    objects = [];
                    if (!(!names || !names.length)) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("names is required");
                  case 4:
                    for (i3 = 0; i3 < names.length; i3++) {
                      object = {};
                      if (typeof names[i3] === "string") {
                        object.Key = utility.escape(this._objectName(names[i3]));
                      } else {
                        _names$i = names[i3], key = _names$i.key, versionId = _names$i.versionId;
                        object.Key = utility.escape(this._objectName(key));
                        object.VersionId = versionId;
                      }
                      objects.push(object);
                    }
                    paramXMLObj = { Delete: { Quiet: !!options.quiet, Object: objects } };
                    paramXML = obj2xml(paramXMLObj, { headers: true });
                    options.subres = Object.assign({ delete: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("POST", "", options);
                    params.mime = "xml";
                    params.content = paramXML;
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context.next = 16;
                    return this.request(params);
                  case 16:
                    result = _context.sent;
                    r2 = result.data;
                    deleted = r2 && r2.Deleted || null;
                    if (deleted) {
                      if (!Array.isArray(deleted)) {
                        deleted = [deleted];
                      }
                    }
                    return _context.abrupt("return", { res: result.res, deleted: deleted || [] });
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function deleteMulti(_x) {
            return _deleteMulti.apply(this, arguments);
          }
          return deleteMulti;
        }();
      }, { "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287, "utility": 474 }], 35: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.deleteObjectTagging = /* @__PURE__ */ function() {
          var _deleteObjectTagging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var options, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({ tagging: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("DELETE", name2, options);
                    params.successStatuses = [204];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", { status: result.status, res: result.res });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function deleteObjectTagging(_x) {
            return _deleteObjectTagging.apply(this, arguments);
          }
          return deleteObjectTagging;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 36: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.concat.js");
        var urlutil = require2("url");
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var proto = exports2;
        proto.generateObjectUrl = function generateObjectUrl(name2, baseUrl) {
          if (isIP(this.options.endpoint.hostname)) {
            throw new Error("can not get the object URL when endpoint is IP");
          }
          if (!baseUrl) {
            baseUrl = this.options.endpoint.format();
            var copyUrl = urlutil.parse(baseUrl);
            var bucket2 = this.options.bucket;
            copyUrl.hostname = "".concat(bucket2, ".").concat(copyUrl.hostname);
            copyUrl.host = "".concat(bucket2, ".").concat(copyUrl.host);
            baseUrl = copyUrl.format();
          } else if (baseUrl[baseUrl.length - 1] !== "/") {
            baseUrl += "/";
          }
          return baseUrl + this._escape(this._objectName(name2));
        };
      }, { "../utils/isIP": 69, "core-js/modules/es.array.concat.js": 272, "url": 472 }], 37: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            require2("core-js/modules/es.object.assign.js");
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            var fs = require2("fs");
            var is = require2("is-type-of");
            var proto = exports2;
            proto.get = /* @__PURE__ */ function() {
              var _get = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, file) {
                var options, writeStream, needDestroy, isBrowserEnv, responseCacheControl, defaultSubresOptions, result, params, _args = arguments;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                        writeStream = null;
                        needDestroy = false;
                        if (is.writableStream(file)) {
                          writeStream = file;
                        } else if (is.string(file)) {
                          writeStream = fs.createWriteStream(file);
                          needDestroy = true;
                        } else {
                          options = file;
                        }
                        options = options || {};
                        isBrowserEnv = process && process.browser;
                        responseCacheControl = options.responseCacheControl === null ? "" : "no-cache";
                        defaultSubresOptions = isBrowserEnv && responseCacheControl ? { "response-cache-control": responseCacheControl } : {};
                        options.subres = Object.assign(defaultSubresOptions, options.subres);
                        if (options.versionId) {
                          options.subres.versionId = options.versionId;
                        }
                        if (options.process) {
                          options.subres["x-oss-process"] = options.process;
                        }
                        _context.prev = 11;
                        params = this._objectRequestParams("GET", name2, options);
                        params.writeStream = writeStream;
                        params.successStatuses = [200, 206, 304];
                        _context.next = 17;
                        return this.request(params);
                      case 17:
                        result = _context.sent;
                        if (needDestroy) {
                          writeStream.destroy();
                        }
                        _context.next = 28;
                        break;
                      case 21:
                        _context.prev = 21;
                        _context.t0 = _context["catch"](11);
                        if (!needDestroy) {
                          _context.next = 27;
                          break;
                        }
                        writeStream.destroy();
                        _context.next = 27;
                        return this._deleteFileSafe(file);
                      case 27:
                        throw _context.t0;
                      case 28:
                        return _context.abrupt("return", { res: result.res, content: result.data });
                      case 29:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this, [[11, 21]]);
              }));
              function get(_x, _x2) {
                return _get.apply(this, arguments);
              }
              return get;
            }();
          }).call(this);
        }).call(this, require2("_process"));
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "_process": 467, "core-js/modules/es.object.assign.js": 287, "fs": 89, "is-type-of": 466 }], 38: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.getACL = /* @__PURE__ */ function() {
          var _getACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var options, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({ acl: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("GET", name2, options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context.sent;
                    return _context.abrupt("return", { acl: result.data.AccessControlList.Grant, owner: { id: result.data.Owner.ID, displayName: result.data.Owner.DisplayName }, res: result.res });
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getACL(_x) {
            return _getACL.apply(this, arguments);
          }
          return getACL;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 39: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.number.constructor.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        var _require = require2("../utils/isObject"), isObject2 = _require.isObject;
        var _require2 = require2("../utils/isArray"), isArray2 = _require2.isArray;
        proto.getBucketVersions = getBucketVersions;
        proto.listObjectVersions = getBucketVersions;
        function getBucketVersions() {
          return _getBucketVersions.apply(this, arguments);
        }
        function _getBucketVersions() {
          _getBucketVersions = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee() {
            var query, options, params, result, objects, deleteMarker, that, prefixes, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    query = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    if (!(query.versionIdMarker && query.keyMarker === void 0)) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("A version-id marker cannot be specified without a key marker");
                  case 4:
                    options.subres = Object.assign({ versions: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("GET", "", options);
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    params.query = formatQuery(query);
                    _context.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context.sent;
                    objects = result.data.Version || [];
                    deleteMarker = result.data.DeleteMarker || [];
                    that = this;
                    if (objects) {
                      if (!Array.isArray(objects)) {
                        objects = [objects];
                      }
                      objects = objects.map(function(obj) {
                        return { name: obj.Key, url: that._objectUrl(obj.Key), lastModified: obj.LastModified, isLatest: obj.IsLatest === "true", versionId: obj.VersionId, etag: obj.ETag, type: obj.Type, size: Number(obj.Size), storageClass: obj.StorageClass, owner: { id: obj.Owner.ID, displayName: obj.Owner.DisplayName } };
                      });
                    }
                    if (deleteMarker) {
                      if (!isArray2(deleteMarker)) {
                        deleteMarker = [deleteMarker];
                      }
                      deleteMarker = deleteMarker.map(function(obj) {
                        return { name: obj.Key, lastModified: obj.LastModified, versionId: obj.VersionId, owner: { id: obj.Owner.ID, displayName: obj.Owner.DisplayName } };
                      });
                    }
                    prefixes = result.data.CommonPrefixes || null;
                    if (prefixes) {
                      if (!isArray2(prefixes)) {
                        prefixes = [prefixes];
                      }
                      prefixes = prefixes.map(function(item) {
                        return item.Prefix;
                      });
                    }
                    return _context.abrupt("return", {
                      res: result.res,
                      objects,
                      deleteMarker,
                      prefixes,
                      // attirbute of legacy error
                      nextMarker: result.data.NextKeyMarker || null,
                      // attirbute of legacy error
                      NextVersionIdMarker: result.data.NextVersionIdMarker || null,
                      nextKeyMarker: result.data.NextKeyMarker || null,
                      nextVersionIdMarker: result.data.NextVersionIdMarker || null,
                      isTruncated: result.data.IsTruncated === "true"
                    });
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _getBucketVersions.apply(this, arguments);
        }
        function camel2Line(name2) {
          return name2.replace(/([A-Z])/g, "-$1").toLowerCase();
        }
        function formatQuery() {
          var query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var obj = {};
          if (isObject2(query)) {
            Object.keys(query).forEach(function(key) {
              obj[camel2Line(key)] = query[key];
            });
          }
          return obj;
        }
      }, { "../utils/isArray": 63, "../utils/isObject": 70, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.number.constructor.js": 286, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339 }], 40: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.getObjectMeta = /* @__PURE__ */ function() {
          var _getObjectMeta = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    name2 = this._objectName(name2);
                    options.subres = Object.assign({ objectMeta: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("HEAD", name2, options);
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", { status: result.status, res: result.res });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getObjectMeta(_x, _x2) {
            return _getObjectMeta.apply(this, arguments);
          }
          return getObjectMeta;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 41: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        var _require = require2("../utils/isObject"), isObject2 = _require.isObject;
        proto.getObjectTagging = /* @__PURE__ */ function() {
          var _getObjectTagging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var options, params, result, Tagging, Tag, tag, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({ tagging: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("GET", name2, options);
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    _context.next = 11;
                    return this.parseXML(result.data);
                  case 11:
                    Tagging = _context.sent;
                    Tag = Tagging.TagSet.Tag;
                    Tag = Tag && isObject2(Tag) ? [Tag] : Tag || [];
                    tag = {};
                    Tag.forEach(function(item) {
                      tag[item.Key] = item.Value;
                    });
                    return _context.abrupt("return", { status: result.status, res: result.res, tag });
                  case 17:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getObjectTagging(_x) {
            return _getObjectTagging.apply(this, arguments);
          }
          return getObjectTagging;
        }();
      }, { "../utils/isObject": 70, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/web.dom-collections.for-each.js": 339 }], 42: [function(require2, module2, exports2) {
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var proto = exports2;
        proto.getObjectUrl = function getObjectUrl(name2, baseUrl) {
          if (isIP(this.options.endpoint.hostname)) {
            throw new Error("can not get the object URL when endpoint is IP");
          }
          if (!baseUrl) {
            baseUrl = this.options.endpoint.format();
          } else if (baseUrl[baseUrl.length - 1] !== "/") {
            baseUrl += "/";
          }
          return baseUrl + this._escape(this._objectName(name2));
        };
      }, { "../utils/isIP": 69 }], 43: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.getSymlink = /* @__PURE__ */ function() {
          var _getSymlink = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var options, params, result, target, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({ symlink: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("GET", name2, options);
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    target = result.res.headers["x-oss-symlink-target"];
                    return _context.abrupt("return", { targetName: decodeURIComponent(target), res: result.res });
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getSymlink(_x) {
            return _getSymlink.apply(this, arguments);
          }
          return getSymlink;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 44: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkEnv"), checkEnv = _require.checkEnv;
        var proto = exports2;
        proto.head = /* @__PURE__ */ function() {
          var _head = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2) {
            var options, params, result, data, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    checkEnv("Because HeadObject has gzip enabled, head cannot get the file size correctly. If you need to get the file size, please use getObjectMeta");
                    options.subres = Object.assign({}, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("HEAD", name2, options);
                    params.successStatuses = [200, 304];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    data = { meta: null, res: result.res, status: result.status };
                    if (result.status === 200) {
                      Object.keys(result.headers).forEach(function(k2) {
                        if (k2.indexOf("x-oss-meta-") === 0) {
                          if (!data.meta) {
                            data.meta = {};
                          }
                          data.meta[k2.substring(11)] = result.headers[k2];
                        }
                      });
                    }
                    return _context.abrupt("return", data);
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function head(_x) {
            return _head.apply(this, arguments);
          }
          return head;
        }();
      }, { "../utils/checkEnv": 53, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/web.dom-collections.for-each.js": 339 }], 45: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.putACL = /* @__PURE__ */ function() {
          var _putACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, acl, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    options.subres = Object.assign({ acl: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    options.headers = options.headers || {};
                    options.headers["x-oss-object-acl"] = acl;
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("PUT", name2, options);
                    params.successStatuses = [200];
                    _context.next = 10;
                    return this.request(params);
                  case 10:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putACL(_x, _x2, _x3) {
            return _putACL.apply(this, arguments);
          }
          return putACL;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 46: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.object.keys.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/obj2xml"), obj2xml = _require.obj2xml;
        var _require2 = require2("../utils/checkObjectTag"), checkObjectTag = _require2.checkObjectTag;
        var proto = exports2;
        proto.putObjectTagging = /* @__PURE__ */ function() {
          var _putObjectTagging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, tag) {
            var options, params, paramXMLObj, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    checkObjectTag(tag);
                    options.subres = Object.assign({ tagging: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("PUT", name2, options);
                    params.successStatuses = [200];
                    tag = Object.keys(tag).map(function(key) {
                      return { Key: key, Value: tag[key] };
                    });
                    paramXMLObj = { Tagging: { TagSet: { Tag: tag } } };
                    params.mime = "xml";
                    params.content = obj2xml(paramXMLObj);
                    _context.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res, status: result.status });
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putObjectTagging(_x, _x2) {
            return _putObjectTagging.apply(this, arguments);
          }
          return putObjectTagging;
        }();
      }, { "../utils/checkObjectTag": 54, "../utils/obj2xml": 72, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.keys.js": 290 }], 47: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports2;
        proto.putSymlink = /* @__PURE__ */ function() {
          var _putSymlink = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name2, targetName, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    options.headers = options.headers || {};
                    targetName = this._escape(this._objectName(targetName));
                    this._convertMetaToHeaders(options.meta, options.headers);
                    options.headers["x-oss-symlink-target"] = targetName;
                    options.subres = Object.assign({ symlink: "" }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    if (options.storageClass) {
                      options.headers["x-oss-storage-class"] = options.storageClass;
                    }
                    name2 = this._objectName(name2);
                    params = this._objectRequestParams("PUT", name2, options);
                    params.successStatuses = [200];
                    _context.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context.sent;
                    return _context.abrupt("return", { res: result.res });
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putSymlink(_x, _x2, _x3) {
            return _putSymlink.apply(this, arguments);
          }
          return putSymlink;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.object.assign.js": 287 }], 48: [function(require2, module2, exports2) {
        var urlutil = require2("url");
        var utility = require2("utility");
        var copy = require2("copy-to");
        var signHelper = require2("../../common/signUtils");
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var proto = exports2;
        proto.signatureUrl = function signatureUrl(name2, options) {
          if (isIP(this.options.endpoint.hostname)) {
            throw new Error("can not get the object URL when endpoint is IP");
          }
          options = options || {};
          name2 = this._objectName(name2);
          options.method = options.method || "GET";
          var expires = utility.timestamp() + (options.expires || 1800);
          var params = { bucket: this.options.bucket, object: name2 };
          var resource = this._getResource(params);
          if (this.options.stsToken) {
            options["security-token"] = this.options.stsToken;
          }
          var signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);
          var url = urlutil.parse(this._getReqUrl(params));
          url.query = { OSSAccessKeyId: this.options.accessKeyId, Expires: expires, Signature: signRes.Signature };
          copy(signRes.subResource).to(url.query);
          return url.format();
        };
      }, { "../../common/signUtils": 50, "../utils/isIP": 69, "copy-to": 94, "url": 472, "utility": 474 }], 49: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.iterator.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.promise.js");
        require2("core-js/modules/es.string.iterator.js");
        require2("core-js/modules/web.dom-collections.iterator.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.function.name.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("./utils/isArray"), isArray2 = _require.isArray;
        var proto = exports2;
        proto._parallelNode = /* @__PURE__ */ function() {
          var _parallelNode2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(todo, parallel, fn, sourceData) {
            var that, jobErr, jobs, tempBatch, remainder, batch, taskIndex, i3;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    that = this;
                    jobErr = [];
                    jobs = [];
                    tempBatch = todo.length / parallel;
                    remainder = todo.length % parallel;
                    batch = remainder === 0 ? tempBatch : (todo.length - remainder) / parallel + 1;
                    taskIndex = 1;
                    i3 = 0;
                  case 8:
                    if (!(i3 < todo.length)) {
                      _context.next = 26;
                      break;
                    }
                    if (!that.isCancel()) {
                      _context.next = 11;
                      break;
                    }
                    return _context.abrupt("break", 26);
                  case 11:
                    if (sourceData) {
                      jobs.push(fn(that, todo[i3], sourceData));
                    } else {
                      jobs.push(fn(that, todo[i3]));
                    }
                    if (!(jobs.length === parallel || taskIndex === batch && i3 === todo.length - 1)) {
                      _context.next = 23;
                      break;
                    }
                    _context.prev = 13;
                    taskIndex += 1;
                    _context.next = 17;
                    return Promise.all(jobs);
                  case 17:
                    _context.next = 22;
                    break;
                  case 19:
                    _context.prev = 19;
                    _context.t0 = _context["catch"](13);
                    jobErr.push(_context.t0);
                  case 22:
                    jobs = [];
                  case 23:
                    i3++;
                    _context.next = 8;
                    break;
                  case 26:
                    return _context.abrupt("return", jobErr);
                  case 27:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[13, 19]]);
          }));
          function _parallelNode(_x, _x2, _x3, _x4) {
            return _parallelNode2.apply(this, arguments);
          }
          return _parallelNode;
        }();
        proto._parallel = function _parallel(todo, parallel, jobPromise) {
          var that = this;
          return new Promise(function(resolve) {
            var _jobErr = [];
            if (parallel <= 0 || !todo) {
              resolve(_jobErr);
              return;
            }
            function onlyOnce(fn) {
              return function() {
                if (fn === null)
                  throw new Error("Callback was already called.");
                var callFn = fn;
                fn = null;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                callFn.apply(this, args);
              };
            }
            function createArrayIterator(coll) {
              var i3 = -1;
              var len = coll.length;
              return function next() {
                return ++i3 < len && !that.isCancel() ? { value: coll[i3], key: i3 } : null;
              };
            }
            var nextElem = createArrayIterator(todo);
            var done = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err2) {
              running -= 1;
              if (err2) {
                done = true;
                _jobErr.push(err2);
                resolve(_jobErr);
              } else if (done && running <= 0) {
                done = true;
                resolve(_jobErr);
              } else if (!looping) {
                if (that.isCancel()) {
                  resolve(_jobErr);
                } else {
                  replenish();
                }
              }
            }
            function iteratee(value, callback) {
              jobPromise(value).then(function(result) {
                callback(null, result);
              }).catch(function(err2) {
                callback(err2);
              });
            }
            function replenish() {
              looping = true;
              while (running < parallel && !done && !that.isCancel()) {
                var elem = nextElem();
                if (elem === null || _jobErr.length > 0) {
                  done = true;
                  if (running <= 0) {
                    resolve(_jobErr);
                  }
                  return;
                }
                running += 1;
                iteratee(elem.value, onlyOnce(iterateeCallback));
              }
              looping = false;
            }
            replenish();
          });
        };
        proto.cancel = function cancel(abort) {
          this.options.cancelFlag = true;
          if (isArray2(this.multipartUploadStreams)) {
            this.multipartUploadStreams.forEach(function(_2) {
              if (_2.destroyed === false) {
                var err2 = { name: "cancel", message: "cancel" };
                _2.destroy(err2);
              }
            });
          }
          this.multipartUploadStreams = [];
          if (abort) {
            this.abortMultipartUpload(abort.name, abort.uploadId, abort.options);
          }
        };
        proto.isCancel = function isCancel2() {
          return this.options.cancelFlag;
        };
        proto.resetCancelFlag = function resetCancelFlag() {
          this.options.cancelFlag = false;
        };
        proto._stop = function _stop() {
          this.options.cancelFlag = true;
        };
        proto._makeCancelEvent = function _makeCancelEvent() {
          var cancelEvent = { status: 0, name: "cancel" };
          return cancelEvent;
        };
        proto._makeAbortEvent = function _makeAbortEvent() {
          var abortEvent = { status: 0, name: "abort", message: "upload task has been abort" };
          return abortEvent;
        };
      }, { "./utils/isArray": 63, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.iterator.js": 278, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.string.iterator.js": 303, "core-js/modules/web.dom-collections.for-each.js": 339, "core-js/modules/web.dom-collections.iterator.js": 340 }], 50: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.string.trim.js");
            require2("core-js/modules/es.array.sort.js");
            require2("core-js/modules/es.array.join.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.keys.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var crypto = require2("./../../shims/crypto/crypto.js");
            var is = require2("is-type-of");
            var _require = require2("./utils/lowercaseKeyHeader"), lowercaseKeyHeader = _require.lowercaseKeyHeader;
            exports2.buildCanonicalizedResource = function buildCanonicalizedResource(resourcePath, parameters) {
              var canonicalizedResource = "".concat(resourcePath);
              var separatorString = "?";
              if (is.string(parameters) && parameters.trim() !== "") {
                canonicalizedResource += separatorString + parameters;
              } else if (is.array(parameters)) {
                parameters.sort();
                canonicalizedResource += separatorString + parameters.join("&");
              } else if (parameters) {
                var compareFunc = function compareFunc2(entry1, entry2) {
                  if (entry1[0] > entry2[0]) {
                    return 1;
                  } else if (entry1[0] < entry2[0]) {
                    return -1;
                  }
                  return 0;
                };
                var processFunc = function processFunc2(key) {
                  canonicalizedResource += separatorString + key;
                  if (parameters[key] || parameters[key] === 0) {
                    canonicalizedResource += "=".concat(parameters[key]);
                  }
                  separatorString = "&";
                };
                Object.keys(parameters).sort(compareFunc).forEach(processFunc);
              }
              return canonicalizedResource;
            };
            exports2.buildCanonicalString = function canonicalString(method, resourcePath, request, expires) {
              request = request || {};
              var headers = lowercaseKeyHeader(request.headers);
              var OSS_PREFIX = "x-oss-";
              var ossHeaders = [];
              var headersToSign = {};
              var signContent = [method.toUpperCase(), headers["content-md5"] || "", headers["content-type"], expires || headers["x-oss-date"]];
              Object.keys(headers).forEach(function(key) {
                var lowerKey = key.toLowerCase();
                if (lowerKey.indexOf(OSS_PREFIX) === 0) {
                  headersToSign[lowerKey] = String(headers[key]).trim();
                }
              });
              Object.keys(headersToSign).sort().forEach(function(key) {
                ossHeaders.push("".concat(key, ":").concat(headersToSign[key]));
              });
              signContent = signContent.concat(ossHeaders);
              signContent.push(this.buildCanonicalizedResource(resourcePath, request.parameters));
              return signContent.join("\n");
            };
            exports2.computeSignature = function computeSignature(accessKeySecret, canonicalString) {
              var headerEncoding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "utf-8";
              var signature = crypto.createHmac("sha1", accessKeySecret);
              return signature.update(Buffer2.from(canonicalString, headerEncoding)).digest("base64");
            };
            exports2.authorization = function authorization(accessKeyId, accessKeySecret, canonicalString, headerEncoding) {
              return "OSS ".concat(accessKeyId, ":").concat(this.computeSignature(accessKeySecret, canonicalString, headerEncoding));
            };
            exports2._signatureForURL = function _signatureForURL(accessKeySecret) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var resource = arguments.length > 2 ? arguments[2] : void 0;
              var expires = arguments.length > 3 ? arguments[3] : void 0;
              var headerEncoding = arguments.length > 4 ? arguments[4] : void 0;
              var headers = {};
              var _options$subResource = options.subResource, subResource = _options$subResource === void 0 ? {} : _options$subResource;
              if (options.process) {
                var processKeyword = "x-oss-process";
                subResource[processKeyword] = options.process;
              }
              if (options.trafficLimit) {
                var trafficLimitKey = "x-oss-traffic-limit";
                subResource[trafficLimitKey] = options.trafficLimit;
              }
              if (options.response) {
                Object.keys(options.response).forEach(function(k2) {
                  var key = "response-".concat(k2.toLowerCase());
                  subResource[key] = options.response[k2];
                });
              }
              Object.keys(options).forEach(function(key) {
                var lowerKey = key.toLowerCase();
                var value = options[key];
                if (lowerKey.indexOf("x-oss-") === 0) {
                  headers[lowerKey] = value;
                } else if (lowerKey.indexOf("content-md5") === 0) {
                  headers[key] = value;
                } else if (lowerKey.indexOf("content-type") === 0) {
                  headers[key] = value;
                }
              });
              if (Object.prototype.hasOwnProperty.call(options, "security-token")) {
                subResource["security-token"] = options["security-token"];
              }
              if (Object.prototype.hasOwnProperty.call(options, "callback")) {
                var json = { callbackUrl: encodeURI(options.callback.url), callbackBody: options.callback.body };
                if (options.callback.host) {
                  json.callbackHost = options.callback.host;
                }
                if (options.callback.contentType) {
                  json.callbackBodyType = options.callback.contentType;
                }
                subResource.callback = Buffer2.from(JSON.stringify(json)).toString("base64");
                if (options.callback.customValue) {
                  var callbackVar = {};
                  Object.keys(options.callback.customValue).forEach(function(key) {
                    callbackVar["x:".concat(key)] = options.callback.customValue[key];
                  });
                  subResource["callback-var"] = Buffer2.from(JSON.stringify(callbackVar)).toString("base64");
                }
              }
              var canonicalString = this.buildCanonicalString(options.method, resource, { headers, parameters: subResource }, expires.toString());
              return { Signature: this.computeSignature(accessKeySecret, canonicalString, headerEncoding), subResource };
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "./../../shims/crypto/crypto.js": 461, "./utils/lowercaseKeyHeader": 71, "buffer": 90, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.join.js": 279, "core-js/modules/es.array.sort.js": 282, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.trim.js": 308, "core-js/modules/web.dom-collections.for-each.js": 339, "is-type-of": 466 }], 51: [function(require2, module2, exports2) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.checkBucketName = void 0;
        exports2.checkBucketName = function(name2) {
          var createBucket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var bucketRegex = createBucket ? /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/ : /^[a-z0-9_][a-z0-9-_]{1,61}[a-z0-9_]$/;
          if (!bucketRegex.test(name2)) {
            throw new Error("The bucket must be conform to the specifications");
          }
        };
      }, { "core-js/modules/es.regexp.exec.js": 300 }], 52: [function(require2, module2, exports2) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.checkConfigValid = void 0;
        var checkConfigMap = { endpoint: checkEndpoint, region: /^[a-zA-Z0-9\-_]+$/ };
        function checkEndpoint(endpoint) {
          if (typeof endpoint === "string") {
            return /^[a-zA-Z0-9._:/-]+$/.test(endpoint);
          } else if (endpoint.host) {
            return /^[a-zA-Z0-9._:/-]+$/.test(endpoint.host);
          }
          return false;
        }
        exports2.checkConfigValid = function(conf, key) {
          if (checkConfigMap[key]) {
            var isConfigValid = true;
            if (checkConfigMap[key] instanceof Function) {
              isConfigValid = checkConfigMap[key](conf);
            } else {
              isConfigValid = checkConfigMap[key].test(conf);
            }
            if (!isConfigValid) {
              throw new Error("The ".concat(key, " must be conform to the specifications"));
            }
          }
        };
      }, { "core-js/modules/es.regexp.exec.js": 300 }], 53: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.checkEnv = void 0;
            function checkEnv(msg) {
              if (process.browser) {
                console.warn(msg);
              }
            }
            exports2.checkEnv = checkEnv;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 467 }], 54: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.object.entries.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.checkObjectTag = void 0;
        var _require = require2("./checkValid"), checkValid = _require.checkValid;
        var _require2 = require2("./isObject"), isObject2 = _require2.isObject;
        var commonRules = [{ validator: function validator2(value) {
          if (typeof value !== "string") {
            throw new Error("the key and value of the tag must be String");
          }
        } }, { pattern: /^[a-zA-Z0-9 +-=._:/]+$/, msg: "tag can contain letters, numbers, spaces, and the following symbols: plus sign (+), hyphen (-), equal sign (=), period (.), underscore (_), colon (:), and forward slash (/)" }];
        var rules = { key: [].concat(commonRules, [{ pattern: /^.{1,128}$/, msg: "tag key can be a maximum of 128 bytes in length" }]), value: [].concat(commonRules, [{ pattern: /^.{0,256}$/, msg: "tag value can be a maximum of 256 bytes in length" }]) };
        function checkObjectTag(tag) {
          if (!isObject2(tag)) {
            throw new Error("tag must be Object");
          }
          var entries2 = Object.entries(tag);
          if (entries2.length > 10) {
            throw new Error("maximum of 10 tags for a object");
          }
          var rulesIndexKey = ["key", "value"];
          entries2.forEach(function(keyValue) {
            keyValue.forEach(function(item, index2) {
              checkValid(item, rules[rulesIndexKey[index2]]);
            });
          });
        }
        exports2.checkObjectTag = checkObjectTag;
      }, { "./checkValid": 55, "./isObject": 70, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.object.entries.js": 288, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/web.dom-collections.for-each.js": 339 }], 55: [function(require2, module2, exports2) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.checkValid = void 0;
        function checkValid(_value, _rules) {
          _rules.forEach(function(rule) {
            if (rule.validator) {
              rule.validator(_value);
            } else if (rule.pattern && !rule.pattern.test(_value)) {
              throw new Error(rule.msg);
            }
          });
        }
        exports2.checkValid = checkValid;
      }, { "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/web.dom-collections.for-each.js": 339 }], 56: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.array.includes.js");
            require2("core-js/modules/es.string.includes.js");
            require2("core-js/modules/es.object.assign.js");
            require2("core-js/modules/es.array.concat.js");
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.createRequest = void 0;
            var crypto = require2("./../../../shims/crypto/crypto.js");
            var debug = require2("debug")("ali-oss");
            var mime = require2("mime");
            var dateFormat2 = require2("dateformat");
            var copy = require2("copy-to");
            var path = require2("path");
            var _require = require2("./encoder"), encoder = _require.encoder;
            var _require2 = require2("./isIP"), isIP = _require2.isIP;
            var _require3 = require2("./setRegion"), setRegion = _require3.setRegion;
            var _require4 = require2("../client/getReqUrl"), getReqUrl = _require4.getReqUrl;
            var _require5 = require2("./isDingTalk"), isDingTalk = _require5.isDingTalk;
            function getHeader(headers, name2) {
              return headers[name2] || headers[name2.toLowerCase()];
            }
            function delHeader(headers, name2) {
              delete headers[name2];
              delete headers[name2.toLowerCase()];
            }
            function createRequest(params) {
              var date = /* @__PURE__ */ new Date();
              if (this.options.amendTimeSkewed) {
                date = +/* @__PURE__ */ new Date() + this.options.amendTimeSkewed;
              }
              var headers = { "x-oss-date": dateFormat2(date, "UTC:ddd, dd mmm yyyy HH:MM:ss 'GMT'") };
              if (typeof window !== "undefined") {
                headers["x-oss-user-agent"] = this.userAgent;
              }
              if (this.userAgent.includes("nodejs")) {
                headers["User-Agent"] = this.userAgent;
              }
              if (this.options.isRequestPay) {
                Object.assign(headers, { "x-oss-request-payer": "requester" });
              }
              if (this.options.stsToken) {
                headers["x-oss-security-token"] = this.options.stsToken;
              }
              copy(params.headers).to(headers);
              if (!getHeader(headers, "Content-Type")) {
                if (params.mime && params.mime.indexOf("/") > 0) {
                  headers["Content-Type"] = params.mime;
                } else if (isDingTalk()) {
                  headers["Content-Type"] = "application/octet-stream";
                } else {
                  headers["Content-Type"] = mime.getType(params.mime || path.extname(params.object || ""));
                }
              }
              if (!getHeader(headers, "Content-Type")) {
                delHeader(headers, "Content-Type");
              }
              if (params.content) {
                if (!params.disabledMD5) {
                  if (!params.headers || !params.headers["Content-MD5"]) {
                    headers["Content-MD5"] = crypto.createHash("md5").update(Buffer2.from(params.content, "utf8")).digest("base64");
                  } else {
                    headers["Content-MD5"] = params.headers["Content-MD5"];
                  }
                }
                if (!headers["Content-Length"]) {
                  headers["Content-Length"] = params.content.length;
                }
              }
              var hasOwnProperty2 = Object.prototype.hasOwnProperty;
              for (var k2 in headers) {
                if (headers[k2] && hasOwnProperty2.call(headers, k2)) {
                  headers[k2] = encoder(String(headers[k2]), this.options.headerEncoding);
                }
              }
              var authResource = this._getResource(params);
              headers.authorization = this.authorization(params.method, authResource, params.subres, headers, this.options.headerEncoding);
              if (isIP(this.options.endpoint.hostname)) {
                var _this$options = this.options, region2 = _this$options.region, internal = _this$options.internal, secure = _this$options.secure;
                var hostInfo = setRegion(region2, internal, secure);
                headers.host = "".concat(params.bucket, ".").concat(hostInfo.host);
              }
              var url = getReqUrl.bind(this)(params);
              debug("request %s %s, with headers %j, !!stream: %s", params.method, url, headers, !!params.stream);
              var timeout2 = params.timeout || this.options.timeout;
              var reqParams = { method: params.method, content: params.content, stream: params.stream, headers, timeout: timeout2, writeStream: params.writeStream, customResponse: params.customResponse, ctx: params.ctx || this.ctx };
              if (this.agent) {
                reqParams.agent = this.agent;
              }
              if (this.httpsAgent) {
                reqParams.httpsAgent = this.httpsAgent;
              }
              reqParams.enableProxy = !!this.options.enableProxy;
              reqParams.proxy = this.options.proxy ? this.options.proxy : null;
              return { url, params: reqParams };
            }
            exports2.createRequest = createRequest;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../client/getReqUrl": 25, "./../../../shims/crypto/crypto.js": 461, "./encoder": 59, "./isDingTalk": 66, "./isIP": 69, "./setRegion": 75, "buffer": 90, "copy-to": 94, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.string.includes.js": 302, "dateformat": 342, "debug": 465, "mime": 374, "path": 378 }], 57: [function(require2, module2, exports2) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.entries.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.object.keys.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.dataFix = void 0;
        var isObject_1 = require2("./isObject");
        var TRUE = ["true", "TRUE", "1", 1];
        var FALSE = ["false", "FALSE", "0", 0];
        function dataFix(o2, conf, finalKill) {
          if (!isObject_1.isObject(o2))
            return;
          var _conf$remove = conf.remove, remove = _conf$remove === void 0 ? [] : _conf$remove, _conf$rename = conf.rename, rename = _conf$rename === void 0 ? {} : _conf$rename, _conf$camel = conf.camel, camel = _conf$camel === void 0 ? [] : _conf$camel, _conf$bool = conf.bool, bool = _conf$bool === void 0 ? [] : _conf$bool, _conf$lowerFirst = conf.lowerFirst, lowerFirst = _conf$lowerFirst === void 0 ? false : _conf$lowerFirst;
          remove.forEach(function(v3) {
            return delete o2[v3];
          });
          Object.entries(rename).forEach(function(v3) {
            if (!o2[v3[0]])
              return;
            if (o2[v3[1]])
              return;
            o2[v3[1]] = o2[v3[0]];
            delete o2[v3[0]];
          });
          camel.forEach(function(v3) {
            if (!o2[v3])
              return;
            var afterKey = v3.replace(/^(.)/, function($0) {
              return $0.toLowerCase();
            }).replace(/-(\w)/g, function(_2, $1) {
              return $1.toUpperCase();
            });
            if (o2[afterKey])
              return;
            o2[afterKey] = o2[v3];
          });
          bool.forEach(function(v3) {
            o2[v3] = fixBool(o2[v3]);
          });
          if (typeof finalKill === "function") {
            finalKill(o2);
          }
          fixLowerFirst(o2, lowerFirst);
          return dataFix;
        }
        exports2.dataFix = dataFix;
        function fixBool(value) {
          if (!value)
            return false;
          if (TRUE.includes(value))
            return true;
          return FALSE.includes(value) ? false : value;
        }
        function fixLowerFirst(o2, lowerFirst) {
          if (lowerFirst) {
            Object.keys(o2).forEach(function(key) {
              var lowerK = key.replace(/^\w/, function(match) {
                return match.toLowerCase();
              });
              if (typeof o2[lowerK] === "undefined") {
                o2[lowerK] = o2[key];
                delete o2[key];
              }
            });
          }
        }
      }, { "./isObject": 70, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.object.entries.js": 288, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339 }], 58: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        require2("core-js/modules/es.array.slice.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.deepCopyWith = exports2.deepCopy = void 0;
        var isBuffer_1 = require2("./isBuffer");
        exports2.deepCopy = function(obj) {
          if (obj === null || (0, _typeof2.default)(obj) !== "object") {
            return obj;
          }
          if (isBuffer_1.isBuffer(obj)) {
            return obj.slice();
          }
          var copy = Array.isArray(obj) ? [] : {};
          Object.keys(obj).forEach(function(key) {
            copy[key] = exports2.deepCopy(obj[key]);
          });
          return copy;
        };
        exports2.deepCopyWith = function(obj, customizer) {
          function deepCopyWithHelper(value, innerKey, innerObject) {
            var result = customizer(value, innerKey, innerObject);
            if (result !== void 0)
              return result;
            if (value === null || (0, _typeof2.default)(value) !== "object") {
              return value;
            }
            if (isBuffer_1.isBuffer(value)) {
              return value.slice();
            }
            var copy = Array.isArray(value) ? [] : {};
            Object.keys(value).forEach(function(k2) {
              copy[k2] = deepCopyWithHelper(value[k2], k2, value);
            });
            return copy;
          }
          if (customizer) {
            return deepCopyWithHelper(obj, "", null);
          } else {
            return exports2.deepCopy(obj);
          }
        };
      }, { "./isBuffer": 65, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/web.dom-collections.for-each.js": 339 }], 59: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.encoder = void 0;
            function encoder(str) {
              var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf-8";
              if (encoding === "utf-8")
                return str;
              return Buffer2.from(str).toString("latin1");
            }
            exports2.encoder = encoder;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 90, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.to-string.js": 301 }], 60: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.formatInventoryConfig = void 0;
        var dataFix_1 = require2("../utils/dataFix");
        var isObject_1 = require2("../utils/isObject");
        var isArray_1 = require2("../utils/isArray");
        var formatObjKey_1 = require2("../utils/formatObjKey");
        function formatInventoryConfig(inventoryConfig) {
          var toArray2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (toArray2 && isObject_1.isObject(inventoryConfig))
            inventoryConfig = [inventoryConfig];
          if (isArray_1.isArray(inventoryConfig)) {
            inventoryConfig = inventoryConfig.map(formatFn);
          } else {
            inventoryConfig = formatFn(inventoryConfig);
          }
          return inventoryConfig;
        }
        exports2.formatInventoryConfig = formatInventoryConfig;
        function formatFn(_2) {
          dataFix_1.dataFix(_2, { bool: ["IsEnabled"] }, function(conf) {
            var _a3, _b2;
            conf.prefix = conf.Filter.Prefix;
            delete conf.Filter;
            conf.OSSBucketDestination = conf.Destination.OSSBucketDestination;
            conf.OSSBucketDestination.rolename = conf.OSSBucketDestination.RoleArn.replace(/.*\//, "");
            delete conf.OSSBucketDestination.RoleArn;
            conf.OSSBucketDestination.bucket = conf.OSSBucketDestination.Bucket.replace(/.*:::/, "");
            delete conf.OSSBucketDestination.Bucket;
            delete conf.Destination;
            conf.frequency = conf.Schedule.Frequency;
            delete conf.Schedule.Frequency;
            if (((_a3 = conf === null || conf === void 0 ? void 0 : conf.OptionalFields) === null || _a3 === void 0 ? void 0 : _a3.Field) && !isArray_1.isArray((_b2 = conf.OptionalFields) === null || _b2 === void 0 ? void 0 : _b2.Field))
              conf.OptionalFields.Field = [conf.OptionalFields.Field];
          });
          _2 = formatObjKey_1.formatObjKey(_2, "firstLowerCase", { exclude: ["OSSBucketDestination", "SSE-OSS", "SSE-KMS"] });
          return _2;
        }
      }, { "../utils/dataFix": 57, "../utils/formatObjKey": 61, "../utils/isArray": 63, "../utils/isObject": 70, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.replace.js": 305 }], 61: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.string.includes.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.formatObjKey = void 0;
        function formatObjKey(obj, type2, options) {
          if (obj === null || (0, _typeof2.default)(obj) !== "object") {
            return obj;
          }
          var o2;
          if (Array.isArray(obj)) {
            o2 = [];
            for (var i3 = 0; i3 < obj.length; i3++) {
              o2.push(formatObjKey(obj[i3], type2, options));
            }
          } else {
            o2 = {};
            Object.keys(obj).forEach(function(key) {
              o2[handelFormat(key, type2, options)] = formatObjKey(obj[key], type2, options);
            });
          }
          return o2;
        }
        exports2.formatObjKey = formatObjKey;
        function handelFormat(key, type2, options) {
          if (options && options.exclude && options.exclude.includes(key))
            return key;
          if (type2 === "firstUpperCase") {
            key = key.replace(/^./, function(_2) {
              return _2.toUpperCase();
            });
          } else if (type2 === "firstLowerCase") {
            key = key.replace(/^./, function(_2) {
              return _2.toLowerCase();
            });
          }
          return key;
        }
      }, { "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.includes.js": 302, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339 }], 62: [function(require2, module2, exports2) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.getStrBytesCount = void 0;
        function getStrBytesCount(str) {
          var bytesCount = 0;
          for (var i3 = 0; i3 < str.length; i3++) {
            var c2 = str.charAt(i3);
            if (/^[\u00-\uff]$/.test(c2)) {
              bytesCount += 1;
            } else {
              bytesCount += 2;
            }
          }
          return bytesCount;
        }
        exports2.getStrBytesCount = getStrBytesCount;
      }, { "core-js/modules/es.regexp.exec.js": 300 }], 63: [function(require2, module2, exports2) {
        require2("core-js/modules/es.object.to-string.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isArray = void 0;
        exports2.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }, { "core-js/modules/es.object.to-string.js": 291 }], 64: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isBlob = void 0;
        function isBlob2(blob) {
          return typeof Blob !== "undefined" && blob instanceof Blob;
        }
        exports2.isBlob = isBlob2;
      }, {}], 65: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isBuffer = void 0;
            function isBuffer2(obj) {
              return Buffer2.isBuffer(obj);
            }
            exports2.isBuffer = isBuffer2;
          }).call(this);
        }).call(this, { "isBuffer": require2("../../../node_modules/is-buffer/index.js") });
      }, { "../../../node_modules/is-buffer/index.js": 366 }], 66: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            require2("core-js/modules/es.array.includes.js");
            require2("core-js/modules/es.string.includes.js");
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isDingTalk = void 0;
            function isDingTalk() {
              if (process.browser && window.navigator.userAgent.toLowerCase().includes("aliapp(dingtalk")) {
                return true;
              }
              return false;
            }
            exports2.isDingTalk = isDingTalk;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 467, "core-js/modules/es.array.includes.js": 277, "core-js/modules/es.string.includes.js": 302 }], 67: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isFile = void 0;
        exports2.isFile = function(obj) {
          return typeof File !== "undefined" && obj instanceof File;
        };
      }, {}], 68: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isFunction = void 0;
        exports2.isFunction = function(v3) {
          return typeof v3 === "function";
        };
      }, {}], 69: [function(require2, module2, exports2) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isIP = void 0;
        exports2.isIP = function(host) {
          var ipv4Regex = /^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$/;
          var ipv6Regex = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
          return ipv4Regex.test(host) || ipv6Regex.test(host);
        };
      }, { "core-js/modules/es.regexp.exec.js": 300 }], 70: [function(require2, module2, exports2) {
        require2("core-js/modules/es.object.to-string.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isObject = void 0;
        exports2.isObject = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        };
      }, { "core-js/modules/es.object.to-string.js": 291 }], 71: [function(require2, module2, exports2) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.lowercaseKeyHeader = void 0;
        var isObject_1 = require2("./isObject");
        function lowercaseKeyHeader(headers) {
          var lowercaseHeader = {};
          if (isObject_1.isObject(headers)) {
            Object.keys(headers).forEach(function(key) {
              lowercaseHeader[key.toLowerCase()] = headers[key];
            });
          }
          return lowercaseHeader;
        }
        exports2.lowercaseKeyHeader = lowercaseKeyHeader;
      }, { "./isObject": 70, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/web.dom-collections.for-each.js": 339 }], 72: [function(require2, module2, exports2) {
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.array.join.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.regexp.to-string.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.obj2xml = void 0;
        var formatObjKey_1 = require2("./formatObjKey");
        function type2(params) {
          return Object.prototype.toString.call(params).replace(/(.*? |])/g, "").toLowerCase();
        }
        function obj2xml(obj, options) {
          var s2 = "";
          if (options && options.headers) {
            s2 = '<?xml version="1.0" encoding="UTF-8"?>\n';
          }
          if (options && options.firstUpperCase) {
            obj = formatObjKey_1.formatObjKey(obj, "firstUpperCase");
          }
          if (type2(obj) === "object") {
            Object.keys(obj).forEach(function(key) {
              if (type2(obj[key]) !== "undefined" && type2(obj[key]) !== "null") {
                if (type2(obj[key]) === "string" || type2(obj[key]) === "number") {
                  s2 += "<".concat(key, ">").concat(obj[key], "</").concat(key, ">");
                } else if (type2(obj[key]) === "object") {
                  s2 += "<".concat(key, ">").concat(obj2xml(obj[key]), "</").concat(key, ">");
                } else if (type2(obj[key]) === "array") {
                  s2 += obj[key].map(function(keyChild) {
                    return "<".concat(key, ">").concat(obj2xml(keyChild), "</").concat(key, ">");
                  }).join("");
                } else {
                  s2 += "<".concat(key, ">").concat(obj[key].toString(), "</").concat(key, ">");
                }
              }
            });
          } else {
            s2 += obj.toString();
          }
          return s2;
        }
        exports2.obj2xml = obj2xml;
      }, { "./formatObjKey": 61, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.join.js": 279, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.replace.js": 305, "core-js/modules/web.dom-collections.for-each.js": 339 }], 73: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.slice.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.function.name.js");
        require2("core-js/modules/es.array.from.js");
        require2("core-js/modules/es.string.iterator.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.symbol.js");
        require2("core-js/modules/es.symbol.description.js");
        require2("core-js/modules/es.symbol.iterator.js");
        require2("core-js/modules/es.array.iterator.js");
        require2("core-js/modules/web.dom-collections.iterator.js");
        require2("core-js/modules/es.object.assign.js");
        function _createForOfIteratorHelper(o2, allowArrayLike) {
          var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
          if (!it2) {
            if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
              if (it2)
                o2 = it2;
              var i3 = 0;
              var F2 = function F3() {
              };
              return { s: F2, n: function n2() {
                if (i3 >= o2.length)
                  return { done: true };
                return { done: false, value: o2[i3++] };
              }, e: function e2(_e2) {
                throw _e2;
              }, f: F2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err2;
          return { s: function s2() {
            it2 = it2.call(o2);
          }, n: function n2() {
            var step = it2.next();
            normalCompletion = step.done;
            return step;
          }, e: function e2(_e2) {
            didErr = true;
            err2 = _e2;
          }, f: function f2() {
            try {
              if (!normalCompletion && it2.return != null)
                it2.return();
            } finally {
              if (didErr)
                throw err2;
            }
          } };
        }
        function _unsupportedIterableToArray(o2, minLen) {
          if (!o2)
            return;
          if (typeof o2 === "string")
            return _arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor)
            n2 = o2.constructor.name;
          if (n2 === "Map" || n2 === "Set")
            return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return _arrayLikeToArray(o2, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
            arr2[i3] = arr[i3];
          }
          return arr2;
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.omit = void 0;
        function omit(originalObject, keysToOmit) {
          var cloneObject = Object.assign({}, originalObject);
          var _iterator = _createForOfIteratorHelper(keysToOmit), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var path = _step.value;
              delete cloneObject[path];
            }
          } catch (err2) {
            _iterator.e(err2);
          } finally {
            _iterator.f();
          }
          return cloneObject;
        }
        exports2.omit = omit;
      }, { "core-js/modules/es.array.from.js": 276, "core-js/modules/es.array.iterator.js": 278, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.iterator.js": 303, "core-js/modules/es.symbol.description.js": 310, "core-js/modules/es.symbol.iterator.js": 312, "core-js/modules/es.symbol.js": 313, "core-js/modules/web.dom-collections.iterator.js": 340 }], 74: [function(require2, module2, exports2) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.promise.js");
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.retry = void 0;
        function retry(func, retryMax) {
          var config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var retryNum = 0;
          var _config$retryDelay = config.retryDelay, retryDelay = _config$retryDelay === void 0 ? 500 : _config$retryDelay, _config$errorHandler = config.errorHandler, errorHandler = _config$errorHandler === void 0 ? function() {
            return true;
          } : _config$errorHandler;
          var funcR = function funcR2() {
            for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
              arg[_key] = arguments[_key];
            }
            return new Promise(function(resolve, reject) {
              func.apply(void 0, arg).then(function(result) {
                retryNum = 0;
                resolve(result);
              }).catch(function(err2) {
                if (retryNum < retryMax && errorHandler(err2)) {
                  retryNum++;
                  setTimeout(function() {
                    resolve(funcR2.apply(void 0, arg));
                  }, retryDelay);
                } else {
                  retryNum = 0;
                  reject(err2);
                }
              });
            });
          };
          return funcR;
        }
        exports2.retry = retry;
      }, { "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295 }], 75: [function(require2, module2, exports2) {
        var __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.setRegion = void 0;
        var url_1 = __importDefault(require2("url"));
        var checkConfigValid_1 = require2("./checkConfigValid");
        function setRegion(region2) {
          var internal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var secure = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          checkConfigValid_1.checkConfigValid(region2, "region");
          var protocol2 = secure ? "https://" : "http://";
          var suffix = internal ? "-internal.aliyuncs.com" : ".aliyuncs.com";
          var prefix = "vpc100-oss-cn-";
          if (region2.substr(0, prefix.length) === prefix) {
            suffix = ".aliyuncs.com";
          }
          return url_1.default.parse(protocol2 + region2 + suffix);
        }
        exports2.setRegion = setRegion;
      }, { "./checkConfigValid": 52, "url": 472 }], 76: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.array.find.js");
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.checkCredentials = exports2.setSTSToken = void 0;
        var formatObjKey_1 = require2("./formatObjKey");
        function setSTSToken() {
          return _setSTSToken.apply(this, arguments);
        }
        function _setSTSToken() {
          _setSTSToken = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee() {
            var now2, credentials;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.options)
                      this.options = {};
                    now2 = /* @__PURE__ */ new Date();
                    if (!this.stsTokenFreshTime) {
                      _context.next = 14;
                      break;
                    }
                    if (!(+now2 - this.stsTokenFreshTime >= this.options.refreshSTSTokenInterval)) {
                      _context.next = 12;
                      break;
                    }
                    this.stsTokenFreshTime = now2;
                    _context.next = 7;
                    return this.options.refreshSTSToken();
                  case 7:
                    credentials = _context.sent;
                    credentials = formatObjKey_1.formatObjKey(credentials, "firstLowerCase");
                    if (credentials.securityToken) {
                      credentials.stsToken = credentials.securityToken;
                    }
                    checkCredentials(credentials);
                    Object.assign(this.options, credentials);
                  case 12:
                    _context.next = 15;
                    break;
                  case 14:
                    this.stsTokenFreshTime = now2;
                  case 15:
                    return _context.abrupt("return", null);
                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          return _setSTSToken.apply(this, arguments);
        }
        exports2.setSTSToken = setSTSToken;
        function checkCredentials(obj) {
          var stsTokenKey = ["accessKeySecret", "accessKeyId", "stsToken"];
          var objKeys = Object.keys(obj);
          stsTokenKey.forEach(function(_2) {
            if (!objKeys.find(function(key) {
              return key === _2;
            })) {
              throw Error("refreshSTSToken must return contains ".concat(_2));
            }
          });
        }
        exports2.checkCredentials = checkCredentials;
      }, { "./formatObjKey": 61, "@babel/runtime/helpers/asyncToGenerator": 77, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/regenerator": 80, "core-js/modules/es.array.find.js": 275, "core-js/modules/es.object.assign.js": 287, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291 }], 77: [function(require2, module2, exports2) {
        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
              }
              function _throw(err2) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err2);
              }
              _next(void 0);
            });
          };
        }
        module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      }, {}], 78: [function(require2, module2, exports2) {
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      }, {}], 79: [function(require2, module2, exports2) {
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(obj);
        }
        module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      }, {}], 80: [function(require2, module2, exports2) {
        module2.exports = require2("regenerator-runtime");
      }, { "regenerator-runtime": 395 }], 81: [function(require2, module2, exports2) {
        module2.exports = noop2;
        module2.exports.HttpsAgent = noop2;
        function noop2() {
        }
      }, {}], 82: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            var objectAssign = require2("object-assign");
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
             * @license  MIT
             */
            function compare2(a2, b2) {
              if (a2 === b2) {
                return 0;
              }
              var x2 = a2.length;
              var y3 = b2.length;
              for (var i3 = 0, len = Math.min(x2, y3); i3 < len; ++i3) {
                if (a2[i3] !== b2[i3]) {
                  x2 = a2[i3];
                  y3 = b2[i3];
                  break;
                }
              }
              if (x2 < y3) {
                return -1;
              }
              if (y3 < x2) {
                return 1;
              }
              return 0;
            }
            function isBuffer2(b2) {
              if (global3.Buffer && typeof global3.Buffer.isBuffer === "function") {
                return global3.Buffer.isBuffer(b2);
              }
              return !!(b2 != null && b2._isBuffer);
            }
            var util = require2("util/");
            var hasOwn = Object.prototype.hasOwnProperty;
            var pSlice = Array.prototype.slice;
            var functionsHaveNames = function() {
              return (function foo() {
              }).name === "foo";
            }();
            function pToString(obj) {
              return Object.prototype.toString.call(obj);
            }
            function isView(arrbuf) {
              if (isBuffer2(arrbuf)) {
                return false;
              }
              if (typeof global3.ArrayBuffer !== "function") {
                return false;
              }
              if (typeof ArrayBuffer.isView === "function") {
                return ArrayBuffer.isView(arrbuf);
              }
              if (!arrbuf) {
                return false;
              }
              if (arrbuf instanceof DataView) {
                return true;
              }
              if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                return true;
              }
              return false;
            }
            var assert = module2.exports = ok;
            var regex = /\s*function\s+([^\(\s]*)\s*/;
            function getName(func) {
              if (!util.isFunction(func)) {
                return;
              }
              if (functionsHaveNames) {
                return func.name;
              }
              var str = func.toString();
              var match = str.match(regex);
              return match && match[1];
            }
            assert.AssertionError = function AssertionError(options) {
              this.name = "AssertionError";
              this.actual = options.actual;
              this.expected = options.expected;
              this.operator = options.operator;
              if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
              } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
              }
              var stackStartFunction = options.stackStartFunction || fail;
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
              } else {
                var err2 = new Error();
                if (err2.stack) {
                  var out = err2.stack;
                  var fn_name = getName(stackStartFunction);
                  var idx = out.indexOf("\n" + fn_name);
                  if (idx >= 0) {
                    var next_line = out.indexOf("\n", idx + 1);
                    out = out.substring(next_line + 1);
                  }
                  this.stack = out;
                }
              }
            };
            util.inherits(assert.AssertionError, Error);
            function truncate(s2, n2) {
              if (typeof s2 === "string") {
                return s2.length < n2 ? s2 : s2.slice(0, n2);
              } else {
                return s2;
              }
            }
            function inspect(something) {
              if (functionsHaveNames || !util.isFunction(something)) {
                return util.inspect(something);
              }
              var rawname = getName(something);
              var name2 = rawname ? ": " + rawname : "";
              return "[Function" + name2 + "]";
            }
            function getMessage(self2) {
              return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
            }
            function fail(actual, expected, message, operator, stackStartFunction) {
              throw new assert.AssertionError({ message, actual, expected, operator, stackStartFunction });
            }
            assert.fail = fail;
            function ok(value, message) {
              if (!value)
                fail(value, true, message, "==", assert.ok);
            }
            assert.ok = ok;
            assert.equal = function equal(actual, expected, message) {
              if (actual != expected)
                fail(actual, expected, message, "==", assert.equal);
            };
            assert.notEqual = function notEqual(actual, expected, message) {
              if (actual == expected) {
                fail(actual, expected, message, "!=", assert.notEqual);
              }
            };
            assert.deepEqual = function deepEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "deepEqual", assert.deepEqual);
              }
            };
            assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
              }
            };
            function _deepEqual(actual, expected, strict2, memos) {
              if (actual === expected) {
                return true;
              } else if (isBuffer2(actual) && isBuffer2(expected)) {
                return compare2(actual, expected) === 0;
              } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
              } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
              } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
                return strict2 ? actual === expected : actual == expected;
              } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                return compare2(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
              } else if (isBuffer2(actual) !== isBuffer2(expected)) {
                return false;
              } else {
                memos = memos || { actual: [], expected: [] };
                var actualIndex = memos.actual.indexOf(actual);
                if (actualIndex !== -1) {
                  if (actualIndex === memos.expected.indexOf(expected)) {
                    return true;
                  }
                }
                memos.actual.push(actual);
                memos.expected.push(expected);
                return objEquiv(actual, expected, strict2, memos);
              }
            }
            function isArguments(object) {
              return Object.prototype.toString.call(object) == "[object Arguments]";
            }
            function objEquiv(a2, b2, strict2, actualVisitedObjects) {
              if (a2 === null || a2 === void 0 || b2 === null || b2 === void 0)
                return false;
              if (util.isPrimitive(a2) || util.isPrimitive(b2))
                return a2 === b2;
              if (strict2 && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b2))
                return false;
              var aIsArgs = isArguments(a2);
              var bIsArgs = isArguments(b2);
              if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
                return false;
              if (aIsArgs) {
                a2 = pSlice.call(a2);
                b2 = pSlice.call(b2);
                return _deepEqual(a2, b2, strict2);
              }
              var ka = objectKeys(a2);
              var kb = objectKeys(b2);
              var key, i3;
              if (ka.length !== kb.length)
                return false;
              ka.sort();
              kb.sort();
              for (i3 = ka.length - 1; i3 >= 0; i3--) {
                if (ka[i3] !== kb[i3])
                  return false;
              }
              for (i3 = ka.length - 1; i3 >= 0; i3--) {
                key = ka[i3];
                if (!_deepEqual(a2[key], b2[key], strict2, actualVisitedObjects))
                  return false;
              }
              return true;
            }
            assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
              }
            };
            assert.notDeepStrictEqual = notDeepStrictEqual;
            function notDeepStrictEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
              }
            }
            assert.strictEqual = function strictEqual(actual, expected, message) {
              if (actual !== expected) {
                fail(actual, expected, message, "===", assert.strictEqual);
              }
            };
            assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
              if (actual === expected) {
                fail(actual, expected, message, "!==", assert.notStrictEqual);
              }
            };
            function expectedException(actual, expected) {
              if (!actual || !expected) {
                return false;
              }
              if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                return expected.test(actual);
              }
              try {
                if (actual instanceof expected) {
                  return true;
                }
              } catch (e2) {
              }
              if (Error.isPrototypeOf(expected)) {
                return false;
              }
              return expected.call({}, actual) === true;
            }
            function _tryBlock(block2) {
              var error;
              try {
                block2();
              } catch (e2) {
                error = e2;
              }
              return error;
            }
            function _throws(shouldThrow, block2, expected, message) {
              var actual;
              if (typeof block2 !== "function") {
                throw new TypeError('"block" argument must be a function');
              }
              if (typeof expected === "string") {
                message = expected;
                expected = null;
              }
              actual = _tryBlock(block2);
              message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
              if (shouldThrow && !actual) {
                fail(actual, expected, "Missing expected exception" + message);
              }
              var userProvidedMessage = typeof message === "string";
              var isUnwantedException = !shouldThrow && util.isError(actual);
              var isUnexpectedException = !shouldThrow && actual && !expected;
              if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                fail(actual, expected, "Got unwanted exception" + message);
              }
              if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                throw actual;
              }
            }
            assert.throws = function(block2, error, message) {
              _throws(true, block2, error, message);
            };
            assert.doesNotThrow = function(block2, error, message) {
              _throws(false, block2, error, message);
            };
            assert.ifError = function(err2) {
              if (err2)
                throw err2;
            };
            function strict(value, message) {
              if (!value)
                fail(value, true, message, "==", strict);
            }
            assert.strict = objectAssign(strict, assert, { equal: assert.strictEqual, deepEqual: assert.deepStrictEqual, notEqual: assert.notStrictEqual, notDeepEqual: assert.notDeepStrictEqual });
            assert.strict.strict = assert.strict;
            var objectKeys = Object.keys || function(obj) {
              var keys = [];
              for (var key in obj) {
                if (hasOwn.call(obj, key))
                  keys.push(key);
              }
              return keys;
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "object-assign": 377, "util/": 85 }], 83: [function(require2, module2, exports2) {
        if (typeof Object.create === "function") {
          module2.exports = function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
          };
        } else {
          module2.exports = function inherits2(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      }, {}], 84: [function(require2, module2, exports2) {
        module2.exports = function isBuffer2(arg) {
          return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
        };
      }, {}], 85: [function(require2, module2, exports2) {
        (function(process, global3) {
          (function() {
            var formatRegExp = /%[sdj%]/g;
            exports2.format = function(f2) {
              if (!isString2(f2)) {
                var objects = [];
                for (var i3 = 0; i3 < arguments.length; i3++) {
                  objects.push(inspect(arguments[i3]));
                }
                return objects.join(" ");
              }
              var i3 = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f2).replace(formatRegExp, function(x3) {
                if (x3 === "%%")
                  return "%";
                if (i3 >= len)
                  return x3;
                switch (x3) {
                  case "%s":
                    return String(args[i3++]);
                  case "%d":
                    return Number(args[i3++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i3++]);
                    } catch (_2) {
                      return "[Circular]";
                    }
                  default:
                    return x3;
                }
              });
              for (var x2 = args[i3]; i3 < len; x2 = args[++i3]) {
                if (isNull(x2) || !isObject2(x2)) {
                  str += " " + x2;
                } else {
                  str += " " + inspect(x2);
                }
              }
              return str;
            };
            exports2.deprecate = function(fn, msg) {
              if (isUndefined2(global3.process)) {
                return function() {
                  return exports2.deprecate(fn, msg).apply(this, arguments);
                };
              }
              if (process.noDeprecation === true) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports2.debuglog = function(set) {
              if (isUndefined2(debugEnviron))
                debugEnviron = {}.NODE_DEBUG || "";
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set] = function() {
                    var msg = exports2.format.apply(exports2, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {
                  };
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = { seen: [], stylize: stylizeNoColor };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean2(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports2._extend(ctx, opts);
              }
              if (isUndefined2(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined2(ctx.depth))
                ctx.depth = 2;
              if (isUndefined2(ctx.colors))
                ctx.colors = false;
              if (isUndefined2(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports2.inspect = inspect;
            inspect.colors = { "bold": [1, 22], "italic": [3, 23], "underline": [4, 24], "inverse": [7, 27], "white": [37, 39], "grey": [90, 39], "black": [30, 39], "blue": [34, 39], "cyan": [36, 39], "green": [32, 39], "magenta": [35, 39], "red": [31, 39], "yellow": [33, 39] };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              // "name": intentionally not styling
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style2 = inspect.styles[styleType];
              if (style2) {
                return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash2 = {};
              array.forEach(function(val, idx) {
                hash2[val] = true;
              });
              return hash2;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
              value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString2(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction2(value)) {
                  var name2 = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name2 + "]", "special");
                }
                if (isRegExp2(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate2(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array = false, braces = ["{", "}"];
              if (isArray2(value)) {
                array = true;
                braces = ["[", "]"];
              }
              if (isFunction2(value)) {
                var n2 = value.name ? ": " + value.name : "";
                base = " [Function" + n2 + "]";
              }
              if (isRegExp2(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate2(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp2(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined2(value))
                return ctx.stylize("undefined", "undefined");
              if (isString2(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber2(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean2(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i3 = 0, l2 = value.length; i3 < l2; ++i3) {
                if (hasOwnProperty2(value, String(i3))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i3), true));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name2, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty2(visibleKeys, key)) {
                name2 = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str.split("\n").map(function(line) {
                        return "  " + line;
                      }).join("\n").substr(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined2(name2)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name2 = JSON.stringify("" + key);
                if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name2 = name2.substr(1, name2.length - 2);
                  name2 = ctx.stylize(name2, "name");
                } else {
                  name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name2 = ctx.stylize(name2, "string");
                }
              }
              return name2 + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var length = output.reduce(function(prev, cur) {
                if (cur.indexOf("\n") >= 0)
                  ;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            function isArray2(ar) {
              return Array.isArray(ar);
            }
            exports2.isArray = isArray2;
            function isBoolean2(arg) {
              return typeof arg === "boolean";
            }
            exports2.isBoolean = isBoolean2;
            function isNull(arg) {
              return arg === null;
            }
            exports2.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports2.isNullOrUndefined = isNullOrUndefined;
            function isNumber2(arg) {
              return typeof arg === "number";
            }
            exports2.isNumber = isNumber2;
            function isString2(arg) {
              return typeof arg === "string";
            }
            exports2.isString = isString2;
            function isSymbol(arg) {
              return typeof arg === "symbol";
            }
            exports2.isSymbol = isSymbol;
            function isUndefined2(arg) {
              return arg === void 0;
            }
            exports2.isUndefined = isUndefined2;
            function isRegExp2(re2) {
              return isObject2(re2) && objectToString(re2) === "[object RegExp]";
            }
            exports2.isRegExp = isRegExp2;
            function isObject2(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports2.isObject = isObject2;
            function isDate2(d2) {
              return isObject2(d2) && objectToString(d2) === "[object Date]";
            }
            exports2.isDate = isDate2;
            function isError(e2) {
              return isObject2(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
            }
            exports2.isError = isError;
            function isFunction2(arg) {
              return typeof arg === "function";
            }
            exports2.isFunction = isFunction2;
            function isPrimitive(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined";
            }
            exports2.isPrimitive = isPrimitive;
            exports2.isBuffer = require2("./support/isBuffer");
            function objectToString(o2) {
              return Object.prototype.toString.call(o2);
            }
            function pad(n2) {
              return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
            }
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            function timestamp() {
              var d2 = /* @__PURE__ */ new Date();
              var time = [pad(d2.getHours()), pad(d2.getMinutes()), pad(d2.getSeconds())].join(":");
              return [d2.getDate(), months[d2.getMonth()], time].join(" ");
            }
            exports2.log = function() {
              console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
            };
            exports2.inherits = require2("inherits");
            exports2._extend = function(origin, add) {
              if (!add || !isObject2(add))
                return origin;
              var keys = Object.keys(add);
              var i3 = keys.length;
              while (i3--) {
                origin[keys[i3]] = add[keys[i3]];
              }
              return origin;
            };
            function hasOwnProperty2(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./support/isBuffer": 84, "_process": 467, "inherits": 83 }], 86: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            var possibleNames = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"];
            var g2 = typeof globalThis === "undefined" ? global3 : globalThis;
            module2.exports = function availableTypedArrays() {
              var out = [];
              for (var i3 = 0; i3 < possibleNames.length; i3++) {
                if (typeof g2[possibleNames[i3]] === "function") {
                  out[out.length] = possibleNames[i3];
                }
              }
              return out;
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 87: [function(require2, module2, exports2) {
        exports2.byteLength = byteLength;
        exports2.toByteArray = toByteArray;
        exports2.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i3 = 0, len = code.length; i3 < len; ++i3) {
          lookup[i3] = code[i3];
          revLookup[code.charCodeAt(i3)] = i3;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i4;
          for (i4 = 0; i4 < len2; i4 += 4) {
            tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i4 = start; i4 < end; i4 += 3) {
            tmp = (uint8[i4] << 16 & 16711680) + (uint8[i4 + 1] << 8 & 65280) + (uint8[i4 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
            parts.push(encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
          }
          return parts.join("");
        }
      }, {}], 88: [function(require2, module2, exports2) {
        /*!
        * Bowser - a browser detector
        * https://github.com/ded/bowser
        * MIT License | (c) Dustin Diaz 2015
        */
        !function(root, name2, definition) {
          if (typeof module2 != "undefined" && module2.exports)
            module2.exports = definition();
          else
            root[name2] = definition();
        }(this, "bowser", function() {
          var t2 = true;
          function detect(ua) {
            function getFirstMatch(regex) {
              var match = ua.match(regex);
              return match && match.length > 1 && match[1] || "";
            }
            function getSecondMatch(regex) {
              var match = ua.match(regex);
              return match && match.length > 1 && match[2] || "";
            }
            var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(), likeAndroid = /like android/i.test(ua), android = !likeAndroid && /android/i.test(ua), nexusMobile = /nexus\s*[0-6]\s*/i.test(ua), nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua), chromeos = /CrOS/.test(ua), silk = /silk/i.test(ua), sailfish = /sailfish/i.test(ua), tizen = /tizen/i.test(ua), webos = /(web|hpw)(o|0)s/i.test(ua), windowsphone = /windows phone/i.test(ua), windows = !windowsphone && /windows/i.test(ua), mac = !iosdevice && !silk && /macintosh/i.test(ua), linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua), edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i), tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua), mobile = !tablet && /[^-]mobi/i.test(ua), xbox = /xbox/i.test(ua), result;
            if (/opera/i.test(ua)) {
              result = { name: "Opera", opera: t2, version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i) };
            } else if (/opr\/|opios/i.test(ua)) {
              result = { name: "Opera", opera: t2, version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier };
            } else if (/SamsungBrowser/i.test(ua)) {
              result = { name: "Samsung Internet for Android", samsungBrowser: t2, version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i) };
            } else if (/Whale/i.test(ua)) {
              result = { name: "NAVER Whale browser", whale: t2, version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/MZBrowser/i.test(ua)) {
              result = { name: "MZ Browser", mzbrowser: t2, version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/coast/i.test(ua)) {
              result = { name: "Opera Coast", coast: t2, version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i) };
            } else if (/focus/i.test(ua)) {
              result = { name: "Focus", focus: t2, version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/yabrowser/i.test(ua)) {
              result = { name: "Yandex Browser", yandexbrowser: t2, version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i) };
            } else if (/ucbrowser/i.test(ua)) {
              result = { name: "UC Browser", ucbrowser: t2, version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/mxios/i.test(ua)) {
              result = { name: "Maxthon", maxthon: t2, version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/epiphany/i.test(ua)) {
              result = { name: "Epiphany", epiphany: t2, version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/puffin/i.test(ua)) {
              result = { name: "Puffin", puffin: t2, version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i) };
            } else if (/sleipnir/i.test(ua)) {
              result = { name: "Sleipnir", sleipnir: t2, version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (/k-meleon/i.test(ua)) {
              result = { name: "K-Meleon", kMeleon: t2, version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i) };
            } else if (windowsphone) {
              result = { name: "Windows Phone", osname: "Windows Phone", windowsphone: t2 };
              if (edgeVersion) {
                result.msedge = t2;
                result.version = edgeVersion;
              } else {
                result.msie = t2;
                result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
              }
            } else if (/msie|trident/i.test(ua)) {
              result = { name: "Internet Explorer", msie: t2, version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i) };
            } else if (chromeos) {
              result = { name: "Chrome", osname: "Chrome OS", chromeos: t2, chromeBook: t2, chrome: t2, version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) };
            } else if (/edg([ea]|ios)/i.test(ua)) {
              result = { name: "Microsoft Edge", msedge: t2, version: edgeVersion };
            } else if (/vivaldi/i.test(ua)) {
              result = { name: "Vivaldi", vivaldi: t2, version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier };
            } else if (sailfish) {
              result = { name: "Sailfish", osname: "Sailfish OS", sailfish: t2, version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i) };
            } else if (/seamonkey\//i.test(ua)) {
              result = { name: "SeaMonkey", seamonkey: t2, version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i) };
            } else if (/firefox|iceweasel|fxios/i.test(ua)) {
              result = { name: "Firefox", firefox: t2, version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i) };
              if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
                result.firefoxos = t2;
                result.osname = "Firefox OS";
              }
            } else if (silk) {
              result = { name: "Amazon Silk", silk: t2, version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i) };
            } else if (/phantom/i.test(ua)) {
              result = { name: "PhantomJS", phantom: t2, version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i) };
            } else if (/slimerjs/i.test(ua)) {
              result = { name: "SlimerJS", slimer: t2, version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i) };
            } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
              result = { name: "BlackBerry", osname: "BlackBerry OS", blackberry: t2, version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i) };
            } else if (webos) {
              result = { name: "WebOS", osname: "WebOS", webos: t2, version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i) };
              /touchpad\//i.test(ua) && (result.touchpad = t2);
            } else if (/bada/i.test(ua)) {
              result = { name: "Bada", osname: "Bada", bada: t2, version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i) };
            } else if (tizen) {
              result = { name: "Tizen", osname: "Tizen", tizen: t2, version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier };
            } else if (/qupzilla/i.test(ua)) {
              result = { name: "QupZilla", qupzilla: t2, version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier };
            } else if (/chromium/i.test(ua)) {
              result = { name: "Chromium", chromium: t2, version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier };
            } else if (/chrome|crios|crmo/i.test(ua)) {
              result = { name: "Chrome", chrome: t2, version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) };
            } else if (android) {
              result = { name: "Android", version: versionIdentifier };
            } else if (/safari|applewebkit/i.test(ua)) {
              result = { name: "Safari", safari: t2 };
              if (versionIdentifier) {
                result.version = versionIdentifier;
              }
            } else if (iosdevice) {
              result = { name: iosdevice == "iphone" ? "iPhone" : iosdevice == "ipad" ? "iPad" : "iPod" };
              if (versionIdentifier) {
                result.version = versionIdentifier;
              }
            } else if (/googlebot/i.test(ua)) {
              result = { name: "Googlebot", googlebot: t2, version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier };
            } else {
              result = { name: getFirstMatch(/^(.*)\/(.*) /), version: getSecondMatch(/^(.*)\/(.*) /) };
            }
            if (!result.msedge && /(apple)?webkit/i.test(ua)) {
              if (/(apple)?webkit\/537\.36/i.test(ua)) {
                result.name = result.name || "Blink";
                result.blink = t2;
              } else {
                result.name = result.name || "Webkit";
                result.webkit = t2;
              }
              if (!result.version && versionIdentifier) {
                result.version = versionIdentifier;
              }
            } else if (!result.opera && /gecko\//i.test(ua)) {
              result.name = result.name || "Gecko";
              result.gecko = t2;
              result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
            }
            if (!result.windowsphone && (android || result.silk)) {
              result.android = t2;
              result.osname = "Android";
            } else if (!result.windowsphone && iosdevice) {
              result[iosdevice] = t2;
              result.ios = t2;
              result.osname = "iOS";
            } else if (mac) {
              result.mac = t2;
              result.osname = "macOS";
            } else if (xbox) {
              result.xbox = t2;
              result.osname = "Xbox";
            } else if (windows) {
              result.windows = t2;
              result.osname = "Windows";
            } else if (linux) {
              result.linux = t2;
              result.osname = "Linux";
            }
            function getWindowsVersion(s2) {
              switch (s2) {
                case "NT":
                  return "NT";
                case "XP":
                  return "XP";
                case "NT 5.0":
                  return "2000";
                case "NT 5.1":
                  return "XP";
                case "NT 5.2":
                  return "2003";
                case "NT 6.0":
                  return "Vista";
                case "NT 6.1":
                  return "7";
                case "NT 6.2":
                  return "8";
                case "NT 6.3":
                  return "8.1";
                case "NT 10.0":
                  return "10";
                default:
                  return void 0;
              }
            }
            var osVersion = "";
            if (result.windows) {
              osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i));
            } else if (result.windowsphone) {
              osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
            } else if (result.mac) {
              osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
              osVersion = osVersion.replace(/[_\s]/g, ".");
            } else if (iosdevice) {
              osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
              osVersion = osVersion.replace(/[_\s]/g, ".");
            } else if (android) {
              osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
            } else if (result.webos) {
              osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
            } else if (result.blackberry) {
              osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
            } else if (result.bada) {
              osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
            } else if (result.tizen) {
              osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
            }
            if (osVersion) {
              result.osversion = osVersion;
            }
            var osMajorVersion = !result.windows && osVersion.split(".")[0];
            if (tablet || nexusTablet || iosdevice == "ipad" || android && (osMajorVersion == 3 || osMajorVersion >= 4 && !mobile) || result.silk) {
              result.tablet = t2;
            } else if (mobile || iosdevice == "iphone" || iosdevice == "ipod" || android || nexusMobile || result.blackberry || result.webos || result.bada) {
              result.mobile = t2;
            }
            if (result.msedge || result.msie && result.version >= 10 || result.yandexbrowser && result.version >= 15 || result.vivaldi && result.version >= 1 || result.chrome && result.version >= 20 || result.samsungBrowser && result.version >= 4 || result.whale && compareVersions([result.version, "1.0"]) === 1 || result.mzbrowser && compareVersions([result.version, "6.0"]) === 1 || result.focus && compareVersions([result.version, "1.0"]) === 1 || result.firefox && result.version >= 20 || result.safari && result.version >= 6 || result.opera && result.version >= 10 || result.ios && result.osversion && result.osversion.split(".")[0] >= 6 || result.blackberry && result.version >= 10.1 || result.chromium && result.version >= 20) {
              result.a = t2;
            } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20 || result.safari && result.version < 6 || result.opera && result.version < 10 || result.ios && result.osversion && result.osversion.split(".")[0] < 6 || result.chromium && result.version < 20) {
              result.c = t2;
            } else
              result.x = t2;
            return result;
          }
          var bowser = detect(typeof navigator !== "undefined" ? navigator.userAgent || "" : "");
          bowser.test = function(browserList) {
            for (var i3 = 0; i3 < browserList.length; ++i3) {
              var browserItem = browserList[i3];
              if (typeof browserItem === "string") {
                if (browserItem in bowser) {
                  return true;
                }
              }
            }
            return false;
          };
          function getVersionPrecision(version2) {
            return version2.split(".").length;
          }
          function map(arr, iterator) {
            var result = [], i3;
            if (Array.prototype.map) {
              return Array.prototype.map.call(arr, iterator);
            }
            for (i3 = 0; i3 < arr.length; i3++) {
              result.push(iterator(arr[i3]));
            }
            return result;
          }
          function compareVersions(versions) {
            var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
            var chunks = map(versions, function(version2) {
              var delta = precision - getVersionPrecision(version2);
              version2 = version2 + new Array(delta + 1).join(".0");
              return map(version2.split("."), function(chunk) {
                return new Array(20 - chunk.length).join("0") + chunk;
              }).reverse();
            });
            while (--precision >= 0) {
              if (chunks[0][precision] > chunks[1][precision]) {
                return 1;
              } else if (chunks[0][precision] === chunks[1][precision]) {
                if (precision === 0) {
                  return 0;
                }
              } else {
                return -1;
              }
            }
          }
          function isUnsupportedBrowser(minVersions, strictMode, ua) {
            var _bowser = bowser;
            if (typeof strictMode === "string") {
              ua = strictMode;
              strictMode = void 0;
            }
            if (strictMode === void 0) {
              strictMode = false;
            }
            if (ua) {
              _bowser = detect(ua);
            }
            var version2 = "" + _bowser.version;
            for (var browser in minVersions) {
              if (minVersions.hasOwnProperty(browser)) {
                if (_bowser[browser]) {
                  if (typeof minVersions[browser] !== "string") {
                    throw new Error("Browser version in the minVersion map should be a string: " + browser + ": " + String(minVersions));
                  }
                  return compareVersions([version2, minVersions[browser]]) < 0;
                }
              }
            }
            return strictMode;
          }
          function check(minVersions, strictMode, ua) {
            return !isUnsupportedBrowser(minVersions, strictMode, ua);
          }
          bowser.isUnsupportedBrowser = isUnsupportedBrowser;
          bowser.compareVersions = compareVersions;
          bowser.check = check;
          bowser._detect = detect;
          bowser.detect = detect;
          return bowser;
        });
      }, {}], 89: [function(require2, module2, exports2) {
      }, {}], 90: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            var base64 = require2("base64-js");
            var ieee754 = require2("ieee754");
            exports2.Buffer = Buffer3;
            exports2.SlowBuffer = SlowBuffer;
            exports2.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports2.kMaxLength = K_MAX_LENGTH;
            Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } };
                return arr.foo() === 42;
              } catch (e2) {
                return false;
              }
            }
            Object.defineProperty(Buffer3.prototype, "parent", { enumerable: true, get: function() {
              if (!Buffer3.isBuffer(this))
                return void 0;
              return this.buffer;
            } });
            Object.defineProperty(Buffer3.prototype, "offset", { enumerable: true, get: function() {
              if (!Buffer3.isBuffer(this))
                return void 0;
              return this.byteOffset;
            } });
            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer3.prototype;
              return buf;
            }
            function Buffer3(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer3[Symbol.species] === Buffer3) {
              Object.defineProperty(Buffer3, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false });
            }
            Buffer3.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }
              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }
              if (value == null) {
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
              }
              if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              }
              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer3.from(valueOf, encodingOrOffset, length);
              }
              var b2 = fromObject(value);
              if (b2)
                return b2;
              if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
              }
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            }
            Buffer3.from = function(value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };
            Buffer3.prototype.__proto__ = Uint8Array.prototype;
            Buffer3.__proto__ = Uint8Array;
            function assertSize(size2) {
              if (typeof size2 !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size2 < 0) {
                throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
              }
            }
            function alloc(size2, fill, encoding) {
              assertSize(size2);
              if (size2 <= 0) {
                return createBuffer(size2);
              }
              if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
              }
              return createBuffer(size2);
            }
            Buffer3.alloc = function(size2, fill, encoding) {
              return alloc(size2, fill, encoding);
            };
            function allocUnsafe(size2) {
              assertSize(size2);
              return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
            }
            Buffer3.allocUnsafe = function(size2) {
              return allocUnsafe(size2);
            };
            Buffer3.allocUnsafeSlow = function(size2) {
              return allocUnsafe(size2);
            };
            function fromString(string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }
              if (!Buffer3.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              var length = byteLength(string, encoding) | 0;
              var buf = createBuffer(length);
              var actual = buf.write(string, encoding);
              if (actual !== length) {
                buf = buf.slice(0, actual);
              }
              return buf;
            }
            function fromArrayLike(array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              var buf = createBuffer(length);
              for (var i3 = 0; i3 < length; i3 += 1) {
                buf[i3] = array[i3] & 255;
              }
              return buf;
            }
            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }
              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }
              var buf;
              if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array);
              } else if (length === void 0) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }
              buf.__proto__ = Buffer3.prototype;
              return buf;
            }
            function fromObject(obj) {
              if (Buffer3.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);
                if (buf.length === 0) {
                  return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
              }
              if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }
              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }
            function checked(length) {
              if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer3.alloc(+length);
            }
            Buffer3.isBuffer = function isBuffer2(b2) {
              return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
            };
            Buffer3.compare = function compare2(a2, b2) {
              if (isInstance(a2, Uint8Array))
                a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
              if (isInstance(b2, Uint8Array))
                b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
              if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b2)) {
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              }
              if (a2 === b2)
                return 0;
              var x2 = a2.length;
              var y3 = b2.length;
              for (var i3 = 0, len = Math.min(x2, y3); i3 < len; ++i3) {
                if (a2[i3] !== b2[i3]) {
                  x2 = a2[i3];
                  y3 = b2[i3];
                  break;
                }
              }
              if (x2 < y3)
                return -1;
              if (y3 < x2)
                return 1;
              return 0;
            };
            Buffer3.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer3.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list.length === 0) {
                return Buffer3.alloc(0);
              }
              var i3;
              if (length === void 0) {
                length = 0;
                for (i3 = 0; i3 < list.length; ++i3) {
                  length += list[i3].length;
                }
              }
              var buffer = Buffer3.allocUnsafe(length);
              var pos = 0;
              for (i3 = 0; i3 < list.length; ++i3) {
                var buf = list[i3];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer3.from(buf);
                }
                if (!Buffer3.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength(string, encoding) {
              if (Buffer3.isBuffer(string)) {
                return string.length;
              }
              if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
              }
              var len = string.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0)
                return 0;
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length;
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer3.byteLength = byteLength;
            function slowToString(encoding, start, end) {
              var loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding)
                encoding = "utf8";
              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer3.prototype._isBuffer = true;
            function swap(b2, n2, m2) {
              var i3 = b2[n2];
              b2[n2] = b2[m2];
              b2[m2] = i3;
            }
            Buffer3.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i3 = 0; i3 < len; i3 += 2) {
                swap(this, i3, i3 + 1);
              }
              return this;
            };
            Buffer3.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i3 = 0; i3 < len; i3 += 4) {
                swap(this, i3, i3 + 3);
                swap(this, i3 + 1, i3 + 2);
              }
              return this;
            };
            Buffer3.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i3 = 0; i3 < len; i3 += 8) {
                swap(this, i3, i3 + 7);
                swap(this, i3 + 1, i3 + 6);
                swap(this, i3 + 2, i3 + 5);
                swap(this, i3 + 3, i3 + 4);
              }
              return this;
            };
            Buffer3.prototype.toString = function toString3() {
              var length = this.length;
              if (length === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
            Buffer3.prototype.equals = function equals(b2) {
              if (!Buffer3.isBuffer(b2))
                throw new TypeError("Argument must be a Buffer");
              if (this === b2)
                return true;
              return Buffer3.compare(this, b2) === 0;
            };
            Buffer3.prototype.inspect = function inspect() {
              var str = "";
              var max2 = exports2.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
              if (this.length > max2)
                str += " ... ";
              return "<Buffer " + str + ">";
            };
            Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer3.from(target, target.offset, target.byteLength);
              }
              if (!Buffer3.isBuffer(target)) {
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              var x2 = thisEnd - thisStart;
              var y3 = end - start;
              var len = Math.min(x2, y3);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i3 = 0; i3 < len; ++i3) {
                if (thisCopy[i3] !== targetCopy[i3]) {
                  x2 = thisCopy[i3];
                  y3 = targetCopy[i3];
                  break;
                }
              }
              if (x2 < y3)
                return -1;
              if (y3 < x2)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
              if (buffer.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer3.from(val, encoding);
              }
              if (Buffer3.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i4) {
                if (indexSize === 1) {
                  return buf[i4];
                } else {
                  return buf.readUInt16BE(i4 * indexSize);
                }
              }
              var i3;
              if (dir) {
                var foundIndex = -1;
                for (i3 = byteOffset; i3 < arrLength; i3++) {
                  if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i3;
                    if (i3 - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i3 -= i3 - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i3 = byteOffset; i3 >= 0; i3--) {
                  var found = true;
                  for (var j2 = 0; j2 < valLength; j2++) {
                    if (read(arr, i3 + j2) !== read(val, j2)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i3;
                }
              }
              return -1;
            }
            Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset2, length) {
              offset2 = Number(offset2) || 0;
              var remaining = buf.length - offset2;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              var strLen = string.length;
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i3 = 0; i3 < length; ++i3) {
                var parsed = parseInt(string.substr(i3 * 2, 2), 16);
                if (numberIsNaN(parsed))
                  return i3;
                buf[offset2 + i3] = parsed;
              }
              return i3;
            }
            function utf8Write(buf, string, offset2, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length);
            }
            function asciiWrite(buf, string, offset2, length) {
              return blitBuffer(asciiToBytes(string), buf, offset2, length);
            }
            function latin1Write(buf, string, offset2, length) {
              return asciiWrite(buf, string, offset2, length);
            }
            function base64Write(buf, string, offset2, length) {
              return blitBuffer(base64ToBytes(string), buf, offset2, length);
            }
            function ucs2Write(buf, string, offset2, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
            }
            Buffer3.prototype.write = function write(string, offset2, length, encoding) {
              if (offset2 === void 0) {
                encoding = "utf8";
                length = this.length;
                offset2 = 0;
              } else if (length === void 0 && typeof offset2 === "string") {
                encoding = offset2;
                length = this.length;
                offset2 = 0;
              } else if (isFinite(offset2)) {
                offset2 = offset2 >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === void 0)
                    encoding = "utf8";
                } else {
                  encoding = length;
                  length = void 0;
                }
              } else {
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              }
              var remaining = this.length - offset2;
              if (length === void 0 || length > remaining)
                length = remaining;
              if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding)
                encoding = "utf8";
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset2, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset2, length);
                  case "ascii":
                    return asciiWrite(this, string, offset2, length);
                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset2, length);
                  case "base64":
                    return base64Write(this, string, offset2, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset2, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer3.prototype.toJSON = function toJSON2() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i3 = start;
              while (i3 < end) {
                var firstByte = buf[i3];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i3 + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i3 + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i3 + 1];
                      thirdByte = buf[i3 + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i3 + 1];
                      thirdByte = buf[i3 + 2];
                      fourthByte = buf[i3 + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i3 += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = "";
              var i3 = 0;
              while (i3 < len) {
                res += String.fromCharCode.apply(String, codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH));
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i3 = start; i3 < end; ++i3) {
                ret += String.fromCharCode(buf[i3] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i3 = start; i3 < end; ++i3) {
                ret += String.fromCharCode(buf[i3]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              var out = "";
              for (var i3 = start; i3 < end; ++i3) {
                out += toHex(buf[i3]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i3 = 0; i3 < bytes.length; i3 += 2) {
                res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
              }
              return res;
            }
            Buffer3.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              var newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer3.prototype;
              return newBuf;
            };
            function checkOffset(offset2, ext, length) {
              if (offset2 % 1 !== 0 || offset2 < 0)
                throw new RangeError("offset is not uint");
              if (offset2 + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
              offset2 = offset2 >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, byteLength2, this.length);
              var val = this[offset2];
              var mul = 1;
              var i3 = 0;
              while (++i3 < byteLength2 && (mul *= 256)) {
                val += this[offset2 + i3] * mul;
              }
              return val;
            };
            Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
              offset2 = offset2 >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                checkOffset(offset2, byteLength2, this.length);
              }
              var val = this[offset2 + --byteLength2];
              var mul = 1;
              while (byteLength2 > 0 && (mul *= 256)) {
                val += this[offset2 + --byteLength2] * mul;
              }
              return val;
            };
            Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 1, this.length);
              return this[offset2];
            };
            Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              return this[offset2] | this[offset2 + 1] << 8;
            };
            Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              return this[offset2] << 8 | this[offset2 + 1];
            };
            Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
            };
            Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
            };
            Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
              offset2 = offset2 >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, byteLength2, this.length);
              var val = this[offset2];
              var mul = 1;
              var i3 = 0;
              while (++i3 < byteLength2 && (mul *= 256)) {
                val += this[offset2 + i3] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
              offset2 = offset2 >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, byteLength2, this.length);
              var i3 = byteLength2;
              var mul = 1;
              var val = this[offset2 + --i3];
              while (i3 > 0 && (mul *= 256)) {
                val += this[offset2 + --i3] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 1, this.length);
              if (!(this[offset2] & 128))
                return this[offset2];
              return (255 - this[offset2] + 1) * -1;
            };
            Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              var val = this[offset2] | this[offset2 + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              var val = this[offset2 + 1] | this[offset2] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
            };
            Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
            };
            Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return ieee754.read(this, offset2, true, 23, 4);
            };
            Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return ieee754.read(this, offset2, false, 23, 4);
            };
            Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 8, this.length);
              return ieee754.read(this, offset2, true, 52, 8);
            };
            Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkOffset(offset2, 8, this.length);
              return ieee754.read(this, offset2, false, 52, 8);
            };
            function checkInt(buf, value, offset2, ext, max2, min2) {
              if (!Buffer3.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max2 || value < min2)
                throw new RangeError('"value" argument is out of bounds');
              if (offset2 + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset2, byteLength2, maxBytes, 0);
              }
              var mul = 1;
              var i3 = 0;
              this[offset2] = value & 255;
              while (++i3 < byteLength2 && (mul *= 256)) {
                this[offset2 + i3] = value / mul & 255;
              }
              return offset2 + byteLength2;
            };
            Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset2, byteLength2, maxBytes, 0);
              }
              var i3 = byteLength2 - 1;
              var mul = 1;
              this[offset2 + i3] = value & 255;
              while (--i3 >= 0 && (mul *= 256)) {
                this[offset2 + i3] = value / mul & 255;
              }
              return offset2 + byteLength2;
            };
            Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 1, 255, 0);
              this[offset2] = value & 255;
              return offset2 + 1;
            };
            Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 2, 65535, 0);
              this[offset2] = value & 255;
              this[offset2 + 1] = value >>> 8;
              return offset2 + 2;
            };
            Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 2, 65535, 0);
              this[offset2] = value >>> 8;
              this[offset2 + 1] = value & 255;
              return offset2 + 2;
            };
            Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 4, 4294967295, 0);
              this[offset2 + 3] = value >>> 24;
              this[offset2 + 2] = value >>> 16;
              this[offset2 + 1] = value >>> 8;
              this[offset2] = value & 255;
              return offset2 + 4;
            };
            Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 4, 4294967295, 0);
              this[offset2] = value >>> 24;
              this[offset2 + 1] = value >>> 16;
              this[offset2 + 2] = value >>> 8;
              this[offset2 + 3] = value & 255;
              return offset2 + 4;
            };
            Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
              }
              var i3 = 0;
              var mul = 1;
              var sub = 0;
              this[offset2] = value & 255;
              while (++i3 < byteLength2 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset2 + i3 - 1] !== 0) {
                  sub = 1;
                }
                this[offset2 + i3] = (value / mul >> 0) - sub & 255;
              }
              return offset2 + byteLength2;
            };
            Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
              }
              var i3 = byteLength2 - 1;
              var mul = 1;
              var sub = 0;
              this[offset2 + i3] = value & 255;
              while (--i3 >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset2 + i3 + 1] !== 0) {
                  sub = 1;
                }
                this[offset2 + i3] = (value / mul >> 0) - sub & 255;
              }
              return offset2 + byteLength2;
            };
            Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 1, 127, -128);
              if (value < 0)
                value = 255 + value + 1;
              this[offset2] = value & 255;
              return offset2 + 1;
            };
            Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 2, 32767, -32768);
              this[offset2] = value & 255;
              this[offset2 + 1] = value >>> 8;
              return offset2 + 2;
            };
            Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 2, 32767, -32768);
              this[offset2] = value >>> 8;
              this[offset2 + 1] = value & 255;
              return offset2 + 2;
            };
            Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 4, 2147483647, -2147483648);
              this[offset2] = value & 255;
              this[offset2 + 1] = value >>> 8;
              this[offset2 + 2] = value >>> 16;
              this[offset2 + 3] = value >>> 24;
              return offset2 + 4;
            };
            Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert)
                checkInt(this, value, offset2, 4, 2147483647, -2147483648);
              if (value < 0)
                value = 4294967295 + value + 1;
              this[offset2] = value >>> 24;
              this[offset2 + 1] = value >>> 16;
              this[offset2 + 2] = value >>> 8;
              this[offset2 + 3] = value & 255;
              return offset2 + 4;
            };
            function checkIEEE754(buf, value, offset2, ext, max2, min2) {
              if (offset2 + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset2 < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset2, littleEndian, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset2, 4);
              }
              ieee754.write(buf, value, offset2, littleEndian, 23, 4);
              return offset2 + 4;
            }
            Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
              return writeFloat(this, value, offset2, true, noAssert);
            };
            Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
              return writeFloat(this, value, offset2, false, noAssert);
            };
            function writeDouble(buf, value, offset2, littleEndian, noAssert) {
              value = +value;
              offset2 = offset2 >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset2, 8);
              }
              ieee754.write(buf, value, offset2, littleEndian, 52, 8);
              return offset2 + 8;
            }
            Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
              return writeDouble(this, value, offset2, true, noAssert);
            };
            Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
              return writeDouble(this, value, offset2, false, noAssert);
            };
            Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer3.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
              } else if (this === target && start < targetStart && targetStart < end) {
                for (var i3 = len - 1; i3 >= 0; --i3) {
                  target[i3 + targetStart] = this[i3 + start];
                }
              } else {
                Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
              }
              return len;
            };
            Buffer3.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              var i3;
              if (typeof val === "number") {
                for (i3 = start; i3 < end; ++i3) {
                  this[i3] = val;
                }
              } else {
                var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i3 = 0; i3 < end - start; ++i3) {
                  this[i3 + start] = bytes[i3 % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = str.split("=")[0];
              str = str.trim().replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function toHex(n2) {
              if (n2 < 16)
                return "0" + n2.toString(16);
              return n2.toString(16);
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i3 = 0; i3 < length; ++i3) {
                codePoint = string.charCodeAt(i3);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i3 + 1 === length) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i3 = 0; i3 < str.length; ++i3) {
                byteArray.push(str.charCodeAt(i3) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c2, hi, lo;
              var byteArray = [];
              for (var i3 = 0; i3 < str.length; ++i3) {
                if ((units -= 2) < 0)
                  break;
                c2 = str.charCodeAt(i3);
                hi = c2 >> 8;
                lo = c2 % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset2, length) {
              for (var i3 = 0; i3 < length; ++i3) {
                if (i3 + offset2 >= dst.length || i3 >= src.length)
                  break;
                dst[i3 + offset2] = src[i3];
              }
              return i3;
            }
            function isInstance(obj, type2) {
              return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
            }
            function numberIsNaN(obj) {
              return obj !== obj;
            }
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 87, "buffer": 90, "ieee754": 357 }], 91: [function(require2, module2, exports2) {
        module2.exports = { "100": "Continue", "101": "Switching Protocols", "102": "Processing", "200": "OK", "201": "Created", "202": "Accepted", "203": "Non-Authoritative Information", "204": "No Content", "205": "Reset Content", "206": "Partial Content", "207": "Multi-Status", "208": "Already Reported", "226": "IM Used", "300": "Multiple Choices", "301": "Moved Permanently", "302": "Found", "303": "See Other", "304": "Not Modified", "305": "Use Proxy", "307": "Temporary Redirect", "308": "Permanent Redirect", "400": "Bad Request", "401": "Unauthorized", "402": "Payment Required", "403": "Forbidden", "404": "Not Found", "405": "Method Not Allowed", "406": "Not Acceptable", "407": "Proxy Authentication Required", "408": "Request Timeout", "409": "Conflict", "410": "Gone", "411": "Length Required", "412": "Precondition Failed", "413": "Payload Too Large", "414": "URI Too Long", "415": "Unsupported Media Type", "416": "Range Not Satisfiable", "417": "Expectation Failed", "418": "I'm a teapot", "421": "Misdirected Request", "422": "Unprocessable Entity", "423": "Locked", "424": "Failed Dependency", "425": "Unordered Collection", "426": "Upgrade Required", "428": "Precondition Required", "429": "Too Many Requests", "431": "Request Header Fields Too Large", "451": "Unavailable For Legal Reasons", "500": "Internal Server Error", "501": "Not Implemented", "502": "Bad Gateway", "503": "Service Unavailable", "504": "Gateway Timeout", "505": "HTTP Version Not Supported", "506": "Variant Also Negotiates", "507": "Insufficient Storage", "508": "Loop Detected", "509": "Bandwidth Limit Exceeded", "510": "Not Extended", "511": "Network Authentication Required" };
      }, {}], 92: [function(require2, module2, exports2) {
        var GetIntrinsic = require2("get-intrinsic");
        var callBind = require2("./");
        var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
        module2.exports = function callBoundIntrinsic(name2, allowMissing) {
          var intrinsic = GetIntrinsic(name2, !!allowMissing);
          if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
            return callBind(intrinsic);
          }
          return intrinsic;
        };
      }, { "./": 93, "get-intrinsic": 348 }], 93: [function(require2, module2, exports2) {
        var bind2 = require2("function-bind");
        var GetIntrinsic = require2("get-intrinsic");
        var $apply = GetIntrinsic("%Function.prototype.apply%");
        var $call = GetIntrinsic("%Function.prototype.call%");
        var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
        var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
        var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
        var $max = GetIntrinsic("%Math.max%");
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
          } catch (e2) {
            $defineProperty = null;
          }
        }
        module2.exports = function callBind(originalFunction) {
          var func = $reflectApply(bind2, $call, arguments);
          if ($gOPD && $defineProperty) {
            var desc = $gOPD(func, "length");
            if (desc.configurable) {
              $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
            }
          }
          return func;
        };
        var applyBind = function applyBind2() {
          return $reflectApply(bind2, $apply, arguments);
        };
        if ($defineProperty) {
          $defineProperty(module2.exports, "apply", { value: applyBind });
        } else {
          module2.exports.apply = applyBind;
        }
      }, { "function-bind": 347, "get-intrinsic": 348 }], 94: [function(require2, module2, exports2) {
        var slice = Array.prototype.slice;
        module2.exports = Copy;
        function Copy(src, withAccess) {
          if (!(this instanceof Copy))
            return new Copy(src, withAccess);
          this.src = src;
          this._withAccess = withAccess;
        }
        Copy.prototype.withAccess = function(w2) {
          this._withAccess = w2 !== false;
          return this;
        };
        Copy.prototype.pick = function(keys) {
          if (!Array.isArray(keys)) {
            keys = slice.call(arguments);
          }
          if (keys.length) {
            this.keys = keys;
          }
          return this;
        };
        Copy.prototype.to = function(to) {
          to = to || {};
          if (!this.src)
            return to;
          var keys = this.keys || Object.keys(this.src);
          if (!this._withAccess) {
            for (var i3 = 0; i3 < keys.length; i3++) {
              key = keys[i3];
              if (to[key] !== void 0)
                continue;
              to[key] = this.src[key];
            }
            return to;
          }
          for (var i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            if (!notDefined(to, key))
              continue;
            var getter = this.src.__lookupGetter__(key);
            var setter = this.src.__lookupSetter__(key);
            if (getter)
              to.__defineGetter__(key, getter);
            if (setter)
              to.__defineSetter__(key, setter);
            if (!getter && !setter) {
              to[key] = this.src[key];
            }
          }
          return to;
        };
        Copy.prototype.toCover = function(to) {
          var keys = this.keys || Object.keys(this.src);
          for (var i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            delete to[key];
            var getter = this.src.__lookupGetter__(key);
            var setter = this.src.__lookupSetter__(key);
            if (getter)
              to.__defineGetter__(key, getter);
            if (setter)
              to.__defineSetter__(key, setter);
            if (!getter && !setter) {
              to[key] = this.src[key];
            }
          }
        };
        Copy.prototype.override = Copy.prototype.toCover;
        Copy.prototype.and = function(obj) {
          var src = {};
          this.to(src);
          this.src = obj;
          this.to(src);
          this.src = src;
          return this;
        };
        function notDefined(obj, key) {
          return obj[key] === void 0 && obj.__lookupGetter__(key) === void 0 && obj.__lookupSetter__(key) === void 0;
        }
      }, {}], 95: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var tryToString = require2("../internals/try-to-string");
        var TypeError2 = global3.TypeError;
        module2.exports = function(argument) {
          if (isCallable(argument))
            return argument;
          throw TypeError2(tryToString(argument) + " is not a function");
        };
      }, { "../internals/global": 163, "../internals/is-callable": 176, "../internals/try-to-string": 257 }], 96: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isConstructor = require2("../internals/is-constructor");
        var tryToString = require2("../internals/try-to-string");
        var TypeError2 = global3.TypeError;
        module2.exports = function(argument) {
          if (isConstructor(argument))
            return argument;
          throw TypeError2(tryToString(argument) + " is not a constructor");
        };
      }, { "../internals/global": 163, "../internals/is-constructor": 177, "../internals/try-to-string": 257 }], 97: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var String2 = global3.String;
        var TypeError2 = global3.TypeError;
        module2.exports = function(argument) {
          if (typeof argument == "object" || isCallable(argument))
            return argument;
          throw TypeError2("Can't set " + String2(argument) + " as a prototype");
        };
      }, { "../internals/global": 163, "../internals/is-callable": 176 }], 98: [function(require2, module2, exports2) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var create2 = require2("../internals/object-create");
        var definePropertyModule = require2("../internals/object-define-property");
        var UNSCOPABLES = wellKnownSymbol("unscopables");
        var ArrayPrototype = Array.prototype;
        if (ArrayPrototype[UNSCOPABLES] == void 0) {
          definePropertyModule.f(ArrayPrototype, UNSCOPABLES, { configurable: true, value: create2(null) });
        }
        module2.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };
      }, { "../internals/object-create": 196, "../internals/object-define-property": 198, "../internals/well-known-symbol": 268 }], 99: [function(require2, module2, exports2) {
        var charAt = require2("../internals/string-multibyte").charAt;
        module2.exports = function(S2, index2, unicode) {
          return index2 + (unicode ? charAt(S2, index2).length : 1);
        };
      }, { "../internals/string-multibyte": 239 }], 100: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var TypeError2 = global3.TypeError;
        module2.exports = function(it2, Prototype) {
          if (isPrototypeOf(Prototype, it2))
            return it2;
          throw TypeError2("Incorrect invocation");
        };
      }, { "../internals/global": 163, "../internals/object-is-prototype-of": 204 }], 101: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isObject2 = require2("../internals/is-object");
        var String2 = global3.String;
        var TypeError2 = global3.TypeError;
        module2.exports = function(argument) {
          if (isObject2(argument))
            return argument;
          throw TypeError2(String2(argument) + " is not an object");
        };
      }, { "../internals/global": 163, "../internals/is-object": 180 }], 102: [function(require2, module2, exports2) {
        module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
      }, {}], 103: [function(require2, module2, exports2) {
        var NATIVE_ARRAY_BUFFER = require2("../internals/array-buffer-native");
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var hasOwn = require2("../internals/has-own-property");
        var classof = require2("../internals/classof");
        var tryToString = require2("../internals/try-to-string");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var redefine = require2("../internals/redefine");
        var defineProperty = require2("../internals/object-define-property").f;
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var getPrototypeOf2 = require2("../internals/object-get-prototype-of");
        var setPrototypeOf2 = require2("../internals/object-set-prototype-of");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var uid = require2("../internals/uid");
        var Int8Array2 = global3.Int8Array;
        var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
        var Uint8ClampedArray2 = global3.Uint8ClampedArray;
        var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
        var TypedArray = Int8Array2 && getPrototypeOf2(Int8Array2);
        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf2(Int8ArrayPrototype);
        var ObjectPrototype = Object.prototype;
        var TypeError2 = global3.TypeError;
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
        var TYPED_ARRAY_CONSTRUCTOR = uid("TYPED_ARRAY_CONSTRUCTOR");
        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf2 && classof(global3.opera) !== "Opera";
        var TYPED_ARRAY_TAG_REQUIRED = false;
        var NAME, Constructor, Prototype;
        var TypedArrayConstructorsList = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 };
        var BigIntArrayConstructorsList = { BigInt64Array: 8, BigUint64Array: 8 };
        var isView = function isView2(it2) {
          if (!isObject2(it2))
            return false;
          var klass = classof(it2);
          return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
        };
        var isTypedArray2 = function(it2) {
          if (!isObject2(it2))
            return false;
          var klass = classof(it2);
          return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
        };
        var aTypedArray = function(it2) {
          if (isTypedArray2(it2))
            return it2;
          throw TypeError2("Target is not a typed array");
        };
        var aTypedArrayConstructor = function(C2) {
          if (isCallable(C2) && (!setPrototypeOf2 || isPrototypeOf(TypedArray, C2)))
            return C2;
          throw TypeError2(tryToString(C2) + " is not a typed array constructor");
        };
        var exportTypedArrayMethod = function(KEY, property, forced, options) {
          if (!DESCRIPTORS)
            return;
          if (forced)
            for (var ARRAY in TypedArrayConstructorsList) {
              var TypedArrayConstructor = global3[ARRAY];
              if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
                try {
                  delete TypedArrayConstructor.prototype[KEY];
                } catch (error) {
                  try {
                    TypedArrayConstructor.prototype[KEY] = property;
                  } catch (error2) {
                  }
                }
            }
          if (!TypedArrayPrototype[KEY] || forced) {
            redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
          }
        };
        var exportTypedArrayStaticMethod = function(KEY, property, forced) {
          var ARRAY, TypedArrayConstructor;
          if (!DESCRIPTORS)
            return;
          if (setPrototypeOf2) {
            if (forced)
              for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = global3[ARRAY];
                if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                  try {
                    delete TypedArrayConstructor[KEY];
                  } catch (error) {
                  }
              }
            if (!TypedArray[KEY] || forced) {
              try {
                return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
              } catch (error) {
              }
            } else
              return;
          }
          for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = global3[ARRAY];
            if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
              redefine(TypedArrayConstructor, KEY, property);
            }
          }
        };
        for (NAME in TypedArrayConstructorsList) {
          Constructor = global3[NAME];
          Prototype = Constructor && Constructor.prototype;
          if (Prototype)
            createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
          else
            NATIVE_ARRAY_BUFFER_VIEWS = false;
        }
        for (NAME in BigIntArrayConstructorsList) {
          Constructor = global3[NAME];
          Prototype = Constructor && Constructor.prototype;
          if (Prototype)
            createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
          TypedArray = function TypedArray2() {
            throw TypeError2("Incorrect invocation");
          };
          if (NATIVE_ARRAY_BUFFER_VIEWS)
            for (NAME in TypedArrayConstructorsList) {
              if (global3[NAME])
                setPrototypeOf2(global3[NAME], TypedArray);
            }
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
          TypedArrayPrototype = TypedArray.prototype;
          if (NATIVE_ARRAY_BUFFER_VIEWS)
            for (NAME in TypedArrayConstructorsList) {
              if (global3[NAME])
                setPrototypeOf2(global3[NAME].prototype, TypedArrayPrototype);
            }
        }
        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf2(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
          setPrototypeOf2(Uint8ClampedArrayPrototype, TypedArrayPrototype);
        }
        if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
          TYPED_ARRAY_TAG_REQUIRED = true;
          defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function() {
            return isObject2(this) ? this[TYPED_ARRAY_TAG] : void 0;
          } });
          for (NAME in TypedArrayConstructorsList)
            if (global3[NAME]) {
              createNonEnumerableProperty(global3[NAME], TYPED_ARRAY_TAG, NAME);
            }
        }
        module2.exports = { NATIVE_ARRAY_BUFFER_VIEWS, TYPED_ARRAY_CONSTRUCTOR, TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG, aTypedArray, aTypedArrayConstructor, exportTypedArrayMethod, exportTypedArrayStaticMethod, isView, isTypedArray: isTypedArray2, TypedArray, TypedArrayPrototype };
      }, { "../internals/array-buffer-native": 102, "../internals/classof": 124, "../internals/create-non-enumerable-property": 129, "../internals/descriptors": 134, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/is-callable": 176, "../internals/is-object": 180, "../internals/object-define-property": 198, "../internals/object-get-prototype-of": 203, "../internals/object-is-prototype-of": 204, "../internals/object-set-prototype-of": 208, "../internals/redefine": 222, "../internals/try-to-string": 257, "../internals/uid": 263, "../internals/well-known-symbol": 268 }], 104: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var DESCRIPTORS = require2("../internals/descriptors");
        var NATIVE_ARRAY_BUFFER = require2("../internals/array-buffer-native");
        var FunctionName = require2("../internals/function-name");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var redefineAll = require2("../internals/redefine-all");
        var fails = require2("../internals/fails");
        var anInstance = require2("../internals/an-instance");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toLength = require2("../internals/to-length");
        var toIndex = require2("../internals/to-index");
        var IEEE754 = require2("../internals/ieee754");
        var getPrototypeOf2 = require2("../internals/object-get-prototype-of");
        var setPrototypeOf2 = require2("../internals/object-set-prototype-of");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var defineProperty = require2("../internals/object-define-property").f;
        var arrayFill = require2("../internals/array-fill");
        var arraySlice = require2("../internals/array-slice-simple");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var InternalStateModule = require2("../internals/internal-state");
        var PROPER_FUNCTION_NAME = FunctionName.PROPER;
        var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var ARRAY_BUFFER = "ArrayBuffer";
        var DATA_VIEW = "DataView";
        var PROTOTYPE = "prototype";
        var WRONG_LENGTH = "Wrong length";
        var WRONG_INDEX = "Wrong index";
        var NativeArrayBuffer = global3[ARRAY_BUFFER];
        var $ArrayBuffer = NativeArrayBuffer;
        var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
        var $DataView = global3[DATA_VIEW];
        var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
        var ObjectPrototype = Object.prototype;
        var Array2 = global3.Array;
        var RangeError2 = global3.RangeError;
        var fill = uncurryThis(arrayFill);
        var reverse = uncurryThis([].reverse);
        var packIEEE754 = IEEE754.pack;
        var unpackIEEE754 = IEEE754.unpack;
        var packInt8 = function(number) {
          return [number & 255];
        };
        var packInt16 = function(number) {
          return [number & 255, number >> 8 & 255];
        };
        var packInt32 = function(number) {
          return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
        };
        var unpackInt32 = function(buffer) {
          return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
        };
        var packFloat32 = function(number) {
          return packIEEE754(number, 23, 4);
        };
        var packFloat64 = function(number) {
          return packIEEE754(number, 52, 8);
        };
        var addGetter = function(Constructor, key2) {
          defineProperty(Constructor[PROTOTYPE], key2, { get: function() {
            return getInternalState(this)[key2];
          } });
        };
        var get = function(view, count, index2, isLittleEndian) {
          var intIndex = toIndex(index2);
          var store = getInternalState(view);
          if (intIndex + count > store.byteLength)
            throw RangeError2(WRONG_INDEX);
          var bytes = getInternalState(store.buffer).bytes;
          var start = intIndex + store.byteOffset;
          var pack = arraySlice(bytes, start, start + count);
          return isLittleEndian ? pack : reverse(pack);
        };
        var set = function(view, count, index2, conversion, value, isLittleEndian) {
          var intIndex = toIndex(index2);
          var store = getInternalState(view);
          if (intIndex + count > store.byteLength)
            throw RangeError2(WRONG_INDEX);
          var bytes = getInternalState(store.buffer).bytes;
          var start = intIndex + store.byteOffset;
          var pack = conversion(+value);
          for (var i3 = 0; i3 < count; i3++)
            bytes[start + i3] = pack[isLittleEndian ? i3 : count - i3 - 1];
        };
        if (!NATIVE_ARRAY_BUFFER) {
          $ArrayBuffer = function ArrayBuffer2(length) {
            anInstance(this, ArrayBufferPrototype);
            var byteLength = toIndex(length);
            setInternalState(this, { bytes: fill(Array2(byteLength), 0), byteLength });
            if (!DESCRIPTORS)
              this.byteLength = byteLength;
          };
          ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
          $DataView = function DataView2(buffer, byteOffset, byteLength) {
            anInstance(this, DataViewPrototype);
            anInstance(buffer, ArrayBufferPrototype);
            var bufferLength = getInternalState(buffer).byteLength;
            var offset2 = toIntegerOrInfinity(byteOffset);
            if (offset2 < 0 || offset2 > bufferLength)
              throw RangeError2("Wrong offset");
            byteLength = byteLength === void 0 ? bufferLength - offset2 : toLength(byteLength);
            if (offset2 + byteLength > bufferLength)
              throw RangeError2(WRONG_LENGTH);
            setInternalState(this, { buffer, byteLength, byteOffset: offset2 });
            if (!DESCRIPTORS) {
              this.buffer = buffer;
              this.byteLength = byteLength;
              this.byteOffset = offset2;
            }
          };
          DataViewPrototype = $DataView[PROTOTYPE];
          if (DESCRIPTORS) {
            addGetter($ArrayBuffer, "byteLength");
            addGetter($DataView, "buffer");
            addGetter($DataView, "byteLength");
            addGetter($DataView, "byteOffset");
          }
          redefineAll(DataViewPrototype, { getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
          }, getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
          }, getInt16: function getInt16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          }, getUint16: function getUint16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
            return bytes[1] << 8 | bytes[0];
          }, getInt32: function getInt32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0));
          }, getUint32: function getUint32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
          }, getFloat32: function getFloat32(byteOffset) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 23);
          }, getFloat64: function getFloat64(byteOffset) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 52);
          }, setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          }, setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          }, setInt16: function setInt16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
          }, setUint16: function setUint16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
          }, setInt32: function setInt32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
          }, setUint32: function setUint32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
          }, setFloat32: function setFloat32(byteOffset, value) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : void 0);
          }, setFloat64: function setFloat64(byteOffset, value) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : void 0);
          } });
        } else {
          var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
          if (!fails(function() {
            NativeArrayBuffer(1);
          }) || !fails(function() {
            new NativeArrayBuffer(-1);
          }) || fails(function() {
            new NativeArrayBuffer();
            new NativeArrayBuffer(1.5);
            new NativeArrayBuffer(NaN);
            return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
          })) {
            $ArrayBuffer = function ArrayBuffer2(length) {
              anInstance(this, ArrayBufferPrototype);
              return new NativeArrayBuffer(toIndex(length));
            };
            $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
            for (var keys = getOwnPropertyNames(NativeArrayBuffer), j2 = 0, key; keys.length > j2; ) {
              if (!((key = keys[j2++]) in $ArrayBuffer)) {
                createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
              }
            }
            ArrayBufferPrototype.constructor = $ArrayBuffer;
          } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
          }
          if (setPrototypeOf2 && getPrototypeOf2(DataViewPrototype) !== ObjectPrototype) {
            setPrototypeOf2(DataViewPrototype, ObjectPrototype);
          }
          var testView = new $DataView(new $ArrayBuffer(2));
          var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
          testView.setInt8(0, 2147483648);
          testView.setInt8(1, 2147483649);
          if (testView.getInt8(0) || !testView.getInt8(1))
            redefineAll(DataViewPrototype, { setInt8: function setInt8(byteOffset, value) {
              $setInt8(this, byteOffset, value << 24 >> 24);
            }, setUint8: function setUint8(byteOffset, value) {
              $setInt8(this, byteOffset, value << 24 >> 24);
            } }, { unsafe: true });
        }
        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
        setToStringTag($DataView, DATA_VIEW);
        module2.exports = { ArrayBuffer: $ArrayBuffer, DataView: $DataView };
      }, { "../internals/an-instance": 100, "../internals/array-buffer-native": 102, "../internals/array-fill": 106, "../internals/array-slice-simple": 116, "../internals/create-non-enumerable-property": 129, "../internals/descriptors": 134, "../internals/fails": 150, "../internals/function-name": 156, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/ieee754": 169, "../internals/internal-state": 173, "../internals/object-define-property": 198, "../internals/object-get-own-property-names": 201, "../internals/object-get-prototype-of": 203, "../internals/object-set-prototype-of": 208, "../internals/redefine-all": 221, "../internals/set-to-string-tag": 234, "../internals/to-index": 246, "../internals/to-integer-or-infinity": 248, "../internals/to-length": 249 }], 105: [function(require2, module2, exports2) {
        var toObject = require2("../internals/to-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var min2 = Math.min;
        module2.exports = [].copyWithin || function copyWithin(target, start) {
          var O2 = toObject(this);
          var len = lengthOfArrayLike(O2);
          var to = toAbsoluteIndex(target, len);
          var from = toAbsoluteIndex(start, len);
          var end = arguments.length > 2 ? arguments[2] : void 0;
          var count = min2((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
          var inc = 1;
          if (from < to && to < from + count) {
            inc = -1;
            from += count - 1;
            to += count - 1;
          }
          while (count-- > 0) {
            if (from in O2)
              O2[to] = O2[from];
            else
              delete O2[to];
            to += inc;
            from += inc;
          }
          return O2;
        };
      }, { "../internals/length-of-array-like": 188, "../internals/to-absolute-index": 245, "../internals/to-object": 250 }], 106: [function(require2, module2, exports2) {
        var toObject = require2("../internals/to-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        module2.exports = function fill(value) {
          var O2 = toObject(this);
          var length = lengthOfArrayLike(O2);
          var argumentsLength = arguments.length;
          var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
          var end = argumentsLength > 2 ? arguments[2] : void 0;
          var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
          while (endPos > index2)
            O2[index2++] = value;
          return O2;
        };
      }, { "../internals/length-of-array-like": 188, "../internals/to-absolute-index": 245, "../internals/to-object": 250 }], 107: [function(require2, module2, exports2) {
        var $forEach = require2("../internals/array-iteration").forEach;
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var STRICT_METHOD = arrayMethodIsStrict("forEach");
        module2.exports = !STRICT_METHOD ? function forEach2(callbackfn) {
          return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } : [].forEach;
      }, { "../internals/array-iteration": 111, "../internals/array-method-is-strict": 114 }], 108: [function(require2, module2, exports2) {
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        module2.exports = function(Constructor, list) {
          var index2 = 0;
          var length = lengthOfArrayLike(list);
          var result = new Constructor(length);
          while (length > index2)
            result[index2] = list[index2++];
          return result;
        };
      }, { "../internals/length-of-array-like": 188 }], 109: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var bind2 = require2("../internals/function-bind-context");
        var call = require2("../internals/function-call");
        var toObject = require2("../internals/to-object");
        var callWithSafeIterationClosing = require2("../internals/call-with-safe-iteration-closing");
        var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
        var isConstructor = require2("../internals/is-constructor");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var createProperty = require2("../internals/create-property");
        var getIterator = require2("../internals/get-iterator");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var Array2 = global3.Array;
        module2.exports = function from(arrayLike) {
          var O2 = toObject(arrayLike);
          var IS_CONSTRUCTOR = isConstructor(this);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          if (mapping)
            mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
          var iteratorMethod = getIteratorMethod(O2);
          var index2 = 0;
          var length, result, step, iterator, next, value;
          if (iteratorMethod && !(this == Array2 && isArrayIteratorMethod(iteratorMethod))) {
            iterator = getIterator(O2, iteratorMethod);
            next = iterator.next;
            result = IS_CONSTRUCTOR ? new this() : [];
            for (; !(step = call(next, iterator)).done; index2++) {
              value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
              createProperty(result, index2, value);
            }
          } else {
            length = lengthOfArrayLike(O2);
            result = IS_CONSTRUCTOR ? new this(length) : Array2(length);
            for (; length > index2; index2++) {
              value = mapping ? mapfn(O2[index2], index2) : O2[index2];
              createProperty(result, index2, value);
            }
          }
          result.length = index2;
          return result;
        };
      }, { "../internals/call-with-safe-iteration-closing": 121, "../internals/create-property": 131, "../internals/function-bind-context": 153, "../internals/function-call": 155, "../internals/get-iterator": 160, "../internals/get-iterator-method": 159, "../internals/global": 163, "../internals/is-array-iterator-method": 174, "../internals/is-constructor": 177, "../internals/length-of-array-like": 188, "../internals/to-object": 250 }], 110: [function(require2, module2, exports2) {
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O2 = toIndexedObject($this);
            var length = lengthOfArrayLike(O2);
            var index2 = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el != el)
              while (length > index2) {
                value = O2[index2++];
                if (value != value)
                  return true;
              }
            else
              for (; length > index2; index2++) {
                if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
                  return IS_INCLUDES || index2 || 0;
              }
            return !IS_INCLUDES && -1;
          };
        };
        module2.exports = {
          // `Array.prototype.includes` method
          // https://tc39.es/ecma262/#sec-array.prototype.includes
          includes: createMethod(true),
          // `Array.prototype.indexOf` method
          // https://tc39.es/ecma262/#sec-array.prototype.indexof
          indexOf: createMethod(false)
        };
      }, { "../internals/length-of-array-like": 188, "../internals/to-absolute-index": 245, "../internals/to-indexed-object": 247 }], 111: [function(require2, module2, exports2) {
        var bind2 = require2("../internals/function-bind-context");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var IndexedObject = require2("../internals/indexed-object");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var arraySpeciesCreate = require2("../internals/array-species-create");
        var push = uncurryThis([].push);
        var createMethod = function(TYPE) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var IS_FILTER_REJECT = TYPE == 7;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            var O2 = toObject($this);
            var self2 = IndexedObject(O2);
            var boundFunction = bind2(callbackfn, that);
            var length = lengthOfArrayLike(self2);
            var index2 = 0;
            var create2 = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
            var value, result;
            for (; length > index2; index2++)
              if (NO_HOLES || index2 in self2) {
                value = self2[index2];
                result = boundFunction(value, index2, O2);
                if (TYPE) {
                  if (IS_MAP)
                    target[index2] = result;
                  else if (result)
                    switch (TYPE) {
                      case 3:
                        return true;
                      case 5:
                        return value;
                      case 6:
                        return index2;
                      case 2:
                        push(target, value);
                    }
                  else
                    switch (TYPE) {
                      case 4:
                        return false;
                      case 7:
                        push(target, value);
                    }
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };
        module2.exports = {
          // `Array.prototype.forEach` method
          // https://tc39.es/ecma262/#sec-array.prototype.foreach
          forEach: createMethod(0),
          // `Array.prototype.map` method
          // https://tc39.es/ecma262/#sec-array.prototype.map
          map: createMethod(1),
          // `Array.prototype.filter` method
          // https://tc39.es/ecma262/#sec-array.prototype.filter
          filter: createMethod(2),
          // `Array.prototype.some` method
          // https://tc39.es/ecma262/#sec-array.prototype.some
          some: createMethod(3),
          // `Array.prototype.every` method
          // https://tc39.es/ecma262/#sec-array.prototype.every
          every: createMethod(4),
          // `Array.prototype.find` method
          // https://tc39.es/ecma262/#sec-array.prototype.find
          find: createMethod(5),
          // `Array.prototype.findIndex` method
          // https://tc39.es/ecma262/#sec-array.prototype.findIndex
          findIndex: createMethod(6),
          // `Array.prototype.filterReject` method
          // https://github.com/tc39/proposal-array-filtering
          filterReject: createMethod(7)
        };
      }, { "../internals/array-species-create": 120, "../internals/function-bind-context": 153, "../internals/function-uncurry-this": 157, "../internals/indexed-object": 170, "../internals/length-of-array-like": 188, "../internals/to-object": 250 }], 112: [function(require2, module2, exports2) {
        var apply2 = require2("../internals/function-apply");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var min2 = Math.min;
        var $lastIndexOf = [].lastIndexOf;
        var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
        var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
        module2.exports = FORCED ? function lastIndexOf(searchElement) {
          if (NEGATIVE_ZERO)
            return apply2($lastIndexOf, this, arguments) || 0;
          var O2 = toIndexedObject(this);
          var length = lengthOfArrayLike(O2);
          var index2 = length - 1;
          if (arguments.length > 1)
            index2 = min2(index2, toIntegerOrInfinity(arguments[1]));
          if (index2 < 0)
            index2 = length + index2;
          for (; index2 >= 0; index2--)
            if (index2 in O2 && O2[index2] === searchElement)
              return index2 || 0;
          return -1;
        } : $lastIndexOf;
      }, { "../internals/array-method-is-strict": 114, "../internals/function-apply": 152, "../internals/length-of-array-like": 188, "../internals/to-indexed-object": 247, "../internals/to-integer-or-infinity": 248 }], 113: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var V8_VERSION = require2("../internals/engine-v8-version");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(METHOD_NAME) {
          return V8_VERSION >= 51 || !fails(function() {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES] = function() {
              return { foo: 1 };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
          });
        };
      }, { "../internals/engine-v8-version": 146, "../internals/fails": 150, "../internals/well-known-symbol": 268 }], 114: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        module2.exports = function(METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return !!method && fails(function() {
            method.call(null, argument || function() {
              return 1;
            }, 1);
          });
        };
      }, { "../internals/fails": 150 }], 115: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var aCallable = require2("../internals/a-callable");
        var toObject = require2("../internals/to-object");
        var IndexedObject = require2("../internals/indexed-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var TypeError2 = global3.TypeError;
        var createMethod = function(IS_RIGHT) {
          return function(that, callbackfn, argumentsLength, memo) {
            aCallable(callbackfn);
            var O2 = toObject(that);
            var self2 = IndexedObject(O2);
            var length = lengthOfArrayLike(O2);
            var index2 = IS_RIGHT ? length - 1 : 0;
            var i3 = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2)
              while (true) {
                if (index2 in self2) {
                  memo = self2[index2];
                  index2 += i3;
                  break;
                }
                index2 += i3;
                if (IS_RIGHT ? index2 < 0 : length <= index2) {
                  throw TypeError2("Reduce of empty array with no initial value");
                }
              }
            for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i3)
              if (index2 in self2) {
                memo = callbackfn(memo, self2[index2], index2, O2);
              }
            return memo;
          };
        };
        module2.exports = {
          // `Array.prototype.reduce` method
          // https://tc39.es/ecma262/#sec-array.prototype.reduce
          left: createMethod(false),
          // `Array.prototype.reduceRight` method
          // https://tc39.es/ecma262/#sec-array.prototype.reduceright
          right: createMethod(true)
        };
      }, { "../internals/a-callable": 95, "../internals/global": 163, "../internals/indexed-object": 170, "../internals/length-of-array-like": 188, "../internals/to-object": 250 }], 116: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var createProperty = require2("../internals/create-property");
        var Array2 = global3.Array;
        var max2 = Math.max;
        module2.exports = function(O2, start, end) {
          var length = lengthOfArrayLike(O2);
          var k2 = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var result = Array2(max2(fin - k2, 0));
          for (var n2 = 0; k2 < fin; k2++, n2++)
            createProperty(result, n2, O2[k2]);
          result.length = n2;
          return result;
        };
      }, { "../internals/create-property": 131, "../internals/global": 163, "../internals/length-of-array-like": 188, "../internals/to-absolute-index": 245 }], 117: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        module2.exports = uncurryThis([].slice);
      }, { "../internals/function-uncurry-this": 157 }], 118: [function(require2, module2, exports2) {
        var arraySlice = require2("../internals/array-slice-simple");
        var floor = Math.floor;
        var mergeSort = function(array, comparefn) {
          var length = array.length;
          var middle = floor(length / 2);
          return length < 8 ? insertionSort(array, comparefn) : merge2(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
        };
        var insertionSort = function(array, comparefn) {
          var length = array.length;
          var i3 = 1;
          var element, j2;
          while (i3 < length) {
            j2 = i3;
            element = array[i3];
            while (j2 && comparefn(array[j2 - 1], element) > 0) {
              array[j2] = array[--j2];
            }
            if (j2 !== i3++)
              array[j2] = element;
          }
          return array;
        };
        var merge2 = function(array, left, right, comparefn) {
          var llength = left.length;
          var rlength = right.length;
          var lindex = 0;
          var rindex = 0;
          while (lindex < llength || rindex < rlength) {
            array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
          }
          return array;
        };
        module2.exports = mergeSort;
      }, { "../internals/array-slice-simple": 116 }], 119: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isArray2 = require2("../internals/is-array");
        var isConstructor = require2("../internals/is-constructor");
        var isObject2 = require2("../internals/is-object");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var SPECIES = wellKnownSymbol("species");
        var Array2 = global3.Array;
        module2.exports = function(originalArray) {
          var C2;
          if (isArray2(originalArray)) {
            C2 = originalArray.constructor;
            if (isConstructor(C2) && (C2 === Array2 || isArray2(C2.prototype)))
              C2 = void 0;
            else if (isObject2(C2)) {
              C2 = C2[SPECIES];
              if (C2 === null)
                C2 = void 0;
            }
          }
          return C2 === void 0 ? Array2 : C2;
        };
      }, { "../internals/global": 163, "../internals/is-array": 175, "../internals/is-constructor": 177, "../internals/is-object": 180, "../internals/well-known-symbol": 268 }], 120: [function(require2, module2, exports2) {
        var arraySpeciesConstructor = require2("../internals/array-species-constructor");
        module2.exports = function(originalArray, length) {
          return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
        };
      }, { "../internals/array-species-constructor": 119 }], 121: [function(require2, module2, exports2) {
        var anObject = require2("../internals/an-object");
        var iteratorClose = require2("../internals/iterator-close");
        module2.exports = function(iterator, fn, value, ENTRIES) {
          try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
        };
      }, { "../internals/an-object": 101, "../internals/iterator-close": 185 }], 122: [function(require2, module2, exports2) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        var SAFE_CLOSING = false;
        try {
          var called = 0;
          var iteratorWithReturn = { next: function() {
            return { done: !!called++ };
          }, "return": function() {
            SAFE_CLOSING = true;
          } };
          iteratorWithReturn[ITERATOR] = function() {
            return this;
          };
          Array.from(iteratorWithReturn, function() {
            throw 2;
          });
        } catch (error) {
        }
        module2.exports = function(exec, SKIP_CLOSING) {
          if (!SKIP_CLOSING && !SAFE_CLOSING)
            return false;
          var ITERATION_SUPPORT = false;
          try {
            var object = {};
            object[ITERATOR] = function() {
              return { next: function() {
                return { done: ITERATION_SUPPORT = true };
              } };
            };
            exec(object);
          } catch (error) {
          }
          return ITERATION_SUPPORT;
        };
      }, { "../internals/well-known-symbol": 268 }], 123: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toString3 = uncurryThis({}.toString);
        var stringSlice = uncurryThis("".slice);
        module2.exports = function(it2) {
          return stringSlice(toString3(it2), 8, -1);
        };
      }, { "../internals/function-uncurry-this": 157 }], 124: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
        var isCallable = require2("../internals/is-callable");
        var classofRaw = require2("../internals/classof-raw");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var Object2 = global3.Object;
        var CORRECT_ARGUMENTS = classofRaw(function() {
          return arguments;
        }()) == "Arguments";
        var tryGet = function(it2, key) {
          try {
            return it2[key];
          } catch (error) {
          }
        };
        module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
          var O2, tag, result;
          return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = Object2(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && isCallable(O2.callee) ? "Arguments" : result;
        };
      }, { "../internals/classof-raw": 123, "../internals/global": 163, "../internals/is-callable": 176, "../internals/to-string-tag-support": 255, "../internals/well-known-symbol": 268 }], 125: [function(require2, module2, exports2) {
        var hasOwn = require2("../internals/has-own-property");
        var ownKeys = require2("../internals/own-keys");
        var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
        var definePropertyModule = require2("../internals/object-define-property");
        module2.exports = function(target, source, exceptions) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
          for (var i3 = 0; i3 < keys.length; i3++) {
            var key = keys[i3];
            if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
              defineProperty(target, key, getOwnPropertyDescriptor2(source, key));
            }
          }
        };
      }, { "../internals/has-own-property": 164, "../internals/object-define-property": 198, "../internals/object-get-own-property-descriptor": 199, "../internals/own-keys": 212 }], 126: [function(require2, module2, exports2) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var MATCH = wellKnownSymbol("match");
        module2.exports = function(METHOD_NAME) {
          var regexp = /./;
          try {
            "/./"[METHOD_NAME](regexp);
          } catch (error1) {
            try {
              regexp[MATCH] = false;
              return "/./"[METHOD_NAME](regexp);
            } catch (error2) {
            }
          }
          return false;
        };
      }, { "../internals/well-known-symbol": 268 }], 127: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        module2.exports = !fails(function() {
          function F2() {
          }
          F2.prototype.constructor = null;
          return Object.getPrototypeOf(new F2()) !== F2.prototype;
        });
      }, { "../internals/fails": 150 }], 128: [function(require2, module2, exports2) {
        var IteratorPrototype = require2("../internals/iterators-core").IteratorPrototype;
        var create2 = require2("../internals/object-create");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var Iterators = require2("../internals/iterators");
        var returnThis = function() {
          return this;
        };
        module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
          var TO_STRING_TAG = NAME + " Iterator";
          IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
          setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
          Iterators[TO_STRING_TAG] = returnThis;
          return IteratorConstructor;
        };
      }, { "../internals/create-property-descriptor": 130, "../internals/iterators": 187, "../internals/iterators-core": 186, "../internals/object-create": 196, "../internals/set-to-string-tag": 234 }], 129: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var definePropertyModule = require2("../internals/object-define-property");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        module2.exports = DESCRIPTORS ? function(object, key, value) {
          return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      }, { "../internals/create-property-descriptor": 130, "../internals/descriptors": 134, "../internals/object-define-property": 198 }], 130: [function(require2, module2, exports2) {
        module2.exports = function(bitmap, value) {
          return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value };
        };
      }, {}], 131: [function(require2, module2, exports2) {
        var toPropertyKey = require2("../internals/to-property-key");
        var definePropertyModule = require2("../internals/object-define-property");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        module2.exports = function(object, key, value) {
          var propertyKey = toPropertyKey(key);
          if (propertyKey in object)
            definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
          else
            object[propertyKey] = value;
        };
      }, { "../internals/create-property-descriptor": 130, "../internals/object-define-property": 198, "../internals/to-property-key": 254 }], 132: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var call = require2("../internals/function-call");
        var IS_PURE = require2("../internals/is-pure");
        var FunctionName = require2("../internals/function-name");
        var isCallable = require2("../internals/is-callable");
        var createIteratorConstructor = require2("../internals/create-iterator-constructor");
        var getPrototypeOf2 = require2("../internals/object-get-prototype-of");
        var setPrototypeOf2 = require2("../internals/object-set-prototype-of");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var redefine = require2("../internals/redefine");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var Iterators = require2("../internals/iterators");
        var IteratorsCore = require2("../internals/iterators-core");
        var PROPER_FUNCTION_NAME = FunctionName.PROPER;
        var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
        var IteratorPrototype = IteratorsCore.IteratorPrototype;
        var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
        var ITERATOR = wellKnownSymbol("iterator");
        var KEYS = "keys";
        var VALUES = "values";
        var ENTRIES = "entries";
        var returnThis = function() {
          return this;
        };
        module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
          createIteratorConstructor(IteratorConstructor, NAME, next);
          var getIterationMethod = function(KIND) {
            if (KIND === DEFAULT && defaultIterator)
              return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
              return IterablePrototype[KIND];
            switch (KIND) {
              case KEYS:
                return function keys() {
                  return new IteratorConstructor(this, KIND);
                };
              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND);
                };
              case ENTRIES:
                return function entries2() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function() {
              return new IteratorConstructor(this);
            };
          };
          var TO_STRING_TAG = NAME + " Iterator";
          var INCORRECT_VALUES_NAME = false;
          var IterablePrototype = Iterable.prototype;
          var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
          var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
          var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
          var CurrentIteratorPrototype, methods, KEY;
          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
            if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
              if (!IS_PURE && getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf2) {
                  setPrototypeOf2(CurrentIteratorPrototype, IteratorPrototype);
                } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                  redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
              }
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
              if (IS_PURE)
                Iterators[TO_STRING_TAG] = returnThis;
            }
          }
          if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
              createNonEnumerableProperty(IterablePrototype, "name", VALUES);
            } else {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values() {
                return call(nativeIterator, this);
              };
            }
          }
          if (DEFAULT) {
            methods = { values: getIterationMethod(VALUES), keys: IS_SET ? defaultIterator : getIterationMethod(KEYS), entries: getIterationMethod(ENTRIES) };
            if (FORCED)
              for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                  redefine(IterablePrototype, KEY, methods[KEY]);
                }
              }
            else
              $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
          }
          if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
            redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
          }
          Iterators[NAME] = defaultIterator;
          return methods;
        };
      }, { "../internals/create-iterator-constructor": 128, "../internals/create-non-enumerable-property": 129, "../internals/export": 149, "../internals/function-call": 155, "../internals/function-name": 156, "../internals/is-callable": 176, "../internals/is-pure": 181, "../internals/iterators": 187, "../internals/iterators-core": 186, "../internals/object-get-prototype-of": 203, "../internals/object-set-prototype-of": 208, "../internals/redefine": 222, "../internals/set-to-string-tag": 234, "../internals/well-known-symbol": 268 }], 133: [function(require2, module2, exports2) {
        var path = require2("../internals/path");
        var hasOwn = require2("../internals/has-own-property");
        var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
        var defineProperty = require2("../internals/object-define-property").f;
        module2.exports = function(NAME) {
          var Symbol2 = path.Symbol || (path.Symbol = {});
          if (!hasOwn(Symbol2, NAME))
            defineProperty(Symbol2, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) });
        };
      }, { "../internals/has-own-property": 164, "../internals/object-define-property": 198, "../internals/path": 213, "../internals/well-known-symbol-wrapped": 267 }], 134: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        module2.exports = !fails(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      }, { "../internals/fails": 150 }], 135: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isObject2 = require2("../internals/is-object");
        var document2 = global3.document;
        var EXISTS = isObject2(document2) && isObject2(document2.createElement);
        module2.exports = function(it2) {
          return EXISTS ? document2.createElement(it2) : {};
        };
      }, { "../internals/global": 163, "../internals/is-object": 180 }], 136: [function(require2, module2, exports2) {
        module2.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
      }, {}], 137: [function(require2, module2, exports2) {
        var documentCreateElement = require2("../internals/document-create-element");
        var classList2 = documentCreateElement("span").classList;
        var DOMTokenListPrototype = classList2 && classList2.constructor && classList2.constructor.prototype;
        module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
      }, { "../internals/document-create-element": 135 }], 138: [function(require2, module2, exports2) {
        var userAgent2 = require2("../internals/engine-user-agent");
        var firefox = userAgent2.match(/firefox\/(\d+)/i);
        module2.exports = !!firefox && +firefox[1];
      }, { "../internals/engine-user-agent": 145 }], 139: [function(require2, module2, exports2) {
        module2.exports = typeof window == "object" && typeof Deno != "object";
      }, {}], 140: [function(require2, module2, exports2) {
        var UA = require2("../internals/engine-user-agent");
        module2.exports = /MSIE|Trident/.test(UA);
      }, { "../internals/engine-user-agent": 145 }], 141: [function(require2, module2, exports2) {
        var userAgent2 = require2("../internals/engine-user-agent");
        var global3 = require2("../internals/global");
        module2.exports = /ipad|iphone|ipod/i.test(userAgent2) && global3.Pebble !== void 0;
      }, { "../internals/engine-user-agent": 145, "../internals/global": 163 }], 142: [function(require2, module2, exports2) {
        var userAgent2 = require2("../internals/engine-user-agent");
        module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent2);
      }, { "../internals/engine-user-agent": 145 }], 143: [function(require2, module2, exports2) {
        var classof = require2("../internals/classof-raw");
        var global3 = require2("../internals/global");
        module2.exports = classof(global3.process) == "process";
      }, { "../internals/classof-raw": 123, "../internals/global": 163 }], 144: [function(require2, module2, exports2) {
        var userAgent2 = require2("../internals/engine-user-agent");
        module2.exports = /web0s(?!.*chrome)/i.test(userAgent2);
      }, { "../internals/engine-user-agent": 145 }], 145: [function(require2, module2, exports2) {
        var getBuiltIn = require2("../internals/get-built-in");
        module2.exports = getBuiltIn("navigator", "userAgent") || "";
      }, { "../internals/get-built-in": 158 }], 146: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var userAgent2 = require2("../internals/engine-user-agent");
        var process = global3.process;
        var Deno2 = global3.Deno;
        var versions = process && process.versions || Deno2 && Deno2.version;
        var v8 = versions && versions.v8;
        var match, version2;
        if (v8) {
          match = v8.split(".");
          version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
        }
        if (!version2 && userAgent2) {
          match = userAgent2.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent2.match(/Chrome\/(\d+)/);
            if (match)
              version2 = +match[1];
          }
        }
        module2.exports = version2;
      }, { "../internals/engine-user-agent": 145, "../internals/global": 163 }], 147: [function(require2, module2, exports2) {
        var userAgent2 = require2("../internals/engine-user-agent");
        var webkit = userAgent2.match(/AppleWebKit\/(\d+)\./);
        module2.exports = !!webkit && +webkit[1];
      }, { "../internals/engine-user-agent": 145 }], 148: [function(require2, module2, exports2) {
        module2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, {}], 149: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var getOwnPropertyDescriptor2 = require2("../internals/object-get-own-property-descriptor").f;
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var redefine = require2("../internals/redefine");
        var setGlobal = require2("../internals/set-global");
        var copyConstructorProperties = require2("../internals/copy-constructor-properties");
        var isForced = require2("../internals/is-forced");
        module2.exports = function(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global3;
          } else if (STATIC) {
            target = global3[TARGET] || setGlobal(TARGET, {});
          } else {
            target = (global3[TARGET] || {}).prototype;
          }
          if (target)
            for (key in source) {
              sourceProperty = source[key];
              if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor2(target, key);
                targetProperty = descriptor && descriptor.value;
              } else
                targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty == typeof targetProperty)
                  continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              redefine(target, key, sourceProperty, options);
            }
        };
      }, { "../internals/copy-constructor-properties": 125, "../internals/create-non-enumerable-property": 129, "../internals/global": 163, "../internals/is-forced": 178, "../internals/object-get-own-property-descriptor": 199, "../internals/redefine": 222, "../internals/set-global": 232 }], 150: [function(require2, module2, exports2) {
        module2.exports = function(exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };
      }, {}], 151: [function(require2, module2, exports2) {
        require2("../modules/es.regexp.exec");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var redefine = require2("../internals/redefine");
        var regexpExec = require2("../internals/regexp-exec");
        var fails = require2("../internals/fails");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var SPECIES = wellKnownSymbol("species");
        var RegExpPrototype = RegExp.prototype;
        module2.exports = function(KEY, exec, FORCED, SHAM) {
          var SYMBOL = wellKnownSymbol(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function() {
            var O2 = {};
            O2[SYMBOL] = function() {
              return 7;
            };
            return ""[KEY](O2) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
            var execCalled = false;
            var re2 = /a/;
            if (KEY === "split") {
              re2 = {};
              re2.constructor = {};
              re2.constructor[SPECIES] = function() {
                return re2;
              };
              re2.flags = "";
              re2[SYMBOL] = /./[SYMBOL];
            }
            re2.exec = function() {
              execCalled = true;
              return null;
            };
            re2[SYMBOL]("");
            return !execCalled;
          });
          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
            var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
            var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
              var uncurriedNativeMethod = uncurryThis(nativeMethod);
              var $exec = regexp.exec;
              if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
                }
                return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
              }
              return { done: false };
            });
            redefine(String.prototype, KEY, methods[0]);
            redefine(RegExpPrototype, SYMBOL, methods[1]);
          }
          if (SHAM)
            createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
        };
      }, { "../internals/create-non-enumerable-property": 129, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/redefine": 222, "../internals/regexp-exec": 224, "../internals/well-known-symbol": 268, "../modules/es.regexp.exec": 300 }], 152: [function(require2, module2, exports2) {
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var FunctionPrototype = Function.prototype;
        var apply2 = FunctionPrototype.apply;
        var call = FunctionPrototype.call;
        module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply2) : function() {
          return call.apply(apply2, arguments);
        });
      }, { "../internals/function-bind-native": 154 }], 153: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var aCallable = require2("../internals/a-callable");
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var bind2 = uncurryThis(uncurryThis.bind);
        module2.exports = function(fn, that) {
          aCallable(fn);
          return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
            return fn.apply(that, arguments);
          };
        };
      }, { "../internals/a-callable": 95, "../internals/function-bind-native": 154, "../internals/function-uncurry-this": 157 }], 154: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        module2.exports = !fails(function() {
          var test = (function() {
          }).bind();
          return typeof test != "function" || test.hasOwnProperty("prototype");
        });
      }, { "../internals/fails": 150 }], 155: [function(require2, module2, exports2) {
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var call = Function.prototype.call;
        module2.exports = NATIVE_BIND ? call.bind(call) : function() {
          return call.apply(call, arguments);
        };
      }, { "../internals/function-bind-native": 154 }], 156: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var hasOwn = require2("../internals/has-own-property");
        var FunctionPrototype = Function.prototype;
        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
        var EXISTS = hasOwn(FunctionPrototype, "name");
        var PROPER = EXISTS && (function something() {
        }).name === "something";
        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
        module2.exports = { EXISTS, PROPER, CONFIGURABLE };
      }, { "../internals/descriptors": 134, "../internals/has-own-property": 164 }], 157: [function(require2, module2, exports2) {
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var FunctionPrototype = Function.prototype;
        var bind2 = FunctionPrototype.bind;
        var call = FunctionPrototype.call;
        var uncurryThis = NATIVE_BIND && bind2.bind(call, call);
        module2.exports = NATIVE_BIND ? function(fn) {
          return fn && uncurryThis(fn);
        } : function(fn) {
          return fn && function() {
            return call.apply(fn, arguments);
          };
        };
      }, { "../internals/function-bind-native": 154 }], 158: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var aFunction = function(argument) {
          return isCallable(argument) ? argument : void 0;
        };
        module2.exports = function(namespace, method) {
          return arguments.length < 2 ? aFunction(global3[namespace]) : global3[namespace] && global3[namespace][method];
        };
      }, { "../internals/global": 163, "../internals/is-callable": 176 }], 159: [function(require2, module2, exports2) {
        var classof = require2("../internals/classof");
        var getMethod = require2("../internals/get-method");
        var Iterators = require2("../internals/iterators");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        module2.exports = function(it2) {
          if (it2 != void 0)
            return getMethod(it2, ITERATOR) || getMethod(it2, "@@iterator") || Iterators[classof(it2)];
        };
      }, { "../internals/classof": 124, "../internals/get-method": 161, "../internals/iterators": 187, "../internals/well-known-symbol": 268 }], 160: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var aCallable = require2("../internals/a-callable");
        var anObject = require2("../internals/an-object");
        var tryToString = require2("../internals/try-to-string");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var TypeError2 = global3.TypeError;
        module2.exports = function(argument, usingIterator) {
          var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
          if (aCallable(iteratorMethod))
            return anObject(call(iteratorMethod, argument));
          throw TypeError2(tryToString(argument) + " is not iterable");
        };
      }, { "../internals/a-callable": 95, "../internals/an-object": 101, "../internals/function-call": 155, "../internals/get-iterator-method": 159, "../internals/global": 163, "../internals/try-to-string": 257 }], 161: [function(require2, module2, exports2) {
        var aCallable = require2("../internals/a-callable");
        module2.exports = function(V2, P2) {
          var func = V2[P2];
          return func == null ? void 0 : aCallable(func);
        };
      }, { "../internals/a-callable": 95 }], 162: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toObject = require2("../internals/to-object");
        var floor = Math.floor;
        var charAt = uncurryThis("".charAt);
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
        module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
          var tailPos = position + matched.length;
          var m2 = captures.length;
          var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
          if (namedCaptures !== void 0) {
            namedCaptures = toObject(namedCaptures);
            symbols = SUBSTITUTION_SYMBOLS;
          }
          return replace(replacement, symbols, function(match, ch) {
            var capture;
            switch (charAt(ch, 0)) {
              case "$":
                return "$";
              case "&":
                return matched;
              case "`":
                return stringSlice(str, 0, position);
              case "'":
                return stringSlice(str, tailPos);
              case "<":
                capture = namedCaptures[stringSlice(ch, 1, -1)];
                break;
              default:
                var n2 = +ch;
                if (n2 === 0)
                  return match;
                if (n2 > m2) {
                  var f2 = floor(n2 / 10);
                  if (f2 === 0)
                    return match;
                  if (f2 <= m2)
                    return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
                  return match;
                }
                capture = captures[n2 - 1];
            }
            return capture === void 0 ? "" : capture;
          });
        };
      }, { "../internals/function-uncurry-this": 157, "../internals/to-object": 250 }], 163: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            var check = function(it2) {
              return it2 && it2.Math == Math && it2;
            };
            module2.exports = // eslint-disable-next-line es-x/no-global-this -- safe
            check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
            check(typeof self == "object" && self) || check(typeof global3 == "object" && global3) || // eslint-disable-next-line no-new-func -- fallback
            function() {
              return this;
            }() || Function("return this")();
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 164: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toObject = require2("../internals/to-object");
        var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
        module2.exports = Object.hasOwn || function hasOwn(it2, key) {
          return hasOwnProperty2(toObject(it2), key);
        };
      }, { "../internals/function-uncurry-this": 157, "../internals/to-object": 250 }], 165: [function(require2, module2, exports2) {
        module2.exports = {};
      }, {}], 166: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        module2.exports = function(a2, b2) {
          var console2 = global3.console;
          if (console2 && console2.error) {
            arguments.length == 1 ? console2.error(a2) : console2.error(a2, b2);
          }
        };
      }, { "../internals/global": 163 }], 167: [function(require2, module2, exports2) {
        var getBuiltIn = require2("../internals/get-built-in");
        module2.exports = getBuiltIn("document", "documentElement");
      }, { "../internals/get-built-in": 158 }], 168: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var fails = require2("../internals/fails");
        var createElement = require2("../internals/document-create-element");
        module2.exports = !DESCRIPTORS && !fails(function() {
          return Object.defineProperty(createElement("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }, { "../internals/descriptors": 134, "../internals/document-create-element": 135, "../internals/fails": 150 }], 169: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var Array2 = global3.Array;
        var abs = Math.abs;
        var pow = Math.pow;
        var floor = Math.floor;
        var log = Math.log;
        var LN2 = Math.LN2;
        var pack = function(number, mantissaLength, bytes) {
          var buffer = Array2(bytes);
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var rt2 = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
          var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
          var index2 = 0;
          var exponent, mantissa, c2;
          number = abs(number);
          if (number != number || number === Infinity) {
            mantissa = number != number ? 1 : 0;
            exponent = eMax;
          } else {
            exponent = floor(log(number) / LN2);
            c2 = pow(2, -exponent);
            if (number * c2 < 1) {
              exponent--;
              c2 *= 2;
            }
            if (exponent + eBias >= 1) {
              number += rt2 / c2;
            } else {
              number += rt2 * pow(2, 1 - eBias);
            }
            if (number * c2 >= 2) {
              exponent++;
              c2 /= 2;
            }
            if (exponent + eBias >= eMax) {
              mantissa = 0;
              exponent = eMax;
            } else if (exponent + eBias >= 1) {
              mantissa = (number * c2 - 1) * pow(2, mantissaLength);
              exponent = exponent + eBias;
            } else {
              mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
              exponent = 0;
            }
          }
          while (mantissaLength >= 8) {
            buffer[index2++] = mantissa & 255;
            mantissa /= 256;
            mantissaLength -= 8;
          }
          exponent = exponent << mantissaLength | mantissa;
          exponentLength += mantissaLength;
          while (exponentLength > 0) {
            buffer[index2++] = exponent & 255;
            exponent /= 256;
            exponentLength -= 8;
          }
          buffer[--index2] |= sign * 128;
          return buffer;
        };
        var unpack = function(buffer, mantissaLength) {
          var bytes = buffer.length;
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var nBits = exponentLength - 7;
          var index2 = bytes - 1;
          var sign = buffer[index2--];
          var exponent = sign & 127;
          var mantissa;
          sign >>= 7;
          while (nBits > 0) {
            exponent = exponent * 256 + buffer[index2--];
            nBits -= 8;
          }
          mantissa = exponent & (1 << -nBits) - 1;
          exponent >>= -nBits;
          nBits += mantissaLength;
          while (nBits > 0) {
            mantissa = mantissa * 256 + buffer[index2--];
            nBits -= 8;
          }
          if (exponent === 0) {
            exponent = 1 - eBias;
          } else if (exponent === eMax) {
            return mantissa ? NaN : sign ? -Infinity : Infinity;
          } else {
            mantissa = mantissa + pow(2, mantissaLength);
            exponent = exponent - eBias;
          }
          return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
        };
        module2.exports = { pack, unpack };
      }, { "../internals/global": 163 }], 170: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var classof = require2("../internals/classof-raw");
        var Object2 = global3.Object;
        var split = uncurryThis("".split);
        module2.exports = fails(function() {
          return !Object2("z").propertyIsEnumerable(0);
        }) ? function(it2) {
          return classof(it2) == "String" ? split(it2, "") : Object2(it2);
        } : Object2;
      }, { "../internals/classof-raw": 123, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/global": 163 }], 171: [function(require2, module2, exports2) {
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var setPrototypeOf2 = require2("../internals/object-set-prototype-of");
        module2.exports = function($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (
            // it can work only with native `setPrototypeOf`
            setPrototypeOf2 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
            isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
          )
            setPrototypeOf2($this, NewTargetPrototype);
          return $this;
        };
      }, { "../internals/is-callable": 176, "../internals/is-object": 180, "../internals/object-set-prototype-of": 208 }], 172: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isCallable = require2("../internals/is-callable");
        var store = require2("../internals/shared-store");
        var functionToString = uncurryThis(Function.toString);
        if (!isCallable(store.inspectSource)) {
          store.inspectSource = function(it2) {
            return functionToString(it2);
          };
        }
        module2.exports = store.inspectSource;
      }, { "../internals/function-uncurry-this": 157, "../internals/is-callable": 176, "../internals/shared-store": 236 }], 173: [function(require2, module2, exports2) {
        var NATIVE_WEAK_MAP = require2("../internals/native-weak-map");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isObject2 = require2("../internals/is-object");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var hasOwn = require2("../internals/has-own-property");
        var shared = require2("../internals/shared-store");
        var sharedKey = require2("../internals/shared-key");
        var hiddenKeys = require2("../internals/hidden-keys");
        var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
        var TypeError2 = global3.TypeError;
        var WeakMap2 = global3.WeakMap;
        var set, get, has;
        var enforce = function(it2) {
          return has(it2) ? get(it2) : set(it2, {});
        };
        var getterFor = function(TYPE) {
          return function(it2) {
            var state;
            if (!isObject2(it2) || (state = get(it2)).type !== TYPE) {
              throw TypeError2("Incompatible receiver, " + TYPE + " required");
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP || shared.state) {
          var store = shared.state || (shared.state = new WeakMap2());
          var wmget = uncurryThis(store.get);
          var wmhas = uncurryThis(store.has);
          var wmset = uncurryThis(store.set);
          set = function(it2, metadata) {
            if (wmhas(store, it2))
              throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it2;
            wmset(store, it2, metadata);
            return metadata;
          };
          get = function(it2) {
            return wmget(store, it2) || {};
          };
          has = function(it2) {
            return wmhas(store, it2);
          };
        } else {
          var STATE = sharedKey("state");
          hiddenKeys[STATE] = true;
          set = function(it2, metadata) {
            if (hasOwn(it2, STATE))
              throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it2;
            createNonEnumerableProperty(it2, STATE, metadata);
            return metadata;
          };
          get = function(it2) {
            return hasOwn(it2, STATE) ? it2[STATE] : {};
          };
          has = function(it2) {
            return hasOwn(it2, STATE);
          };
        }
        module2.exports = { set, get, has, enforce, getterFor };
      }, { "../internals/create-non-enumerable-property": 129, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/hidden-keys": 165, "../internals/is-object": 180, "../internals/native-weak-map": 192, "../internals/shared-key": 235, "../internals/shared-store": 236 }], 174: [function(require2, module2, exports2) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var Iterators = require2("../internals/iterators");
        var ITERATOR = wellKnownSymbol("iterator");
        var ArrayPrototype = Array.prototype;
        module2.exports = function(it2) {
          return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
        };
      }, { "../internals/iterators": 187, "../internals/well-known-symbol": 268 }], 175: [function(require2, module2, exports2) {
        var classof = require2("../internals/classof-raw");
        module2.exports = Array.isArray || function isArray2(argument) {
          return classof(argument) == "Array";
        };
      }, { "../internals/classof-raw": 123 }], 176: [function(require2, module2, exports2) {
        module2.exports = function(argument) {
          return typeof argument == "function";
        };
      }, {}], 177: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var classof = require2("../internals/classof");
        var getBuiltIn = require2("../internals/get-built-in");
        var inspectSource = require2("../internals/inspect-source");
        var noop2 = function() {
        };
        var empty = [];
        var construct2 = getBuiltIn("Reflect", "construct");
        var constructorRegExp = /^\s*(?:class|function)\b/;
        var exec = uncurryThis(constructorRegExp.exec);
        var INCORRECT_TO_STRING = !constructorRegExp.exec(noop2);
        var isConstructorModern = function isConstructor(argument) {
          if (!isCallable(argument))
            return false;
          try {
            construct2(noop2, empty, argument);
            return true;
          } catch (error) {
            return false;
          }
        };
        var isConstructorLegacy = function isConstructor(argument) {
          if (!isCallable(argument))
            return false;
          switch (classof(argument)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
          } catch (error) {
            return true;
          }
        };
        isConstructorLegacy.sham = true;
        module2.exports = !construct2 || fails(function() {
          var called;
          return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
            called = true;
          }) || called;
        }) ? isConstructorLegacy : isConstructorModern;
      }, { "../internals/classof": 124, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/get-built-in": 158, "../internals/inspect-source": 172, "../internals/is-callable": 176 }], 178: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var replacement = /#|\.prototype\./;
        var isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
        };
        var normalize = isForced.normalize = function(string) {
          return String(string).replace(replacement, ".").toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = "N";
        var POLYFILL = isForced.POLYFILL = "P";
        module2.exports = isForced;
      }, { "../internals/fails": 150, "../internals/is-callable": 176 }], 179: [function(require2, module2, exports2) {
        var isObject2 = require2("../internals/is-object");
        var floor = Math.floor;
        module2.exports = Number.isInteger || function isInteger(it2) {
          return !isObject2(it2) && isFinite(it2) && floor(it2) === it2;
        };
      }, { "../internals/is-object": 180 }], 180: [function(require2, module2, exports2) {
        var isCallable = require2("../internals/is-callable");
        module2.exports = function(it2) {
          return typeof it2 == "object" ? it2 !== null : isCallable(it2);
        };
      }, { "../internals/is-callable": 176 }], 181: [function(require2, module2, exports2) {
        module2.exports = false;
      }, {}], 182: [function(require2, module2, exports2) {
        var isObject2 = require2("../internals/is-object");
        var classof = require2("../internals/classof-raw");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var MATCH = wellKnownSymbol("match");
        module2.exports = function(it2) {
          var isRegExp2;
          return isObject2(it2) && ((isRegExp2 = it2[MATCH]) !== void 0 ? !!isRegExp2 : classof(it2) == "RegExp");
        };
      }, { "../internals/classof-raw": 123, "../internals/is-object": 180, "../internals/well-known-symbol": 268 }], 183: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var getBuiltIn = require2("../internals/get-built-in");
        var isCallable = require2("../internals/is-callable");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
        var Object2 = global3.Object;
        module2.exports = USE_SYMBOL_AS_UID ? function(it2) {
          return typeof it2 == "symbol";
        } : function(it2) {
          var $Symbol = getBuiltIn("Symbol");
          return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object2(it2));
        };
      }, { "../internals/get-built-in": 158, "../internals/global": 163, "../internals/is-callable": 176, "../internals/object-is-prototype-of": 204, "../internals/use-symbol-as-uid": 264 }], 184: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var bind2 = require2("../internals/function-bind-context");
        var call = require2("../internals/function-call");
        var anObject = require2("../internals/an-object");
        var tryToString = require2("../internals/try-to-string");
        var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var getIterator = require2("../internals/get-iterator");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var iteratorClose = require2("../internals/iterator-close");
        var TypeError2 = global3.TypeError;
        var Result = function(stopped, result) {
          this.stopped = stopped;
          this.result = result;
        };
        var ResultPrototype = Result.prototype;
        module2.exports = function(iterable, unboundFunction, options) {
          var that = options && options.that;
          var AS_ENTRIES = !!(options && options.AS_ENTRIES);
          var IS_ITERATOR = !!(options && options.IS_ITERATOR);
          var INTERRUPTED = !!(options && options.INTERRUPTED);
          var fn = bind2(unboundFunction, that);
          var iterator, iterFn, index2, length, result, next, step;
          var stop = function(condition) {
            if (iterator)
              iteratorClose(iterator, "normal", condition);
            return new Result(true, condition);
          };
          var callFn = function(value) {
            if (AS_ENTRIES) {
              anObject(value);
              return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
            }
            return INTERRUPTED ? fn(value, stop) : fn(value);
          };
          if (IS_ITERATOR) {
            iterator = iterable;
          } else {
            iterFn = getIteratorMethod(iterable);
            if (!iterFn)
              throw TypeError2(tryToString(iterable) + " is not iterable");
            if (isArrayIteratorMethod(iterFn)) {
              for (index2 = 0, length = lengthOfArrayLike(iterable); length > index2; index2++) {
                result = callFn(iterable[index2]);
                if (result && isPrototypeOf(ResultPrototype, result))
                  return result;
              }
              return new Result(false);
            }
            iterator = getIterator(iterable, iterFn);
          }
          next = iterator.next;
          while (!(step = call(next, iterator)).done) {
            try {
              result = callFn(step.value);
            } catch (error) {
              iteratorClose(iterator, "throw", error);
            }
            if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        };
      }, { "../internals/an-object": 101, "../internals/function-bind-context": 153, "../internals/function-call": 155, "../internals/get-iterator": 160, "../internals/get-iterator-method": 159, "../internals/global": 163, "../internals/is-array-iterator-method": 174, "../internals/iterator-close": 185, "../internals/length-of-array-like": 188, "../internals/object-is-prototype-of": 204, "../internals/try-to-string": 257 }], 185: [function(require2, module2, exports2) {
        var call = require2("../internals/function-call");
        var anObject = require2("../internals/an-object");
        var getMethod = require2("../internals/get-method");
        module2.exports = function(iterator, kind, value) {
          var innerResult, innerError;
          anObject(iterator);
          try {
            innerResult = getMethod(iterator, "return");
            if (!innerResult) {
              if (kind === "throw")
                throw value;
              return value;
            }
            innerResult = call(innerResult, iterator);
          } catch (error) {
            innerError = true;
            innerResult = error;
          }
          if (kind === "throw")
            throw value;
          if (innerError)
            throw innerResult;
          anObject(innerResult);
          return value;
        };
      }, { "../internals/an-object": 101, "../internals/function-call": 155, "../internals/get-method": 161 }], 186: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var create2 = require2("../internals/object-create");
        var getPrototypeOf2 = require2("../internals/object-get-prototype-of");
        var redefine = require2("../internals/redefine");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var IS_PURE = require2("../internals/is-pure");
        var ITERATOR = wellKnownSymbol("iterator");
        var BUGGY_SAFARI_ITERATORS = false;
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
        if ([].keys) {
          arrayIterator = [].keys();
          if (!("next" in arrayIterator))
            BUGGY_SAFARI_ITERATORS = true;
          else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf2(getPrototypeOf2(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
              IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }
        var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
          var test = {};
          return IteratorPrototype[ITERATOR].call(test) !== test;
        });
        if (NEW_ITERATOR_PROTOTYPE)
          IteratorPrototype = {};
        else if (IS_PURE)
          IteratorPrototype = create2(IteratorPrototype);
        if (!isCallable(IteratorPrototype[ITERATOR])) {
          redefine(IteratorPrototype, ITERATOR, function() {
            return this;
          });
        }
        module2.exports = { IteratorPrototype, BUGGY_SAFARI_ITERATORS };
      }, { "../internals/fails": 150, "../internals/is-callable": 176, "../internals/is-pure": 181, "../internals/object-create": 196, "../internals/object-get-prototype-of": 203, "../internals/redefine": 222, "../internals/well-known-symbol": 268 }], 187: [function(require2, module2, exports2) {
        arguments[4][165][0].apply(exports2, arguments);
      }, { "dup": 165 }], 188: [function(require2, module2, exports2) {
        var toLength = require2("../internals/to-length");
        module2.exports = function(obj) {
          return toLength(obj.length);
        };
      }, { "../internals/to-length": 249 }], 189: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var bind2 = require2("../internals/function-bind-context");
        var getOwnPropertyDescriptor2 = require2("../internals/object-get-own-property-descriptor").f;
        var macrotask = require2("../internals/task").set;
        var IS_IOS = require2("../internals/engine-is-ios");
        var IS_IOS_PEBBLE = require2("../internals/engine-is-ios-pebble");
        var IS_WEBOS_WEBKIT = require2("../internals/engine-is-webos-webkit");
        var IS_NODE = require2("../internals/engine-is-node");
        var MutationObserver2 = global3.MutationObserver || global3.WebKitMutationObserver;
        var document2 = global3.document;
        var process = global3.process;
        var Promise2 = global3.Promise;
        var queueMicrotaskDescriptor = getOwnPropertyDescriptor2(global3, "queueMicrotask");
        var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
        var flush, head, last, notify, toggle, node2, promise2, then;
        if (!queueMicrotask) {
          flush = function() {
            var parent, fn;
            if (IS_NODE && (parent = process.domain))
              parent.exit();
            while (head) {
              fn = head.fn;
              head = head.next;
              try {
                fn();
              } catch (error) {
                if (head)
                  notify();
                else
                  last = void 0;
                throw error;
              }
            }
            last = void 0;
            if (parent)
              parent.enter();
          };
          if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver2 && document2) {
            toggle = true;
            node2 = document2.createTextNode("");
            new MutationObserver2(flush).observe(node2, { characterData: true });
            notify = function() {
              node2.data = toggle = !toggle;
            };
          } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
            promise2 = Promise2.resolve(void 0);
            promise2.constructor = Promise2;
            then = bind2(promise2.then, promise2);
            notify = function() {
              then(flush);
            };
          } else if (IS_NODE) {
            notify = function() {
              process.nextTick(flush);
            };
          } else {
            macrotask = bind2(macrotask, global3);
            notify = function() {
              macrotask(flush);
            };
          }
        }
        module2.exports = queueMicrotask || function(fn) {
          var task = { fn, next: void 0 };
          if (last)
            last.next = task;
          if (!head) {
            head = task;
            notify();
          }
          last = task;
        };
      }, { "../internals/engine-is-ios": 142, "../internals/engine-is-ios-pebble": 141, "../internals/engine-is-node": 143, "../internals/engine-is-webos-webkit": 144, "../internals/function-bind-context": 153, "../internals/global": 163, "../internals/object-get-own-property-descriptor": 199, "../internals/task": 243 }], 190: [function(require2, module2, exports2) {
        var NATIVE_SYMBOL = require2("../internals/native-symbol");
        module2.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
      }, { "../internals/native-symbol": 191 }], 191: [function(require2, module2, exports2) {
        var V8_VERSION = require2("../internals/engine-v8-version");
        var fails = require2("../internals/fails");
        module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
          var symbol = Symbol();
          return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
          !Symbol.sham && V8_VERSION && V8_VERSION < 41;
        });
      }, { "../internals/engine-v8-version": 146, "../internals/fails": 150 }], 192: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var inspectSource = require2("../internals/inspect-source");
        var WeakMap2 = global3.WeakMap;
        module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
      }, { "../internals/global": 163, "../internals/inspect-source": 172, "../internals/is-callable": 176 }], 193: [function(require2, module2, exports2) {
        var aCallable = require2("../internals/a-callable");
        var PromiseCapability = function(C2) {
          var resolve, reject;
          this.promise = new C2(function($$resolve, $$reject) {
            if (resolve !== void 0 || reject !== void 0)
              throw TypeError("Bad Promise constructor");
            resolve = $$resolve;
            reject = $$reject;
          });
          this.resolve = aCallable(resolve);
          this.reject = aCallable(reject);
        };
        module2.exports.f = function(C2) {
          return new PromiseCapability(C2);
        };
      }, { "../internals/a-callable": 95 }], 194: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isRegExp2 = require2("../internals/is-regexp");
        var TypeError2 = global3.TypeError;
        module2.exports = function(it2) {
          if (isRegExp2(it2)) {
            throw TypeError2("The method doesn't accept regular expressions");
          }
          return it2;
        };
      }, { "../internals/global": 163, "../internals/is-regexp": 182 }], 195: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var call = require2("../internals/function-call");
        var fails = require2("../internals/fails");
        var objectKeys = require2("../internals/object-keys");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
        var toObject = require2("../internals/to-object");
        var IndexedObject = require2("../internals/indexed-object");
        var $assign = Object.assign;
        var defineProperty = Object.defineProperty;
        var concat = uncurryThis([].concat);
        module2.exports = !$assign || fails(function() {
          if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", { enumerable: true, get: function() {
            defineProperty(this, "b", { value: 3, enumerable: false });
          } }), { b: 2 })).b !== 1)
            return true;
          var A2 = {};
          var B2 = {};
          var symbol = Symbol();
          var alphabet = "abcdefghijklmnopqrst";
          A2[symbol] = 7;
          alphabet.split("").forEach(function(chr) {
            B2[chr] = chr;
          });
          return $assign({}, A2)[symbol] != 7 || objectKeys($assign({}, B2)).join("") != alphabet;
        }) ? function assign(target, source) {
          var T2 = toObject(target);
          var argumentsLength = arguments.length;
          var index2 = 1;
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          var propertyIsEnumerable = propertyIsEnumerableModule.f;
          while (argumentsLength > index2) {
            var S2 = IndexedObject(arguments[index2++]);
            var keys = getOwnPropertySymbols ? concat(objectKeys(S2), getOwnPropertySymbols(S2)) : objectKeys(S2);
            var length = keys.length;
            var j2 = 0;
            var key;
            while (length > j2) {
              key = keys[j2++];
              if (!DESCRIPTORS || call(propertyIsEnumerable, S2, key))
                T2[key] = S2[key];
            }
          }
          return T2;
        } : $assign;
      }, { "../internals/descriptors": 134, "../internals/fails": 150, "../internals/function-call": 155, "../internals/function-uncurry-this": 157, "../internals/indexed-object": 170, "../internals/object-get-own-property-symbols": 202, "../internals/object-keys": 206, "../internals/object-property-is-enumerable": 207, "../internals/to-object": 250 }], 196: [function(require2, module2, exports2) {
        var anObject = require2("../internals/an-object");
        var definePropertiesModule = require2("../internals/object-define-properties");
        var enumBugKeys = require2("../internals/enum-bug-keys");
        var hiddenKeys = require2("../internals/hidden-keys");
        var html2 = require2("../internals/html");
        var documentCreateElement = require2("../internals/document-create-element");
        var sharedKey = require2("../internals/shared-key");
        var GT = ">";
        var LT = "<";
        var PROTOTYPE = "prototype";
        var SCRIPT = "script";
        var IE_PROTO = sharedKey("IE_PROTO");
        var EmptyConstructor = function() {
        };
        var scriptTag = function(content) {
          return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
        };
        var NullProtoObjectViaActiveX = function(activeXDocument2) {
          activeXDocument2.write(scriptTag(""));
          activeXDocument2.close();
          var temp = activeXDocument2.parentWindow.Object;
          activeXDocument2 = null;
          return temp;
        };
        var NullProtoObjectViaIFrame = function() {
          var iframe = documentCreateElement("iframe");
          var JS = "java" + SCRIPT + ":";
          var iframeDocument;
          iframe.style.display = "none";
          html2.appendChild(iframe);
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag("document.F=Object"));
          iframeDocument.close();
          return iframeDocument.F;
        };
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            activeXDocument = new ActiveXObject("htmlfile");
          } catch (error) {
          }
          NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
          var length = enumBugKeys.length;
          while (length--)
            delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;
        module2.exports = Object.create || function create2(O2, Properties) {
          var result;
          if (O2 !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O2);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O2;
          } else
            result = NullProtoObject();
          return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
        };
      }, { "../internals/an-object": 101, "../internals/document-create-element": 135, "../internals/enum-bug-keys": 148, "../internals/hidden-keys": 165, "../internals/html": 167, "../internals/object-define-properties": 197, "../internals/shared-key": 235 }], 197: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var V8_PROTOTYPE_DEFINE_BUG = require2("../internals/v8-prototype-define-bug");
        var definePropertyModule = require2("../internals/object-define-property");
        var anObject = require2("../internals/an-object");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var objectKeys = require2("../internals/object-keys");
        exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
          anObject(O2);
          var props = toIndexedObject(Properties);
          var keys = objectKeys(Properties);
          var length = keys.length;
          var index2 = 0;
          var key;
          while (length > index2)
            definePropertyModule.f(O2, key = keys[index2++], props[key]);
          return O2;
        };
      }, { "../internals/an-object": 101, "../internals/descriptors": 134, "../internals/object-define-property": 198, "../internals/object-keys": 206, "../internals/to-indexed-object": 247, "../internals/v8-prototype-define-bug": 265 }], 198: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var DESCRIPTORS = require2("../internals/descriptors");
        var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
        var V8_PROTOTYPE_DEFINE_BUG = require2("../internals/v8-prototype-define-bug");
        var anObject = require2("../internals/an-object");
        var toPropertyKey = require2("../internals/to-property-key");
        var TypeError2 = global3.TypeError;
        var $defineProperty = Object.defineProperty;
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var ENUMERABLE = "enumerable";
        var CONFIGURABLE = "configurable";
        var WRITABLE = "writable";
        exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P2, Attributes) {
          anObject(O2);
          P2 = toPropertyKey(P2);
          anObject(Attributes);
          if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
            var current = $getOwnPropertyDescriptor(O2, P2);
            if (current && current[WRITABLE]) {
              O2[P2] = Attributes.value;
              Attributes = { configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE], enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE], writable: false };
            }
          }
          return $defineProperty(O2, P2, Attributes);
        } : $defineProperty : function defineProperty(O2, P2, Attributes) {
          anObject(O2);
          P2 = toPropertyKey(P2);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return $defineProperty(O2, P2, Attributes);
            } catch (error) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError2("Accessors not supported");
          if ("value" in Attributes)
            O2[P2] = Attributes.value;
          return O2;
        };
      }, { "../internals/an-object": 101, "../internals/descriptors": 134, "../internals/global": 163, "../internals/ie8-dom-define": 168, "../internals/to-property-key": 254, "../internals/v8-prototype-define-bug": 265 }], 199: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var call = require2("../internals/function-call");
        var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toPropertyKey = require2("../internals/to-property-key");
        var hasOwn = require2("../internals/has-own-property");
        var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O2, P2) {
          O2 = toIndexedObject(O2);
          P2 = toPropertyKey(P2);
          if (IE8_DOM_DEFINE)
            try {
              return $getOwnPropertyDescriptor(O2, P2);
            } catch (error) {
            }
          if (hasOwn(O2, P2))
            return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
        };
      }, { "../internals/create-property-descriptor": 130, "../internals/descriptors": 134, "../internals/function-call": 155, "../internals/has-own-property": 164, "../internals/ie8-dom-define": 168, "../internals/object-property-is-enumerable": 207, "../internals/to-indexed-object": 247, "../internals/to-property-key": 254 }], 200: [function(require2, module2, exports2) {
        var classof = require2("../internals/classof-raw");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var $getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var arraySlice = require2("../internals/array-slice-simple");
        var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function(it2) {
          try {
            return $getOwnPropertyNames(it2);
          } catch (error) {
            return arraySlice(windowNames);
          }
        };
        module2.exports.f = function getOwnPropertyNames(it2) {
          return windowNames && classof(it2) == "Window" ? getWindowNames(it2) : $getOwnPropertyNames(toIndexedObject(it2));
        };
      }, { "../internals/array-slice-simple": 116, "../internals/classof-raw": 123, "../internals/object-get-own-property-names": 201, "../internals/to-indexed-object": 247 }], 201: [function(require2, module2, exports2) {
        var internalObjectKeys = require2("../internals/object-keys-internal");
        var enumBugKeys = require2("../internals/enum-bug-keys");
        var hiddenKeys = enumBugKeys.concat("length", "prototype");
        exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
          return internalObjectKeys(O2, hiddenKeys);
        };
      }, { "../internals/enum-bug-keys": 148, "../internals/object-keys-internal": 205 }], 202: [function(require2, module2, exports2) {
        exports2.f = Object.getOwnPropertySymbols;
      }, {}], 203: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var hasOwn = require2("../internals/has-own-property");
        var isCallable = require2("../internals/is-callable");
        var toObject = require2("../internals/to-object");
        var sharedKey = require2("../internals/shared-key");
        var CORRECT_PROTOTYPE_GETTER = require2("../internals/correct-prototype-getter");
        var IE_PROTO = sharedKey("IE_PROTO");
        var Object2 = global3.Object;
        var ObjectPrototype = Object2.prototype;
        module2.exports = CORRECT_PROTOTYPE_GETTER ? Object2.getPrototypeOf : function(O2) {
          var object = toObject(O2);
          if (hasOwn(object, IE_PROTO))
            return object[IE_PROTO];
          var constructor = object.constructor;
          if (isCallable(constructor) && object instanceof constructor) {
            return constructor.prototype;
          }
          return object instanceof Object2 ? ObjectPrototype : null;
        };
      }, { "../internals/correct-prototype-getter": 127, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/is-callable": 176, "../internals/shared-key": 235, "../internals/to-object": 250 }], 204: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        module2.exports = uncurryThis({}.isPrototypeOf);
      }, { "../internals/function-uncurry-this": 157 }], 205: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var hasOwn = require2("../internals/has-own-property");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var indexOf = require2("../internals/array-includes").indexOf;
        var hiddenKeys = require2("../internals/hidden-keys");
        var push = uncurryThis([].push);
        module2.exports = function(object, names) {
          var O2 = toIndexedObject(object);
          var i3 = 0;
          var result = [];
          var key;
          for (key in O2)
            !hasOwn(hiddenKeys, key) && hasOwn(O2, key) && push(result, key);
          while (names.length > i3)
            if (hasOwn(O2, key = names[i3++])) {
              ~indexOf(result, key) || push(result, key);
            }
          return result;
        };
      }, { "../internals/array-includes": 110, "../internals/function-uncurry-this": 157, "../internals/has-own-property": 164, "../internals/hidden-keys": 165, "../internals/to-indexed-object": 247 }], 206: [function(require2, module2, exports2) {
        var internalObjectKeys = require2("../internals/object-keys-internal");
        var enumBugKeys = require2("../internals/enum-bug-keys");
        module2.exports = Object.keys || function keys(O2) {
          return internalObjectKeys(O2, enumBugKeys);
        };
      }, { "../internals/enum-bug-keys": 148, "../internals/object-keys-internal": 205 }], 207: [function(require2, module2, exports2) {
        var $propertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
        var NASHORN_BUG = getOwnPropertyDescriptor2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
        exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
          var descriptor = getOwnPropertyDescriptor2(this, V2);
          return !!descriptor && descriptor.enumerable;
        } : $propertyIsEnumerable;
      }, {}], 208: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var anObject = require2("../internals/an-object");
        var aPossiblePrototype = require2("../internals/a-possible-prototype");
        module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var CORRECT_SETTER = false;
          var test = {};
          var setter;
          try {
            setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
            setter(test, []);
            CORRECT_SETTER = test instanceof Array;
          } catch (error) {
          }
          return function setPrototypeOf2(O2, proto) {
            anObject(O2);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER)
              setter(O2, proto);
            else
              O2.__proto__ = proto;
            return O2;
          };
        }() : void 0);
      }, { "../internals/a-possible-prototype": 97, "../internals/an-object": 101, "../internals/function-uncurry-this": 157 }], 209: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var objectKeys = require2("../internals/object-keys");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var $propertyIsEnumerable = require2("../internals/object-property-is-enumerable").f;
        var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
        var push = uncurryThis([].push);
        var createMethod = function(TO_ENTRIES) {
          return function(it2) {
            var O2 = toIndexedObject(it2);
            var keys = objectKeys(O2);
            var length = keys.length;
            var i3 = 0;
            var result = [];
            var key;
            while (length > i3) {
              key = keys[i3++];
              if (!DESCRIPTORS || propertyIsEnumerable(O2, key)) {
                push(result, TO_ENTRIES ? [key, O2[key]] : O2[key]);
              }
            }
            return result;
          };
        };
        module2.exports = {
          // `Object.entries` method
          // https://tc39.es/ecma262/#sec-object.entries
          entries: createMethod(true),
          // `Object.values` method
          // https://tc39.es/ecma262/#sec-object.values
          values: createMethod(false)
        };
      }, { "../internals/descriptors": 134, "../internals/function-uncurry-this": 157, "../internals/object-keys": 206, "../internals/object-property-is-enumerable": 207, "../internals/to-indexed-object": 247 }], 210: [function(require2, module2, exports2) {
        var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
        var classof = require2("../internals/classof");
        module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString3() {
          return "[object " + classof(this) + "]";
        };
      }, { "../internals/classof": 124, "../internals/to-string-tag-support": 255 }], 211: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var TypeError2 = global3.TypeError;
        module2.exports = function(input, pref) {
          var fn, val;
          if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
            return val;
          if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input)))
            return val;
          if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
            return val;
          throw TypeError2("Can't convert object to primitive value");
        };
      }, { "../internals/function-call": 155, "../internals/global": 163, "../internals/is-callable": 176, "../internals/is-object": 180 }], 212: [function(require2, module2, exports2) {
        var getBuiltIn = require2("../internals/get-built-in");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var anObject = require2("../internals/an-object");
        var concat = uncurryThis([].concat);
        module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it2) {
          var keys = getOwnPropertyNamesModule.f(anObject(it2));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it2)) : keys;
        };
      }, { "../internals/an-object": 101, "../internals/function-uncurry-this": 157, "../internals/get-built-in": 158, "../internals/object-get-own-property-names": 201, "../internals/object-get-own-property-symbols": 202 }], 213: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        module2.exports = global3;
      }, { "../internals/global": 163 }], 214: [function(require2, module2, exports2) {
        module2.exports = function(exec) {
          try {
            return { error: false, value: exec() };
          } catch (error) {
            return { error: true, value: error };
          }
        };
      }, {}], 215: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var isCallable = require2("../internals/is-callable");
        var isForced = require2("../internals/is-forced");
        var inspectSource = require2("../internals/inspect-source");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var IS_BROWSER = require2("../internals/engine-is-browser");
        var IS_PURE = require2("../internals/is-pure");
        var V8_VERSION = require2("../internals/engine-v8-version");
        var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
        var SPECIES = wellKnownSymbol("species");
        var SUBCLASSING = false;
        var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global3.PromiseRejectionEvent);
        var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
          var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
          var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
          if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
            return true;
          if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
            return true;
          if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
            return false;
          var promise2 = new NativePromiseConstructor(function(resolve) {
            resolve(1);
          });
          var FakePromise = function(exec) {
            exec(function() {
            }, function() {
            });
          };
          var constructor = promise2.constructor = {};
          constructor[SPECIES] = FakePromise;
          SUBCLASSING = promise2.then(function() {
          }) instanceof FakePromise;
          if (!SUBCLASSING)
            return true;
          return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT;
        });
        module2.exports = { CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR, REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT, SUBCLASSING };
      }, { "../internals/engine-is-browser": 139, "../internals/engine-v8-version": 146, "../internals/global": 163, "../internals/inspect-source": 172, "../internals/is-callable": 176, "../internals/is-forced": 178, "../internals/is-pure": 181, "../internals/promise-native-constructor": 216, "../internals/well-known-symbol": 268 }], 216: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        module2.exports = global3.Promise;
      }, { "../internals/global": 163 }], 217: [function(require2, module2, exports2) {
        var anObject = require2("../internals/an-object");
        var isObject2 = require2("../internals/is-object");
        var newPromiseCapability = require2("../internals/new-promise-capability");
        module2.exports = function(C2, x2) {
          anObject(C2);
          if (isObject2(x2) && x2.constructor === C2)
            return x2;
          var promiseCapability = newPromiseCapability.f(C2);
          var resolve = promiseCapability.resolve;
          resolve(x2);
          return promiseCapability.promise;
        };
      }, { "../internals/an-object": 101, "../internals/is-object": 180, "../internals/new-promise-capability": 193 }], 218: [function(require2, module2, exports2) {
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        module2.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
          NativePromiseConstructor.all(iterable).then(void 0, function() {
          });
        });
      }, { "../internals/check-correctness-of-iteration": 122, "../internals/promise-constructor-detection": 215, "../internals/promise-native-constructor": 216 }], 219: [function(require2, module2, exports2) {
        var defineProperty = require2("../internals/object-define-property").f;
        module2.exports = function(Target, Source, key) {
          key in Target || defineProperty(Target, key, { configurable: true, get: function() {
            return Source[key];
          }, set: function(it2) {
            Source[key] = it2;
          } });
        };
      }, { "../internals/object-define-property": 198 }], 220: [function(require2, module2, exports2) {
        var Queue = function() {
          this.head = null;
          this.tail = null;
        };
        Queue.prototype = { add: function(item) {
          var entry = { item, next: null };
          if (this.head)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
        }, get: function() {
          var entry = this.head;
          if (entry) {
            this.head = entry.next;
            if (this.tail === entry)
              this.tail = null;
            return entry.item;
          }
        } };
        module2.exports = Queue;
      }, {}], 221: [function(require2, module2, exports2) {
        var redefine = require2("../internals/redefine");
        module2.exports = function(target, src, options) {
          for (var key in src)
            redefine(target, key, src[key], options);
          return target;
        };
      }, { "../internals/redefine": 222 }], 222: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var hasOwn = require2("../internals/has-own-property");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var setGlobal = require2("../internals/set-global");
        var inspectSource = require2("../internals/inspect-source");
        var InternalStateModule = require2("../internals/internal-state");
        var CONFIGURABLE_FUNCTION_NAME = require2("../internals/function-name").CONFIGURABLE;
        var getInternalState = InternalStateModule.get;
        var enforceInternalState = InternalStateModule.enforce;
        var TEMPLATE = String(String).split("String");
        (module2.exports = function(O2, key, value, options) {
          var unsafe = options ? !!options.unsafe : false;
          var simple = options ? !!options.enumerable : false;
          var noTargetGet = options ? !!options.noTargetGet : false;
          var name2 = options && options.name !== void 0 ? options.name : key;
          var state;
          if (isCallable(value)) {
            if (String(name2).slice(0, 7) === "Symbol(") {
              name2 = "[" + String(name2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
            }
            if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name2) {
              createNonEnumerableProperty(value, "name", name2);
            }
            state = enforceInternalState(value);
            if (!state.source) {
              state.source = TEMPLATE.join(typeof name2 == "string" ? name2 : "");
            }
          }
          if (O2 === global3) {
            if (simple)
              O2[key] = value;
            else
              setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O2[key];
          } else if (!noTargetGet && O2[key]) {
            simple = true;
          }
          if (simple)
            O2[key] = value;
          else
            createNonEnumerableProperty(O2, key, value);
        })(Function.prototype, "toString", function toString3() {
          return isCallable(this) && getInternalState(this).source || inspectSource(this);
        });
      }, { "../internals/create-non-enumerable-property": 129, "../internals/function-name": 156, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/inspect-source": 172, "../internals/internal-state": 173, "../internals/is-callable": 176, "../internals/set-global": 232 }], 223: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var anObject = require2("../internals/an-object");
        var isCallable = require2("../internals/is-callable");
        var classof = require2("../internals/classof-raw");
        var regexpExec = require2("../internals/regexp-exec");
        var TypeError2 = global3.TypeError;
        module2.exports = function(R2, S2) {
          var exec = R2.exec;
          if (isCallable(exec)) {
            var result = call(exec, R2, S2);
            if (result !== null)
              anObject(result);
            return result;
          }
          if (classof(R2) === "RegExp")
            return call(regexpExec, R2, S2);
          throw TypeError2("RegExp#exec called on incompatible receiver");
        };
      }, { "../internals/an-object": 101, "../internals/classof-raw": 123, "../internals/function-call": 155, "../internals/global": 163, "../internals/is-callable": 176, "../internals/regexp-exec": 224 }], 224: [function(require2, module2, exports2) {
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toString3 = require2("../internals/to-string");
        var regexpFlags = require2("../internals/regexp-flags");
        var stickyHelpers = require2("../internals/regexp-sticky-helpers");
        var shared = require2("../internals/shared");
        var create2 = require2("../internals/object-create");
        var getInternalState = require2("../internals/internal-state").get;
        var UNSUPPORTED_DOT_ALL = require2("../internals/regexp-unsupported-dot-all");
        var UNSUPPORTED_NCG = require2("../internals/regexp-unsupported-ncg");
        var nativeReplace = shared("native-string-replace", String.prototype.replace);
        var nativeExec = RegExp.prototype.exec;
        var patchedExec = nativeExec;
        var charAt = uncurryThis("".charAt);
        var indexOf = uncurryThis("".indexOf);
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        var UPDATES_LAST_INDEX_WRONG = function() {
          var re1 = /a/;
          var re2 = /b*/g;
          call(nativeExec, re1, "a");
          call(nativeExec, re2, "a");
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        }();
        var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
        var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
        if (PATCH) {
          patchedExec = function exec(string) {
            var re2 = this;
            var state = getInternalState(re2);
            var str = toString3(string);
            var raw = state.raw;
            var result, reCopy, lastIndex, match, i3, object, group;
            if (raw) {
              raw.lastIndex = re2.lastIndex;
              result = call(patchedExec, raw, str);
              re2.lastIndex = raw.lastIndex;
              return result;
            }
            var groups = state.groups;
            var sticky = UNSUPPORTED_Y && re2.sticky;
            var flags = call(regexpFlags, re2);
            var source = re2.source;
            var charsAdded = 0;
            var strCopy = str;
            if (sticky) {
              flags = replace(flags, "y", "");
              if (indexOf(flags, "g") === -1) {
                flags += "g";
              }
              strCopy = stringSlice(str, re2.lastIndex);
              if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt(str, re2.lastIndex - 1) !== "\n")) {
                source = "(?: " + source + ")";
                strCopy = " " + strCopy;
                charsAdded++;
              }
              reCopy = new RegExp("^(?:" + source + ")", flags);
            }
            if (NPCG_INCLUDED) {
              reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
            }
            if (UPDATES_LAST_INDEX_WRONG)
              lastIndex = re2.lastIndex;
            match = call(nativeExec, sticky ? reCopy : re2, strCopy);
            if (sticky) {
              if (match) {
                match.input = stringSlice(match.input, charsAdded);
                match[0] = stringSlice(match[0], charsAdded);
                match.index = re2.lastIndex;
                re2.lastIndex += match[0].length;
              } else
                re2.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
              re2.lastIndex = re2.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
              call(nativeReplace, match[0], reCopy, function() {
                for (i3 = 1; i3 < arguments.length - 2; i3++) {
                  if (arguments[i3] === void 0)
                    match[i3] = void 0;
                }
              });
            }
            if (match && groups) {
              match.groups = object = create2(null);
              for (i3 = 0; i3 < groups.length; i3++) {
                group = groups[i3];
                object[group[0]] = match[group[1]];
              }
            }
            return match;
          };
        }
        module2.exports = patchedExec;
      }, { "../internals/function-call": 155, "../internals/function-uncurry-this": 157, "../internals/internal-state": 173, "../internals/object-create": 196, "../internals/regexp-flags": 225, "../internals/regexp-sticky-helpers": 227, "../internals/regexp-unsupported-dot-all": 228, "../internals/regexp-unsupported-ncg": 229, "../internals/shared": 237, "../internals/to-string": 256 }], 225: [function(require2, module2, exports2) {
        var anObject = require2("../internals/an-object");
        module2.exports = function() {
          var that = anObject(this);
          var result = "";
          if (that.hasIndices)
            result += "d";
          if (that.global)
            result += "g";
          if (that.ignoreCase)
            result += "i";
          if (that.multiline)
            result += "m";
          if (that.dotAll)
            result += "s";
          if (that.unicode)
            result += "u";
          if (that.sticky)
            result += "y";
          return result;
        };
      }, { "../internals/an-object": 101 }], 226: [function(require2, module2, exports2) {
        var call = require2("../internals/function-call");
        var hasOwn = require2("../internals/has-own-property");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var regExpFlags = require2("../internals/regexp-flags");
        var RegExpPrototype = RegExp.prototype;
        module2.exports = function(R2) {
          var flags = R2.flags;
          return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R2, "flags") && isPrototypeOf(RegExpPrototype, R2) ? call(regExpFlags, R2) : flags;
        };
      }, { "../internals/function-call": 155, "../internals/has-own-property": 164, "../internals/object-is-prototype-of": 204, "../internals/regexp-flags": 225 }], 227: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $RegExp = global3.RegExp;
        var UNSUPPORTED_Y = fails(function() {
          var re2 = $RegExp("a", "y");
          re2.lastIndex = 2;
          return re2.exec("abcd") != null;
        });
        var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
          return !$RegExp("a", "y").sticky;
        });
        var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
          var re2 = $RegExp("^r", "gy");
          re2.lastIndex = 2;
          return re2.exec("str") != null;
        });
        module2.exports = { BROKEN_CARET, MISSED_STICKY, UNSUPPORTED_Y };
      }, { "../internals/fails": 150, "../internals/global": 163 }], 228: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $RegExp = global3.RegExp;
        module2.exports = fails(function() {
          var re2 = $RegExp(".", "s");
          return !(re2.dotAll && re2.exec("\n") && re2.flags === "s");
        });
      }, { "../internals/fails": 150, "../internals/global": 163 }], 229: [function(require2, module2, exports2) {
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $RegExp = global3.RegExp;
        module2.exports = fails(function() {
          var re2 = $RegExp("(?<a>b)", "g");
          return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
        });
      }, { "../internals/fails": 150, "../internals/global": 163 }], 230: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var TypeError2 = global3.TypeError;
        module2.exports = function(it2) {
          if (it2 == void 0)
            throw TypeError2("Can't call method on " + it2);
          return it2;
        };
      }, { "../internals/global": 163 }], 231: [function(require2, module2, exports2) {
        module2.exports = Object.is || function is(x2, y3) {
          return x2 === y3 ? x2 !== 0 || 1 / x2 === 1 / y3 : x2 != x2 && y3 != y3;
        };
      }, {}], 232: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var defineProperty = Object.defineProperty;
        module2.exports = function(key, value) {
          try {
            defineProperty(global3, key, { value, configurable: true, writable: true });
          } catch (error) {
            global3[key] = value;
          }
          return value;
        };
      }, { "../internals/global": 163 }], 233: [function(require2, module2, exports2) {
        var getBuiltIn = require2("../internals/get-built-in");
        var definePropertyModule = require2("../internals/object-define-property");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var DESCRIPTORS = require2("../internals/descriptors");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(CONSTRUCTOR_NAME) {
          var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
          var defineProperty = definePropertyModule.f;
          if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
            defineProperty(Constructor, SPECIES, { configurable: true, get: function() {
              return this;
            } });
          }
        };
      }, { "../internals/descriptors": 134, "../internals/get-built-in": 158, "../internals/object-define-property": 198, "../internals/well-known-symbol": 268 }], 234: [function(require2, module2, exports2) {
        var defineProperty = require2("../internals/object-define-property").f;
        var hasOwn = require2("../internals/has-own-property");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        module2.exports = function(target, TAG, STATIC) {
          if (target && !STATIC)
            target = target.prototype;
          if (target && !hasOwn(target, TO_STRING_TAG)) {
            defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
          }
        };
      }, { "../internals/has-own-property": 164, "../internals/object-define-property": 198, "../internals/well-known-symbol": 268 }], 235: [function(require2, module2, exports2) {
        var shared = require2("../internals/shared");
        var uid = require2("../internals/uid");
        var keys = shared("keys");
        module2.exports = function(key) {
          return keys[key] || (keys[key] = uid(key));
        };
      }, { "../internals/shared": 237, "../internals/uid": 263 }], 236: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var setGlobal = require2("../internals/set-global");
        var SHARED = "__core-js_shared__";
        var store = global3[SHARED] || setGlobal(SHARED, {});
        module2.exports = store;
      }, { "../internals/global": 163, "../internals/set-global": 232 }], 237: [function(require2, module2, exports2) {
        var IS_PURE = require2("../internals/is-pure");
        var store = require2("../internals/shared-store");
        (module2.exports = function(key, value) {
          return store[key] || (store[key] = value !== void 0 ? value : {});
        })("versions", []).push({ version: "3.22.1", mode: IS_PURE ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      }, { "../internals/is-pure": 181, "../internals/shared-store": 236 }], 238: [function(require2, module2, exports2) {
        var anObject = require2("../internals/an-object");
        var aConstructor = require2("../internals/a-constructor");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(O2, defaultConstructor) {
          var C2 = anObject(O2).constructor;
          var S2;
          return C2 === void 0 || (S2 = anObject(C2)[SPECIES]) == void 0 ? defaultConstructor : aConstructor(S2);
        };
      }, { "../internals/a-constructor": 96, "../internals/an-object": 101, "../internals/well-known-symbol": 268 }], 239: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toString3 = require2("../internals/to-string");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var charAt = uncurryThis("".charAt);
        var charCodeAt = uncurryThis("".charCodeAt);
        var stringSlice = uncurryThis("".slice);
        var createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var S2 = toString3(requireObjectCoercible($this));
            var position = toIntegerOrInfinity(pos);
            var size2 = S2.length;
            var first, second;
            if (position < 0 || position >= size2)
              return CONVERT_TO_STRING ? "" : void 0;
            first = charCodeAt(S2, position);
            return first < 55296 || first > 56319 || position + 1 === size2 || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position) : first : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        };
        module2.exports = {
          // `String.prototype.codePointAt` method
          // https://tc39.es/ecma262/#sec-string.prototype.codepointat
          codeAt: createMethod(false),
          // `String.prototype.at` method
          // https://github.com/mathiasbynens/String.prototype.at
          charAt: createMethod(true)
        };
      }, { "../internals/function-uncurry-this": 157, "../internals/require-object-coercible": 230, "../internals/to-integer-or-infinity": 248, "../internals/to-string": 256 }], 240: [function(require2, module2, exports2) {
        var PROPER_FUNCTION_NAME = require2("../internals/function-name").PROPER;
        var fails = require2("../internals/fails");
        var whitespaces = require2("../internals/whitespaces");
        var non = "​᠎";
        module2.exports = function(METHOD_NAME) {
          return fails(function() {
            return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
          });
        };
      }, { "../internals/fails": 150, "../internals/function-name": 156, "../internals/whitespaces": 269 }], 241: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var toString3 = require2("../internals/to-string");
        var whitespaces = require2("../internals/whitespaces");
        var replace = uncurryThis("".replace);
        var whitespace = "[" + whitespaces + "]";
        var ltrim = RegExp("^" + whitespace + whitespace + "*");
        var rtrim2 = RegExp(whitespace + whitespace + "*$");
        var createMethod = function(TYPE) {
          return function($this) {
            var string = toString3(requireObjectCoercible($this));
            if (TYPE & 1)
              string = replace(string, ltrim, "");
            if (TYPE & 2)
              string = replace(string, rtrim2, "");
            return string;
          };
        };
        module2.exports = {
          // `String.prototype.{ trimLeft, trimStart }` methods
          // https://tc39.es/ecma262/#sec-string.prototype.trimstart
          start: createMethod(1),
          // `String.prototype.{ trimRight, trimEnd }` methods
          // https://tc39.es/ecma262/#sec-string.prototype.trimend
          end: createMethod(2),
          // `String.prototype.trim` method
          // https://tc39.es/ecma262/#sec-string.prototype.trim
          trim: createMethod(3)
        };
      }, { "../internals/function-uncurry-this": 157, "../internals/require-object-coercible": 230, "../internals/to-string": 256, "../internals/whitespaces": 269 }], 242: [function(require2, module2, exports2) {
        var call = require2("../internals/function-call");
        var getBuiltIn = require2("../internals/get-built-in");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var redefine = require2("../internals/redefine");
        module2.exports = function() {
          var Symbol2 = getBuiltIn("Symbol");
          var SymbolPrototype = Symbol2 && Symbol2.prototype;
          var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
            redefine(SymbolPrototype, TO_PRIMITIVE, function(hint) {
              return call(valueOf, this);
            });
          }
        };
      }, { "../internals/function-call": 155, "../internals/get-built-in": 158, "../internals/redefine": 222, "../internals/well-known-symbol": 268 }], 243: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var apply2 = require2("../internals/function-apply");
        var bind2 = require2("../internals/function-bind-context");
        var isCallable = require2("../internals/is-callable");
        var hasOwn = require2("../internals/has-own-property");
        var fails = require2("../internals/fails");
        var html2 = require2("../internals/html");
        var arraySlice = require2("../internals/array-slice");
        var createElement = require2("../internals/document-create-element");
        var validateArgumentsLength = require2("../internals/validate-arguments-length");
        var IS_IOS = require2("../internals/engine-is-ios");
        var IS_NODE = require2("../internals/engine-is-node");
        var set = global3.setImmediate;
        var clear = global3.clearImmediate;
        var process = global3.process;
        var Dispatch = global3.Dispatch;
        var Function2 = global3.Function;
        var MessageChannel = global3.MessageChannel;
        var String2 = global3.String;
        var counter = 0;
        var queue2 = {};
        var ONREADYSTATECHANGE = "onreadystatechange";
        var location2, defer, channel, port;
        try {
          location2 = global3.location;
        } catch (error) {
        }
        var run = function(id) {
          if (hasOwn(queue2, id)) {
            var fn = queue2[id];
            delete queue2[id];
            fn();
          }
        };
        var runner = function(id) {
          return function() {
            run(id);
          };
        };
        var listener = function(event) {
          run(event.data);
        };
        var post = function(id) {
          global3.postMessage(String2(id), location2.protocol + "//" + location2.host);
        };
        if (!set || !clear) {
          set = function setImmediate(handler) {
            validateArgumentsLength(arguments.length, 1);
            var fn = isCallable(handler) ? handler : Function2(handler);
            var args = arraySlice(arguments, 1);
            queue2[++counter] = function() {
              apply2(fn, void 0, args);
            };
            defer(counter);
            return counter;
          };
          clear = function clearImmediate(id) {
            delete queue2[id];
          };
          if (IS_NODE) {
            defer = function(id) {
              process.nextTick(runner(id));
            };
          } else if (Dispatch && Dispatch.now) {
            defer = function(id) {
              Dispatch.now(runner(id));
            };
          } else if (MessageChannel && !IS_IOS) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = bind2(port.postMessage, port);
          } else if (global3.addEventListener && isCallable(global3.postMessage) && !global3.importScripts && location2 && location2.protocol !== "file:" && !fails(post)) {
            defer = post;
            global3.addEventListener("message", listener, false);
          } else if (ONREADYSTATECHANGE in createElement("script")) {
            defer = function(id) {
              html2.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                html2.removeChild(this);
                run(id);
              };
            };
          } else {
            defer = function(id) {
              setTimeout(runner(id), 0);
            };
          }
        }
        module2.exports = { set, clear };
      }, { "../internals/array-slice": 117, "../internals/document-create-element": 135, "../internals/engine-is-ios": 142, "../internals/engine-is-node": 143, "../internals/fails": 150, "../internals/function-apply": 152, "../internals/function-bind-context": 153, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/html": 167, "../internals/is-callable": 176, "../internals/validate-arguments-length": 266 }], 244: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        module2.exports = uncurryThis(1 .valueOf);
      }, { "../internals/function-uncurry-this": 157 }], 245: [function(require2, module2, exports2) {
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var max2 = Math.max;
        var min2 = Math.min;
        module2.exports = function(index2, length) {
          var integer = toIntegerOrInfinity(index2);
          return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
        };
      }, { "../internals/to-integer-or-infinity": 248 }], 246: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toLength = require2("../internals/to-length");
        var RangeError2 = global3.RangeError;
        module2.exports = function(it2) {
          if (it2 === void 0)
            return 0;
          var number = toIntegerOrInfinity(it2);
          var length = toLength(number);
          if (number !== length)
            throw RangeError2("Wrong length or index");
          return length;
        };
      }, { "../internals/global": 163, "../internals/to-integer-or-infinity": 248, "../internals/to-length": 249 }], 247: [function(require2, module2, exports2) {
        var IndexedObject = require2("../internals/indexed-object");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        module2.exports = function(it2) {
          return IndexedObject(requireObjectCoercible(it2));
        };
      }, { "../internals/indexed-object": 170, "../internals/require-object-coercible": 230 }], 248: [function(require2, module2, exports2) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module2.exports = function(argument) {
          var number = +argument;
          return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
        };
      }, {}], 249: [function(require2, module2, exports2) {
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var min2 = Math.min;
        module2.exports = function(argument) {
          return argument > 0 ? min2(toIntegerOrInfinity(argument), 9007199254740991) : 0;
        };
      }, { "../internals/to-integer-or-infinity": 248 }], 250: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var Object2 = global3.Object;
        module2.exports = function(argument) {
          return Object2(requireObjectCoercible(argument));
        };
      }, { "../internals/global": 163, "../internals/require-object-coercible": 230 }], 251: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var toPositiveInteger = require2("../internals/to-positive-integer");
        var RangeError2 = global3.RangeError;
        module2.exports = function(it2, BYTES) {
          var offset2 = toPositiveInteger(it2);
          if (offset2 % BYTES)
            throw RangeError2("Wrong offset");
          return offset2;
        };
      }, { "../internals/global": 163, "../internals/to-positive-integer": 252 }], 252: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var RangeError2 = global3.RangeError;
        module2.exports = function(it2) {
          var result = toIntegerOrInfinity(it2);
          if (result < 0)
            throw RangeError2("The argument can't be less than 0");
          return result;
        };
      }, { "../internals/global": 163, "../internals/to-integer-or-infinity": 248 }], 253: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var isObject2 = require2("../internals/is-object");
        var isSymbol = require2("../internals/is-symbol");
        var getMethod = require2("../internals/get-method");
        var ordinaryToPrimitive = require2("../internals/ordinary-to-primitive");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TypeError2 = global3.TypeError;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        module2.exports = function(input, pref) {
          if (!isObject2(input) || isSymbol(input))
            return input;
          var exoticToPrim = getMethod(input, TO_PRIMITIVE);
          var result;
          if (exoticToPrim) {
            if (pref === void 0)
              pref = "default";
            result = call(exoticToPrim, input, pref);
            if (!isObject2(result) || isSymbol(result))
              return result;
            throw TypeError2("Can't convert object to primitive value");
          }
          if (pref === void 0)
            pref = "number";
          return ordinaryToPrimitive(input, pref);
        };
      }, { "../internals/function-call": 155, "../internals/get-method": 161, "../internals/global": 163, "../internals/is-object": 180, "../internals/is-symbol": 183, "../internals/ordinary-to-primitive": 211, "../internals/well-known-symbol": 268 }], 254: [function(require2, module2, exports2) {
        var toPrimitive = require2("../internals/to-primitive");
        var isSymbol = require2("../internals/is-symbol");
        module2.exports = function(argument) {
          var key = toPrimitive(argument, "string");
          return isSymbol(key) ? key : key + "";
        };
      }, { "../internals/is-symbol": 183, "../internals/to-primitive": 253 }], 255: [function(require2, module2, exports2) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var test = {};
        test[TO_STRING_TAG] = "z";
        module2.exports = String(test) === "[object z]";
      }, { "../internals/well-known-symbol": 268 }], 256: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var classof = require2("../internals/classof");
        var String2 = global3.String;
        module2.exports = function(argument) {
          if (classof(argument) === "Symbol")
            throw TypeError("Cannot convert a Symbol value to a string");
          return String2(argument);
        };
      }, { "../internals/classof": 124, "../internals/global": 163 }], 257: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var String2 = global3.String;
        module2.exports = function(argument) {
          try {
            return String2(argument);
          } catch (error) {
            return "Object";
          }
        };
      }, { "../internals/global": 163 }], 258: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var DESCRIPTORS = require2("../internals/descriptors");
        var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require2("../internals/typed-array-constructors-require-wrappers");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var ArrayBufferModule = require2("../internals/array-buffer");
        var anInstance = require2("../internals/an-instance");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var isIntegralNumber = require2("../internals/is-integral-number");
        var toLength = require2("../internals/to-length");
        var toIndex = require2("../internals/to-index");
        var toOffset = require2("../internals/to-offset");
        var toPropertyKey = require2("../internals/to-property-key");
        var hasOwn = require2("../internals/has-own-property");
        var classof = require2("../internals/classof");
        var isObject2 = require2("../internals/is-object");
        var isSymbol = require2("../internals/is-symbol");
        var create2 = require2("../internals/object-create");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var setPrototypeOf2 = require2("../internals/object-set-prototype-of");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var typedArrayFrom = require2("../internals/typed-array-from");
        var forEach2 = require2("../internals/array-iteration").forEach;
        var setSpecies = require2("../internals/set-species");
        var definePropertyModule = require2("../internals/object-define-property");
        var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
        var InternalStateModule = require2("../internals/internal-state");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var round = Math.round;
        var RangeError2 = global3.RangeError;
        var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
        var ArrayBufferPrototype = ArrayBuffer2.prototype;
        var DataView2 = ArrayBufferModule.DataView;
        var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
        var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
        var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
        var TypedArray = ArrayBufferViewCore.TypedArray;
        var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var isTypedArray2 = ArrayBufferViewCore.isTypedArray;
        var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
        var WRONG_LENGTH = "Wrong length";
        var fromList = function(C2, list) {
          aTypedArrayConstructor(C2);
          var index2 = 0;
          var length = list.length;
          var result = new C2(length);
          while (length > index2)
            result[index2] = list[index2++];
          return result;
        };
        var addGetter = function(it2, key) {
          nativeDefineProperty(it2, key, { get: function() {
            return getInternalState(this)[key];
          } });
        };
        var isArrayBuffer2 = function(it2) {
          var klass;
          return isPrototypeOf(ArrayBufferPrototype, it2) || (klass = classof(it2)) == "ArrayBuffer" || klass == "SharedArrayBuffer";
        };
        var isTypedArrayIndex = function(target, key) {
          return isTypedArray2(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
        };
        var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor2(target, key) {
          key = toPropertyKey(key);
          return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
        };
        var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
          key = toPropertyKey(key);
          if (isTypedArrayIndex(target, key) && isObject2(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
            target[key] = descriptor.value;
            return target;
          }
          return nativeDefineProperty(target, key, descriptor);
        };
        if (DESCRIPTORS) {
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
            definePropertyModule.f = wrappedDefineProperty;
            addGetter(TypedArrayPrototype, "buffer");
            addGetter(TypedArrayPrototype, "byteOffset");
            addGetter(TypedArrayPrototype, "byteLength");
            addGetter(TypedArrayPrototype, "length");
          }
          $2({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, { getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor, defineProperty: wrappedDefineProperty });
          module2.exports = function(TYPE, wrapper, CLAMPED) {
            var BYTES = TYPE.match(/\d+$/)[0] / 8;
            var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
            var GETTER = "get" + TYPE;
            var SETTER = "set" + TYPE;
            var NativeTypedArrayConstructor = global3[CONSTRUCTOR_NAME];
            var TypedArrayConstructor = NativeTypedArrayConstructor;
            var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
            var exported = {};
            var getter = function(that, index2) {
              var data = getInternalState(that);
              return data.view[GETTER](index2 * BYTES + data.byteOffset, true);
            };
            var setter = function(that, index2, value) {
              var data = getInternalState(that);
              if (CLAMPED)
                value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
              data.view[SETTER](index2 * BYTES + data.byteOffset, value, true);
            };
            var addElement = function(that, index2) {
              nativeDefineProperty(that, index2, { get: function() {
                return getter(this, index2);
              }, set: function(value) {
                return setter(this, index2, value);
              }, enumerable: true });
            };
            if (!NATIVE_ARRAY_BUFFER_VIEWS) {
              TypedArrayConstructor = wrapper(function(that, data, offset2, $length) {
                anInstance(that, TypedArrayConstructorPrototype);
                var index2 = 0;
                var byteOffset = 0;
                var buffer, byteLength, length;
                if (!isObject2(data)) {
                  length = toIndex(data);
                  byteLength = length * BYTES;
                  buffer = new ArrayBuffer2(byteLength);
                } else if (isArrayBuffer2(data)) {
                  buffer = data;
                  byteOffset = toOffset(offset2, BYTES);
                  var $len = data.byteLength;
                  if ($length === void 0) {
                    if ($len % BYTES)
                      throw RangeError2(WRONG_LENGTH);
                    byteLength = $len - byteOffset;
                    if (byteLength < 0)
                      throw RangeError2(WRONG_LENGTH);
                  } else {
                    byteLength = toLength($length) * BYTES;
                    if (byteLength + byteOffset > $len)
                      throw RangeError2(WRONG_LENGTH);
                  }
                  length = byteLength / BYTES;
                } else if (isTypedArray2(data)) {
                  return fromList(TypedArrayConstructor, data);
                } else {
                  return call(typedArrayFrom, TypedArrayConstructor, data);
                }
                setInternalState(that, { buffer, byteOffset, byteLength, length, view: new DataView2(buffer) });
                while (index2 < length)
                  addElement(that, index2++);
              });
              if (setPrototypeOf2)
                setPrototypeOf2(TypedArrayConstructor, TypedArray);
              TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create2(TypedArrayPrototype);
            } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
              TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructorPrototype);
                return inheritIfRequired(function() {
                  if (!isObject2(data))
                    return new NativeTypedArrayConstructor(toIndex(data));
                  if (isArrayBuffer2(data))
                    return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                  if (isTypedArray2(data))
                    return fromList(TypedArrayConstructor, data);
                  return call(typedArrayFrom, TypedArrayConstructor, data);
                }(), dummy, TypedArrayConstructor);
              });
              if (setPrototypeOf2)
                setPrototypeOf2(TypedArrayConstructor, TypedArray);
              forEach2(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                if (!(key in TypedArrayConstructor)) {
                  createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                }
              });
              TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
            }
            if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
            }
            createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
            if (TYPED_ARRAY_TAG) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
            }
            exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
            $2({ global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
            if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
            }
            if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
            }
            setSpecies(CONSTRUCTOR_NAME);
          };
        } else
          module2.exports = function() {
          };
      }, { "../internals/an-instance": 100, "../internals/array-buffer": 104, "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111, "../internals/classof": 124, "../internals/create-non-enumerable-property": 129, "../internals/create-property-descriptor": 130, "../internals/descriptors": 134, "../internals/export": 149, "../internals/function-call": 155, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/inherit-if-required": 171, "../internals/internal-state": 173, "../internals/is-integral-number": 179, "../internals/is-object": 180, "../internals/is-symbol": 183, "../internals/object-create": 196, "../internals/object-define-property": 198, "../internals/object-get-own-property-descriptor": 199, "../internals/object-get-own-property-names": 201, "../internals/object-is-prototype-of": 204, "../internals/object-set-prototype-of": 208, "../internals/set-species": 233, "../internals/to-index": 246, "../internals/to-length": 249, "../internals/to-offset": 251, "../internals/to-property-key": 254, "../internals/typed-array-constructors-require-wrappers": 259, "../internals/typed-array-from": 261 }], 259: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var fails = require2("../internals/fails");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var NATIVE_ARRAY_BUFFER_VIEWS = require2("../internals/array-buffer-view-core").NATIVE_ARRAY_BUFFER_VIEWS;
        var ArrayBuffer2 = global3.ArrayBuffer;
        var Int8Array2 = global3.Int8Array;
        module2.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
          Int8Array2(1);
        }) || !fails(function() {
          new Int8Array2(-1);
        }) || !checkCorrectnessOfIteration(function(iterable) {
          new Int8Array2();
          new Int8Array2(null);
          new Int8Array2(1.5);
          new Int8Array2(iterable);
        }, true) || fails(function() {
          return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/check-correctness-of-iteration": 122, "../internals/fails": 150, "../internals/global": 163 }], 260: [function(require2, module2, exports2) {
        var arrayFromConstructorAndList = require2("../internals/array-from-constructor-and-list");
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        module2.exports = function(instance, list) {
          return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
        };
      }, { "../internals/array-from-constructor-and-list": 108, "../internals/typed-array-species-constructor": 262 }], 261: [function(require2, module2, exports2) {
        var bind2 = require2("../internals/function-bind-context");
        var call = require2("../internals/function-call");
        var aConstructor = require2("../internals/a-constructor");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var getIterator = require2("../internals/get-iterator");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
        var aTypedArrayConstructor = require2("../internals/array-buffer-view-core").aTypedArrayConstructor;
        module2.exports = function from(source) {
          var C2 = aConstructor(this);
          var O2 = toObject(source);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          var iteratorMethod = getIteratorMethod(O2);
          var i3, length, result, step, iterator, next;
          if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
            iterator = getIterator(O2, iteratorMethod);
            next = iterator.next;
            O2 = [];
            while (!(step = call(next, iterator)).done) {
              O2.push(step.value);
            }
          }
          if (mapping && argumentsLength > 2) {
            mapfn = bind2(mapfn, arguments[2]);
          }
          length = lengthOfArrayLike(O2);
          result = new (aTypedArrayConstructor(C2))(length);
          for (i3 = 0; length > i3; i3++) {
            result[i3] = mapping ? mapfn(O2[i3], i3) : O2[i3];
          }
          return result;
        };
      }, { "../internals/a-constructor": 96, "../internals/array-buffer-view-core": 103, "../internals/function-bind-context": 153, "../internals/function-call": 155, "../internals/get-iterator": 160, "../internals/get-iterator-method": 159, "../internals/is-array-iterator-method": 174, "../internals/length-of-array-like": 188, "../internals/to-object": 250 }], 262: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var speciesConstructor = require2("../internals/species-constructor");
        var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        module2.exports = function(originalArray) {
          return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
        };
      }, { "../internals/array-buffer-view-core": 103, "../internals/species-constructor": 238 }], 263: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var id = 0;
        var postfix = Math.random();
        var toString3 = uncurryThis(1 .toString);
        module2.exports = function(key) {
          return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString3(++id + postfix, 36);
        };
      }, { "../internals/function-uncurry-this": 157 }], 264: [function(require2, module2, exports2) {
        var NATIVE_SYMBOL = require2("../internals/native-symbol");
        module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
      }, { "../internals/native-symbol": 191 }], 265: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var fails = require2("../internals/fails");
        module2.exports = DESCRIPTORS && fails(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      }, { "../internals/descriptors": 134, "../internals/fails": 150 }], 266: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var TypeError2 = global3.TypeError;
        module2.exports = function(passed, required) {
          if (passed < required)
            throw TypeError2("Not enough arguments");
          return passed;
        };
      }, { "../internals/global": 163 }], 267: [function(require2, module2, exports2) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        exports2.f = wellKnownSymbol;
      }, { "../internals/well-known-symbol": 268 }], 268: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var shared = require2("../internals/shared");
        var hasOwn = require2("../internals/has-own-property");
        var uid = require2("../internals/uid");
        var NATIVE_SYMBOL = require2("../internals/native-symbol");
        var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
        var WellKnownSymbolsStore = shared("wks");
        var Symbol2 = global3.Symbol;
        var symbolFor = Symbol2 && Symbol2["for"];
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
        module2.exports = function(name2) {
          if (!hasOwn(WellKnownSymbolsStore, name2) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name2] == "string")) {
            var description2 = "Symbol." + name2;
            if (NATIVE_SYMBOL && hasOwn(Symbol2, name2)) {
              WellKnownSymbolsStore[name2] = Symbol2[name2];
            } else if (USE_SYMBOL_AS_UID && symbolFor) {
              WellKnownSymbolsStore[name2] = symbolFor(description2);
            } else {
              WellKnownSymbolsStore[name2] = createWellKnownSymbol(description2);
            }
          }
          return WellKnownSymbolsStore[name2];
        };
      }, { "../internals/global": 163, "../internals/has-own-property": 164, "../internals/native-symbol": 191, "../internals/shared": 237, "../internals/uid": 263, "../internals/use-symbol-as-uid": 264 }], 269: [function(require2, module2, exports2) {
        module2.exports = "	\n\v\f\r                　\u2028\u2029\uFEFF";
      }, {}], 270: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var global3 = require2("../internals/global");
        var arrayBufferModule = require2("../internals/array-buffer");
        var setSpecies = require2("../internals/set-species");
        var ARRAY_BUFFER = "ArrayBuffer";
        var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
        var NativeArrayBuffer = global3[ARRAY_BUFFER];
        $2({ global: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, { ArrayBuffer: ArrayBuffer2 });
        setSpecies(ARRAY_BUFFER);
      }, { "../internals/array-buffer": 104, "../internals/export": 149, "../internals/global": 163, "../internals/set-species": 233 }], 271: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var ArrayBufferModule = require2("../internals/array-buffer");
        var anObject = require2("../internals/an-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var toLength = require2("../internals/to-length");
        var speciesConstructor = require2("../internals/species-constructor");
        var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
        var DataView2 = ArrayBufferModule.DataView;
        var DataViewPrototype = DataView2.prototype;
        var un$ArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
        var getUint8 = uncurryThis(DataViewPrototype.getUint8);
        var setUint8 = uncurryThis(DataViewPrototype.setUint8);
        var INCORRECT_SLICE = fails(function() {
          return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
        });
        $2({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, { slice: function slice(start, end) {
          if (un$ArrayBufferSlice && end === void 0) {
            return un$ArrayBufferSlice(anObject(this), start);
          }
          var length = anObject(this).byteLength;
          var first = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var result = new (speciesConstructor(this, ArrayBuffer2))(toLength(fin - first));
          var viewSource = new DataView2(this);
          var viewTarget = new DataView2(result);
          var index2 = 0;
          while (first < fin) {
            setUint8(viewTarget, index2++, getUint8(viewSource, first++));
          }
          return result;
        } });
      }, { "../internals/an-object": 101, "../internals/array-buffer": 104, "../internals/export": 149, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/species-constructor": 238, "../internals/to-absolute-index": 245, "../internals/to-length": 249 }], 272: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var global3 = require2("../internals/global");
        var fails = require2("../internals/fails");
        var isArray2 = require2("../internals/is-array");
        var isObject2 = require2("../internals/is-object");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var createProperty = require2("../internals/create-property");
        var arraySpeciesCreate = require2("../internals/array-species-create");
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var V8_VERSION = require2("../internals/engine-v8-version");
        var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
        var TypeError2 = global3.TypeError;
        var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
          var array = [];
          array[IS_CONCAT_SPREADABLE] = false;
          return array.concat()[0] !== array;
        });
        var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
        var isConcatSpreadable = function(O2) {
          if (!isObject2(O2))
            return false;
          var spreadable = O2[IS_CONCAT_SPREADABLE];
          return spreadable !== void 0 ? !!spreadable : isArray2(O2);
        };
        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
        $2({ target: "Array", proto: true, forced: FORCED }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          concat: function concat(arg) {
            var O2 = toObject(this);
            var A2 = arraySpeciesCreate(O2, 0);
            var n2 = 0;
            var i3, k2, length, len, E2;
            for (i3 = -1, length = arguments.length; i3 < length; i3++) {
              E2 = i3 === -1 ? O2 : arguments[i3];
              if (isConcatSpreadable(E2)) {
                len = lengthOfArrayLike(E2);
                if (n2 + len > MAX_SAFE_INTEGER)
                  throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for (k2 = 0; k2 < len; k2++, n2++)
                  if (k2 in E2)
                    createProperty(A2, n2, E2[k2]);
              } else {
                if (n2 >= MAX_SAFE_INTEGER)
                  throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A2, n2++, E2);
              }
            }
            A2.length = n2;
            return A2;
          }
        });
      }, { "../internals/array-method-has-species-support": 113, "../internals/array-species-create": 120, "../internals/create-property": 131, "../internals/engine-v8-version": 146, "../internals/export": 149, "../internals/fails": 150, "../internals/global": 163, "../internals/is-array": 175, "../internals/is-object": 180, "../internals/length-of-array-like": 188, "../internals/to-object": 250, "../internals/well-known-symbol": 268 }], 273: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var fill = require2("../internals/array-fill");
        var addToUnscopables = require2("../internals/add-to-unscopables");
        $2({ target: "Array", proto: true }, { fill });
        addToUnscopables("fill");
      }, { "../internals/add-to-unscopables": 98, "../internals/array-fill": 106, "../internals/export": 149 }], 274: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var $filter = require2("../internals/array-iteration").filter;
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, { filter: function filter2(callbackfn) {
          return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, { "../internals/array-iteration": 111, "../internals/array-method-has-species-support": 113, "../internals/export": 149 }], 275: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var $find = require2("../internals/array-iteration").find;
        var addToUnscopables = require2("../internals/add-to-unscopables");
        var FIND = "find";
        var SKIPS_HOLES = true;
        if (FIND in [])
          Array(1)[FIND](function() {
            SKIPS_HOLES = false;
          });
        $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, { find: function find(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } });
        addToUnscopables(FIND);
      }, { "../internals/add-to-unscopables": 98, "../internals/array-iteration": 111, "../internals/export": 149 }], 276: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var from = require2("../internals/array-from");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
          Array.from(iterable);
        });
        $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, { from });
      }, { "../internals/array-from": 109, "../internals/check-correctness-of-iteration": 122, "../internals/export": 149 }], 277: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var $includes = require2("../internals/array-includes").includes;
        var addToUnscopables = require2("../internals/add-to-unscopables");
        $2({ target: "Array", proto: true }, { includes: function includes(el) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
        } });
        addToUnscopables("includes");
      }, { "../internals/add-to-unscopables": 98, "../internals/array-includes": 110, "../internals/export": 149 }], 278: [function(require2, module2, exports2) {
        var toIndexedObject = require2("../internals/to-indexed-object");
        var addToUnscopables = require2("../internals/add-to-unscopables");
        var Iterators = require2("../internals/iterators");
        var InternalStateModule = require2("../internals/internal-state");
        var defineProperty = require2("../internals/object-define-property").f;
        var defineIterator = require2("../internals/define-iterator");
        var IS_PURE = require2("../internals/is-pure");
        var DESCRIPTORS = require2("../internals/descriptors");
        var ARRAY_ITERATOR = "Array Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
        module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            // target
            index: 0,
            // next index
            kind
            // kind
          });
        }, function() {
          var state = getInternalState(this);
          var target = state.target;
          var kind = state.kind;
          var index2 = state.index++;
          if (!target || index2 >= target.length) {
            state.target = void 0;
            return { value: void 0, done: true };
          }
          if (kind == "keys")
            return { value: index2, done: false };
          if (kind == "values")
            return { value: target[index2], done: false };
          return { value: [index2, target[index2]], done: false };
        }, "values");
        var values = Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
        if (!IS_PURE && DESCRIPTORS && values.name !== "values")
          try {
            defineProperty(values, "name", { value: "values" });
          } catch (error) {
          }
      }, { "../internals/add-to-unscopables": 98, "../internals/define-iterator": 132, "../internals/descriptors": 134, "../internals/internal-state": 173, "../internals/is-pure": 181, "../internals/iterators": 187, "../internals/object-define-property": 198, "../internals/to-indexed-object": 247 }], 279: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var IndexedObject = require2("../internals/indexed-object");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var un$Join = uncurryThis([].join);
        var ES3_STRINGS = IndexedObject != Object;
        var STRICT_METHOD = arrayMethodIsStrict("join", ",");
        $2({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, { join: function join(separator) {
          return un$Join(toIndexedObject(this), separator === void 0 ? "," : separator);
        } });
      }, { "../internals/array-method-is-strict": 114, "../internals/export": 149, "../internals/function-uncurry-this": 157, "../internals/indexed-object": 170, "../internals/to-indexed-object": 247 }], 280: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var $map = require2("../internals/array-iteration").map;
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, { map: function map(callbackfn) {
          return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, { "../internals/array-iteration": 111, "../internals/array-method-has-species-support": 113, "../internals/export": 149 }], 281: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var global3 = require2("../internals/global");
        var isArray2 = require2("../internals/is-array");
        var isConstructor = require2("../internals/is-constructor");
        var isObject2 = require2("../internals/is-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var createProperty = require2("../internals/create-property");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var un$Slice = require2("../internals/array-slice");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
        var SPECIES = wellKnownSymbol("species");
        var Array2 = global3.Array;
        var max2 = Math.max;
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, { slice: function slice(start, end) {
          var O2 = toIndexedObject(this);
          var length = lengthOfArrayLike(O2);
          var k2 = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var Constructor, result, n2;
          if (isArray2(O2)) {
            Constructor = O2.constructor;
            if (isConstructor(Constructor) && (Constructor === Array2 || isArray2(Constructor.prototype))) {
              Constructor = void 0;
            } else if (isObject2(Constructor)) {
              Constructor = Constructor[SPECIES];
              if (Constructor === null)
                Constructor = void 0;
            }
            if (Constructor === Array2 || Constructor === void 0) {
              return un$Slice(O2, k2, fin);
            }
          }
          result = new (Constructor === void 0 ? Array2 : Constructor)(max2(fin - k2, 0));
          for (n2 = 0; k2 < fin; k2++, n2++)
            if (k2 in O2)
              createProperty(result, n2, O2[k2]);
          result.length = n2;
          return result;
        } });
      }, { "../internals/array-method-has-species-support": 113, "../internals/array-slice": 117, "../internals/create-property": 131, "../internals/export": 149, "../internals/global": 163, "../internals/is-array": 175, "../internals/is-constructor": 177, "../internals/is-object": 180, "../internals/length-of-array-like": 188, "../internals/to-absolute-index": 245, "../internals/to-indexed-object": 247, "../internals/well-known-symbol": 268 }], 282: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var aCallable = require2("../internals/a-callable");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var toString3 = require2("../internals/to-string");
        var fails = require2("../internals/fails");
        var internalSort = require2("../internals/array-sort");
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var FF = require2("../internals/engine-ff-version");
        var IE_OR_EDGE = require2("../internals/engine-is-ie-or-edge");
        var V8 = require2("../internals/engine-v8-version");
        var WEBKIT = require2("../internals/engine-webkit-version");
        var test = [];
        var un$Sort = uncurryThis(test.sort);
        var push = uncurryThis(test.push);
        var FAILS_ON_UNDEFINED = fails(function() {
          test.sort(void 0);
        });
        var FAILS_ON_NULL = fails(function() {
          test.sort(null);
        });
        var STRICT_METHOD = arrayMethodIsStrict("sort");
        var STABLE_SORT = !fails(function() {
          if (V8)
            return V8 < 70;
          if (FF && FF > 3)
            return;
          if (IE_OR_EDGE)
            return true;
          if (WEBKIT)
            return WEBKIT < 603;
          var result = "";
          var code, chr, value, index2;
          for (code = 65; code < 76; code++) {
            chr = String.fromCharCode(code);
            switch (code) {
              case 66:
              case 69:
              case 70:
              case 72:
                value = 3;
                break;
              case 68:
              case 71:
                value = 4;
                break;
              default:
                value = 2;
            }
            for (index2 = 0; index2 < 47; index2++) {
              test.push({ k: chr + index2, v: value });
            }
          }
          test.sort(function(a2, b2) {
            return b2.v - a2.v;
          });
          for (index2 = 0; index2 < test.length; index2++) {
            chr = test[index2].k.charAt(0);
            if (result.charAt(result.length - 1) !== chr)
              result += chr;
          }
          return result !== "DGBEFHACIJK";
        });
        var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
        var getSortCompare = function(comparefn) {
          return function(x2, y3) {
            if (y3 === void 0)
              return -1;
            if (x2 === void 0)
              return 1;
            if (comparefn !== void 0)
              return +comparefn(x2, y3) || 0;
            return toString3(x2) > toString3(y3) ? 1 : -1;
          };
        };
        $2({ target: "Array", proto: true, forced: FORCED }, { sort: function sort(comparefn) {
          if (comparefn !== void 0)
            aCallable(comparefn);
          var array = toObject(this);
          if (STABLE_SORT)
            return comparefn === void 0 ? un$Sort(array) : un$Sort(array, comparefn);
          var items = [];
          var arrayLength = lengthOfArrayLike(array);
          var itemsLength, index2;
          for (index2 = 0; index2 < arrayLength; index2++) {
            if (index2 in array)
              push(items, array[index2]);
          }
          internalSort(items, getSortCompare(comparefn));
          itemsLength = items.length;
          index2 = 0;
          while (index2 < itemsLength)
            array[index2] = items[index2++];
          while (index2 < arrayLength)
            delete array[index2++];
          return array;
        } });
      }, { "../internals/a-callable": 95, "../internals/array-method-is-strict": 114, "../internals/array-sort": 118, "../internals/engine-ff-version": 138, "../internals/engine-is-ie-or-edge": 140, "../internals/engine-v8-version": 146, "../internals/engine-webkit-version": 147, "../internals/export": 149, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/length-of-array-like": 188, "../internals/to-object": 250, "../internals/to-string": 256 }], 283: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var global3 = require2("../internals/global");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var toObject = require2("../internals/to-object");
        var arraySpeciesCreate = require2("../internals/array-species-create");
        var createProperty = require2("../internals/create-property");
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
        var TypeError2 = global3.TypeError;
        var max2 = Math.max;
        var min2 = Math.min;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, { splice: function splice(start, deleteCount) {
          var O2 = toObject(this);
          var len = lengthOfArrayLike(O2);
          var actualStart = toAbsoluteIndex(start, len);
          var argumentsLength = arguments.length;
          var insertCount, actualDeleteCount, A2, k2, from, to;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min2(max2(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
            throw TypeError2(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
          }
          A2 = arraySpeciesCreate(O2, actualDeleteCount);
          for (k2 = 0; k2 < actualDeleteCount; k2++) {
            from = actualStart + k2;
            if (from in O2)
              createProperty(A2, k2, O2[from]);
          }
          A2.length = actualDeleteCount;
          if (insertCount < actualDeleteCount) {
            for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
              from = k2 + actualDeleteCount;
              to = k2 + insertCount;
              if (from in O2)
                O2[to] = O2[from];
              else
                delete O2[to];
            }
            for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
              delete O2[k2 - 1];
          } else if (insertCount > actualDeleteCount) {
            for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
              from = k2 + actualDeleteCount - 1;
              to = k2 + insertCount - 1;
              if (from in O2)
                O2[to] = O2[from];
              else
                delete O2[to];
            }
          }
          for (k2 = 0; k2 < insertCount; k2++) {
            O2[k2 + actualStart] = arguments[k2 + 2];
          }
          O2.length = len - actualDeleteCount + insertCount;
          return A2;
        } });
      }, { "../internals/array-method-has-species-support": 113, "../internals/array-species-create": 120, "../internals/create-property": 131, "../internals/export": 149, "../internals/global": 163, "../internals/length-of-array-like": 188, "../internals/to-absolute-index": 245, "../internals/to-integer-or-infinity": 248, "../internals/to-object": 250 }], 284: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var FUNCTION_NAME_EXISTS = require2("../internals/function-name").EXISTS;
        var uncurryThis = require2("../internals/function-uncurry-this");
        var defineProperty = require2("../internals/object-define-property").f;
        var FunctionPrototype = Function.prototype;
        var functionToString = uncurryThis(FunctionPrototype.toString);
        var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
        var regExpExec = uncurryThis(nameRE.exec);
        var NAME = "name";
        if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
          defineProperty(FunctionPrototype, NAME, { configurable: true, get: function() {
            try {
              return regExpExec(nameRE, functionToString(this))[1];
            } catch (error) {
              return "";
            }
          } });
        }
      }, { "../internals/descriptors": 134, "../internals/function-name": 156, "../internals/function-uncurry-this": 157, "../internals/object-define-property": 198 }], 285: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var getBuiltIn = require2("../internals/get-built-in");
        var apply2 = require2("../internals/function-apply");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var isArray2 = require2("../internals/is-array");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var isSymbol = require2("../internals/is-symbol");
        var arraySlice = require2("../internals/array-slice");
        var NATIVE_SYMBOL = require2("../internals/native-symbol");
        var $stringify = getBuiltIn("JSON", "stringify");
        var exec = uncurryThis(/./.exec);
        var charAt = uncurryThis("".charAt);
        var charCodeAt = uncurryThis("".charCodeAt);
        var replace = uncurryThis("".replace);
        var numberToString = uncurryThis(1 .toString);
        var tester = /[\uD800-\uDFFF]/g;
        var low = /^[\uD800-\uDBFF]$/;
        var hi = /^[\uDC00-\uDFFF]$/;
        var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
          var symbol = getBuiltIn("Symbol")();
          return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
        });
        var ILL_FORMED_UNICODE = fails(function() {
          return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
        });
        var stringifyWithSymbolsFix = function(it2, replacer) {
          var args = arraySlice(arguments);
          var $replacer = replacer;
          if (!isObject2(replacer) && it2 === void 0 || isSymbol(it2))
            return;
          if (!isArray2(replacer))
            replacer = function(key, value) {
              if (isCallable($replacer))
                value = call($replacer, this, key, value);
              if (!isSymbol(value))
                return value;
            };
          args[1] = replacer;
          return apply2($stringify, null, args);
        };
        var fixIllFormed = function(match, offset2, string) {
          var prev = charAt(string, offset2 - 1);
          var next = charAt(string, offset2 + 1);
          if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
            return "\\u" + numberToString(charCodeAt(match, 0), 16);
          }
          return match;
        };
        if ($stringify) {
          $2({ target: "JSON", stat: true, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
            // eslint-disable-next-line no-unused-vars -- required for `.length`
            stringify: function stringify(it2, replacer, space) {
              var args = arraySlice(arguments);
              var result = apply2(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
              return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
            }
          });
        }
      }, { "../internals/array-slice": 117, "../internals/export": 149, "../internals/fails": 150, "../internals/function-apply": 152, "../internals/function-call": 155, "../internals/function-uncurry-this": 157, "../internals/get-built-in": 158, "../internals/is-array": 175, "../internals/is-callable": 176, "../internals/is-object": 180, "../internals/is-symbol": 183, "../internals/native-symbol": 191 }], 286: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isForced = require2("../internals/is-forced");
        var redefine = require2("../internals/redefine");
        var hasOwn = require2("../internals/has-own-property");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var isSymbol = require2("../internals/is-symbol");
        var toPrimitive = require2("../internals/to-primitive");
        var fails = require2("../internals/fails");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var getOwnPropertyDescriptor2 = require2("../internals/object-get-own-property-descriptor").f;
        var defineProperty = require2("../internals/object-define-property").f;
        var thisNumberValue = require2("../internals/this-number-value");
        var trim2 = require2("../internals/string-trim").trim;
        var NUMBER = "Number";
        var NativeNumber = global3[NUMBER];
        var NumberPrototype = NativeNumber.prototype;
        var TypeError2 = global3.TypeError;
        var arraySlice = uncurryThis("".slice);
        var charCodeAt = uncurryThis("".charCodeAt);
        var toNumeric = function(value) {
          var primValue = toPrimitive(value, "number");
          return typeof primValue == "bigint" ? primValue : toNumber(primValue);
        };
        var toNumber = function(argument) {
          var it2 = toPrimitive(argument, "number");
          var first, third, radix, maxCode, digits, length, index2, code;
          if (isSymbol(it2))
            throw TypeError2("Cannot convert a Symbol value to a number");
          if (typeof it2 == "string" && it2.length > 2) {
            it2 = trim2(it2);
            first = charCodeAt(it2, 0);
            if (first === 43 || first === 45) {
              third = charCodeAt(it2, 2);
              if (third === 88 || third === 120)
                return NaN;
            } else if (first === 48) {
              switch (charCodeAt(it2, 1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break;
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break;
                default:
                  return +it2;
              }
              digits = arraySlice(it2, 2);
              length = digits.length;
              for (index2 = 0; index2 < length; index2++) {
                code = charCodeAt(digits, index2);
                if (code < 48 || code > maxCode)
                  return NaN;
              }
              return parseInt(digits, radix);
            }
          }
          return +it2;
        };
        if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
          var NumberWrapper = function Number2(value) {
            var n2 = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
            var dummy = this;
            return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
              thisNumberValue(dummy);
            }) ? inheritIfRequired(Object(n2), dummy, NumberWrapper) : n2;
          };
          for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
            // ES3:
            "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
          ), j2 = 0, key; keys.length > j2; j2++) {
            if (hasOwn(NativeNumber, key = keys[j2]) && !hasOwn(NumberWrapper, key)) {
              defineProperty(NumberWrapper, key, getOwnPropertyDescriptor2(NativeNumber, key));
            }
          }
          NumberWrapper.prototype = NumberPrototype;
          NumberPrototype.constructor = NumberWrapper;
          redefine(global3, NUMBER, NumberWrapper);
        }
      }, { "../internals/descriptors": 134, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/inherit-if-required": 171, "../internals/is-forced": 178, "../internals/is-symbol": 183, "../internals/object-define-property": 198, "../internals/object-get-own-property-descriptor": 199, "../internals/object-get-own-property-names": 201, "../internals/object-is-prototype-of": 204, "../internals/redefine": 222, "../internals/string-trim": 241, "../internals/this-number-value": 244, "../internals/to-primitive": 253 }], 287: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var assign = require2("../internals/object-assign");
        $2({ target: "Object", stat: true, forced: Object.assign !== assign }, { assign });
      }, { "../internals/export": 149, "../internals/object-assign": 195 }], 288: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var $entries = require2("../internals/object-to-array").entries;
        $2({ target: "Object", stat: true }, { entries: function entries2(O2) {
          return $entries(O2);
        } });
      }, { "../internals/export": 149, "../internals/object-to-array": 209 }], 289: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var NATIVE_SYMBOL = require2("../internals/native-symbol");
        var fails = require2("../internals/fails");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var toObject = require2("../internals/to-object");
        var FORCED = !NATIVE_SYMBOL || fails(function() {
          getOwnPropertySymbolsModule.f(1);
        });
        $2({ target: "Object", stat: true, forced: FORCED }, { getOwnPropertySymbols: function getOwnPropertySymbols(it2) {
          var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it2)) : [];
        } });
      }, { "../internals/export": 149, "../internals/fails": 150, "../internals/native-symbol": 191, "../internals/object-get-own-property-symbols": 202, "../internals/to-object": 250 }], 290: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var toObject = require2("../internals/to-object");
        var nativeKeys = require2("../internals/object-keys");
        var fails = require2("../internals/fails");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeKeys(1);
        });
        $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, { keys: function keys(it2) {
          return nativeKeys(toObject(it2));
        } });
      }, { "../internals/export": 149, "../internals/fails": 150, "../internals/object-keys": 206, "../internals/to-object": 250 }], 291: [function(require2, module2, exports2) {
        var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
        var redefine = require2("../internals/redefine");
        var toString3 = require2("../internals/object-to-string");
        if (!TO_STRING_TAG_SUPPORT) {
          redefine(Object.prototype, "toString", toString3, { unsafe: true });
        }
      }, { "../internals/object-to-string": 210, "../internals/redefine": 222, "../internals/to-string-tag-support": 255 }], 292: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var call = require2("../internals/function-call");
        var aCallable = require2("../internals/a-callable");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var perform = require2("../internals/perform");
        var iterate = require2("../internals/iterate");
        var PROMISE_STATICS_INCORRECT_ITERATION = require2("../internals/promise-statics-incorrect-iteration");
        $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, { all: function all2(iterable) {
          var C2 = this;
          var capability = newPromiseCapabilityModule.f(C2);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C2.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise2) {
              var index2 = counter++;
              var alreadyCalled = false;
              remaining++;
              call($promiseResolve, C2, promise2).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                values[index2] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        } });
      }, { "../internals/a-callable": 95, "../internals/export": 149, "../internals/function-call": 155, "../internals/iterate": 184, "../internals/new-promise-capability": 193, "../internals/perform": 214, "../internals/promise-statics-incorrect-iteration": 218 }], 293: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var IS_PURE = require2("../internals/is-pure");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var getBuiltIn = require2("../internals/get-built-in");
        var isCallable = require2("../internals/is-callable");
        var redefine = require2("../internals/redefine");
        var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
        $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, { "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        } });
        if (!IS_PURE && isCallable(NativePromiseConstructor)) {
          var method = getBuiltIn("Promise").prototype["catch"];
          if (NativePromisePrototype["catch"] !== method) {
            redefine(NativePromisePrototype, "catch", method, { unsafe: true });
          }
        }
      }, { "../internals/export": 149, "../internals/get-built-in": 158, "../internals/is-callable": 176, "../internals/is-pure": 181, "../internals/promise-constructor-detection": 215, "../internals/promise-native-constructor": 216, "../internals/redefine": 222 }], 294: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var IS_PURE = require2("../internals/is-pure");
        var IS_NODE = require2("../internals/engine-is-node");
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var redefine = require2("../internals/redefine");
        var redefineAll = require2("../internals/redefine-all");
        var setPrototypeOf2 = require2("../internals/object-set-prototype-of");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var setSpecies = require2("../internals/set-species");
        var aCallable = require2("../internals/a-callable");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var anInstance = require2("../internals/an-instance");
        var speciesConstructor = require2("../internals/species-constructor");
        var task = require2("../internals/task").set;
        var microtask = require2("../internals/microtask");
        var hostReportErrors = require2("../internals/host-report-errors");
        var perform = require2("../internals/perform");
        var Queue = require2("../internals/queue");
        var InternalStateModule = require2("../internals/internal-state");
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var PromiseConstructorDetection = require2("../internals/promise-constructor-detection");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var PROMISE = "Promise";
        var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
        var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
        var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
        var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
        var setInternalState = InternalStateModule.set;
        var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
        var PromiseConstructor = NativePromiseConstructor;
        var PromisePrototype = NativePromisePrototype;
        var TypeError2 = global3.TypeError;
        var document2 = global3.document;
        var process = global3.process;
        var newPromiseCapability = newPromiseCapabilityModule.f;
        var newGenericPromiseCapability = newPromiseCapability;
        var DISPATCH_EVENT = !!(document2 && document2.createEvent && global3.dispatchEvent);
        var UNHANDLED_REJECTION = "unhandledrejection";
        var REJECTION_HANDLED = "rejectionhandled";
        var PENDING = 0;
        var FULFILLED = 1;
        var REJECTED = 2;
        var HANDLED = 1;
        var UNHANDLED = 2;
        var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
        var isThenable2 = function(it2) {
          var then;
          return isObject2(it2) && isCallable(then = it2.then) ? then : false;
        };
        var callReaction = function(reaction, state) {
          var value = state.value;
          var ok = state.state == FULFILLED;
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve = reaction.resolve;
          var reject = reaction.reject;
          var domain2 = reaction.domain;
          var result, then, exited;
          try {
            if (handler) {
              if (!ok) {
                if (state.rejection === UNHANDLED)
                  onHandleUnhandled(state);
                state.rejection = HANDLED;
              }
              if (handler === true)
                result = value;
              else {
                if (domain2)
                  domain2.enter();
                result = handler(value);
                if (domain2) {
                  domain2.exit();
                  exited = true;
                }
              }
              if (result === reaction.promise) {
                reject(TypeError2("Promise-chain cycle"));
              } else if (then = isThenable2(result)) {
                call(then, result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (error) {
            if (domain2 && !exited)
              domain2.exit();
            reject(error);
          }
        };
        var notify = function(state, isReject) {
          if (state.notified)
            return;
          state.notified = true;
          microtask(function() {
            var reactions = state.reactions;
            var reaction;
            while (reaction = reactions.get()) {
              callReaction(reaction, state);
            }
            state.notified = false;
            if (isReject && !state.rejection)
              onUnhandled(state);
          });
        };
        var dispatchEvent = function(name2, promise2, reason) {
          var event, handler;
          if (DISPATCH_EVENT) {
            event = document2.createEvent("Event");
            event.promise = promise2;
            event.reason = reason;
            event.initEvent(name2, false, true);
            global3.dispatchEvent(event);
          } else
            event = { promise: promise2, reason };
          if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global3["on" + name2]))
            handler(event);
          else if (name2 === UNHANDLED_REJECTION)
            hostReportErrors("Unhandled promise rejection", reason);
        };
        var onUnhandled = function(state) {
          call(task, global3, function() {
            var promise2 = state.facade;
            var value = state.value;
            var IS_UNHANDLED = isUnhandled(state);
            var result;
            if (IS_UNHANDLED) {
              result = perform(function() {
                if (IS_NODE) {
                  process.emit("unhandledRejection", value, promise2);
                } else
                  dispatchEvent(UNHANDLED_REJECTION, promise2, value);
              });
              state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
              if (result.error)
                throw result.value;
            }
          });
        };
        var isUnhandled = function(state) {
          return state.rejection !== HANDLED && !state.parent;
        };
        var onHandleUnhandled = function(state) {
          call(task, global3, function() {
            var promise2 = state.facade;
            if (IS_NODE) {
              process.emit("rejectionHandled", promise2);
            } else
              dispatchEvent(REJECTION_HANDLED, promise2, state.value);
          });
        };
        var bind2 = function(fn, state, unwrap) {
          return function(value) {
            fn(state, value, unwrap);
          };
        };
        var internalReject = function(state, value, unwrap) {
          if (state.done)
            return;
          state.done = true;
          if (unwrap)
            state = unwrap;
          state.value = value;
          state.state = REJECTED;
          notify(state, true);
        };
        var internalResolve = function(state, value, unwrap) {
          if (state.done)
            return;
          state.done = true;
          if (unwrap)
            state = unwrap;
          try {
            if (state.facade === value)
              throw TypeError2("Promise can't be resolved itself");
            var then = isThenable2(value);
            if (then) {
              microtask(function() {
                var wrapper = { done: false };
                try {
                  call(then, value, bind2(internalResolve, wrapper, state), bind2(internalReject, wrapper, state));
                } catch (error) {
                  internalReject(wrapper, error, state);
                }
              });
            } else {
              state.value = value;
              state.state = FULFILLED;
              notify(state, false);
            }
          } catch (error) {
            internalReject({ done: false }, error, state);
          }
        };
        if (FORCED_PROMISE_CONSTRUCTOR) {
          PromiseConstructor = function Promise2(executor) {
            anInstance(this, PromisePrototype);
            aCallable(executor);
            call(Internal, this);
            var state = getInternalPromiseState(this);
            try {
              executor(bind2(internalResolve, state), bind2(internalReject, state));
            } catch (error) {
              internalReject(state, error);
            }
          };
          PromisePrototype = PromiseConstructor.prototype;
          Internal = function Promise2(executor) {
            setInternalState(this, { type: PROMISE, done: false, notified: false, parent: false, reactions: new Queue(), rejection: false, state: PENDING, value: void 0 });
          };
          Internal.prototype = redefineAll(PromisePrototype, {
            // `Promise.prototype.then` method
            // https://tc39.es/ecma262/#sec-promise.prototype.then
            // eslint-disable-next-line unicorn/no-thenable -- safe
            then: function then(onFulfilled, onRejected) {
              var state = getInternalPromiseState(this);
              var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
              state.parent = true;
              reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
              reaction.fail = isCallable(onRejected) && onRejected;
              reaction.domain = IS_NODE ? process.domain : void 0;
              if (state.state == PENDING)
                state.reactions.add(reaction);
              else
                microtask(function() {
                  callReaction(reaction, state);
                });
              return reaction.promise;
            }
          });
          OwnPromiseCapability = function() {
            var promise2 = new Internal();
            var state = getInternalPromiseState(promise2);
            this.promise = promise2;
            this.resolve = bind2(internalResolve, state);
            this.reject = bind2(internalReject, state);
          };
          newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
            return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
          };
          if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
            nativeThen = NativePromisePrototype.then;
            if (!NATIVE_PROMISE_SUBCLASSING) {
              redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
                var that = this;
                return new PromiseConstructor(function(resolve, reject) {
                  call(nativeThen, that, resolve, reject);
                }).then(onFulfilled, onRejected);
              }, { unsafe: true });
            }
            try {
              delete NativePromisePrototype.constructor;
            } catch (error) {
            }
            if (setPrototypeOf2) {
              setPrototypeOf2(NativePromisePrototype, PromisePrototype);
            }
          }
        }
        $2({ global: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, { Promise: PromiseConstructor });
        setToStringTag(PromiseConstructor, PROMISE, false, true);
        setSpecies(PROMISE);
      }, { "../internals/a-callable": 95, "../internals/an-instance": 100, "../internals/engine-is-node": 143, "../internals/export": 149, "../internals/function-call": 155, "../internals/global": 163, "../internals/host-report-errors": 166, "../internals/internal-state": 173, "../internals/is-callable": 176, "../internals/is-object": 180, "../internals/is-pure": 181, "../internals/microtask": 189, "../internals/new-promise-capability": 193, "../internals/object-set-prototype-of": 208, "../internals/perform": 214, "../internals/promise-constructor-detection": 215, "../internals/promise-native-constructor": 216, "../internals/queue": 220, "../internals/redefine": 222, "../internals/redefine-all": 221, "../internals/set-species": 233, "../internals/set-to-string-tag": 234, "../internals/species-constructor": 238, "../internals/task": 243 }], 295: [function(require2, module2, exports2) {
        require2("../modules/es.promise.constructor");
        require2("../modules/es.promise.all");
        require2("../modules/es.promise.catch");
        require2("../modules/es.promise.race");
        require2("../modules/es.promise.reject");
        require2("../modules/es.promise.resolve");
      }, { "../modules/es.promise.all": 292, "../modules/es.promise.catch": 293, "../modules/es.promise.constructor": 294, "../modules/es.promise.race": 296, "../modules/es.promise.reject": 297, "../modules/es.promise.resolve": 298 }], 296: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var call = require2("../internals/function-call");
        var aCallable = require2("../internals/a-callable");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var perform = require2("../internals/perform");
        var iterate = require2("../internals/iterate");
        var PROMISE_STATICS_INCORRECT_ITERATION = require2("../internals/promise-statics-incorrect-iteration");
        $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, { race: function race(iterable) {
          var C2 = this;
          var capability = newPromiseCapabilityModule.f(C2);
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C2.resolve);
            iterate(iterable, function(promise2) {
              call($promiseResolve, C2, promise2).then(capability.resolve, reject);
            });
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        } });
      }, { "../internals/a-callable": 95, "../internals/export": 149, "../internals/function-call": 155, "../internals/iterate": 184, "../internals/new-promise-capability": 193, "../internals/perform": 214, "../internals/promise-statics-incorrect-iteration": 218 }], 297: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var call = require2("../internals/function-call");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, { reject: function reject(r2) {
          var capability = newPromiseCapabilityModule.f(this);
          call(capability.reject, void 0, r2);
          return capability.promise;
        } });
      }, { "../internals/export": 149, "../internals/function-call": 155, "../internals/new-promise-capability": 193, "../internals/promise-constructor-detection": 215 }], 298: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var getBuiltIn = require2("../internals/get-built-in");
        var IS_PURE = require2("../internals/is-pure");
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        var promiseResolve2 = require2("../internals/promise-resolve");
        var PromiseConstructorWrapper = getBuiltIn("Promise");
        var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
        $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, { resolve: function resolve(x2) {
          return promiseResolve2(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
        } });
      }, { "../internals/export": 149, "../internals/get-built-in": 158, "../internals/is-pure": 181, "../internals/promise-constructor-detection": 215, "../internals/promise-native-constructor": 216, "../internals/promise-resolve": 217 }], 299: [function(require2, module2, exports2) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isForced = require2("../internals/is-forced");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var isRegExp2 = require2("../internals/is-regexp");
        var toString3 = require2("../internals/to-string");
        var getRegExpFlags = require2("../internals/regexp-get-flags");
        var stickyHelpers = require2("../internals/regexp-sticky-helpers");
        var proxyAccessor = require2("../internals/proxy-accessor");
        var redefine = require2("../internals/redefine");
        var fails = require2("../internals/fails");
        var hasOwn = require2("../internals/has-own-property");
        var enforceInternalState = require2("../internals/internal-state").enforce;
        var setSpecies = require2("../internals/set-species");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var UNSUPPORTED_DOT_ALL = require2("../internals/regexp-unsupported-dot-all");
        var UNSUPPORTED_NCG = require2("../internals/regexp-unsupported-ncg");
        var MATCH = wellKnownSymbol("match");
        var NativeRegExp = global3.RegExp;
        var RegExpPrototype = NativeRegExp.prototype;
        var SyntaxError2 = global3.SyntaxError;
        var exec = uncurryThis(RegExpPrototype.exec);
        var charAt = uncurryThis("".charAt);
        var replace = uncurryThis("".replace);
        var stringIndexOf2 = uncurryThis("".indexOf);
        var stringSlice = uncurryThis("".slice);
        var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
        var re1 = /a/g;
        var re2 = /a/g;
        var CORRECT_NEW = new NativeRegExp(re1) !== re1;
        var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
        var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
          re2[MATCH] = false;
          return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
        }));
        var handleDotAll = function(string) {
          var length = string.length;
          var index3 = 0;
          var result = "";
          var brackets = false;
          var chr;
          for (; index3 <= length; index3++) {
            chr = charAt(string, index3);
            if (chr === "\\") {
              result += chr + charAt(string, ++index3);
              continue;
            }
            if (!brackets && chr === ".") {
              result += "[\\s\\S]";
            } else {
              if (chr === "[") {
                brackets = true;
              } else if (chr === "]") {
                brackets = false;
              }
              result += chr;
            }
          }
          return result;
        };
        var handleNCG = function(string) {
          var length = string.length;
          var index3 = 0;
          var result = "";
          var named = [];
          var names = {};
          var brackets = false;
          var ncg = false;
          var groupid = 0;
          var groupname = "";
          var chr;
          for (; index3 <= length; index3++) {
            chr = charAt(string, index3);
            if (chr === "\\") {
              chr = chr + charAt(string, ++index3);
            } else if (chr === "]") {
              brackets = false;
            } else if (!brackets)
              switch (true) {
                case chr === "[":
                  brackets = true;
                  break;
                case chr === "(":
                  if (exec(IS_NCG, stringSlice(string, index3 + 1))) {
                    index3 += 2;
                    ncg = true;
                  }
                  result += chr;
                  groupid++;
                  continue;
                case (chr === ">" && ncg):
                  if (groupname === "" || hasOwn(names, groupname)) {
                    throw new SyntaxError2("Invalid capture group name");
                  }
                  names[groupname] = true;
                  named[named.length] = [groupname, groupid];
                  ncg = false;
                  groupname = "";
                  continue;
              }
            if (ncg)
              groupname += chr;
            else
              result += chr;
          }
          return [result, named];
        };
        if (isForced("RegExp", BASE_FORCED)) {
          var RegExpWrapper = function RegExp2(pattern, flags) {
            var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
            var patternIsRegExp = isRegExp2(pattern);
            var flagsAreUndefined = flags === void 0;
            var groups = [];
            var rawPattern = pattern;
            var rawFlags, dotAll, sticky, handled, result, state;
            if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
              return pattern;
            }
            if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
              pattern = pattern.source;
              if (flagsAreUndefined)
                flags = getRegExpFlags(rawPattern);
            }
            pattern = pattern === void 0 ? "" : toString3(pattern);
            flags = flags === void 0 ? "" : toString3(flags);
            rawPattern = pattern;
            if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
              dotAll = !!flags && stringIndexOf2(flags, "s") > -1;
              if (dotAll)
                flags = replace(flags, /s/g, "");
            }
            rawFlags = flags;
            if (MISSED_STICKY && "sticky" in re1) {
              sticky = !!flags && stringIndexOf2(flags, "y") > -1;
              if (sticky && UNSUPPORTED_Y)
                flags = replace(flags, /y/g, "");
            }
            if (UNSUPPORTED_NCG) {
              handled = handleNCG(pattern);
              pattern = handled[0];
              groups = handled[1];
            }
            result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
            if (dotAll || sticky || groups.length) {
              state = enforceInternalState(result);
              if (dotAll) {
                state.dotAll = true;
                state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
              }
              if (sticky)
                state.sticky = true;
              if (groups.length)
                state.groups = groups;
            }
            if (pattern !== rawPattern)
              try {
                createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
              } catch (error) {
              }
            return result;
          };
          for (var keys = getOwnPropertyNames(NativeRegExp), index2 = 0; keys.length > index2; ) {
            proxyAccessor(RegExpWrapper, NativeRegExp, keys[index2++]);
          }
          RegExpPrototype.constructor = RegExpWrapper;
          RegExpWrapper.prototype = RegExpPrototype;
          redefine(global3, "RegExp", RegExpWrapper);
        }
        setSpecies("RegExp");
      }, { "../internals/create-non-enumerable-property": 129, "../internals/descriptors": 134, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/inherit-if-required": 171, "../internals/internal-state": 173, "../internals/is-forced": 178, "../internals/is-regexp": 182, "../internals/object-get-own-property-names": 201, "../internals/object-is-prototype-of": 204, "../internals/proxy-accessor": 219, "../internals/redefine": 222, "../internals/regexp-get-flags": 226, "../internals/regexp-sticky-helpers": 227, "../internals/regexp-unsupported-dot-all": 228, "../internals/regexp-unsupported-ncg": 229, "../internals/set-species": 233, "../internals/to-string": 256, "../internals/well-known-symbol": 268 }], 300: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var exec = require2("../internals/regexp-exec");
        $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, { exec });
      }, { "../internals/export": 149, "../internals/regexp-exec": 224 }], 301: [function(require2, module2, exports2) {
        var PROPER_FUNCTION_NAME = require2("../internals/function-name").PROPER;
        var redefine = require2("../internals/redefine");
        var anObject = require2("../internals/an-object");
        var $toString = require2("../internals/to-string");
        var fails = require2("../internals/fails");
        var getRegExpFlags = require2("../internals/regexp-get-flags");
        var TO_STRING = "toString";
        var RegExpPrototype = RegExp.prototype;
        var n$ToString = RegExpPrototype[TO_STRING];
        var NOT_GENERIC = fails(function() {
          return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
        });
        var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
        if (NOT_GENERIC || INCORRECT_NAME) {
          redefine(RegExp.prototype, TO_STRING, function toString3() {
            var R2 = anObject(this);
            var pattern = $toString(R2.source);
            var flags = $toString(getRegExpFlags(R2));
            return "/" + pattern + "/" + flags;
          }, { unsafe: true });
        }
      }, { "../internals/an-object": 101, "../internals/fails": 150, "../internals/function-name": 156, "../internals/redefine": 222, "../internals/regexp-get-flags": 226, "../internals/to-string": 256 }], 302: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var notARegExp = require2("../internals/not-a-regexp");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var toString3 = require2("../internals/to-string");
        var correctIsRegExpLogic = require2("../internals/correct-is-regexp-logic");
        var stringIndexOf2 = uncurryThis("".indexOf);
        $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, { includes: function includes(searchString) {
          return !!~stringIndexOf2(toString3(requireObjectCoercible(this)), toString3(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, { "../internals/correct-is-regexp-logic": 126, "../internals/export": 149, "../internals/function-uncurry-this": 157, "../internals/not-a-regexp": 194, "../internals/require-object-coercible": 230, "../internals/to-string": 256 }], 303: [function(require2, module2, exports2) {
        var charAt = require2("../internals/string-multibyte").charAt;
        var toString3 = require2("../internals/to-string");
        var InternalStateModule = require2("../internals/internal-state");
        var defineIterator = require2("../internals/define-iterator");
        var STRING_ITERATOR = "String Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
        defineIterator(String, "String", function(iterated) {
          setInternalState(this, { type: STRING_ITERATOR, string: toString3(iterated), index: 0 });
        }, function next() {
          var state = getInternalState(this);
          var string = state.string;
          var index2 = state.index;
          var point;
          if (index2 >= string.length)
            return { value: void 0, done: true };
          point = charAt(string, index2);
          state.index += point.length;
          return { value: point, done: false };
        });
      }, { "../internals/define-iterator": 132, "../internals/internal-state": 173, "../internals/string-multibyte": 239, "../internals/to-string": 256 }], 304: [function(require2, module2, exports2) {
        var call = require2("../internals/function-call");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var anObject = require2("../internals/an-object");
        var toLength = require2("../internals/to-length");
        var toString3 = require2("../internals/to-string");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var getMethod = require2("../internals/get-method");
        var advanceStringIndex = require2("../internals/advance-string-index");
        var regExpExec = require2("../internals/regexp-exec-abstract");
        fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
          return [
            // `String.prototype.match` method
            // https://tc39.es/ecma262/#sec-string.prototype.match
            function match(regexp) {
              var O2 = requireObjectCoercible(this);
              var matcher = regexp == void 0 ? void 0 : getMethod(regexp, MATCH);
              return matcher ? call(matcher, regexp, O2) : new RegExp(regexp)[MATCH](toString3(O2));
            },
            // `RegExp.prototype[@@match]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
            function(string) {
              var rx = anObject(this);
              var S2 = toString3(string);
              var res = maybeCallNative(nativeMatch, rx, S2);
              if (res.done)
                return res.value;
              if (!rx.global)
                return regExpExec(rx, S2);
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
              var A2 = [];
              var n2 = 0;
              var result;
              while ((result = regExpExec(rx, S2)) !== null) {
                var matchStr = toString3(result[0]);
                A2[n2] = matchStr;
                if (matchStr === "")
                  rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
                n2++;
              }
              return n2 === 0 ? null : A2;
            }
          ];
        });
      }, { "../internals/advance-string-index": 99, "../internals/an-object": 101, "../internals/fix-regexp-well-known-symbol-logic": 151, "../internals/function-call": 155, "../internals/get-method": 161, "../internals/regexp-exec-abstract": 223, "../internals/require-object-coercible": 230, "../internals/to-length": 249, "../internals/to-string": 256 }], 305: [function(require2, module2, exports2) {
        var apply2 = require2("../internals/function-apply");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var fails = require2("../internals/fails");
        var anObject = require2("../internals/an-object");
        var isCallable = require2("../internals/is-callable");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toLength = require2("../internals/to-length");
        var toString3 = require2("../internals/to-string");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var advanceStringIndex = require2("../internals/advance-string-index");
        var getMethod = require2("../internals/get-method");
        var getSubstitution = require2("../internals/get-substitution");
        var regExpExec = require2("../internals/regexp-exec-abstract");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var REPLACE = wellKnownSymbol("replace");
        var max2 = Math.max;
        var min2 = Math.min;
        var concat = uncurryThis([].concat);
        var push = uncurryThis([].push);
        var stringIndexOf2 = uncurryThis("".indexOf);
        var stringSlice = uncurryThis("".slice);
        var maybeToString = function(it2) {
          return it2 === void 0 ? it2 : String(it2);
        };
        var REPLACE_KEEPS_$0 = function() {
          return "a".replace(/./, "$0") === "$0";
        }();
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
          if (/./[REPLACE]) {
            return /./[REPLACE]("a", "$0") === "";
          }
          return false;
        }();
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          var re2 = /./;
          re2.exec = function() {
            var result = [];
            result.groups = { a: "7" };
            return result;
          };
          return "".replace(re2, "$<a>") !== "7";
        });
        fixRegExpWellKnownSymbolLogic("replace", function(_2, nativeReplace, maybeCallNative) {
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
          return [
            // `String.prototype.replace` method
            // https://tc39.es/ecma262/#sec-string.prototype.replace
            function replace(searchValue, replaceValue) {
              var O2 = requireObjectCoercible(this);
              var replacer = searchValue == void 0 ? void 0 : getMethod(searchValue, REPLACE);
              return replacer ? call(replacer, searchValue, O2, replaceValue) : call(nativeReplace, toString3(O2), searchValue, replaceValue);
            },
            // `RegExp.prototype[@@replace]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
            function(string, replaceValue) {
              var rx = anObject(this);
              var S2 = toString3(string);
              if (typeof replaceValue == "string" && stringIndexOf2(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf2(replaceValue, "$<") === -1) {
                var res = maybeCallNative(nativeReplace, rx, S2, replaceValue);
                if (res.done)
                  return res.value;
              }
              var functionalReplace = isCallable(replaceValue);
              if (!functionalReplace)
                replaceValue = toString3(replaceValue);
              var global3 = rx.global;
              if (global3) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
              }
              var results = [];
              while (true) {
                var result = regExpExec(rx, S2);
                if (result === null)
                  break;
                push(results, result);
                if (!global3)
                  break;
                var matchStr = toString3(result[0]);
                if (matchStr === "")
                  rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
              }
              var accumulatedResult = "";
              var nextSourcePosition = 0;
              for (var i3 = 0; i3 < results.length; i3++) {
                result = results[i3];
                var matched = toString3(result[0]);
                var position = max2(min2(toIntegerOrInfinity(result.index), S2.length), 0);
                var captures = [];
                for (var j2 = 1; j2 < result.length; j2++)
                  push(captures, maybeToString(result[j2]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                  var replacerArgs = concat([matched], captures, position, S2);
                  if (namedCaptures !== void 0)
                    push(replacerArgs, namedCaptures);
                  var replacement = toString3(apply2(replaceValue, void 0, replacerArgs));
                } else {
                  replacement = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
                }
                if (position >= nextSourcePosition) {
                  accumulatedResult += stringSlice(S2, nextSourcePosition, position) + replacement;
                  nextSourcePosition = position + matched.length;
                }
              }
              return accumulatedResult + stringSlice(S2, nextSourcePosition);
            }
          ];
        }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
      }, { "../internals/advance-string-index": 99, "../internals/an-object": 101, "../internals/fails": 150, "../internals/fix-regexp-well-known-symbol-logic": 151, "../internals/function-apply": 152, "../internals/function-call": 155, "../internals/function-uncurry-this": 157, "../internals/get-method": 161, "../internals/get-substitution": 162, "../internals/is-callable": 176, "../internals/regexp-exec-abstract": 223, "../internals/require-object-coercible": 230, "../internals/to-integer-or-infinity": 248, "../internals/to-length": 249, "../internals/to-string": 256, "../internals/well-known-symbol": 268 }], 306: [function(require2, module2, exports2) {
        var call = require2("../internals/function-call");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var anObject = require2("../internals/an-object");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var sameValue = require2("../internals/same-value");
        var toString3 = require2("../internals/to-string");
        var getMethod = require2("../internals/get-method");
        var regExpExec = require2("../internals/regexp-exec-abstract");
        fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
          return [
            // `String.prototype.search` method
            // https://tc39.es/ecma262/#sec-string.prototype.search
            function search2(regexp) {
              var O2 = requireObjectCoercible(this);
              var searcher = regexp == void 0 ? void 0 : getMethod(regexp, SEARCH);
              return searcher ? call(searcher, regexp, O2) : new RegExp(regexp)[SEARCH](toString3(O2));
            },
            // `RegExp.prototype[@@search]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
            function(string) {
              var rx = anObject(this);
              var S2 = toString3(string);
              var res = maybeCallNative(nativeSearch, rx, S2);
              if (res.done)
                return res.value;
              var previousLastIndex = rx.lastIndex;
              if (!sameValue(previousLastIndex, 0))
                rx.lastIndex = 0;
              var result = regExpExec(rx, S2);
              if (!sameValue(rx.lastIndex, previousLastIndex))
                rx.lastIndex = previousLastIndex;
              return result === null ? -1 : result.index;
            }
          ];
        });
      }, { "../internals/an-object": 101, "../internals/fix-regexp-well-known-symbol-logic": 151, "../internals/function-call": 155, "../internals/get-method": 161, "../internals/regexp-exec-abstract": 223, "../internals/require-object-coercible": 230, "../internals/same-value": 231, "../internals/to-string": 256 }], 307: [function(require2, module2, exports2) {
        var apply2 = require2("../internals/function-apply");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var isRegExp2 = require2("../internals/is-regexp");
        var anObject = require2("../internals/an-object");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var speciesConstructor = require2("../internals/species-constructor");
        var advanceStringIndex = require2("../internals/advance-string-index");
        var toLength = require2("../internals/to-length");
        var toString3 = require2("../internals/to-string");
        var getMethod = require2("../internals/get-method");
        var arraySlice = require2("../internals/array-slice-simple");
        var callRegExpExec = require2("../internals/regexp-exec-abstract");
        var regexpExec = require2("../internals/regexp-exec");
        var stickyHelpers = require2("../internals/regexp-sticky-helpers");
        var fails = require2("../internals/fails");
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
        var MAX_UINT32 = 4294967295;
        var min2 = Math.min;
        var $push = [].push;
        var exec = uncurryThis(/./.exec);
        var push = uncurryThis($push);
        var stringSlice = uncurryThis("".slice);
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          var re2 = /(?:)/;
          var originalExec = re2.exec;
          re2.exec = function() {
            return originalExec.apply(this, arguments);
          };
          var result = "ab".split(re2);
          return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
        });
        fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
          var internalSplit;
          if ("abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
          "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
          ".".split(/()()/).length > 1 || "".split(/.?/).length) {
            internalSplit = function(separator, limit) {
              var string = toString3(requireObjectCoercible(this));
              var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
              if (lim === 0)
                return [];
              if (separator === void 0)
                return [string];
              if (!isRegExp2(separator)) {
                return call(nativeSplit, string, separator, lim);
              }
              var output = [];
              var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
              var lastLastIndex = 0;
              var separatorCopy = new RegExp(separator.source, flags + "g");
              var match, lastIndex, lastLength;
              while (match = call(regexpExec, separatorCopy, string)) {
                lastIndex = separatorCopy.lastIndex;
                if (lastIndex > lastLastIndex) {
                  push(output, stringSlice(string, lastLastIndex, match.index));
                  if (match.length > 1 && match.index < string.length)
                    apply2($push, output, arraySlice(match, 1));
                  lastLength = match[0].length;
                  lastLastIndex = lastIndex;
                  if (output.length >= lim)
                    break;
                }
                if (separatorCopy.lastIndex === match.index)
                  separatorCopy.lastIndex++;
              }
              if (lastLastIndex === string.length) {
                if (lastLength || !exec(separatorCopy, ""))
                  push(output, "");
              } else
                push(output, stringSlice(string, lastLastIndex));
              return output.length > lim ? arraySlice(output, 0, lim) : output;
            };
          } else if ("0".split(void 0, 0).length) {
            internalSplit = function(separator, limit) {
              return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
            };
          } else
            internalSplit = nativeSplit;
          return [
            // `String.prototype.split` method
            // https://tc39.es/ecma262/#sec-string.prototype.split
            function split(separator, limit) {
              var O2 = requireObjectCoercible(this);
              var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
              return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString3(O2), separator, limit);
            },
            // `RegExp.prototype[@@split]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
            //
            // NOTE: This cannot be properly polyfilled in engines that don't support
            // the 'y' flag.
            function(string, limit) {
              var rx = anObject(this);
              var S2 = toString3(string);
              var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
              if (res.done)
                return res.value;
              var C2 = speciesConstructor(rx, RegExp);
              var unicodeMatching = rx.unicode;
              var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
              var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
              var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
              if (lim === 0)
                return [];
              if (S2.length === 0)
                return callRegExpExec(splitter, S2) === null ? [S2] : [];
              var p2 = 0;
              var q2 = 0;
              var A2 = [];
              while (q2 < S2.length) {
                splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
                var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
                var e2;
                if (z2 === null || (e2 = min2(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p2) {
                  q2 = advanceStringIndex(S2, q2, unicodeMatching);
                } else {
                  push(A2, stringSlice(S2, p2, q2));
                  if (A2.length === lim)
                    return A2;
                  for (var i3 = 1; i3 <= z2.length - 1; i3++) {
                    push(A2, z2[i3]);
                    if (A2.length === lim)
                      return A2;
                  }
                  q2 = p2 = e2;
                }
              }
              push(A2, stringSlice(S2, p2));
              return A2;
            }
          ];
        }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
      }, { "../internals/advance-string-index": 99, "../internals/an-object": 101, "../internals/array-slice-simple": 116, "../internals/fails": 150, "../internals/fix-regexp-well-known-symbol-logic": 151, "../internals/function-apply": 152, "../internals/function-call": 155, "../internals/function-uncurry-this": 157, "../internals/get-method": 161, "../internals/is-regexp": 182, "../internals/regexp-exec": 224, "../internals/regexp-exec-abstract": 223, "../internals/regexp-sticky-helpers": 227, "../internals/require-object-coercible": 230, "../internals/species-constructor": 238, "../internals/to-length": 249, "../internals/to-string": 256 }], 308: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var $trim = require2("../internals/string-trim").trim;
        var forcedStringTrimMethod = require2("../internals/string-trim-forced");
        $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, { trim: function trim2() {
          return $trim(this);
        } });
      }, { "../internals/export": 149, "../internals/string-trim": 241, "../internals/string-trim-forced": 240 }], 309: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var IS_PURE = require2("../internals/is-pure");
        var DESCRIPTORS = require2("../internals/descriptors");
        var NATIVE_SYMBOL = require2("../internals/native-symbol");
        var fails = require2("../internals/fails");
        var hasOwn = require2("../internals/has-own-property");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var anObject = require2("../internals/an-object");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toPropertyKey = require2("../internals/to-property-key");
        var $toString = require2("../internals/to-string");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var nativeObjectCreate = require2("../internals/object-create");
        var objectKeys = require2("../internals/object-keys");
        var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
        var getOwnPropertyNamesExternal = require2("../internals/object-get-own-property-names-external");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
        var definePropertyModule = require2("../internals/object-define-property");
        var definePropertiesModule = require2("../internals/object-define-properties");
        var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
        var redefine = require2("../internals/redefine");
        var shared = require2("../internals/shared");
        var sharedKey = require2("../internals/shared-key");
        var hiddenKeys = require2("../internals/hidden-keys");
        var uid = require2("../internals/uid");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
        var defineWellKnownSymbol = require2("../internals/define-well-known-symbol");
        var defineSymbolToPrimitive = require2("../internals/symbol-define-to-primitive");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var InternalStateModule = require2("../internals/internal-state");
        var $forEach = require2("../internals/array-iteration").forEach;
        var HIDDEN = sharedKey("hidden");
        var SYMBOL = "Symbol";
        var PROTOTYPE = "prototype";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(SYMBOL);
        var ObjectPrototype = Object[PROTOTYPE];
        var $Symbol = global3.Symbol;
        var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
        var TypeError2 = global3.TypeError;
        var QObject = global3.QObject;
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
        var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
        var push = uncurryThis([].push);
        var AllSymbols = shared("symbols");
        var ObjectPrototypeSymbols = shared("op-symbols");
        var WellKnownSymbolsStore = shared("wks");
        var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        var setSymbolDescriptor = DESCRIPTORS && fails(function() {
          return nativeObjectCreate(nativeDefineProperty({}, "a", { get: function() {
            return nativeDefineProperty(this, "a", { value: 7 }).a;
          } })).a != 7;
        }) ? function(O2, P2, Attributes) {
          var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
          if (ObjectPrototypeDescriptor)
            delete ObjectPrototype[P2];
          nativeDefineProperty(O2, P2, Attributes);
          if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype) {
            nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
          }
        } : nativeDefineProperty;
        var wrap = function(tag, description2) {
          var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
          setInternalState(symbol, { type: SYMBOL, tag, description: description2 });
          if (!DESCRIPTORS)
            symbol.description = description2;
          return symbol;
        };
        var $defineProperty = function defineProperty(O2, P2, Attributes) {
          if (O2 === ObjectPrototype)
            $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
          anObject(O2);
          var key = toPropertyKey(P2);
          anObject(Attributes);
          if (hasOwn(AllSymbols, key)) {
            if (!Attributes.enumerable) {
              if (!hasOwn(O2, HIDDEN))
                nativeDefineProperty(O2, HIDDEN, createPropertyDescriptor(1, {}));
              O2[HIDDEN][key] = true;
            } else {
              if (hasOwn(O2, HIDDEN) && O2[HIDDEN][key])
                O2[HIDDEN][key] = false;
              Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            }
            return setSymbolDescriptor(O2, key, Attributes);
          }
          return nativeDefineProperty(O2, key, Attributes);
        };
        var $defineProperties = function defineProperties(O2, Properties) {
          anObject(O2);
          var properties = toIndexedObject(Properties);
          var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
          $forEach(keys, function(key) {
            if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
              $defineProperty(O2, key, properties[key]);
          });
          return O2;
        };
        var $create = function create2(O2, Properties) {
          return Properties === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(V2) {
          var P2 = toPropertyKey(V2);
          var enumerable = call(nativePropertyIsEnumerable, this, P2);
          if (this === ObjectPrototype && hasOwn(AllSymbols, P2) && !hasOwn(ObjectPrototypeSymbols, P2))
            return false;
          return enumerable || !hasOwn(this, P2) || !hasOwn(AllSymbols, P2) || hasOwn(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O2, P2) {
          var it2 = toIndexedObject(O2);
          var key = toPropertyKey(P2);
          if (it2 === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
            return;
          var descriptor = nativeGetOwnPropertyDescriptor(it2, key);
          if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it2, HIDDEN) && it2[HIDDEN][key])) {
            descriptor.enumerable = true;
          }
          return descriptor;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(O2) {
          var names = nativeGetOwnPropertyNames(toIndexedObject(O2));
          var result = [];
          $forEach(names, function(key) {
            if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
              push(result, key);
          });
          return result;
        };
        var $getOwnPropertySymbols = function(O2) {
          var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype;
          var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O2));
          var result = [];
          $forEach(names, function(key) {
            if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
              push(result, AllSymbols[key]);
            }
          });
          return result;
        };
        if (!NATIVE_SYMBOL) {
          $Symbol = function Symbol2() {
            if (isPrototypeOf(SymbolPrototype, this))
              throw TypeError2("Symbol is not a constructor");
            var description2 = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
            var tag = uid(description2);
            var setter = function(value) {
              if (this === ObjectPrototype)
                call(setter, ObjectPrototypeSymbols, value);
              if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
                this[HIDDEN][tag] = false;
              setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
            };
            if (DESCRIPTORS && USE_SETTER)
              setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
            return wrap(tag, description2);
          };
          SymbolPrototype = $Symbol[PROTOTYPE];
          redefine(SymbolPrototype, "toString", function toString3() {
            return getInternalState(this).tag;
          });
          redefine($Symbol, "withoutSetter", function(description2) {
            return wrap(uid(description2), description2);
          });
          propertyIsEnumerableModule.f = $propertyIsEnumerable;
          definePropertyModule.f = $defineProperty;
          definePropertiesModule.f = $defineProperties;
          getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
          getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
          getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
          wrappedWellKnownSymbolModule.f = function(name2) {
            return wrap(wellKnownSymbol(name2), name2);
          };
          if (DESCRIPTORS) {
            nativeDefineProperty(SymbolPrototype, "description", { configurable: true, get: function description2() {
              return getInternalState(this).description;
            } });
            if (!IS_PURE) {
              redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
            }
          }
        }
        $2({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });
        $forEach(objectKeys(WellKnownSymbolsStore), function(name2) {
          defineWellKnownSymbol(name2);
        });
        $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, { useSetter: function() {
          USE_SETTER = true;
        }, useSimple: function() {
          USE_SETTER = false;
        } });
        $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
          // `Object.create` method
          // https://tc39.es/ecma262/#sec-object.create
          create: $create,
          // `Object.defineProperty` method
          // https://tc39.es/ecma262/#sec-object.defineproperty
          defineProperty: $defineProperty,
          // `Object.defineProperties` method
          // https://tc39.es/ecma262/#sec-object.defineproperties
          defineProperties: $defineProperties,
          // `Object.getOwnPropertyDescriptor` method
          // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor
        });
        $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
          // `Object.getOwnPropertyNames` method
          // https://tc39.es/ecma262/#sec-object.getownpropertynames
          getOwnPropertyNames: $getOwnPropertyNames
        });
        defineSymbolToPrimitive();
        setToStringTag($Symbol, SYMBOL);
        hiddenKeys[HIDDEN] = true;
      }, { "../internals/an-object": 101, "../internals/array-iteration": 111, "../internals/create-property-descriptor": 130, "../internals/define-well-known-symbol": 133, "../internals/descriptors": 134, "../internals/export": 149, "../internals/fails": 150, "../internals/function-call": 155, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/hidden-keys": 165, "../internals/internal-state": 173, "../internals/is-pure": 181, "../internals/native-symbol": 191, "../internals/object-create": 196, "../internals/object-define-properties": 197, "../internals/object-define-property": 198, "../internals/object-get-own-property-descriptor": 199, "../internals/object-get-own-property-names": 201, "../internals/object-get-own-property-names-external": 200, "../internals/object-get-own-property-symbols": 202, "../internals/object-is-prototype-of": 204, "../internals/object-keys": 206, "../internals/object-property-is-enumerable": 207, "../internals/redefine": 222, "../internals/set-to-string-tag": 234, "../internals/shared": 237, "../internals/shared-key": 235, "../internals/symbol-define-to-primitive": 242, "../internals/to-indexed-object": 247, "../internals/to-property-key": 254, "../internals/to-string": 256, "../internals/uid": 263, "../internals/well-known-symbol": 268, "../internals/well-known-symbol-wrapped": 267 }], 310: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var hasOwn = require2("../internals/has-own-property");
        var isCallable = require2("../internals/is-callable");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var toString3 = require2("../internals/to-string");
        var defineProperty = require2("../internals/object-define-property").f;
        var copyConstructorProperties = require2("../internals/copy-constructor-properties");
        var NativeSymbol = global3.Symbol;
        var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
        if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
        NativeSymbol().description !== void 0)) {
          var EmptyStringDescriptionStore = {};
          var SymbolWrapper = function Symbol2() {
            var description2 = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString3(arguments[0]);
            var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description2) : description2 === void 0 ? NativeSymbol() : NativeSymbol(description2);
            if (description2 === "")
              EmptyStringDescriptionStore[result] = true;
            return result;
          };
          copyConstructorProperties(SymbolWrapper, NativeSymbol);
          SymbolWrapper.prototype = SymbolPrototype;
          SymbolPrototype.constructor = SymbolWrapper;
          var NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
          var symbolToString = uncurryThis(SymbolPrototype.toString);
          var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
          var regexp = /^Symbol\((.*)\)[^)]+$/;
          var replace = uncurryThis("".replace);
          var stringSlice = uncurryThis("".slice);
          defineProperty(SymbolPrototype, "description", { configurable: true, get: function description2() {
            var symbol = symbolValueOf(this);
            var string = symbolToString(symbol);
            if (hasOwn(EmptyStringDescriptionStore, symbol))
              return "";
            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
            return desc === "" ? void 0 : desc;
          } });
          $2({ global: true, forced: true }, { Symbol: SymbolWrapper });
        }
      }, { "../internals/copy-constructor-properties": 125, "../internals/descriptors": 134, "../internals/export": 149, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/has-own-property": 164, "../internals/is-callable": 176, "../internals/object-define-property": 198, "../internals/object-is-prototype-of": 204, "../internals/to-string": 256 }], 311: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var getBuiltIn = require2("../internals/get-built-in");
        var hasOwn = require2("../internals/has-own-property");
        var toString3 = require2("../internals/to-string");
        var shared = require2("../internals/shared");
        var NATIVE_SYMBOL_REGISTRY = require2("../internals/native-symbol-registry");
        var StringToSymbolRegistry = shared("string-to-symbol-registry");
        var SymbolToStringRegistry = shared("symbol-to-string-registry");
        $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, { "for": function(key) {
          var string = toString3(key);
          if (hasOwn(StringToSymbolRegistry, string))
            return StringToSymbolRegistry[string];
          var symbol = getBuiltIn("Symbol")(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry[symbol] = string;
          return symbol;
        } });
      }, { "../internals/export": 149, "../internals/get-built-in": 158, "../internals/has-own-property": 164, "../internals/native-symbol-registry": 190, "../internals/shared": 237, "../internals/to-string": 256 }], 312: [function(require2, module2, exports2) {
        var defineWellKnownSymbol = require2("../internals/define-well-known-symbol");
        defineWellKnownSymbol("iterator");
      }, { "../internals/define-well-known-symbol": 133 }], 313: [function(require2, module2, exports2) {
        require2("../modules/es.symbol.constructor");
        require2("../modules/es.symbol.for");
        require2("../modules/es.symbol.key-for");
        require2("../modules/es.json.stringify");
        require2("../modules/es.object.get-own-property-symbols");
      }, { "../modules/es.json.stringify": 285, "../modules/es.object.get-own-property-symbols": 289, "../modules/es.symbol.constructor": 309, "../modules/es.symbol.for": 311, "../modules/es.symbol.key-for": 314 }], 314: [function(require2, module2, exports2) {
        var $2 = require2("../internals/export");
        var hasOwn = require2("../internals/has-own-property");
        var isSymbol = require2("../internals/is-symbol");
        var tryToString = require2("../internals/try-to-string");
        var shared = require2("../internals/shared");
        var NATIVE_SYMBOL_REGISTRY = require2("../internals/native-symbol-registry");
        var SymbolToStringRegistry = shared("symbol-to-string-registry");
        $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, { keyFor: function keyFor(sym) {
          if (!isSymbol(sym))
            throw TypeError(tryToString(sym) + " is not a symbol");
          if (hasOwn(SymbolToStringRegistry, sym))
            return SymbolToStringRegistry[sym];
        } });
      }, { "../internals/export": 149, "../internals/has-own-property": 164, "../internals/is-symbol": 183, "../internals/native-symbol-registry": 190, "../internals/shared": 237, "../internals/try-to-string": 257 }], 315: [function(require2, module2, exports2) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $ArrayCopyWithin = require2("../internals/array-copy-within");
        var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
          return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-copy-within": 105, "../internals/function-uncurry-this": 157 }], 316: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $every = require2("../internals/array-iteration").every;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("every", function every(callbackfn) {
          return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111 }], 317: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var call = require2("../internals/function-call");
        var $fill = require2("../internals/array-fill");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("fill", function fill(value) {
          var length = arguments.length;
          return call($fill, aTypedArray(this), value, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-fill": 106, "../internals/function-call": 155 }], 318: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $filter = require2("../internals/array-iteration").filter;
        var fromSpeciesAndList = require2("../internals/typed-array-from-species-and-list");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("filter", function filter2(callbackfn) {
          var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return fromSpeciesAndList(this, list);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111, "../internals/typed-array-from-species-and-list": 260 }], 319: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $findIndex = require2("../internals/array-iteration").findIndex;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("findIndex", function findIndex(predicate) {
          return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111 }], 320: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $find = require2("../internals/array-iteration").find;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("find", function find(predicate) {
          return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111 }], 321: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $forEach = require2("../internals/array-iteration").forEach;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("forEach", function forEach2(callbackfn) {
          $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111 }], 322: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $includes = require2("../internals/array-includes").includes;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("includes", function includes(searchElement) {
          return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-includes": 110 }], 323: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $indexOf = require2("../internals/array-includes").indexOf;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
          return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-includes": 110 }], 324: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var fails = require2("../internals/fails");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var ArrayIterators = require2("../modules/es.array.iterator");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        var Uint8Array2 = global3.Uint8Array;
        var arrayValues = uncurryThis(ArrayIterators.values);
        var arrayKeys = uncurryThis(ArrayIterators.keys);
        var arrayEntries = uncurryThis(ArrayIterators.entries);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
        var GENERIC = !fails(function() {
          TypedArrayPrototype[ITERATOR].call([1]);
        });
        var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
        var typedArrayValues = function values() {
          return arrayValues(aTypedArray(this));
        };
        exportTypedArrayMethod("entries", function entries2() {
          return arrayEntries(aTypedArray(this));
        }, GENERIC);
        exportTypedArrayMethod("keys", function keys() {
          return arrayKeys(aTypedArray(this));
        }, GENERIC);
        exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
        exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
      }, { "../internals/array-buffer-view-core": 103, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/global": 163, "../internals/well-known-symbol": 268, "../modules/es.array.iterator": 278 }], 325: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $join = uncurryThis([].join);
        exportTypedArrayMethod("join", function join(separator) {
          return $join(aTypedArray(this), separator);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/function-uncurry-this": 157 }], 326: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var apply2 = require2("../internals/function-apply");
        var $lastIndexOf = require2("../internals/array-last-index-of");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
          var length = arguments.length;
          return apply2($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-last-index-of": 112, "../internals/function-apply": 152 }], 327: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $map = require2("../internals/array-iteration").map;
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("map", function map(mapfn) {
          return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O2, length) {
            return new (typedArraySpeciesConstructor(O2))(length);
          });
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111, "../internals/typed-array-species-constructor": 262 }], 328: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $reduceRight = require2("../internals/array-reduce").right;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
          var length = arguments.length;
          return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-reduce": 115 }], 329: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $reduce = require2("../internals/array-reduce").left;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("reduce", function reduce(callbackfn) {
          var length = arguments.length;
          return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-reduce": 115 }], 330: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var floor = Math.floor;
        exportTypedArrayMethod("reverse", function reverse() {
          var that = this;
          var length = aTypedArray(that).length;
          var middle = floor(length / 2);
          var index2 = 0;
          var value;
          while (index2 < middle) {
            value = that[index2];
            that[index2++] = that[--length];
            that[length] = value;
          }
          return that;
        });
      }, { "../internals/array-buffer-view-core": 103 }], 331: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var toOffset = require2("../internals/to-offset");
        var toIndexedObject = require2("../internals/to-object");
        var fails = require2("../internals/fails");
        var RangeError2 = global3.RangeError;
        var Int8Array2 = global3.Int8Array;
        var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
        var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function() {
          var array = new Uint8ClampedArray(2);
          call($set, array, { length: 1, 0: 3 }, 1);
          return array[1] !== 3;
        });
        var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
          var array = new Int8Array2(2);
          array.set(1);
          array.set("2", 1);
          return array[0] !== 0 || array[1] !== 2;
        });
        exportTypedArrayMethod("set", function set(arrayLike) {
          aTypedArray(this);
          var offset2 = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
          var src = toIndexedObject(arrayLike);
          if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS)
            return call($set, this, src, offset2);
          var length = this.length;
          var len = lengthOfArrayLike(src);
          var index2 = 0;
          if (len + offset2 > length)
            throw RangeError2("Wrong length");
          while (index2 < len)
            this[offset2 + index2] = src[index2++];
        }, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
      }, { "../internals/array-buffer-view-core": 103, "../internals/fails": 150, "../internals/function-call": 155, "../internals/global": 163, "../internals/length-of-array-like": 188, "../internals/to-object": 250, "../internals/to-offset": 251 }], 332: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        var fails = require2("../internals/fails");
        var arraySlice = require2("../internals/array-slice");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var FORCED = fails(function() {
          new Int8Array(1).slice();
        });
        exportTypedArrayMethod("slice", function slice(start, end) {
          var list = arraySlice(aTypedArray(this), start, end);
          var C2 = typedArraySpeciesConstructor(this);
          var index2 = 0;
          var length = list.length;
          var result = new C2(length);
          while (length > index2)
            result[index2] = list[index2++];
          return result;
        }, FORCED);
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-slice": 117, "../internals/fails": 150, "../internals/typed-array-species-constructor": 262 }], 333: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $some = require2("../internals/array-iteration").some;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("some", function some(callbackfn) {
          return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-iteration": 111 }], 334: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var aCallable = require2("../internals/a-callable");
        var internalSort = require2("../internals/array-sort");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var FF = require2("../internals/engine-ff-version");
        var IE_OR_EDGE = require2("../internals/engine-is-ie-or-edge");
        var V8 = require2("../internals/engine-v8-version");
        var WEBKIT = require2("../internals/engine-webkit-version");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var Uint16Array2 = global3.Uint16Array;
        var un$Sort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
        var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function() {
          un$Sort(new Uint16Array2(2), null);
        }) && fails(function() {
          un$Sort(new Uint16Array2(2), {});
        }));
        var STABLE_SORT = !!un$Sort && !fails(function() {
          if (V8)
            return V8 < 74;
          if (FF)
            return FF < 67;
          if (IE_OR_EDGE)
            return true;
          if (WEBKIT)
            return WEBKIT < 602;
          var array = new Uint16Array2(516);
          var expected = Array(516);
          var index2, mod;
          for (index2 = 0; index2 < 516; index2++) {
            mod = index2 % 4;
            array[index2] = 515 - index2;
            expected[index2] = index2 - 2 * mod + 3;
          }
          un$Sort(array, function(a2, b2) {
            return (a2 / 4 | 0) - (b2 / 4 | 0);
          });
          for (index2 = 0; index2 < 516; index2++) {
            if (array[index2] !== expected[index2])
              return true;
          }
        });
        var getSortCompare = function(comparefn) {
          return function(x2, y3) {
            if (comparefn !== void 0)
              return +comparefn(x2, y3) || 0;
            if (y3 !== y3)
              return -1;
            if (x2 !== x2)
              return 1;
            if (x2 === 0 && y3 === 0)
              return 1 / x2 > 0 && 1 / y3 < 0 ? 1 : -1;
            return x2 > y3;
          };
        };
        exportTypedArrayMethod("sort", function sort(comparefn) {
          if (comparefn !== void 0)
            aCallable(comparefn);
          if (STABLE_SORT)
            return un$Sort(this, comparefn);
          return internalSort(aTypedArray(this), getSortCompare(comparefn));
        }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
      }, { "../internals/a-callable": 95, "../internals/array-buffer-view-core": 103, "../internals/array-sort": 118, "../internals/engine-ff-version": 138, "../internals/engine-is-ie-or-edge": 140, "../internals/engine-v8-version": 146, "../internals/engine-webkit-version": 147, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/global": 163 }], 335: [function(require2, module2, exports2) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var toLength = require2("../internals/to-length");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("subarray", function subarray(begin, end) {
          var O2 = aTypedArray(this);
          var length = O2.length;
          var beginIndex = toAbsoluteIndex(begin, length);
          var C2 = typedArraySpeciesConstructor(O2);
          return new C2(O2.buffer, O2.byteOffset + beginIndex * O2.BYTES_PER_ELEMENT, toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex));
        });
      }, { "../internals/array-buffer-view-core": 103, "../internals/to-absolute-index": 245, "../internals/to-length": 249, "../internals/typed-array-species-constructor": 262 }], 336: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var apply2 = require2("../internals/function-apply");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var fails = require2("../internals/fails");
        var arraySlice = require2("../internals/array-slice");
        var Int8Array2 = global3.Int8Array;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $toLocaleString = [].toLocaleString;
        var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
          $toLocaleString.call(new Int8Array2(1));
        });
        var FORCED = fails(function() {
          return [1, 2].toLocaleString() != new Int8Array2([1, 2]).toLocaleString();
        }) || !fails(function() {
          Int8Array2.prototype.toLocaleString.call([1, 2]);
        });
        exportTypedArrayMethod("toLocaleString", function toLocaleString() {
          return apply2($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this), arraySlice(arguments));
        }, FORCED);
      }, { "../internals/array-buffer-view-core": 103, "../internals/array-slice": 117, "../internals/fails": 150, "../internals/function-apply": 152, "../internals/global": 163 }], 337: [function(require2, module2, exports2) {
        var exportTypedArrayMethod = require2("../internals/array-buffer-view-core").exportTypedArrayMethod;
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var Uint8Array2 = global3.Uint8Array;
        var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
        var arrayToString = [].toString;
        var join = uncurryThis([].join);
        if (fails(function() {
          arrayToString.call({});
        })) {
          arrayToString = function toString3() {
            return join(this);
          };
        }
        var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
        exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
      }, { "../internals/array-buffer-view-core": 103, "../internals/fails": 150, "../internals/function-uncurry-this": 157, "../internals/global": 163 }], 338: [function(require2, module2, exports2) {
        var createTypedArrayConstructor = require2("../internals/typed-array-constructor");
        createTypedArrayConstructor("Uint8", function(init) {
          return function Uint8Array2(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      }, { "../internals/typed-array-constructor": 258 }], 339: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var DOMIterables = require2("../internals/dom-iterables");
        var DOMTokenListPrototype = require2("../internals/dom-token-list-prototype");
        var forEach2 = require2("../internals/array-for-each");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var handlePrototype = function(CollectionPrototype) {
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach2)
            try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach2);
            } catch (error) {
              CollectionPrototype.forEach = forEach2;
            }
        };
        for (var COLLECTION_NAME in DOMIterables) {
          if (DOMIterables[COLLECTION_NAME]) {
            handlePrototype(global3[COLLECTION_NAME] && global3[COLLECTION_NAME].prototype);
          }
        }
        handlePrototype(DOMTokenListPrototype);
      }, { "../internals/array-for-each": 107, "../internals/create-non-enumerable-property": 129, "../internals/dom-iterables": 136, "../internals/dom-token-list-prototype": 137, "../internals/global": 163 }], 340: [function(require2, module2, exports2) {
        var global3 = require2("../internals/global");
        var DOMIterables = require2("../internals/dom-iterables");
        var DOMTokenListPrototype = require2("../internals/dom-token-list-prototype");
        var ArrayIteratorMethods = require2("../modules/es.array.iterator");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var ArrayValues = ArrayIteratorMethods.values;
        var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
          if (CollectionPrototype) {
            if (CollectionPrototype[ITERATOR] !== ArrayValues)
              try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
              } catch (error) {
                CollectionPrototype[ITERATOR] = ArrayValues;
              }
            if (!CollectionPrototype[TO_STRING_TAG]) {
              createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
            }
            if (DOMIterables[COLLECTION_NAME2])
              for (var METHOD_NAME in ArrayIteratorMethods) {
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                  try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                  } catch (error) {
                    CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                  }
              }
          }
        };
        for (var COLLECTION_NAME in DOMIterables) {
          handlePrototype(global3[COLLECTION_NAME] && global3[COLLECTION_NAME].prototype, COLLECTION_NAME);
        }
        handlePrototype(DOMTokenListPrototype, "DOMTokenList");
      }, { "../internals/create-non-enumerable-property": 129, "../internals/dom-iterables": 136, "../internals/dom-token-list-prototype": 137, "../internals/global": 163, "../internals/well-known-symbol": 268, "../modules/es.array.iterator": 278 }], 341: [function(require2, module2, exports2) {
        function isArray2(arg) {
          if (Array.isArray) {
            return Array.isArray(arg);
          }
          return objectToString(arg) === "[object Array]";
        }
        exports2.isArray = isArray2;
        function isBoolean2(arg) {
          return typeof arg === "boolean";
        }
        exports2.isBoolean = isBoolean2;
        function isNull(arg) {
          return arg === null;
        }
        exports2.isNull = isNull;
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports2.isNullOrUndefined = isNullOrUndefined;
        function isNumber2(arg) {
          return typeof arg === "number";
        }
        exports2.isNumber = isNumber2;
        function isString2(arg) {
          return typeof arg === "string";
        }
        exports2.isString = isString2;
        function isSymbol(arg) {
          return typeof arg === "symbol";
        }
        exports2.isSymbol = isSymbol;
        function isUndefined2(arg) {
          return arg === void 0;
        }
        exports2.isUndefined = isUndefined2;
        function isRegExp2(re2) {
          return objectToString(re2) === "[object RegExp]";
        }
        exports2.isRegExp = isRegExp2;
        function isObject2(arg) {
          return typeof arg === "object" && arg !== null;
        }
        exports2.isObject = isObject2;
        function isDate2(d2) {
          return objectToString(d2) === "[object Date]";
        }
        exports2.isDate = isDate2;
        function isError(e2) {
          return objectToString(e2) === "[object Error]" || e2 instanceof Error;
        }
        exports2.isError = isError;
        function isFunction2(arg) {
          return typeof arg === "function";
        }
        exports2.isFunction = isFunction2;
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        exports2.isPrimitive = isPrimitive;
        exports2.isBuffer = require2("buffer").Buffer.isBuffer;
        function objectToString(o2) {
          return Object.prototype.toString.call(o2);
        }
      }, { "buffer": 90 }], 342: [function(require2, module2, exports2) {
        (function(global3) {
          var dateFormat2 = function() {
            var token2 = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
            var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
            var timezoneClip = /[^-+\dA-Z]/g;
            return function(date, mask, utc, gmt) {
              if (arguments.length === 1 && kindOf2(date) === "string" && !/\d/.test(date)) {
                mask = date;
                date = void 0;
              }
              date = date || /* @__PURE__ */ new Date();
              if (!(date instanceof Date)) {
                date = new Date(date);
              }
              if (isNaN(date)) {
                throw TypeError("Invalid date");
              }
              mask = String(dateFormat2.masks[mask] || mask || dateFormat2.masks["default"]);
              var maskSlice = mask.slice(0, 4);
              if (maskSlice === "UTC:" || maskSlice === "GMT:") {
                mask = mask.slice(4);
                utc = true;
                if (maskSlice === "GMT:") {
                  gmt = true;
                }
              }
              var _2 = utc ? "getUTC" : "get";
              var d2 = date[_2 + "Date"]();
              var D2 = date[_2 + "Day"]();
              var m2 = date[_2 + "Month"]();
              var y3 = date[_2 + "FullYear"]();
              var H2 = date[_2 + "Hours"]();
              var M3 = date[_2 + "Minutes"]();
              var s2 = date[_2 + "Seconds"]();
              var L2 = date[_2 + "Milliseconds"]();
              var o2 = utc ? 0 : date.getTimezoneOffset();
              var W2 = getWeek(date);
              var N2 = getDayOfWeek(date);
              var flags = { d: d2, dd: pad(d2), ddd: dateFormat2.i18n.dayNames[D2], dddd: dateFormat2.i18n.dayNames[D2 + 7], m: m2 + 1, mm: pad(m2 + 1), mmm: dateFormat2.i18n.monthNames[m2], mmmm: dateFormat2.i18n.monthNames[m2 + 12], yy: String(y3).slice(2), yyyy: y3, h: H2 % 12 || 12, hh: pad(H2 % 12 || 12), H: H2, HH: pad(H2), M: M3, MM: pad(M3), s: s2, ss: pad(s2), l: pad(L2, 3), L: pad(Math.round(L2 / 10)), t: H2 < 12 ? "a" : "p", tt: H2 < 12 ? "am" : "pm", T: H2 < 12 ? "A" : "P", TT: H2 < 12 ? "AM" : "PM", Z: gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""), o: (o2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o2) / 60) * 100 + Math.abs(o2) % 60, 4), S: ["th", "st", "nd", "rd"][d2 % 10 > 3 ? 0 : (d2 % 100 - d2 % 10 != 10) * d2 % 10], W: W2, N: N2 };
              return mask.replace(token2, function(match) {
                if (match in flags) {
                  return flags[match];
                }
                return match.slice(1, match.length - 1);
              });
            };
          }();
          dateFormat2.masks = { "default": "ddd mmm dd yyyy HH:MM:ss", "shortDate": "m/d/yy", "mediumDate": "mmm d, yyyy", "longDate": "mmmm d, yyyy", "fullDate": "dddd, mmmm d, yyyy", "shortTime": "h:MM TT", "mediumTime": "h:MM:ss TT", "longTime": "h:MM:ss TT Z", "isoDate": "yyyy-mm-dd", "isoTime": "HH:MM:ss", "isoDateTime": "yyyy-mm-dd'T'HH:MM:sso", "isoUtcDateTime": "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", "expiresHeaderFormat": "ddd, dd mmm yyyy HH:MM:ss Z" };
          dateFormat2.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] };
          function pad(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) {
              val = "0" + val;
            }
            return val;
          }
          function getWeek(date) {
            var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
            var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
            firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
            var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
            targetThursday.setHours(targetThursday.getHours() - ds);
            var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
            return 1 + Math.floor(weekDiff);
          }
          function getDayOfWeek(date) {
            var dow = date.getDay();
            if (dow === 0) {
              dow = 7;
            }
            return dow;
          }
          function kindOf2(val) {
            if (val === null) {
              return "null";
            }
            if (val === void 0) {
              return "undefined";
            }
            if (typeof val !== "object") {
              return typeof val;
            }
            if (Array.isArray(val)) {
              return "array";
            }
            return {}.toString.call(val).slice(8, -1).toLowerCase();
          }
          if (typeof exports2 === "object") {
            module2.exports = dateFormat2;
          } else {
            global3.dateFormat = dateFormat2;
          }
        })(this);
      }, {}], 343: [function(require2, module2, exports2) {
        var matchHtmlRegExp = /["'&<>]/;
        module2.exports = escapeHtml;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape2;
          var html2 = "";
          var index2 = 0;
          var lastIndex = 0;
          for (index2 = match.index; index2 < str.length; index2++) {
            switch (str.charCodeAt(index2)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#39;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index2) {
              html2 += str.substring(lastIndex, index2);
            }
            lastIndex = index2 + 1;
            html2 += escape2;
          }
          return lastIndex !== index2 ? html2 + str.substring(lastIndex, index2) : html2;
        }
      }, {}], 344: [function(require2, module2, exports2) {
        var R2 = typeof Reflect === "object" ? Reflect : null;
        var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
          return Function.prototype.apply.call(target, receiver, args);
        };
        var ReflectOwnKeys;
        if (R2 && typeof R2.ownKeys === "function") {
          ReflectOwnKeys = R2.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target);
          };
        }
        function ProcessEmitWarning(warning) {
          if (console && console.warn)
            console.warn(warning);
        }
        var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
          return value !== value;
        };
        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module2.exports = EventEmitter;
        module2.exports.once = once;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        function checkListener(listener) {
          if (typeof listener !== "function") {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
        }
        Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function() {
          return defaultMaxListeners;
        }, set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        } });
        EventEmitter.init = function() {
          if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        };
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
          if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
          }
          this._maxListeners = n2;
          return this;
        };
        function _getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };
        EventEmitter.prototype.emit = function emit(type2) {
          var args = [];
          for (var i3 = 1; i3 < arguments.length; i3++)
            args.push(arguments[i3]);
          var doError = type2 === "error";
          var events = this._events;
          if (events !== void 0)
            doError = doError && events.error === void 0;
          else if (!doError)
            return false;
          if (doError) {
            var er;
            if (args.length > 0)
              er = args[0];
            if (er instanceof Error) {
              throw er;
            }
            var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
            err2.context = er;
            throw err2;
          }
          var handler = events[type2];
          if (handler === void 0)
            return false;
          if (typeof handler === "function") {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i3 = 0; i3 < len; ++i3)
              ReflectApply(listeners[i3], this, args);
          }
          return true;
        };
        function _addListener(target, type2, listener, prepend) {
          var m2;
          var events;
          var existing;
          checkListener(listener);
          events = target._events;
          if (events === void 0) {
            events = target._events = /* @__PURE__ */ Object.create(null);
            target._eventsCount = 0;
          } else {
            if (events.newListener !== void 0) {
              target.emit("newListener", type2, listener.listener ? listener.listener : listener);
              events = target._events;
            }
            existing = events[type2];
          }
          if (existing === void 0) {
            existing = events[type2] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
            } else if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
            m2 = _getMaxListeners(target);
            if (m2 > 0 && existing.length > m2 && !existing.warned) {
              existing.warned = true;
              var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w2.name = "MaxListenersExceededWarning";
              w2.emitter = target;
              w2.type = type2;
              w2.count = existing.length;
              ProcessEmitWarning(w2);
            }
          }
          return target;
        }
        EventEmitter.prototype.addListener = function addListener(type2, listener) {
          return _addListener(this, type2, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
          return _addListener(this, type2, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0)
              return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }
        function _onceWrap(target, type2, listener) {
          var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once2(type2, listener) {
          checkListener(listener);
          this.on(type2, _onceWrap(this, type2, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
          checkListener(listener);
          this.prependListener(type2, _onceWrap(this, type2, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
          var list, events, position, i3, originalListener;
          checkListener(listener);
          events = this._events;
          if (events === void 0)
            return this;
          list = events[type2];
          if (list === void 0)
            return this;
          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else {
              delete events[type2];
              if (events.removeListener)
                this.emit("removeListener", type2, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;
            for (i3 = list.length - 1; i3 >= 0; i3--) {
              if (list[i3] === listener || list[i3].listener === listener) {
                originalListener = list[i3].listener;
                position = i3;
                break;
              }
            }
            if (position < 0)
              return this;
            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }
            if (list.length === 1)
              events[type2] = list[0];
            if (events.removeListener !== void 0)
              this.emit("removeListener", type2, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
          var listeners, events, i3;
          events = this._events;
          if (events === void 0)
            return this;
          if (events.removeListener === void 0) {
            if (arguments.length === 0) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            } else if (events[type2] !== void 0) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else
                delete events[type2];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i3 = 0; i3 < keys.length; ++i3) {
              key = keys[i3];
              if (key === "removeListener")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type2];
          if (typeof listeners === "function") {
            this.removeListener(type2, listeners);
          } else if (listeners !== void 0) {
            for (i3 = listeners.length - 1; i3 >= 0; i3--) {
              this.removeListener(type2, listeners[i3]);
            }
          }
          return this;
        };
        function _listeners(target, type2, unwrap) {
          var events = target._events;
          if (events === void 0)
            return [];
          var evlistener = events[type2];
          if (evlistener === void 0)
            return [];
          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type2) {
          return _listeners(this, type2, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type2) {
          return _listeners(this, type2, false);
        };
        EventEmitter.listenerCount = function(emitter, type2) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type2);
          } else {
            return listenerCount.call(emitter, type2);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type2) {
          var events = this._events;
          if (events !== void 0) {
            var evlistener = events[type2];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener !== void 0) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };
        function arrayClone(arr, n2) {
          var copy = new Array(n2);
          for (var i3 = 0; i3 < n2; ++i3)
            copy[i3] = arr[i3];
          return copy;
        }
        function spliceOne(list, index2) {
          for (; index2 + 1 < list.length; index2++)
            list[index2] = list[index2 + 1];
          list.pop();
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i3 = 0; i3 < ret.length; ++i3) {
            ret[i3] = arr[i3].listener || arr[i3];
          }
          return ret;
        }
        function once(emitter, name2) {
          return new Promise(function(resolve, reject) {
            function errorListener(err2) {
              emitter.removeListener(name2, resolver);
              reject(err2);
            }
            function resolver() {
              if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
              }
              resolve([].slice.call(arguments));
            }
            eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
            if (name2 !== "error") {
              addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
            }
          });
        }
        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
          if (typeof emitter.on === "function") {
            eventTargetAgnosticAddListener(emitter, "error", handler, flags);
          }
        }
        function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
          if (typeof emitter.on === "function") {
            if (flags.once) {
              emitter.once(name2, listener);
            } else {
              emitter.on(name2, listener);
            }
          } else if (typeof emitter.addEventListener === "function") {
            emitter.addEventListener(name2, function wrapListener(arg) {
              if (flags.once) {
                emitter.removeEventListener(name2, wrapListener);
              }
              listener(arg);
            });
          } else {
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
          }
        }
      }, {}], 345: [function(require2, module2, exports2) {
        var isCallable = require2("is-callable");
        var toStr = Object.prototype.toString;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var forEachArray = function forEachArray2(array, iterator, receiver) {
          for (var i3 = 0, len = array.length; i3 < len; i3++) {
            if (hasOwnProperty2.call(array, i3)) {
              if (receiver == null) {
                iterator(array[i3], i3, array);
              } else {
                iterator.call(receiver, array[i3], i3, array);
              }
            }
          }
        };
        var forEachString = function forEachString2(string, iterator, receiver) {
          for (var i3 = 0, len = string.length; i3 < len; i3++) {
            if (receiver == null) {
              iterator(string.charAt(i3), i3, string);
            } else {
              iterator.call(receiver, string.charAt(i3), i3, string);
            }
          }
        };
        var forEachObject = function forEachObject2(object, iterator, receiver) {
          for (var k2 in object) {
            if (hasOwnProperty2.call(object, k2)) {
              if (receiver == null) {
                iterator(object[k2], k2, object);
              } else {
                iterator.call(receiver, object[k2], k2, object);
              }
            }
          }
        };
        var forEach2 = function forEach3(list, iterator, thisArg) {
          if (!isCallable(iterator)) {
            throw new TypeError("iterator must be a function");
          }
          var receiver;
          if (arguments.length >= 3) {
            receiver = thisArg;
          }
          if (toStr.call(list) === "[object Array]") {
            forEachArray(list, iterator, receiver);
          } else if (typeof list === "string") {
            forEachString(list, iterator, receiver);
          } else {
            forEachObject(list, iterator, receiver);
          }
        };
        module2.exports = forEach2;
      }, { "is-callable": 367 }], 346: [function(require2, module2, exports2) {
        var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
        var slice = Array.prototype.slice;
        var toStr = Object.prototype.toString;
        var funcType = "[object Function]";
        module2.exports = function bind2(that) {
          var target = this;
          if (typeof target !== "function" || toStr.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
          }
          var args = slice.call(arguments, 1);
          var bound;
          var binder = function() {
            if (this instanceof bound) {
              var result = target.apply(this, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          var boundLength = Math.max(0, target.length - args.length);
          var boundArgs = [];
          for (var i3 = 0; i3 < boundLength; i3++) {
            boundArgs.push("$" + i3);
          }
          bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
          if (target.prototype) {
            var Empty = function Empty2() {
            };
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
      }, {}], 347: [function(require2, module2, exports2) {
        var implementation = require2("./implementation");
        module2.exports = Function.prototype.bind || implementation;
      }, { "./implementation": 346 }], 348: [function(require2, module2, exports2) {
        var undefined$1;
        var $SyntaxError = SyntaxError;
        var $Function = Function;
        var $TypeError = TypeError;
        var getEvalledConstructor = function(expressionSyntax) {
          try {
            return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
          } catch (e2) {
          }
        };
        var $gOPD = Object.getOwnPropertyDescriptor;
        if ($gOPD) {
          try {
            $gOPD({}, "");
          } catch (e2) {
            $gOPD = null;
          }
        }
        var throwTypeError = function() {
          throw new $TypeError();
        };
        var ThrowTypeError = $gOPD ? function() {
          try {
            arguments.callee;
            return throwTypeError;
          } catch (calleeThrows) {
            try {
              return $gOPD(arguments, "callee").get;
            } catch (gOPDthrows) {
              return throwTypeError;
            }
          }
        }() : throwTypeError;
        var hasSymbols = require2("has-symbols")();
        var hasProto = require2("has-proto")();
        var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
          return x2.__proto__;
        } : null);
        var needsEval = {};
        var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
        var INTRINSICS = {
          "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
          "%Array%": Array,
          "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
          "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
          "%AsyncFromSyncIteratorPrototype%": undefined$1,
          "%AsyncFunction%": needsEval,
          "%AsyncGenerator%": needsEval,
          "%AsyncGeneratorFunction%": needsEval,
          "%AsyncIteratorPrototype%": needsEval,
          "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
          "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
          "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
          "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
          "%Boolean%": Boolean,
          "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
          "%Date%": Date,
          "%decodeURI%": decodeURI,
          "%decodeURIComponent%": decodeURIComponent,
          "%encodeURI%": encodeURI,
          "%encodeURIComponent%": encodeURIComponent,
          "%Error%": Error,
          "%eval%": eval,
          // eslint-disable-line no-eval
          "%EvalError%": EvalError,
          "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
          "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
          "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
          "%Function%": $Function,
          "%GeneratorFunction%": needsEval,
          "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
          "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
          "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
          "%isFinite%": isFinite,
          "%isNaN%": isNaN,
          "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
          "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
          "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
          "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
          "%Math%": Math,
          "%Number%": Number,
          "%Object%": Object,
          "%parseFloat%": parseFloat,
          "%parseInt%": parseInt,
          "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
          "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
          "%RangeError%": RangeError,
          "%ReferenceError%": ReferenceError,
          "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
          "%RegExp%": RegExp,
          "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
          "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
          "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
          "%String%": String,
          "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
          "%Symbol%": hasSymbols ? Symbol : undefined$1,
          "%SyntaxError%": $SyntaxError,
          "%ThrowTypeError%": ThrowTypeError,
          "%TypedArray%": TypedArray,
          "%TypeError%": $TypeError,
          "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
          "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
          "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
          "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
          "%URIError%": URIError,
          "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
          "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
          "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
        };
        if (getProto) {
          try {
            null.error;
          } catch (e2) {
            var errorProto = getProto(getProto(e2));
            INTRINSICS["%Error.prototype%"] = errorProto;
          }
        }
        var doEval = function doEval2(name2) {
          var value;
          if (name2 === "%AsyncFunction%") {
            value = getEvalledConstructor("async function () {}");
          } else if (name2 === "%GeneratorFunction%") {
            value = getEvalledConstructor("function* () {}");
          } else if (name2 === "%AsyncGeneratorFunction%") {
            value = getEvalledConstructor("async function* () {}");
          } else if (name2 === "%AsyncGenerator%") {
            var fn = doEval2("%AsyncGeneratorFunction%");
            if (fn) {
              value = fn.prototype;
            }
          } else if (name2 === "%AsyncIteratorPrototype%") {
            var gen = doEval2("%AsyncGenerator%");
            if (gen && getProto) {
              value = getProto(gen.prototype);
            }
          }
          INTRINSICS[name2] = value;
          return value;
        };
        var LEGACY_ALIASES = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] };
        var bind2 = require2("function-bind");
        var hasOwn = require2("has");
        var $concat = bind2.call(Function.call, Array.prototype.concat);
        var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
        var $replace = bind2.call(Function.call, String.prototype.replace);
        var $strSlice = bind2.call(Function.call, String.prototype.slice);
        var $exec = bind2.call(Function.call, RegExp.prototype.exec);
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g;
        var stringToPath = function stringToPath2(string) {
          var first = $strSlice(string, 0, 1);
          var last = $strSlice(string, -1);
          if (first === "%" && last !== "%") {
            throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
          } else if (last === "%" && first !== "%") {
            throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
          }
          var result = [];
          $replace(string, rePropName, function(match, number, quote, subString) {
            result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
          });
          return result;
        };
        var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
          var intrinsicName = name2;
          var alias;
          if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = "%" + alias[0] + "%";
          }
          if (hasOwn(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) {
              value = doEval(intrinsicName);
            }
            if (typeof value === "undefined" && !allowMissing) {
              throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
            }
            return { alias, name: intrinsicName, value };
          }
          throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
        };
        module2.exports = function GetIntrinsic(name2, allowMissing) {
          if (typeof name2 !== "string" || name2.length === 0) {
            throw new $TypeError("intrinsic name must be a non-empty string");
          }
          if (arguments.length > 1 && typeof allowMissing !== "boolean") {
            throw new $TypeError('"allowMissing" argument must be a boolean');
          }
          if ($exec(/^%?[^%]*%?$/, name2) === null) {
            throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          }
          var parts = stringToPath(name2);
          var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
          var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
          var intrinsicRealName = intrinsic.name;
          var value = intrinsic.value;
          var skipFurtherCaching = false;
          var alias = intrinsic.alias;
          if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat([0, 1], alias));
          }
          for (var i3 = 1, isOwn = true; i3 < parts.length; i3 += 1) {
            var part = parts[i3];
            var first = $strSlice(part, 0, 1);
            var last = $strSlice(part, -1);
            if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
              throw new $SyntaxError("property names with quotes must have matching quotes");
            }
            if (part === "constructor" || !isOwn) {
              skipFurtherCaching = true;
            }
            intrinsicBaseName += "." + part;
            intrinsicRealName = "%" + intrinsicBaseName + "%";
            if (hasOwn(INTRINSICS, intrinsicRealName)) {
              value = INTRINSICS[intrinsicRealName];
            } else if (value != null) {
              if (!(part in value)) {
                if (!allowMissing) {
                  throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
                }
                return void 0;
              }
              if ($gOPD && i3 + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                  value = desc.get;
                } else {
                  value = value[part];
                }
              } else {
                isOwn = hasOwn(value, part);
                value = value[part];
              }
              if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
              }
            }
          }
          return value;
        };
      }, { "function-bind": 347, "has": 354, "has-proto": 350, "has-symbols": 351 }], 349: [function(require2, module2, exports2) {
        var GetIntrinsic = require2("get-intrinsic");
        var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
        if ($gOPD) {
          try {
            $gOPD([], "length");
          } catch (e2) {
            $gOPD = null;
          }
        }
        module2.exports = $gOPD;
      }, { "get-intrinsic": 348 }], 350: [function(require2, module2, exports2) {
        var test = { foo: {} };
        var $Object = Object;
        module2.exports = function hasProto() {
          return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
        };
      }, {}], 351: [function(require2, module2, exports2) {
        var origSymbol = typeof Symbol !== "undefined" && Symbol;
        var hasSymbolSham = require2("./shams");
        module2.exports = function hasNativeSymbols() {
          if (typeof origSymbol !== "function") {
            return false;
          }
          if (typeof Symbol !== "function") {
            return false;
          }
          if (typeof origSymbol("foo") !== "symbol") {
            return false;
          }
          if (typeof Symbol("bar") !== "symbol") {
            return false;
          }
          return hasSymbolSham();
        };
      }, { "./shams": 352 }], 352: [function(require2, module2, exports2) {
        module2.exports = function hasSymbols() {
          if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
            return false;
          }
          if (typeof Symbol.iterator === "symbol") {
            return true;
          }
          var obj = {};
          var sym = Symbol("test");
          var symObj = Object(sym);
          if (typeof sym === "string") {
            return false;
          }
          if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
            return false;
          }
          if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
            return false;
          }
          var symVal = 42;
          obj[sym] = symVal;
          for (sym in obj) {
            return false;
          }
          if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
            return false;
          }
          if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
            return false;
          }
          var syms = Object.getOwnPropertySymbols(obj);
          if (syms.length !== 1 || syms[0] !== sym) {
            return false;
          }
          if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
          }
          if (typeof Object.getOwnPropertyDescriptor === "function") {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
              return false;
            }
          }
          return true;
        };
      }, {}], 353: [function(require2, module2, exports2) {
        var hasSymbols = require2("has-symbols/shams");
        module2.exports = function hasToStringTagShams() {
          return hasSymbols() && !!Symbol.toStringTag;
        };
      }, { "has-symbols/shams": 352 }], 354: [function(require2, module2, exports2) {
        var bind2 = require2("function-bind");
        module2.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
      }, { "function-bind": 347 }], 355: [function(require2, module2, exports2) {
        var http = require2("http");
        var url = require2("url");
        var https = module2.exports;
        for (var key in http) {
          if (http.hasOwnProperty(key))
            https[key] = http[key];
        }
        https.request = function(params, cb) {
          params = validateParams(params);
          return http.request.call(this, params, cb);
        };
        https.get = function(params, cb) {
          params = validateParams(params);
          return http.get.call(this, params, cb);
        };
        function validateParams(params) {
          if (typeof params === "string") {
            params = url.parse(params);
          }
          if (!params.protocol) {
            params.protocol = "https:";
          }
          if (params.protocol !== "https:") {
            throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
          }
          return params;
        }
      }, { "http": 468, "url": 472 }], 356: [function(require2, module2, exports2) {
        var util = require2("util");
        var ms = require2("ms");
        module2.exports = function(t2) {
          if (typeof t2 === "number")
            return t2;
          var r2 = ms(t2);
          if (r2 === void 0) {
            var err2 = new Error(util.format("humanize-ms(%j) result undefined", t2));
            console.warn(err2.stack);
          }
          return r2;
        };
      }, { "ms": 376, "util": 419 }], 357: [function(require2, module2, exports2) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        exports2.read = function(buffer, offset2, isLE, mLen, nBytes) {
          var e2, m2;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i3 = isLE ? nBytes - 1 : 0;
          var d2 = isLE ? -1 : 1;
          var s2 = buffer[offset2 + i3];
          i3 += d2;
          e2 = s2 & (1 << -nBits) - 1;
          s2 >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e2 = e2 * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
          }
          m2 = e2 & (1 << -nBits) - 1;
          e2 >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i3], i3 += d2, nBits -= 8) {
          }
          if (e2 === 0) {
            e2 = 1 - eBias;
          } else if (e2 === eMax) {
            return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
          } else {
            m2 = m2 + Math.pow(2, mLen);
            e2 = e2 - eBias;
          }
          return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
        };
        exports2.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
          var e2, m2, c2;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i3 = isLE ? 0 : nBytes - 1;
          var d2 = isLE ? 1 : -1;
          var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m2 = isNaN(value) ? 1 : 0;
            e2 = eMax;
          } else {
            e2 = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c2 = Math.pow(2, -e2)) < 1) {
              e2--;
              c2 *= 2;
            }
            if (e2 + eBias >= 1) {
              value += rt2 / c2;
            } else {
              value += rt2 * Math.pow(2, 1 - eBias);
            }
            if (value * c2 >= 2) {
              e2++;
              c2 /= 2;
            }
            if (e2 + eBias >= eMax) {
              m2 = 0;
              e2 = eMax;
            } else if (e2 + eBias >= 1) {
              m2 = (value * c2 - 1) * Math.pow(2, mLen);
              e2 = e2 + eBias;
            } else {
              m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e2 = 0;
            }
          }
          for (; mLen >= 8; buffer[offset2 + i3] = m2 & 255, i3 += d2, m2 /= 256, mLen -= 8) {
          }
          e2 = e2 << mLen | m2;
          eLen += mLen;
          for (; eLen > 0; buffer[offset2 + i3] = e2 & 255, i3 += d2, e2 /= 256, eLen -= 8) {
          }
          buffer[offset2 + i3 - d2] |= s2 * 128;
        };
      }, {}], 358: [function(require2, module2, exports2) {
        var types2 = [require2("./nextTick"), require2("./queueMicrotask"), require2("./mutation.js"), require2("./messageChannel"), require2("./stateChange"), require2("./timeout")];
        var draining;
        var currentQueue;
        var queueIndex = -1;
        var queue2 = [];
        var scheduled = false;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue2 = currentQueue.concat(queue2);
          } else {
            queueIndex = -1;
          }
          if (queue2.length) {
            nextTick2();
          }
        }
        function nextTick2() {
          if (draining) {
            return;
          }
          scheduled = false;
          draining = true;
          var len2 = queue2.length;
          var timeout2 = setTimeout(cleanUpNextTick);
          while (len2) {
            currentQueue = queue2;
            queue2 = [];
            while (currentQueue && ++queueIndex < len2) {
              currentQueue[queueIndex].run();
            }
            queueIndex = -1;
            len2 = queue2.length;
          }
          currentQueue = null;
          queueIndex = -1;
          draining = false;
          clearTimeout(timeout2);
        }
        var scheduleDrain;
        var i3 = -1;
        var len = types2.length;
        while (++i3 < len) {
          if (types2[i3] && types2[i3].test && types2[i3].test()) {
            scheduleDrain = types2[i3].install(nextTick2);
            break;
          }
        }
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          var fun = this.fun;
          var array = this.array;
          switch (array.length) {
            case 0:
              return fun();
            case 1:
              return fun(array[0]);
            case 2:
              return fun(array[0], array[1]);
            case 3:
              return fun(array[0], array[1], array[2]);
            default:
              return fun.apply(null, array);
          }
        };
        module2.exports = immediate;
        function immediate(task) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i4 = 1; i4 < arguments.length; i4++) {
              args[i4 - 1] = arguments[i4];
            }
          }
          queue2.push(new Item(task, args));
          if (!scheduled && !draining) {
            scheduled = true;
            scheduleDrain();
          }
        }
      }, { "./messageChannel": 359, "./mutation.js": 360, "./nextTick": 89, "./queueMicrotask": 361, "./stateChange": 362, "./timeout": 363 }], 359: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            exports2.test = function() {
              if (global3.setImmediate) {
                return false;
              }
              return typeof global3.MessageChannel !== "undefined";
            };
            exports2.install = function(func) {
              var channel = new global3.MessageChannel();
              channel.port1.onmessage = func;
              return function() {
                channel.port2.postMessage(0);
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 360: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            var Mutation = global3.MutationObserver || global3.WebKitMutationObserver;
            exports2.test = function() {
              return Mutation;
            };
            exports2.install = function(handle) {
              var called = 0;
              var observer = new Mutation(handle);
              var element = global3.document.createTextNode("");
              observer.observe(element, { characterData: true });
              return function() {
                element.data = called = ++called % 2;
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 361: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            exports2.test = function() {
              return typeof global3.queueMicrotask === "function";
            };
            exports2.install = function(func) {
              return function() {
                global3.queueMicrotask(func);
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 362: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            exports2.test = function() {
              return "document" in global3 && "onreadystatechange" in global3.document.createElement("script");
            };
            exports2.install = function(handle) {
              return function() {
                var scriptEl = global3.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  handle();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global3.document.documentElement.appendChild(scriptEl);
                return handle;
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 363: [function(require2, module2, exports2) {
        exports2.test = function() {
          return true;
        };
        exports2.install = function(t2) {
          return function() {
            setTimeout(t2, 0);
          };
        };
      }, {}], 364: [function(require2, module2, exports2) {
        if (typeof Object.create === "function") {
          module2.exports = function inherits2(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
            }
          };
        } else {
          module2.exports = function inherits2(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      }, {}], 365: [function(require2, module2, exports2) {
        var hasToStringTag = require2("has-tostringtag/shams")();
        var callBound = require2("call-bind/callBound");
        var $toString = callBound("Object.prototype.toString");
        var isStandardArguments = function isArguments(value) {
          if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
            return false;
          }
          return $toString(value) === "[object Arguments]";
        };
        var isLegacyArguments = function isArguments(value) {
          if (isStandardArguments(value)) {
            return true;
          }
          return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
        };
        var supportsStandardArguments = function() {
          return isStandardArguments(arguments);
        }();
        isStandardArguments.isLegacyArguments = isLegacyArguments;
        module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
      }, { "call-bind/callBound": 92, "has-tostringtag/shams": 353 }], 366: [function(require2, module2, exports2) {
        /*!
        * Determine if an object is a Buffer
        *
        * @author   Feross Aboukhadijeh <https://feross.org>
        * @license  MIT
        */
        module2.exports = function(obj) {
          return obj != null && (isBuffer2(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer2(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer2(obj.slice(0, 0));
        }
      }, {}], 367: [function(require2, module2, exports2) {
        var fnToStr = Function.prototype.toString;
        var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
        var badArrayLike;
        var isCallableMarker;
        if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
          try {
            badArrayLike = Object.defineProperty({}, "length", { get: function() {
              throw isCallableMarker;
            } });
            isCallableMarker = {};
            reflectApply(function() {
              throw 42;
            }, null, badArrayLike);
          } catch (_2) {
            if (_2 !== isCallableMarker) {
              reflectApply = null;
            }
          }
        } else {
          reflectApply = null;
        }
        var constructorRegex = /^\s*class\b/;
        var isES6ClassFn = function isES6ClassFunction(value) {
          try {
            var fnStr = fnToStr.call(value);
            return constructorRegex.test(fnStr);
          } catch (e2) {
            return false;
          }
        };
        var tryFunctionObject = function tryFunctionToStr(value) {
          try {
            if (isES6ClassFn(value)) {
              return false;
            }
            fnToStr.call(value);
            return true;
          } catch (e2) {
            return false;
          }
        };
        var toStr = Object.prototype.toString;
        var objectClass = "[object Object]";
        var fnClass = "[object Function]";
        var genClass = "[object GeneratorFunction]";
        var ddaClass = "[object HTMLAllCollection]";
        var ddaClass2 = "[object HTML document.all class]";
        var ddaClass3 = "[object HTMLCollection]";
        var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
        var isIE68 = !(0 in [,]);
        var isDDA = function isDocumentDotAll() {
          return false;
        };
        if (typeof document === "object") {
          var all2 = document.all;
          if (toStr.call(all2) === toStr.call(document.all)) {
            isDDA = function isDocumentDotAll(value) {
              if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                try {
                  var str = toStr.call(value);
                  return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
                } catch (e2) {
                }
              }
              return false;
            };
          }
        }
        module2.exports = reflectApply ? function isCallable(value) {
          if (isDDA(value)) {
            return true;
          }
          if (!value) {
            return false;
          }
          if (typeof value !== "function" && typeof value !== "object") {
            return false;
          }
          try {
            reflectApply(value, null, badArrayLike);
          } catch (e2) {
            if (e2 !== isCallableMarker) {
              return false;
            }
          }
          return !isES6ClassFn(value) && tryFunctionObject(value);
        } : function isCallable(value) {
          if (isDDA(value)) {
            return true;
          }
          if (!value) {
            return false;
          }
          if (typeof value !== "function" && typeof value !== "object") {
            return false;
          }
          if (hasToStringTag) {
            return tryFunctionObject(value);
          }
          if (isES6ClassFn(value)) {
            return false;
          }
          var strClass = toStr.call(value);
          if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
            return false;
          }
          return tryFunctionObject(value);
        };
      }, {}], 368: [function(require2, module2, exports2) {
        var toStr = Object.prototype.toString;
        var fnToStr = Function.prototype.toString;
        var isFnRegex = /^\s*(?:function)?\*/;
        var hasToStringTag = require2("has-tostringtag/shams")();
        var getProto = Object.getPrototypeOf;
        var getGeneratorFunc = function() {
          if (!hasToStringTag) {
            return false;
          }
          try {
            return Function("return function*() {}")();
          } catch (e2) {
          }
        };
        var GeneratorFunction;
        module2.exports = function isGeneratorFunction(fn) {
          if (typeof fn !== "function") {
            return false;
          }
          if (isFnRegex.test(fnToStr.call(fn))) {
            return true;
          }
          if (!hasToStringTag) {
            var str = toStr.call(fn);
            return str === "[object GeneratorFunction]";
          }
          if (!getProto) {
            return false;
          }
          if (typeof GeneratorFunction === "undefined") {
            var generatorFunc = getGeneratorFunc();
            GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
          }
          return getProto(fn) === GeneratorFunction;
        };
      }, { "has-tostringtag/shams": 353 }], 369: [function(require2, module2, exports2) {
        var whichTypedArray = require2("which-typed-array");
        module2.exports = function isTypedArray2(value) {
          return !!whichTypedArray(value);
        };
      }, { "which-typed-array": 420 }], 370: [function(require2, module2, exports2) {
        var toString3 = {}.toString;
        module2.exports = Array.isArray || function(arr) {
          return toString3.call(arr) == "[object Array]";
        };
      }, {}], 371: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            (function(global4, factory) {
              typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory(global4) : factory(global4);
            })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global3 !== "undefined" ? global3 : this, function(global4) {
              global4 = global4 || {};
              var _Base64 = global4.Base64;
              var version2 = "2.6.4";
              var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              var b64tab = function(bin) {
                var t2 = {};
                for (var i3 = 0, l2 = bin.length; i3 < l2; i3++)
                  t2[bin.charAt(i3)] = i3;
                return t2;
              }(b64chars);
              var fromCharCode = String.fromCharCode;
              var cb_utob = function(c2) {
                if (c2.length < 2) {
                  var cc = c2.charCodeAt(0);
                  return cc < 128 ? c2 : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
                } else {
                  var cc = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
                  return fromCharCode(240 | cc >>> 18 & 7) + fromCharCode(128 | cc >>> 12 & 63) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
                }
              };
              var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
              var utob = function(u3) {
                return u3.replace(re_utob, cb_utob);
              };
              var cb_encode = function(ccc) {
                var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0), chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? "=" : b64chars.charAt(ord & 63)];
                return chars.join("");
              };
              var btoa2 = global4.btoa && typeof global4.btoa == "function" ? function(b2) {
                return global4.btoa(b2);
              } : function(b2) {
                if (b2.match(/[^\x00-\xFF]/))
                  throw new RangeError("The string contains invalid characters.");
                return b2.replace(/[\s\S]{1,3}/g, cb_encode);
              };
              var _encode = function(u3) {
                return btoa2(utob(String(u3)));
              };
              var mkUriSafe = function(b64) {
                return b64.replace(/[+\/]/g, function(m0) {
                  return m0 == "+" ? "-" : "_";
                }).replace(/=/g, "");
              };
              var encode2 = function(u3, urisafe) {
                return urisafe ? mkUriSafe(_encode(u3)) : _encode(u3);
              };
              var encodeURI2 = function(u3) {
                return encode2(u3, true);
              };
              var fromUint8Array;
              if (global4.Uint8Array)
                fromUint8Array = function(a2, urisafe) {
                  var b64 = "";
                  for (var i3 = 0, l2 = a2.length; i3 < l2; i3 += 3) {
                    var a0 = a2[i3], a1 = a2[i3 + 1], a22 = a2[i3 + 2];
                    var ord = a0 << 16 | a1 << 8 | a22;
                    b64 += b64chars.charAt(ord >>> 18) + b64chars.charAt(ord >>> 12 & 63) + (typeof a1 != "undefined" ? b64chars.charAt(ord >>> 6 & 63) : "=") + (typeof a22 != "undefined" ? b64chars.charAt(ord & 63) : "=");
                  }
                  return urisafe ? mkUriSafe(b64) : b64;
                };
              var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
              var cb_btou = function(cccc) {
                switch (cccc.length) {
                  case 4:
                    var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset2 = cp - 65536;
                    return fromCharCode((offset2 >>> 10) + 55296) + fromCharCode((offset2 & 1023) + 56320);
                  case 3:
                    return fromCharCode((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
                  default:
                    return fromCharCode((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
                }
              };
              var btou = function(b2) {
                return b2.replace(re_btou, cb_btou);
              };
              var cb_decode = function(cccc) {
                var len = cccc.length, padlen = len % 4, n2 = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0), chars = [fromCharCode(n2 >>> 16), fromCharCode(n2 >>> 8 & 255), fromCharCode(n2 & 255)];
                chars.length -= [0, 0, 2, 1][padlen];
                return chars.join("");
              };
              var _atob = global4.atob && typeof global4.atob == "function" ? function(a2) {
                return global4.atob(a2);
              } : function(a2) {
                return a2.replace(/\S{1,4}/g, cb_decode);
              };
              var atob2 = function(a2) {
                return _atob(String(a2).replace(/[^A-Za-z0-9\+\/]/g, ""));
              };
              var _decode = function(a2) {
                return btou(_atob(a2));
              };
              var _fromURI = function(a2) {
                return String(a2).replace(/[-_]/g, function(m0) {
                  return m0 == "-" ? "+" : "/";
                }).replace(/[^A-Za-z0-9\+\/]/g, "");
              };
              var decode = function(a2) {
                return _decode(_fromURI(a2));
              };
              var toUint8Array;
              if (global4.Uint8Array)
                toUint8Array = function(a2) {
                  return Uint8Array.from(atob2(_fromURI(a2)), function(c2) {
                    return c2.charCodeAt(0);
                  });
                };
              var noConflict = function() {
                var Base642 = global4.Base64;
                global4.Base64 = _Base64;
                return Base642;
              };
              global4.Base64 = { VERSION: version2, atob: atob2, btoa: btoa2, fromBase64: decode, toBase64: encode2, utob, encode: encode2, encodeURI: encodeURI2, btou, decode, noConflict, fromUint8Array, toUint8Array };
              if (typeof Object.defineProperty === "function") {
                var noEnum = function(v3) {
                  return { value: v3, enumerable: false, writable: true, configurable: true };
                };
                global4.Base64.extendString = function() {
                  Object.defineProperty(String.prototype, "fromBase64", noEnum(function() {
                    return decode(this);
                  }));
                  Object.defineProperty(String.prototype, "toBase64", noEnum(function(urisafe) {
                    return encode2(this, urisafe);
                  }));
                  Object.defineProperty(String.prototype, "toBase64URI", noEnum(function() {
                    return encode2(this, true);
                  }));
                };
              }
              if (global4["Meteor"]) {
                Base64 = global4.Base64;
              }
              if (typeof module2 !== "undefined" && module2.exports) {
                module2.exports.Base64 = global4.Base64;
              }
              return { Base64: global4.Base64 };
            });
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 372: [function(require2, module2, exports2) {
        module2.exports = merge2;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function merge2(dest, src, redefine) {
          if (!dest) {
            throw new TypeError("argument dest is required");
          }
          if (!src) {
            throw new TypeError("argument src is required");
          }
          if (redefine === void 0) {
            redefine = true;
          }
          Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name2) {
            if (!redefine && hasOwnProperty2.call(dest, name2)) {
              return;
            }
            var descriptor = Object.getOwnPropertyDescriptor(src, name2);
            Object.defineProperty(dest, name2, descriptor);
          });
          return dest;
        }
      }, {}], 373: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.regexp.constructor.js");
        require2("core-js/modules/es.regexp.to-string.js");
        function Mime() {
          this._types = /* @__PURE__ */ Object.create(null);
          this._extensions = /* @__PURE__ */ Object.create(null);
          for (var i3 = 0; i3 < arguments.length; i3++) {
            this.define(arguments[i3]);
          }
          this.define = this.define.bind(this);
          this.getType = this.getType.bind(this);
          this.getExtension = this.getExtension.bind(this);
        }
        Mime.prototype.define = function(typeMap, force) {
          for (var type2 in typeMap) {
            var extensions = typeMap[type2].map(function(t2) {
              return t2.toLowerCase();
            });
            type2 = type2.toLowerCase();
            for (var i3 = 0; i3 < extensions.length; i3++) {
              var ext = extensions[i3];
              if (ext[0] === "*") {
                continue;
              }
              if (!force && ext in this._types) {
                throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type2 + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type2 + '".');
              }
              this._types[ext] = type2;
            }
            if (force || !this._extensions[type2]) {
              var _ext = extensions[0];
              this._extensions[type2] = _ext[0] !== "*" ? _ext : _ext.substr(1);
            }
          }
        };
        Mime.prototype.getType = function(path) {
          path = String(path);
          var last = path.replace(/^.*[/\\]/, "").toLowerCase();
          var ext = last.replace(/^.*\./, "").toLowerCase();
          var hasPath = last.length < path.length;
          var hasDot = ext.length < last.length - 1;
          return (hasDot || !hasPath) && this._types[ext] || null;
        };
        Mime.prototype.getExtension = function(type2) {
          type2 = /^\s*([^;\s]*)/.test(type2) && RegExp.$1;
          return type2 && this._extensions[type2.toLowerCase()] || null;
        };
        module2.exports = Mime;
      }, { "core-js/modules/es.array.map.js": 280, "core-js/modules/es.regexp.constructor.js": 299, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.replace.js": 305 }], 374: [function(require2, module2, exports2) {
        var Mime = require2("./Mime");
        module2.exports = new Mime(require2("./types/standard"));
      }, { "./Mime": 373, "./types/standard": 375 }], 375: [function(require2, module2, exports2) {
        module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
      }, {}], 376: [function(require2, module2, exports2) {
        var s2 = 1e3;
        var m2 = s2 * 60;
        var h2 = m2 * 60;
        var d2 = h2 * 24;
        var w2 = d2 * 7;
        var y3 = d2 * 365.25;
        module2.exports = function(val, options) {
          options = options || {};
          var type2 = typeof val;
          if (type2 === "string" && val.length > 0) {
            return parse(val);
          } else if (type2 === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
          if (!match) {
            return;
          }
          var n2 = parseFloat(match[1]);
          var type2 = (match[2] || "ms").toLowerCase();
          switch (type2) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n2 * y3;
            case "weeks":
            case "week":
            case "w":
              return n2 * w2;
            case "days":
            case "day":
            case "d":
              return n2 * d2;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n2 * h2;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n2 * m2;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n2 * s2;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n2;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d2) {
            return Math.round(ms / d2) + "d";
          }
          if (msAbs >= h2) {
            return Math.round(ms / h2) + "h";
          }
          if (msAbs >= m2) {
            return Math.round(ms / m2) + "m";
          }
          if (msAbs >= s2) {
            return Math.round(ms / s2) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d2) {
            return plural(ms, msAbs, d2, "day");
          }
          if (msAbs >= h2) {
            return plural(ms, msAbs, h2, "hour");
          }
          if (msAbs >= m2) {
            return plural(ms, msAbs, m2, "minute");
          }
          if (msAbs >= s2) {
            return plural(ms, msAbs, s2, "second");
          }
          return ms + " ms";
        }
        function plural(ms, msAbs, n2, name2) {
          var isPlural = msAbs >= n2 * 1.5;
          return Math.round(ms / n2) + " " + name2 + (isPlural ? "s" : "");
        }
      }, {}], 377: [function(require2, module2, exports2) {
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Object.assign cannot be called with null or undefined");
          }
          return Object(val);
        }
        function shouldUseNative() {
          try {
            if (!Object.assign) {
              return false;
            }
            var test1 = new String("abc");
            test1[5] = "de";
            if (Object.getOwnPropertyNames(test1)[0] === "5") {
              return false;
            }
            var test2 = {};
            for (var i3 = 0; i3 < 10; i3++) {
              test2["_" + String.fromCharCode(i3)] = i3;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
              return test2[n2];
            });
            if (order2.join("") !== "0123456789") {
              return false;
            }
            var test3 = {};
            "abcdefghijklmnopqrst".split("").forEach(function(letter) {
              test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
              return false;
            }
            return true;
          } catch (err2) {
            return false;
          }
        }
        module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
          var from;
          var to = toObject(target);
          var symbols;
          for (var s2 = 1; s2 < arguments.length; s2++) {
            from = Object(arguments[s2]);
            for (var key in from) {
              if (hasOwnProperty2.call(from, key)) {
                to[key] = from[key];
              }
            }
            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (var i3 = 0; i3 < symbols.length; i3++) {
                if (propIsEnumerable.call(from, symbols[i3])) {
                  to[symbols[i3]] = from[symbols[i3]];
                }
              }
            }
          }
          return to;
        };
      }, {}], 378: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            function assertPath(path) {
              if (typeof path !== "string") {
                throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
              }
            }
            function normalizeStringPosix(path, allowAboveRoot) {
              var res = "";
              var lastSegmentLength = 0;
              var lastSlash = -1;
              var dots = 0;
              var code;
              for (var i3 = 0; i3 <= path.length; ++i3) {
                if (i3 < path.length)
                  code = path.charCodeAt(i3);
                else if (code === 47)
                  break;
                else
                  code = 47;
                if (code === 47) {
                  if (lastSlash === i3 - 1 || dots === 1)
                    ;
                  else if (lastSlash !== i3 - 1 && dots === 2) {
                    if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                      if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                          if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                          } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                          }
                          lastSlash = i3;
                          dots = 0;
                          continue;
                        }
                      } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i3;
                        dots = 0;
                        continue;
                      }
                    }
                    if (allowAboveRoot) {
                      if (res.length > 0)
                        res += "/..";
                      else
                        res = "..";
                      lastSegmentLength = 2;
                    }
                  } else {
                    if (res.length > 0)
                      res += "/" + path.slice(lastSlash + 1, i3);
                    else
                      res = path.slice(lastSlash + 1, i3);
                    lastSegmentLength = i3 - lastSlash - 1;
                  }
                  lastSlash = i3;
                  dots = 0;
                } else if (code === 46 && dots !== -1) {
                  ++dots;
                } else {
                  dots = -1;
                }
              }
              return res;
            }
            function _format(sep, pathObject) {
              var dir = pathObject.dir || pathObject.root;
              var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
              if (!dir) {
                return base;
              }
              if (dir === pathObject.root) {
                return dir + base;
              }
              return dir + sep + base;
            }
            var posix = {
              // path.resolve([from ...], to)
              resolve: function resolve() {
                var resolvedPath = "";
                var resolvedAbsolute = false;
                var cwd;
                for (var i3 = arguments.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
                  var path;
                  if (i3 >= 0)
                    path = arguments[i3];
                  else {
                    if (cwd === void 0)
                      cwd = process.cwd();
                    path = cwd;
                  }
                  assertPath(path);
                  if (path.length === 0) {
                    continue;
                  }
                  resolvedPath = path + "/" + resolvedPath;
                  resolvedAbsolute = path.charCodeAt(0) === 47;
                }
                resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
                if (resolvedAbsolute) {
                  if (resolvedPath.length > 0)
                    return "/" + resolvedPath;
                  else
                    return "/";
                } else if (resolvedPath.length > 0) {
                  return resolvedPath;
                } else {
                  return ".";
                }
              },
              normalize: function normalize(path) {
                assertPath(path);
                if (path.length === 0)
                  return ".";
                var isAbsolute = path.charCodeAt(0) === 47;
                var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
                path = normalizeStringPosix(path, !isAbsolute);
                if (path.length === 0 && !isAbsolute)
                  path = ".";
                if (path.length > 0 && trailingSeparator)
                  path += "/";
                if (isAbsolute)
                  return "/" + path;
                return path;
              },
              isAbsolute: function isAbsolute(path) {
                assertPath(path);
                return path.length > 0 && path.charCodeAt(0) === 47;
              },
              join: function join() {
                if (arguments.length === 0)
                  return ".";
                var joined;
                for (var i3 = 0; i3 < arguments.length; ++i3) {
                  var arg = arguments[i3];
                  assertPath(arg);
                  if (arg.length > 0) {
                    if (joined === void 0)
                      joined = arg;
                    else
                      joined += "/" + arg;
                  }
                }
                if (joined === void 0)
                  return ".";
                return posix.normalize(joined);
              },
              relative: function relative(from, to) {
                assertPath(from);
                assertPath(to);
                if (from === to)
                  return "";
                from = posix.resolve(from);
                to = posix.resolve(to);
                if (from === to)
                  return "";
                var fromStart = 1;
                for (; fromStart < from.length; ++fromStart) {
                  if (from.charCodeAt(fromStart) !== 47)
                    break;
                }
                var fromEnd = from.length;
                var fromLen = fromEnd - fromStart;
                var toStart = 1;
                for (; toStart < to.length; ++toStart) {
                  if (to.charCodeAt(toStart) !== 47)
                    break;
                }
                var toEnd = to.length;
                var toLen = toEnd - toStart;
                var length = fromLen < toLen ? fromLen : toLen;
                var lastCommonSep = -1;
                var i3 = 0;
                for (; i3 <= length; ++i3) {
                  if (i3 === length) {
                    if (toLen > length) {
                      if (to.charCodeAt(toStart + i3) === 47) {
                        return to.slice(toStart + i3 + 1);
                      } else if (i3 === 0) {
                        return to.slice(toStart + i3);
                      }
                    } else if (fromLen > length) {
                      if (from.charCodeAt(fromStart + i3) === 47) {
                        lastCommonSep = i3;
                      } else if (i3 === 0) {
                        lastCommonSep = 0;
                      }
                    }
                    break;
                  }
                  var fromCode = from.charCodeAt(fromStart + i3);
                  var toCode = to.charCodeAt(toStart + i3);
                  if (fromCode !== toCode)
                    break;
                  else if (fromCode === 47)
                    lastCommonSep = i3;
                }
                var out = "";
                for (i3 = fromStart + lastCommonSep + 1; i3 <= fromEnd; ++i3) {
                  if (i3 === fromEnd || from.charCodeAt(i3) === 47) {
                    if (out.length === 0)
                      out += "..";
                    else
                      out += "/..";
                  }
                }
                if (out.length > 0)
                  return out + to.slice(toStart + lastCommonSep);
                else {
                  toStart += lastCommonSep;
                  if (to.charCodeAt(toStart) === 47)
                    ++toStart;
                  return to.slice(toStart);
                }
              },
              _makeLong: function _makeLong(path) {
                return path;
              },
              dirname: function dirname(path) {
                assertPath(path);
                if (path.length === 0)
                  return ".";
                var code = path.charCodeAt(0);
                var hasRoot = code === 47;
                var end = -1;
                var matchedSlash = true;
                for (var i3 = path.length - 1; i3 >= 1; --i3) {
                  code = path.charCodeAt(i3);
                  if (code === 47) {
                    if (!matchedSlash) {
                      end = i3;
                      break;
                    }
                  } else {
                    matchedSlash = false;
                  }
                }
                if (end === -1)
                  return hasRoot ? "/" : ".";
                if (hasRoot && end === 1)
                  return "//";
                return path.slice(0, end);
              },
              basename: function basename(path, ext) {
                if (ext !== void 0 && typeof ext !== "string")
                  throw new TypeError('"ext" argument must be a string');
                assertPath(path);
                var start = 0;
                var end = -1;
                var matchedSlash = true;
                var i3;
                if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
                  if (ext.length === path.length && ext === path)
                    return "";
                  var extIdx = ext.length - 1;
                  var firstNonSlashEnd = -1;
                  for (i3 = path.length - 1; i3 >= 0; --i3) {
                    var code = path.charCodeAt(i3);
                    if (code === 47) {
                      if (!matchedSlash) {
                        start = i3 + 1;
                        break;
                      }
                    } else {
                      if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i3 + 1;
                      }
                      if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                          if (--extIdx === -1) {
                            end = i3;
                          }
                        } else {
                          extIdx = -1;
                          end = firstNonSlashEnd;
                        }
                      }
                    }
                  }
                  if (start === end)
                    end = firstNonSlashEnd;
                  else if (end === -1)
                    end = path.length;
                  return path.slice(start, end);
                } else {
                  for (i3 = path.length - 1; i3 >= 0; --i3) {
                    if (path.charCodeAt(i3) === 47) {
                      if (!matchedSlash) {
                        start = i3 + 1;
                        break;
                      }
                    } else if (end === -1) {
                      matchedSlash = false;
                      end = i3 + 1;
                    }
                  }
                  if (end === -1)
                    return "";
                  return path.slice(start, end);
                }
              },
              extname: function extname(path) {
                assertPath(path);
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var preDotState = 0;
                for (var i3 = path.length - 1; i3 >= 0; --i3) {
                  var code = path.charCodeAt(i3);
                  if (code === 47) {
                    if (!matchedSlash) {
                      startPart = i3 + 1;
                      break;
                    }
                    continue;
                  }
                  if (end === -1) {
                    matchedSlash = false;
                    end = i3 + 1;
                  }
                  if (code === 46) {
                    if (startDot === -1)
                      startDot = i3;
                    else if (preDotState !== 1)
                      preDotState = 1;
                  } else if (startDot !== -1) {
                    preDotState = -1;
                  }
                }
                if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                  return "";
                }
                return path.slice(startDot, end);
              },
              format: function format(pathObject) {
                if (pathObject === null || typeof pathObject !== "object") {
                  throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
                }
                return _format("/", pathObject);
              },
              parse: function parse(path) {
                assertPath(path);
                var ret = { root: "", dir: "", base: "", ext: "", name: "" };
                if (path.length === 0)
                  return ret;
                var code = path.charCodeAt(0);
                var isAbsolute = code === 47;
                var start;
                if (isAbsolute) {
                  ret.root = "/";
                  start = 1;
                } else {
                  start = 0;
                }
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var i3 = path.length - 1;
                var preDotState = 0;
                for (; i3 >= start; --i3) {
                  code = path.charCodeAt(i3);
                  if (code === 47) {
                    if (!matchedSlash) {
                      startPart = i3 + 1;
                      break;
                    }
                    continue;
                  }
                  if (end === -1) {
                    matchedSlash = false;
                    end = i3 + 1;
                  }
                  if (code === 46) {
                    if (startDot === -1)
                      startDot = i3;
                    else if (preDotState !== 1)
                      preDotState = 1;
                  } else if (startDot !== -1) {
                    preDotState = -1;
                  }
                }
                if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                  if (end !== -1) {
                    if (startPart === 0 && isAbsolute)
                      ret.base = ret.name = path.slice(1, end);
                    else
                      ret.base = ret.name = path.slice(startPart, end);
                  }
                } else {
                  if (startPart === 0 && isAbsolute) {
                    ret.name = path.slice(1, startDot);
                    ret.base = path.slice(1, end);
                  } else {
                    ret.name = path.slice(startPart, startDot);
                    ret.base = path.slice(startPart, end);
                  }
                  ret.ext = path.slice(startDot, end);
                }
                if (startPart > 0)
                  ret.dir = path.slice(0, startPart - 1);
                else if (isAbsolute)
                  ret.dir = "/";
                return ret;
              },
              sep: "/",
              delimiter: ":",
              win32: null,
              posix: null
            };
            posix.posix = posix;
            module2.exports = posix;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 467 }], 379: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            (function() {
              var objectTypes = { "function": true, "object": true };
              var root = objectTypes[typeof window] && window || this;
              var freeExports = objectTypes[typeof exports2] && exports2;
              var freeModule = objectTypes[typeof module2] && module2 && !module2.nodeType && module2;
              var freeGlobal = freeExports && freeModule && typeof global3 == "object" && global3;
              if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
                root = freeGlobal;
              }
              var maxSafeInteger = Math.pow(2, 53) - 1;
              var reOpera = /\bOpera/;
              var objectProto = Object.prototype;
              var hasOwnProperty2 = objectProto.hasOwnProperty;
              var toString3 = objectProto.toString;
              function capitalize2(string) {
                string = String(string);
                return string.charAt(0).toUpperCase() + string.slice(1);
              }
              function cleanupOS(os, pattern, label) {
                var data = { "10.0": "10", "6.4": "10 Technical Preview", "6.3": "8.1", "6.2": "8", "6.1": "Server 2008 R2 / 7", "6.0": "Server 2008 / Vista", "5.2": "Server 2003 / XP 64-bit", "5.1": "XP", "5.01": "2000 SP1", "5.0": "2000", "4.0": "NT", "4.90": "ME" };
                if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
                  os = "Windows " + data;
                }
                os = String(os);
                if (pattern && label) {
                  os = os.replace(RegExp(pattern, "i"), label);
                }
                os = format(os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]);
                return os;
              }
              function each(object, callback) {
                var index2 = -1, length = object ? object.length : 0;
                if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
                  while (++index2 < length) {
                    callback(object[index2], index2, object);
                  }
                } else {
                  forOwn(object, callback);
                }
              }
              function format(string) {
                string = trim2(string);
                return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize2(string);
              }
              function forOwn(object, callback) {
                for (var key in object) {
                  if (hasOwnProperty2.call(object, key)) {
                    callback(object[key], key, object);
                  }
                }
              }
              function getClassOf(value) {
                return value == null ? capitalize2(value) : toString3.call(value).slice(8, -1);
              }
              function isHostType(object, property) {
                var type2 = object != null ? typeof object[property] : "number";
                return !/^(?:boolean|number|string|undefined)$/.test(type2) && (type2 == "object" ? !!object[property] : true);
              }
              function qualify(string) {
                return String(string).replace(/([ -])(?!$)/g, "$1?");
              }
              function reduce(array, callback) {
                var accumulator = null;
                each(array, function(value, index2) {
                  accumulator = callback(accumulator, value, index2, array);
                });
                return accumulator;
              }
              function trim2(string) {
                return String(string).replace(/^ +| +$/g, "");
              }
              function parse(ua) {
                var context = root;
                var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
                if (isCustomContext) {
                  context = ua;
                  ua = null;
                }
                var nav = context.navigator || {};
                var userAgent2 = nav.userAgent || "";
                ua || (ua = userAgent2);
                var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString3.toString());
                var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
                var java = /\bJava/.test(javaClass) && context.java;
                var rhino = java && getClassOf(context.environment) == enviroClass;
                var alpha = java ? "a" : "α";
                var beta = java ? "b" : "β";
                var doc = context.document || {};
                var opera = context.operamini || context.opera;
                var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
                var data;
                var arch = ua;
                var description2 = [];
                var prerelease = null;
                var useFeatures = ua == userAgent2;
                var version2 = useFeatures && opera && typeof opera.version == "function" && opera.version();
                var isSpecialCasedOS;
                var layout = getLayout([{ "label": "EdgeHTML", "pattern": "Edge" }, "Trident", { "label": "WebKit", "pattern": "AppleWebKit" }, "iCab", "Presto", "NetFront", "Tasman", "KHTML", "Gecko"]);
                var name2 = getName(["Adobe AIR", "Arora", "Avant Browser", "Breach", "Camino", "Electron", "Epiphany", "Fennec", "Flock", "Galeon", "GreenBrowser", "iCab", "Iceweasel", "K-Meleon", "Konqueror", "Lunascape", "Maxthon", { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" }, "Midori", "Nook Browser", "PaleMoon", "PhantomJS", "Raven", "Rekonq", "RockMelt", { "label": "Samsung Internet", "pattern": "SamsungBrowser" }, "SeaMonkey", { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" }, "Sleipnir", "SlimBrowser", { "label": "SRWare Iron", "pattern": "Iron" }, "Sunrise", "Swiftfox", "Vivaldi", "Waterfox", "WebPositive", { "label": "Yandex Browser", "pattern": "YaBrowser" }, { "label": "UC Browser", "pattern": "UCBrowser" }, "Opera Mini", { "label": "Opera Mini", "pattern": "OPiOS" }, "Opera", { "label": "Opera", "pattern": "OPR" }, "Chromium", "Chrome", { "label": "Chrome", "pattern": "(?:HeadlessChrome)" }, { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" }, { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" }, { "label": "Firefox for iOS", "pattern": "FxiOS" }, { "label": "IE", "pattern": "IEMobile" }, { "label": "IE", "pattern": "MSIE" }, "Safari"]);
                var product = getProduct([{ "label": "BlackBerry", "pattern": "BB10" }, "BlackBerry", { "label": "Galaxy S", "pattern": "GT-I9000" }, { "label": "Galaxy S2", "pattern": "GT-I9100" }, { "label": "Galaxy S3", "pattern": "GT-I9300" }, { "label": "Galaxy S4", "pattern": "GT-I9500" }, { "label": "Galaxy S5", "pattern": "SM-G900" }, { "label": "Galaxy S6", "pattern": "SM-G920" }, { "label": "Galaxy S6 Edge", "pattern": "SM-G925" }, { "label": "Galaxy S7", "pattern": "SM-G930" }, { "label": "Galaxy S7 Edge", "pattern": "SM-G935" }, "Google TV", "Lumia", "iPad", "iPod", "iPhone", "Kindle", { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" }, "Nexus", "Nook", "PlayBook", "PlayStation Vita", "PlayStation", "TouchPad", "Transformer", { "label": "Wii U", "pattern": "WiiU" }, "Wii", "Xbox One", { "label": "Xbox 360", "pattern": "Xbox" }, "Xoom"]);
                var manufacturer = getManufacturer({ "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 }, "Alcatel": {}, "Archos": {}, "Amazon": { "Kindle": 1, "Kindle Fire": 1 }, "Asus": { "Transformer": 1 }, "Barnes & Noble": { "Nook": 1 }, "BlackBerry": { "PlayBook": 1 }, "Google": { "Google TV": 1, "Nexus": 1 }, "HP": { "TouchPad": 1 }, "HTC": {}, "Huawei": {}, "Lenovo": {}, "LG": {}, "Microsoft": { "Xbox": 1, "Xbox One": 1 }, "Motorola": { "Xoom": 1 }, "Nintendo": { "Wii U": 1, "Wii": 1 }, "Nokia": { "Lumia": 1 }, "Oppo": {}, "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 }, "Sony": { "PlayStation": 1, "PlayStation Vita": 1 }, "Xiaomi": { "Mi": 1, "Redmi": 1 } });
                var os = getOS(["Windows Phone", "KaiOS", "Android", "CentOS", { "label": "Chrome OS", "pattern": "CrOS" }, "Debian", { "label": "DragonFly BSD", "pattern": "DragonFly" }, "Fedora", "FreeBSD", "Gentoo", "Haiku", "Kubuntu", "Linux Mint", "OpenBSD", "Red Hat", "SuSE", "Ubuntu", "Xubuntu", "Cygwin", "Symbian OS", "hpwOS", "webOS ", "webOS", "Tablet OS", "Tizen", "Linux", "Mac OS X", "Macintosh", "Mac", "Windows 98;", "Windows "]);
                function getLayout(guesses) {
                  return reduce(guesses, function(result, guess) {
                    return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                  });
                }
                function getManufacturer(guesses) {
                  return reduce(guesses, function(result, value, key) {
                    return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
                  });
                }
                function getName(guesses) {
                  return reduce(guesses, function(result, guess) {
                    return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                  });
                }
                function getOS(guesses) {
                  return reduce(guesses, function(result, guess) {
                    var pattern = guess.pattern || qualify(guess);
                    if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
                      result = cleanupOS(result, pattern, guess.label || guess);
                    }
                    return result;
                  });
                }
                function getProduct(guesses) {
                  return reduce(guesses, function(result, guess) {
                    var pattern = guess.pattern || qualify(guess);
                    if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
                      if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                        result[0] += " " + result[1];
                      }
                      guess = guess.label || guess;
                      result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
                    }
                    return result;
                  });
                }
                function getVersion(patterns) {
                  return reduce(patterns, function(result, pattern) {
                    return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
                  });
                }
                function toStringPlatform() {
                  return this.description || "";
                }
                layout && (layout = [layout]);
                if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
                  product = trim2(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
                }
                if (manufacturer && !product) {
                  product = getProduct([manufacturer]);
                } else if (manufacturer && product) {
                  product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
                }
                if (data = /\bGoogle TV\b/.exec(product)) {
                  product = data[0];
                }
                if (/\bSimulator\b/i.test(ua)) {
                  product = (product ? product + " " : "") + "Simulator";
                }
                if (name2 == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
                  description2.push("running in Turbo/Uncompressed mode");
                }
                if (name2 == "IE" && /\blike iPhone OS\b/.test(ua)) {
                  data = parse(ua.replace(/like iPhone OS/, ""));
                  manufacturer = data.manufacturer;
                  product = data.product;
                } else if (/^iP/.test(product)) {
                  name2 || (name2 = "Safari");
                  os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
                } else if (name2 == "Konqueror" && /^Linux\b/i.test(os)) {
                  os = "Kubuntu";
                } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name2) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name2) && /\bVersion\//i.test(ua)) {
                  name2 = "Android Browser";
                  os = /\bAndroid\b/.test(os) ? os : "Android";
                } else if (name2 == "Silk") {
                  if (!/\bMobi/i.test(ua)) {
                    os = "Android";
                    description2.unshift("desktop mode");
                  }
                  if (/Accelerated *= *true/i.test(ua)) {
                    description2.unshift("accelerated");
                  }
                } else if (name2 == "UC Browser" && /\bUCWEB\b/.test(ua)) {
                  description2.push("speed mode");
                } else if (name2 == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
                  description2.push("identifying as Firefox " + data[1]);
                } else if (name2 == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
                  os || (os = "Firefox OS");
                  product || (product = data[1]);
                } else if (!name2 || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name2))) {
                  if (name2 && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
                    name2 = null;
                  }
                  if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
                    name2 = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
                  }
                } else if (name2 == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
                  description2.push("Chromium " + data);
                }
                if (!version2) {
                  version2 = getVersion(["(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)", "Version", qualify(name2), "(?:Firefox|Minefield|NetFront)"]);
                }
                if (data = layout == "iCab" && parseFloat(version2) > 3 && "WebKit" || /\bOpera\b/.test(name2) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name2) && "NetFront") {
                  layout = [data];
                }
                if (name2 == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
                  name2 += " Mobile";
                  os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
                  description2.unshift("desktop mode");
                } else if (/\bWPDesktop\b/i.test(ua)) {
                  name2 = "IE Mobile";
                  os = "Windows Phone 8.x";
                  description2.unshift("desktop mode");
                  version2 || (version2 = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
                } else if (name2 != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
                  if (name2) {
                    description2.push("identifying as " + name2 + (version2 ? " " + version2 : ""));
                  }
                  name2 = "IE";
                  version2 = data[1];
                }
                if (useFeatures) {
                  if (isHostType(context, "global")) {
                    if (java) {
                      data = java.lang.System;
                      arch = data.getProperty("os.arch");
                      os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
                    }
                    if (rhino) {
                      try {
                        version2 = context.require("ringo/engine").version.join(".");
                        name2 = "RingoJS";
                      } catch (e2) {
                        if ((data = context.system) && data.global.system == context.system) {
                          name2 = "Narwhal";
                          os || (os = data[0].os || null);
                        }
                      }
                      if (!name2) {
                        name2 = "Rhino";
                      }
                    } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
                      if (typeof data.versions == "object") {
                        if (typeof data.versions.electron == "string") {
                          description2.push("Node " + data.versions.node);
                          name2 = "Electron";
                          version2 = data.versions.electron;
                        } else if (typeof data.versions.nw == "string") {
                          description2.push("Chromium " + version2, "Node " + data.versions.node);
                          name2 = "NW.js";
                          version2 = data.versions.nw;
                        }
                      }
                      if (!name2) {
                        name2 = "Node.js";
                        arch = data.arch;
                        os = data.platform;
                        version2 = /[\d.]+/.exec(data.version);
                        version2 = version2 ? version2[0] : null;
                      }
                    }
                  } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
                    name2 = "Adobe AIR";
                    os = data.flash.system.Capabilities.os;
                  } else if (getClassOf(data = context.phantom) == phantomClass) {
                    name2 = "PhantomJS";
                    version2 = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
                  } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
                    version2 = [version2, doc.documentMode];
                    if ((data = +data[1] + 4) != version2[1]) {
                      description2.push("IE " + version2[1] + " mode");
                      layout && (layout[1] = "");
                      version2[1] = data;
                    }
                    version2 = name2 == "IE" ? String(version2[1].toFixed(1)) : version2[0];
                  } else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name2)) {
                    description2.push("masking as " + name2 + " " + version2);
                    name2 = "IE";
                    version2 = "11.0";
                    layout = ["Trident"];
                    os = "Windows";
                  }
                  os = os && format(os);
                }
                if (version2 && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version2) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
                  prerelease = /b/i.test(data) ? "beta" : "alpha";
                  version2 = version2.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
                }
                if (name2 == "Fennec" || name2 == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
                  name2 = "Firefox Mobile";
                } else if (name2 == "Maxthon" && version2) {
                  version2 = version2.replace(/\.[\d.]+/, ".x");
                } else if (/\bXbox\b/i.test(product)) {
                  if (product == "Xbox 360") {
                    os = null;
                  }
                  if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
                    description2.unshift("mobile mode");
                  }
                } else if ((/^(?:Chrome|IE|Opera)$/.test(name2) || name2 && !product && !/Browser|Mobi/.test(name2)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
                  name2 += " Mobile";
                } else if (name2 == "IE" && useFeatures) {
                  try {
                    if (context.external === null) {
                      description2.unshift("platform preview");
                    }
                  } catch (e2) {
                    description2.unshift("embedded");
                  }
                } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version2)) {
                  data = [data, /BB10/.test(ua)];
                  os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
                  version2 = null;
                } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name2) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name2 == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name2 == "IE" && (os && !/^Win/.test(os) && version2 > 5.5 || /\bWindows XP\b/.test(os) && version2 > 8 || version2 == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
                  data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
                  if (reOpera.test(name2)) {
                    if (/\bIE\b/.test(data) && os == "Mac OS") {
                      os = null;
                    }
                    data = "identify" + data;
                  } else {
                    data = "mask" + data;
                    if (operaClass) {
                      name2 = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
                    } else {
                      name2 = "Opera";
                    }
                    if (/\bIE\b/.test(data)) {
                      os = null;
                    }
                    if (!useFeatures) {
                      version2 = null;
                    }
                  }
                  layout = ["Presto"];
                  description2.push(data);
                }
                if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
                  data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
                  if (name2 == "Safari" && data[1].slice(-1) == "+") {
                    name2 = "WebKit Nightly";
                    prerelease = "alpha";
                    version2 = data[1].slice(0, -1);
                  } else if (version2 == data[1] || version2 == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
                    version2 = null;
                  }
                  data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
                  if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
                    layout = ["Blink"];
                  }
                  if (!useFeatures || !likeChrome && !data[1]) {
                    layout && (layout[1] = "like Safari");
                    data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
                  } else {
                    layout && (layout[1] = "like Chrome");
                    data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
                  }
                  layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
                  if (name2 == "Safari" && (!version2 || parseInt(version2) > 45)) {
                    version2 = data;
                  } else if (name2 == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
                    description2.unshift("headless");
                  }
                }
                if (name2 == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
                  name2 += " ";
                  description2.unshift("desktop mode");
                  if (data == "zvav") {
                    name2 += "Mini";
                    version2 = null;
                  } else {
                    name2 += "Mobile";
                  }
                  os = os.replace(RegExp(" *" + data + "$"), "");
                } else if (name2 == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
                  description2.unshift("desktop mode");
                  name2 = "Chrome Mobile";
                  version2 = null;
                  if (/\bOS X\b/.test(os)) {
                    manufacturer = "Apple";
                    os = "iOS 4.3+";
                  } else {
                    os = null;
                  }
                } else if (/\bSRWare Iron\b/.test(name2) && !version2) {
                  version2 = getVersion("Chrome");
                }
                if (version2 && version2.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
                  os = trim2(os.replace(data, ""));
                }
                if (os && os.indexOf(name2) != -1 && !RegExp(name2 + " OS").test(os)) {
                  os = os.replace(RegExp(" *" + qualify(name2) + " *"), "");
                }
                if (layout && !/\b(?:Avant|Nook)\b/.test(name2) && (/Browser|Lunascape|Maxthon/.test(name2) || name2 != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name2) && layout[1])) {
                  (data = layout[layout.length - 1]) && description2.push(data);
                }
                if (description2.length) {
                  description2 = ["(" + description2.join("; ") + ")"];
                }
                if (manufacturer && product && product.indexOf(manufacturer) < 0) {
                  description2.push("on " + manufacturer);
                }
                if (product) {
                  description2.push((/^on /.test(description2[description2.length - 1]) ? "" : "on ") + product);
                }
                if (os) {
                  data = / ([\d.+]+)$/.exec(os);
                  isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
                  os = { "architecture": 32, "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os, "version": data ? data[1] : null, "toString": function() {
                    var version3 = this.version;
                    return this.family + (version3 && !isSpecialCasedOS ? " " + version3 : "") + (this.architecture == 64 ? " 64-bit" : "");
                  } };
                }
                if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
                  if (os) {
                    os.architecture = 64;
                    os.family = os.family.replace(RegExp(" *" + data), "");
                  }
                  if (name2 && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
                    description2.unshift("32-bit");
                  }
                } else if (os && /^OS X/.test(os.family) && name2 == "Chrome" && parseFloat(version2) >= 39) {
                  os.architecture = 64;
                }
                ua || (ua = null);
                var platform3 = {};
                platform3.description = ua;
                platform3.layout = layout && layout[0];
                platform3.manufacturer = manufacturer;
                platform3.name = name2;
                platform3.prerelease = prerelease;
                platform3.product = product;
                platform3.ua = ua;
                platform3.version = name2 && version2;
                platform3.os = os || {
                  /**
                  * The CPU architecture the OS is built for.
                  *
                  * @memberOf platform.os
                  * @type number|null
                  */
                  "architecture": null,
                  /**
                  * The family of the OS.
                  *
                  * Common values include:
                  * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
                  * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
                  * "SuSE", "Android", "iOS" and "Windows Phone"
                  *
                  * @memberOf platform.os
                  * @type string|null
                  */
                  "family": null,
                  /**
                  * The version of the OS.
                  *
                  * @memberOf platform.os
                  * @type string|null
                  */
                  "version": null,
                  /**
                  * Returns the OS string.
                  *
                  * @memberOf platform.os
                  * @returns {string} The OS string.
                  */
                  "toString": function() {
                    return "null";
                  }
                };
                platform3.parse = parse;
                platform3.toString = toStringPlatform;
                if (platform3.version) {
                  description2.unshift(version2);
                }
                if (platform3.name) {
                  description2.unshift(name2);
                }
                if (os && name2 && !(os == String(os).split(" ")[0] && (os == name2.split(" ")[0] || product))) {
                  description2.push(product ? "(" + os + ")" : "on " + os);
                }
                if (description2.length) {
                  platform3.description = description2.join(" ");
                }
                return platform3;
              }
              var platform2 = parse();
              if (freeExports && freeModule) {
                forOwn(platform2, function(value, key) {
                  freeExports[key] = value;
                });
              } else {
                root.platform = platform2;
              }
            }).call(this);
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 380: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
              module2.exports = { nextTick: nextTick2 };
            } else {
              module2.exports = process;
            }
            function nextTick2(fn, arg1, arg2, arg3) {
              if (typeof fn !== "function") {
                throw new TypeError('"callback" argument must be a function');
              }
              var len = arguments.length;
              var args, i3;
              switch (len) {
                case 0:
                case 1:
                  return process.nextTick(fn);
                case 2:
                  return process.nextTick(function afterTickOne() {
                    fn.call(null, arg1);
                  });
                case 3:
                  return process.nextTick(function afterTickTwo() {
                    fn.call(null, arg1, arg2);
                  });
                case 4:
                  return process.nextTick(function afterTickThree() {
                    fn.call(null, arg1, arg2, arg3);
                  });
                default:
                  args = new Array(len - 1);
                  i3 = 0;
                  while (i3 < args.length) {
                    args[i3++] = arguments[i3];
                  }
                  return process.nextTick(function afterTick() {
                    fn.apply(null, args);
                  });
              }
            }
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 467 }], 381: [function(require2, module2, exports2) {
        var process = module2.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e2) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e2) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e2) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e3) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e2) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e3) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue2 = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue2 = currentQueue.concat(queue2);
          } else {
            queueIndex = -1;
          }
          if (queue2.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout2 = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue2.length;
          while (len) {
            currentQueue = queue2;
            queue2 = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue2.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout2);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i3 = 1; i3 < arguments.length; i3++) {
              args[i3 - 1] = arguments[i3];
            }
          }
          queue2.push(new Item(fun, args));
          if (queue2.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop2() {
        }
        process.on = noop2;
        process.addListener = noop2;
        process.once = noop2;
        process.off = noop2;
        process.removeListener = noop2;
        process.removeAllListeners = noop2;
        process.emit = noop2;
        process.prependListener = noop2;
        process.prependOnceListener = noop2;
        process.listeners = function(name2) {
          return [];
        };
        process.binding = function(name2) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 382: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            (function(root) {
              var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
              var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
              var freeGlobal = typeof global3 == "object" && global3;
              if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                root = freeGlobal;
              }
              var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = { "overflow": "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
              function error(type2) {
                throw new RangeError(errors[type2]);
              }
              function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array[length]);
                }
                return result;
              }
              function mapDomain(string, fn) {
                var parts = string.split("@");
                var result = "";
                if (parts.length > 1) {
                  result = parts[0] + "@";
                  string = parts[1];
                }
                string = string.replace(regexSeparators, ".");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
              }
              function ucs2decode(string) {
                var output = [], counter = 0, length = string.length, value, extra;
                while (counter < length) {
                  value = string.charCodeAt(counter++);
                  if (value >= 55296 && value <= 56319 && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                      output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                    } else {
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }
              function ucs2encode(array) {
                return map(array, function(value) {
                  var output = "";
                  if (value > 65535) {
                    value -= 65536;
                    output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                    value = 56320 | value & 1023;
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join("");
              }
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }
              function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
              }
              function adapt(delta, numPoints, firstTime) {
                var k2 = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
              }
              function decode(input) {
                var output = [], inputLength = input.length, out, i3 = 0, n2 = initialN, bias = initialBias, basic, j2, index2, oldi, w2, k2, digit, t2, baseMinusT;
                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }
                for (j2 = 0; j2 < basic; ++j2) {
                  if (input.charCodeAt(j2) >= 128) {
                    error("not-basic");
                  }
                  output.push(input.charCodeAt(j2));
                }
                for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
                  for (oldi = i3, w2 = 1, k2 = base; ; k2 += base) {
                    if (index2 >= inputLength) {
                      error("invalid-input");
                    }
                    digit = basicToDigit(input.charCodeAt(index2++));
                    if (digit >= base || digit > floor((maxInt - i3) / w2)) {
                      error("overflow");
                    }
                    i3 += digit * w2;
                    t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                    if (digit < t2) {
                      break;
                    }
                    baseMinusT = base - t2;
                    if (w2 > floor(maxInt / baseMinusT)) {
                      error("overflow");
                    }
                    w2 *= baseMinusT;
                  }
                  out = output.length + 1;
                  bias = adapt(i3 - oldi, out, oldi == 0);
                  if (floor(i3 / out) > maxInt - n2) {
                    error("overflow");
                  }
                  n2 += floor(i3 / out);
                  i3 %= out;
                  output.splice(i3++, 0, n2);
                }
                return ucs2encode(output);
              }
              function encode2(input) {
                var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                input = ucs2decode(input);
                inputLength = input.length;
                n2 = initialN;
                delta = 0;
                bias = initialBias;
                for (j2 = 0; j2 < inputLength; ++j2) {
                  currentValue = input[j2];
                  if (currentValue < 128) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) {
                  output.push(delimiter);
                }
                while (handledCPCount < inputLength) {
                  for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
                    currentValue = input[j2];
                    if (currentValue >= n2 && currentValue < m2) {
                      m2 = currentValue;
                    }
                  }
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error("overflow");
                  }
                  delta += (m2 - n2) * handledCPCountPlusOne;
                  n2 = m2;
                  for (j2 = 0; j2 < inputLength; ++j2) {
                    currentValue = input[j2];
                    if (currentValue < n2 && ++delta > maxInt) {
                      error("overflow");
                    }
                    if (currentValue == n2) {
                      for (q2 = delta, k2 = base; ; k2 += base) {
                        t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                        if (q2 < t2) {
                          break;
                        }
                        qMinusT = q2 - t2;
                        baseMinusT = base - t2;
                        output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                        q2 = floor(qMinusT / baseMinusT);
                      }
                      output.push(stringFromCharCode(digitToBasic(q2, 0)));
                      bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                      delta = 0;
                      ++handledCPCount;
                    }
                  }
                  ++delta;
                  ++n2;
                }
                return output.join("");
              }
              function toUnicode(input) {
                return mapDomain(input, function(string) {
                  return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                });
              }
              function toASCII(input) {
                return mapDomain(input, function(string) {
                  return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
                });
              }
              punycode = {
                /**
                * A string representing the current Punycode.js version number.
                * @memberOf punycode
                * @type String
                */
                "version": "1.4.1",
                /**
                * An object of methods to convert from JavaScript's internal character
                * representation (UCS-2) to Unicode code points, and back.
                * @see <https://mathiasbynens.be/notes/javascript-encoding>
                * @memberOf punycode
                * @type Object
                */
                "ucs2": { "decode": ucs2decode, "encode": ucs2encode },
                "decode": decode,
                "encode": encode2,
                "toASCII": toASCII,
                "toUnicode": toUnicode
              };
              if (freeExports && freeModule) {
                if (module2.exports == freeExports) {
                  freeModule.exports = punycode;
                } else {
                  for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                  }
                }
              } else {
                root.punycode = punycode;
              }
            })(this);
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 383: [function(require2, module2, exports2) {
        function hasOwnProperty2(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module2.exports = function(qs2, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};
          if (typeof qs2 !== "string" || qs2.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs2 = qs2.split(sep);
          var maxKeys = 1e3;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }
          var len = qs2.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i3 = 0; i3 < len; ++i3) {
            var x2 = qs2[i3].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k2, v3;
            if (idx >= 0) {
              kstr = x2.substr(0, idx);
              vstr = x2.substr(idx + 1);
            } else {
              kstr = x2;
              vstr = "";
            }
            k2 = decodeURIComponent(kstr);
            v3 = decodeURIComponent(vstr);
            if (!hasOwnProperty2(obj, k2)) {
              obj[k2] = v3;
            } else if (isArray2(obj[k2])) {
              obj[k2].push(v3);
            } else {
              obj[k2] = [obj[k2], v3];
            }
          }
          return obj;
        };
        var isArray2 = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      }, {}], 384: [function(require2, module2, exports2) {
        var stringifyPrimitive = function(v3) {
          switch (typeof v3) {
            case "string":
              return v3;
            case "boolean":
              return v3 ? "true" : "false";
            case "number":
              return isFinite(v3) ? v3 : "";
            default:
              return "";
          }
        };
        module2.exports = function(obj, sep, eq, name2) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = void 0;
          }
          if (typeof obj === "object") {
            return map(objectKeys(obj), function(k2) {
              var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq;
              if (isArray2(obj[k2])) {
                return map(obj[k2], function(v3) {
                  return ks + encodeURIComponent(stringifyPrimitive(v3));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
              }
            }).join(sep);
          }
          if (!name2)
            return "";
          return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray2 = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map(xs, f2) {
          if (xs.map)
            return xs.map(f2);
          var res = [];
          for (var i3 = 0; i3 < xs.length; i3++) {
            res.push(f2(xs[i3], i3));
          }
          return res;
        }
        var objectKeys = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              res.push(key);
          }
          return res;
        };
      }, {}], 385: [function(require2, module2, exports2) {
        exports2.decode = exports2.parse = require2("./decode");
        exports2.encode = exports2.stringify = require2("./encode");
      }, { "./decode": 383, "./encode": 384 }], 386: [function(require2, module2, exports2) {
        var pna = require2("process-nextick-args");
        var objectKeys = Object.keys || function(obj) {
          var keys2 = [];
          for (var key in obj) {
            keys2.push(key);
          }
          return keys2;
        };
        module2.exports = Duplex;
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        var Readable = require2("./_stream_readable");
        var Writable = require2("./_stream_writable");
        util.inherits(Duplex, Readable);
        {
          var keys = objectKeys(Writable.prototype);
          for (var v3 = 0; v3 < keys.length; v3++) {
            var method = keys[v3];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false)
            this.readable = false;
          if (options && options.writable === false)
            this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;
          this.once("end", onend);
        }
        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function onend() {
          if (this.allowHalfOpen || this._writableState.ended)
            return;
          pna.nextTick(onEndNT, this);
        }
        function onEndNT(self2) {
          self2.end();
        }
        Object.defineProperty(Duplex.prototype, "destroyed", { get: function() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        }, set: function(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        } });
        Duplex.prototype._destroy = function(err2, cb) {
          this.push(null);
          this.end();
          pna.nextTick(cb, err2);
        };
      }, { "./_stream_readable": 388, "./_stream_writable": 390, "core-util-is": 341, "inherits": 364, "process-nextick-args": 380 }], 387: [function(require2, module2, exports2) {
        module2.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 389, "core-util-is": 341, "inherits": 364 }], 388: [function(require2, module2, exports2) {
        (function(process, global3) {
          (function() {
            var pna = require2("process-nextick-args");
            module2.exports = Readable;
            var isArray2 = require2("isarray");
            var Duplex;
            Readable.ReadableState = ReadableState;
            require2("events").EventEmitter;
            var EElistenerCount = function(emitter, type2) {
              return emitter.listeners(type2).length;
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("safe-buffer").Buffer;
            var OurUint8Array = global3.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var util = Object.create(require2("core-util-is"));
            util.inherits = require2("inherits");
            var debugUtil = require2("util");
            var debug = void 0;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function() {
              };
            }
            var BufferList = require2("./internal/streams/BufferList");
            var destroyImpl = require2("./internal/streams/destroy");
            var StringDecoder;
            util.inherits(Readable, Stream);
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (isArray2(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              var isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              var hwm = options.highWaterMark;
              var readableHwm = options.readableHighWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              if (hwm || hwm === 0)
                this.highWaterMark = hwm;
              else if (isDuplex && (readableHwm || readableHwm === 0))
                this.highWaterMark = readableHwm;
              else
                this.highWaterMark = defaultHwm;
              this.highWaterMark = Math.floor(this.highWaterMark);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require2("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!(this instanceof Readable))
                return new Readable(options);
              this._readableState = new ReadableState(options, this);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", { get: function() {
              if (this._readableState === void 0) {
                return false;
              }
              return this._readableState.destroyed;
            }, set: function(value) {
              if (!this._readableState) {
                return;
              }
              this._readableState.destroyed = value;
            } });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err2, cb) {
              this.push(null);
              cb(err2);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer2.from(chunk, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  stream.emit("error", er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      stream.emit("error", new Error("stream.unshift() after end event"));
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    stream.emit("error", new Error("stream.push() after EOF"));
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                }
              }
              return needMoreData(state);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new TypeError("Invalid non-string/buffer chunk");
              }
              return er;
            }
            function needMoreData(state) {
              return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this._readableState.decoder = new StringDecoder(enc);
              this._readableState.encoding = enc;
              return this;
            };
            var MAX_HWM = 8388608;
            function computeNewHighWaterMark(n2) {
              if (n2 >= MAX_HWM) {
                n2 = MAX_HWM;
              } else {
                n2--;
                n2 |= n2 >>> 1;
                n2 |= n2 >>> 2;
                n2 |= n2 >>> 4;
                n2 |= n2 >>> 8;
                n2 |= n2 >>> 16;
                n2++;
              }
              return n2;
            }
            function howMuchToRead(n2, state) {
              if (n2 <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n2 !== n2) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n2 > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n2);
              if (n2 <= state.length)
                return n2;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n2) {
              debug("read", n2);
              n2 = parseInt(n2, 10);
              var state = this._readableState;
              var nOrig = n2;
              if (n2 !== 0)
                state.emittedReadable = false;
              if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n2 = howMuchToRead(n2, state);
              if (n2 === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n2 < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n2 = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n2 > 0)
                ret = fromList(n2, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = true;
                n2 = 0;
              } else {
                state.length -= n2;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n2 && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              emitReadable(stream);
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                if (state.sync)
                  pna.nextTick(emitReadable_, stream);
                else
                  emitReadable_(stream);
              }
            }
            function emitReadable_(stream) {
              debug("emit readable");
              stream.emit("readable");
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                pna.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              var len = state.length;
              while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
                else
                  len = state.length;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n2) {
              this.emit("error", new Error("_read() is not implemented"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                pna.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              var increasedAwaitDrain = false;
              src.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                increasedAwaitDrain = false;
                var ret = dest.write(chunk);
                if (false === ret && !increasedAwaitDrain) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", src._readableState.awaitDrain);
                    src._readableState.awaitDrain++;
                    increasedAwaitDrain = true;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  dest.emit("error", er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = { hasUnpiped: false };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i3 = 0; i3 < len; i3++) {
                  dests[i3].emit("unpipe", this, unpipeInfo);
                }
                return this;
              }
              var index2 = indexOf(state.pipes, dest);
              if (index2 === -1)
                return this;
              state.pipes.splice(index2, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              if (ev === "data") {
                if (this._readableState.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                var state = this._readableState;
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.emittedReadable = false;
                  if (!state.reading) {
                    pna.nextTick(nReadingNextTick, this);
                  } else if (state.length) {
                    emitReadable(this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = true;
                resume(this, state);
              }
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                pna.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              if (!state.reading) {
                debug("resume read 0");
                stream.read(0);
              }
              state.resumeScheduled = false;
              state.awaitDrain = 0;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (false !== this._readableState.flowing) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null) {
              }
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i3 in stream) {
                if (this[i3] === void 0 && typeof stream[i3] === "function") {
                  this[i3] = function(method) {
                    return function() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i3);
                }
              }
              for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
                stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
              }
              this._read = function(n3) {
                debug("wrapped _read", n3);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function() {
                return this._readableState.highWaterMark;
              }
            });
            Readable._fromList = fromList;
            function fromList(n2, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n2 || n2 >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.head.data;
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = fromListPartial(n2, state.buffer, state.decoder);
              }
              return ret;
            }
            function fromListPartial(n2, list, hasStrings) {
              var ret;
              if (n2 < list.head.data.length) {
                ret = list.head.data.slice(0, n2);
                list.head.data = list.head.data.slice(n2);
              } else if (n2 === list.head.data.length) {
                ret = list.shift();
              } else {
                ret = hasStrings ? copyFromBufferString(n2, list) : copyFromBuffer(n2, list);
              }
              return ret;
            }
            function copyFromBufferString(n2, list) {
              var p2 = list.head;
              var c2 = 1;
              var ret = p2.data;
              n2 -= ret.length;
              while (p2 = p2.next) {
                var str = p2.data;
                var nb = n2 > str.length ? str.length : n2;
                if (nb === str.length)
                  ret += str;
                else
                  ret += str.slice(0, n2);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === str.length) {
                    ++c2;
                    if (p2.next)
                      list.head = p2.next;
                    else
                      list.head = list.tail = null;
                  } else {
                    list.head = p2;
                    p2.data = str.slice(nb);
                  }
                  break;
                }
                ++c2;
              }
              list.length -= c2;
              return ret;
            }
            function copyFromBuffer(n2, list) {
              var ret = Buffer2.allocUnsafe(n2);
              var p2 = list.head;
              var c2 = 1;
              p2.data.copy(ret);
              n2 -= p2.data.length;
              while (p2 = p2.next) {
                var buf = p2.data;
                var nb = n2 > buf.length ? buf.length : n2;
                buf.copy(ret, ret.length - n2, 0, nb);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === buf.length) {
                    ++c2;
                    if (p2.next)
                      list.head = p2.next;
                    else
                      list.head = list.tail = null;
                  } else {
                    list.head = p2;
                    p2.data = buf.slice(nb);
                  }
                  break;
                }
                ++c2;
              }
              list.length -= c2;
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              if (state.length > 0)
                throw new Error('"endReadable()" called on non-empty stream');
              if (!state.endEmitted) {
                state.ended = true;
                pna.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
              }
            }
            function indexOf(xs, x2) {
              for (var i3 = 0, l2 = xs.length; i3 < l2; i3++) {
                if (xs[i3] === x2)
                  return i3;
              }
              return -1;
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./_stream_duplex": 386, "./internal/streams/BufferList": 391, "./internal/streams/destroy": 392, "./internal/streams/stream": 393, "_process": 467, "core-util-is": 341, "events": 344, "inherits": 364, "isarray": 370, "process-nextick-args": 380, "safe-buffer": 396, "string_decoder/": 413, "util": 89 }], 389: [function(require2, module2, exports2) {
        module2.exports = Transform;
        var Duplex = require2("./_stream_duplex");
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        util.inherits(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb) {
            return this.emit("error", new Error("write callback called multiple times"));
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented");
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n2) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err2, cb) {
          var _this2 = this;
          Duplex.prototype._destroy.call(this, err2, function(err22) {
            cb(err22);
            _this2.emit("close");
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
          return stream.push(null);
        }
      }, { "./_stream_duplex": 386, "core-util-is": 341, "inherits": 364 }], 390: [function(require2, module2, exports2) {
        (function(process, global3, setImmediate) {
          (function() {
            var pna = require2("process-nextick-args");
            module2.exports = Writable;
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
            var Duplex;
            Writable.WritableState = WritableState;
            var util = Object.create(require2("core-util-is"));
            util.inherits = require2("inherits");
            var internalUtil = { deprecate: require2("util-deprecate") };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("safe-buffer").Buffer;
            var OurUint8Array = global3.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require2("./internal/streams/destroy");
            util.inherits(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              var isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              var hwm = options.highWaterMark;
              var writableHwm = options.writableHighWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              if (hwm || hwm === 0)
                this.highWaterMark = hwm;
              else if (isDuplex && (writableHwm || writableHwm === 0))
                this.highWaterMark = writableHwm;
              else
                this.highWaterMark = defaultHwm;
              this.highWaterMark = Math.floor(this.highWaterMark);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (_2) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, { value: function(object) {
                if (realHasInstance.call(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              } });
            } else {
              realHasInstance = function(object) {
                return object instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                return new Writable(options);
              }
              this._writableState = new WritableState(options, this);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              this.emit("error", new Error("Cannot pipe, not readable"));
            };
            function writeAfterEnd(stream, cb) {
              var er = new Error("write after end");
              stream.emit("error", er);
              pna.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var valid = true;
              var er = false;
              if (chunk === null) {
                er = new TypeError("May not write null values to stream");
              } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new TypeError("Invalid non-string/buffer chunk");
              }
              if (er) {
                stream.emit("error", er);
                pna.nextTick(cb, er);
                valid = false;
              }
              return valid;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer2.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ended)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              var state = this._writableState;
              state.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new TypeError("Unknown encoding: " + encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer2.from(chunk, encoding);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                pna.nextTick(cb, er);
                pna.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state);
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  asyncWrite(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l2 = state.bufferedRequestCount;
                var buffer = new Array(l2);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new Error("_write() is not implemented"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending && !state.finished)
                endWritable(this, state, cb);
            };
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err2) {
                state.pendingcb--;
                if (err2) {
                  stream.emit("error", err2);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function") {
                  state.pendingcb++;
                  state.finalCalled = true;
                  pna.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  pna.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err2) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err2);
                entry = entry.next;
              }
              if (state.corkedRequestsFree) {
                state.corkedRequestsFree.next = corkReq;
              } else {
                state.corkedRequestsFree = corkReq;
              }
            }
            Object.defineProperty(Writable.prototype, "destroyed", { get: function() {
              if (this._writableState === void 0) {
                return false;
              }
              return this._writableState.destroyed;
            }, set: function(value) {
              if (!this._writableState) {
                return;
              }
              this._writableState.destroyed = value;
            } });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err2, cb) {
              this.end();
              cb(err2);
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
      }, { "./_stream_duplex": 386, "./internal/streams/destroy": 392, "./internal/streams/stream": 393, "_process": 467, "core-util-is": 341, "inherits": 364, "process-nextick-args": 380, "safe-buffer": 396, "timers": 414, "util-deprecate": 416 }], 391: [function(require2, module2, exports2) {
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Buffer2 = require2("safe-buffer").Buffer;
        var util = require2("util");
        function copyBuffer(src, target, offset2) {
          src.copy(target, offset2);
        }
        module2.exports = function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          BufferList.prototype.push = function push(v3) {
            var entry = { data: v3, next: null };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          };
          BufferList.prototype.unshift = function unshift(v3) {
            var entry = { data: v3, next: this.head };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          };
          BufferList.prototype.shift = function shift2() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          };
          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
          };
          BufferList.prototype.join = function join(s2) {
            if (this.length === 0)
              return "";
            var p2 = this.head;
            var ret = "" + p2.data;
            while (p2 = p2.next) {
              ret += s2 + p2.data;
            }
            return ret;
          };
          BufferList.prototype.concat = function concat(n2) {
            if (this.length === 0)
              return Buffer2.alloc(0);
            if (this.length === 1)
              return this.head.data;
            var ret = Buffer2.allocUnsafe(n2 >>> 0);
            var p2 = this.head;
            var i3 = 0;
            while (p2) {
              copyBuffer(p2.data, ret, i3);
              i3 += p2.data.length;
              p2 = p2.next;
            }
            return ret;
          };
          return BufferList;
        }();
        if (util && util.inspect && util.inspect.custom) {
          module2.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length });
            return this.constructor.name + " " + obj;
          };
        }
      }, { "safe-buffer": 396, "util": 89 }], 392: [function(require2, module2, exports2) {
        var pna = require2("process-nextick-args");
        function destroy(err2, cb) {
          var _this = this;
          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;
          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err2);
            } else if (err2 && (!this._writableState || !this._writableState.errorEmitted)) {
              pna.nextTick(emitErrorNT, this, err2);
            }
            return this;
          }
          if (this._readableState) {
            this._readableState.destroyed = true;
          }
          if (this._writableState) {
            this._writableState.destroyed = true;
          }
          this._destroy(err2 || null, function(err3) {
            if (!cb && err3) {
              pna.nextTick(emitErrorNT, _this, err3);
              if (_this._writableState) {
                _this._writableState.errorEmitted = true;
              }
            } else if (cb) {
              cb(err3);
            }
          });
          return this;
        }
        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }
          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }
        function emitErrorNT(self2, err2) {
          self2.emit("error", err2);
        }
        module2.exports = { destroy, undestroy };
      }, { "process-nextick-args": 380 }], 393: [function(require2, module2, exports2) {
        module2.exports = require2("events").EventEmitter;
      }, { "events": 344 }], 394: [function(require2, module2, exports2) {
        exports2 = module2.exports = require2("./lib/_stream_readable.js");
        exports2.Stream = exports2;
        exports2.Readable = exports2;
        exports2.Writable = require2("./lib/_stream_writable.js");
        exports2.Duplex = require2("./lib/_stream_duplex.js");
        exports2.Transform = require2("./lib/_stream_transform.js");
        exports2.PassThrough = require2("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 386, "./lib/_stream_passthrough.js": 387, "./lib/_stream_readable.js": 388, "./lib/_stream_transform.js": 389, "./lib/_stream_writable.js": 390 }], 395: [function(require2, module2, exports2) {
        var runtime = function(exports3) {
          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var undefined$1;
          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
          function define(obj, key, value) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            return obj[key];
          }
          try {
            define({}, "");
          } catch (err2) {
            define = function(obj, key, value) {
              return obj[key] = value;
            };
          }
          function wrap(innerFn, outerFn, self2, tryLocsList) {
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);
            generator._invoke = makeInvokeMethod(innerFn, self2, context);
            return generator;
          }
          exports3.wrap = wrap;
          function tryCatch(fn, obj, arg) {
            try {
              return { type: "normal", arg: fn.call(obj, arg) };
            } catch (err2) {
              return { type: "throw", arg: err2 };
            }
          }
          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed";
          var ContinueSentinel = {};
          function Generator() {
          }
          function GeneratorFunction() {
          }
          function GeneratorFunctionPrototype() {
          }
          var IteratorPrototype = {};
          define(IteratorPrototype, iteratorSymbol, function() {
            return this;
          });
          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
          if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
            IteratorPrototype = NativeIteratorPrototype;
          }
          var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
          GeneratorFunction.prototype = GeneratorFunctionPrototype;
          define(Gp, "constructor", GeneratorFunctionPrototype);
          define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
          GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
          function defineIteratorMethods(prototype2) {
            ["next", "throw", "return"].forEach(function(method) {
              define(prototype2, method, function(arg) {
                return this._invoke(method, arg);
              });
            });
          }
          exports3.isGeneratorFunction = function(genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
          };
          exports3.mark = function(genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              define(genFun, toStringTagSymbol, "GeneratorFunction");
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };
          exports3.awrap = function(arg) {
            return { __await: arg };
          };
          function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === "throw") {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;
                if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                  return PromiseImpl.resolve(value.__await).then(function(value2) {
                    invoke("next", value2, resolve, reject);
                  }, function(err2) {
                    invoke("throw", err2, resolve, reject);
                  });
                }
                return PromiseImpl.resolve(value).then(function(unwrapped) {
                  result.value = unwrapped;
                  resolve(result);
                }, function(error) {
                  return invoke("throw", error, resolve, reject);
                });
              }
            }
            var previousPromise;
            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }
              return previousPromise = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(
                callInvokeWithMethodAndArg,
                // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                callInvokeWithMethodAndArg
              ) : callInvokeWithMethodAndArg();
            }
            this._invoke = enqueue;
          }
          defineIteratorMethods(AsyncIterator.prototype);
          define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
            return this;
          });
          exports3.AsyncIterator = AsyncIterator;
          exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
            if (PromiseImpl === void 0)
              PromiseImpl = Promise;
            var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
            return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
              return result.done ? result.value : iter.next();
            });
          };
          function makeInvokeMethod(innerFn, self2, context) {
            var state = GenStateSuspendedStart;
            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
              }
              if (state === GenStateCompleted) {
                if (method === "throw") {
                  throw arg;
                }
                return doneResult();
              }
              context.method = method;
              context.arg = arg;
              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);
                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel)
                      continue;
                    return delegateResult;
                  }
                }
                if (context.method === "next") {
                  context.sent = context._sent = context.arg;
                } else if (context.method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }
                  context.dispatchException(context.arg);
                } else if (context.method === "return") {
                  context.abrupt("return", context.arg);
                }
                state = GenStateExecuting;
                var record = tryCatch(innerFn, self2, context);
                if (record.type === "normal") {
                  state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                  if (record.arg === ContinueSentinel) {
                    continue;
                  }
                  return { value: record.arg, done: context.done };
                } else if (record.type === "throw") {
                  state = GenStateCompleted;
                  context.method = "throw";
                  context.arg = record.arg;
                }
              }
            };
          }
          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined$1) {
              context.delegate = null;
              if (context.method === "throw") {
                if (delegate.iterator["return"]) {
                  context.method = "return";
                  context.arg = undefined$1;
                  maybeInvokeDelegate(delegate, context);
                  if (context.method === "throw") {
                    return ContinueSentinel;
                  }
                }
                context.method = "throw";
                context.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return ContinueSentinel;
            }
            var record = tryCatch(method, delegate.iterator, context.arg);
            if (record.type === "throw") {
              context.method = "throw";
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }
            var info = record.arg;
            if (!info) {
              context.method = "throw";
              context.arg = new TypeError("iterator result is not an object");
              context.delegate = null;
              return ContinueSentinel;
            }
            if (info.done) {
              context[delegate.resultName] = info.value;
              context.next = delegate.nextLoc;
              if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined$1;
              }
            } else {
              return info;
            }
            context.delegate = null;
            return ContinueSentinel;
          }
          defineIteratorMethods(Gp);
          define(Gp, toStringTagSymbol, "Generator");
          define(Gp, iteratorSymbol, function() {
            return this;
          });
          define(Gp, "toString", function() {
            return "[object Generator]";
          });
          function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };
            if (1 in locs) {
              entry.catchLoc = locs[1];
            }
            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }
            this.tryEntries.push(entry);
          }
          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }
          function Context(tryLocsList) {
            this.tryEntries = [{ tryLoc: "root" }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }
          exports3.keys = function(object) {
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            keys.reverse();
            return function next() {
              while (keys.length) {
                var key2 = keys.pop();
                if (key2 in object) {
                  next.value = key2;
                  next.done = false;
                  return next;
                }
              }
              next.done = true;
              return next;
            };
          };
          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }
              if (typeof iterable.next === "function") {
                return iterable;
              }
              if (!isNaN(iterable.length)) {
                var i3 = -1, next = function next2() {
                  while (++i3 < iterable.length) {
                    if (hasOwn.call(iterable, i3)) {
                      next2.value = iterable[i3];
                      next2.done = false;
                      return next2;
                    }
                  }
                  next2.value = undefined$1;
                  next2.done = true;
                  return next2;
                };
                return next.next = next;
              }
            }
            return { next: doneResult };
          }
          exports3.values = values;
          function doneResult() {
            return { value: undefined$1, done: true };
          }
          Context.prototype = { constructor: Context, reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined$1;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined$1;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name2 in this) {
                if (name2.charAt(0) === "t" && hasOwn.call(this, name2) && !isNaN(+name2.slice(1))) {
                  this[name2] = undefined$1;
                }
              }
            }
          }, stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          }, dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined$1;
              }
              return !!caught;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var entry = this.tryEntries[i3];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          }, abrupt: function(type2, arg) {
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var entry = this.tryEntries[i3];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type2 === "break" || type2 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type2;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          }, complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          }, finish: function(finallyLoc) {
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var entry = this.tryEntries[i3];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          }, "catch": function(tryLoc) {
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var entry = this.tryEntries[i3];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          }, delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = { iterator: values(iterable), resultName, nextLoc };
            if (this.method === "next") {
              this.arg = undefined$1;
            }
            return ContinueSentinel;
          } };
          return exports3;
        }(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          typeof module2 === "object" ? module2.exports : {}
        );
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }
      }, {}], 396: [function(require2, module2, exports2) {
        var buffer = require2("buffer");
        var Buffer2 = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module2.exports = buffer;
        } else {
          copyProps(buffer, exports2);
          exports2.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size2, fill, encoding) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size2);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size2) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size2);
        };
        SafeBuffer.allocUnsafeSlow = function(size2) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size2);
        };
      }, { "buffer": 90 }], 397: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            (function(sax) {
              sax.parser = function(strict, opt) {
                return new SAXParser(strict, opt);
              };
              sax.SAXParser = SAXParser;
              sax.SAXStream = SAXStream;
              sax.createStream = createStream;
              sax.MAX_BUFFER_LENGTH = 64 * 1024;
              var buffers = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
              sax.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"];
              function SAXParser(strict, opt) {
                if (!(this instanceof SAXParser)) {
                  return new SAXParser(strict, opt);
                }
                var parser = this;
                clearBuffers(parser);
                parser.q = parser.c = "";
                parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                parser.opt = opt || {};
                parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
                parser.tags = [];
                parser.closed = parser.closedRoot = parser.sawRoot = false;
                parser.tag = parser.error = null;
                parser.strict = !!strict;
                parser.noscript = !!(strict || parser.opt.noscript);
                parser.state = S2.BEGIN;
                parser.strictEntities = parser.opt.strictEntities;
                parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                parser.attribList = [];
                if (parser.opt.xmlns) {
                  parser.ns = Object.create(rootNS);
                }
                parser.trackPosition = parser.opt.position !== false;
                if (parser.trackPosition) {
                  parser.position = parser.line = parser.column = 0;
                }
                emit(parser, "onready");
              }
              if (!Object.create) {
                Object.create = function(o2) {
                  function F2() {
                  }
                  F2.prototype = o2;
                  var newf = new F2();
                  return newf;
                };
              }
              if (!Object.keys) {
                Object.keys = function(o2) {
                  var a2 = [];
                  for (var i3 in o2)
                    if (o2.hasOwnProperty(i3))
                      a2.push(i3);
                  return a2;
                };
              }
              function checkBufferLength(parser) {
                var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                var maxActual = 0;
                for (var i3 = 0, l2 = buffers.length; i3 < l2; i3++) {
                  var len = parser[buffers[i3]].length;
                  if (len > maxAllowed) {
                    switch (buffers[i3]) {
                      case "textNode":
                        closeText(parser);
                        break;
                      case "cdata":
                        emitNode(parser, "oncdata", parser.cdata);
                        parser.cdata = "";
                        break;
                      case "script":
                        emitNode(parser, "onscript", parser.script);
                        parser.script = "";
                        break;
                      default:
                        error(parser, "Max buffer length exceeded: " + buffers[i3]);
                    }
                  }
                  maxActual = Math.max(maxActual, len);
                }
                var m2 = sax.MAX_BUFFER_LENGTH - maxActual;
                parser.bufferCheckPosition = m2 + parser.position;
              }
              function clearBuffers(parser) {
                for (var i3 = 0, l2 = buffers.length; i3 < l2; i3++) {
                  parser[buffers[i3]] = "";
                }
              }
              function flushBuffers(parser) {
                closeText(parser);
                if (parser.cdata !== "") {
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                }
                if (parser.script !== "") {
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                }
              }
              SAXParser.prototype = { end: function() {
                end(this);
              }, write, resume: function() {
                this.error = null;
                return this;
              }, close: function() {
                return this.write(null);
              }, flush: function() {
                flushBuffers(this);
              } };
              var Stream;
              try {
                Stream = require2("stream").Stream;
              } catch (ex) {
                Stream = function() {
                };
              }
              var streamWraps = sax.EVENTS.filter(function(ev) {
                return ev !== "error" && ev !== "end";
              });
              function createStream(strict, opt) {
                return new SAXStream(strict, opt);
              }
              function SAXStream(strict, opt) {
                if (!(this instanceof SAXStream)) {
                  return new SAXStream(strict, opt);
                }
                Stream.apply(this);
                this._parser = new SAXParser(strict, opt);
                this.writable = true;
                this.readable = true;
                var me2 = this;
                this._parser.onend = function() {
                  me2.emit("end");
                };
                this._parser.onerror = function(er) {
                  me2.emit("error", er);
                  me2._parser.error = null;
                };
                this._decoder = null;
                streamWraps.forEach(function(ev) {
                  Object.defineProperty(me2, "on" + ev, { get: function() {
                    return me2._parser["on" + ev];
                  }, set: function(h2) {
                    if (!h2) {
                      me2.removeAllListeners(ev);
                      me2._parser["on" + ev] = h2;
                      return h2;
                    }
                    me2.on(ev, h2);
                  }, enumerable: true, configurable: false });
                });
              }
              SAXStream.prototype = Object.create(Stream.prototype, { constructor: { value: SAXStream } });
              SAXStream.prototype.write = function(data) {
                if (typeof Buffer2 === "function" && typeof Buffer2.isBuffer === "function" && Buffer2.isBuffer(data)) {
                  if (!this._decoder) {
                    var SD = require2("string_decoder").StringDecoder;
                    this._decoder = new SD("utf8");
                  }
                  data = this._decoder.write(data);
                }
                this._parser.write(data.toString());
                this.emit("data", data);
                return true;
              };
              SAXStream.prototype.end = function(chunk) {
                if (chunk && chunk.length) {
                  this.write(chunk);
                }
                this._parser.end();
                return true;
              };
              SAXStream.prototype.on = function(ev, handler) {
                var me2 = this;
                if (!me2._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                  me2._parser["on" + ev] = function() {
                    var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                    args.splice(0, 0, ev);
                    me2.emit.apply(me2, args);
                  };
                }
                return Stream.prototype.on.call(me2, ev, handler);
              };
              var CDATA = "[CDATA[";
              var DOCTYPE = "DOCTYPE";
              var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
              var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
              var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
              var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
              var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
              var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
              var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
              function isWhitespace(c2) {
                return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
              }
              function isQuote(c2) {
                return c2 === '"' || c2 === "'";
              }
              function isAttribEnd(c2) {
                return c2 === ">" || isWhitespace(c2);
              }
              function isMatch(regex, c2) {
                return regex.test(c2);
              }
              function notMatch(regex, c2) {
                return !isMatch(regex, c2);
              }
              var S2 = 0;
              sax.STATE = {
                BEGIN: S2++,
                // leading byte order mark or whitespace
                BEGIN_WHITESPACE: S2++,
                // leading whitespace
                TEXT: S2++,
                // general stuff
                TEXT_ENTITY: S2++,
                // &amp and such.
                OPEN_WAKA: S2++,
                // <
                SGML_DECL: S2++,
                // <!BLARG
                SGML_DECL_QUOTED: S2++,
                // <!BLARG foo "bar
                DOCTYPE: S2++,
                // <!DOCTYPE
                DOCTYPE_QUOTED: S2++,
                // <!DOCTYPE "//blah
                DOCTYPE_DTD: S2++,
                // <!DOCTYPE "//blah" [ ...
                DOCTYPE_DTD_QUOTED: S2++,
                // <!DOCTYPE "//blah" [ "foo
                COMMENT_STARTING: S2++,
                // <!-
                COMMENT: S2++,
                // <!--
                COMMENT_ENDING: S2++,
                // <!-- blah -
                COMMENT_ENDED: S2++,
                // <!-- blah --
                CDATA: S2++,
                // <![CDATA[ something
                CDATA_ENDING: S2++,
                // ]
                CDATA_ENDING_2: S2++,
                // ]]
                PROC_INST: S2++,
                // <?hi
                PROC_INST_BODY: S2++,
                // <?hi there
                PROC_INST_ENDING: S2++,
                // <?hi "there" ?
                OPEN_TAG: S2++,
                // <strong
                OPEN_TAG_SLASH: S2++,
                // <strong /
                ATTRIB: S2++,
                // <a
                ATTRIB_NAME: S2++,
                // <a foo
                ATTRIB_NAME_SAW_WHITE: S2++,
                // <a foo _
                ATTRIB_VALUE: S2++,
                // <a foo=
                ATTRIB_VALUE_QUOTED: S2++,
                // <a foo="bar
                ATTRIB_VALUE_CLOSED: S2++,
                // <a foo="bar"
                ATTRIB_VALUE_UNQUOTED: S2++,
                // <a foo=bar
                ATTRIB_VALUE_ENTITY_Q: S2++,
                // <foo bar="&quot;"
                ATTRIB_VALUE_ENTITY_U: S2++,
                // <foo bar=&quot
                CLOSE_TAG: S2++,
                // </a
                CLOSE_TAG_SAW_WHITE: S2++,
                // </a   >
                SCRIPT: S2++,
                // <script> ...
                SCRIPT_ENDING: S2++
                // <script> ... <
              };
              sax.XML_ENTITIES = { "amp": "&", "gt": ">", "lt": "<", "quot": '"', "apos": "'" };
              sax.ENTITIES = { "amp": "&", "gt": ">", "lt": "<", "quot": '"', "apos": "'", "AElig": 198, "Aacute": 193, "Acirc": 194, "Agrave": 192, "Aring": 197, "Atilde": 195, "Auml": 196, "Ccedil": 199, "ETH": 208, "Eacute": 201, "Ecirc": 202, "Egrave": 200, "Euml": 203, "Iacute": 205, "Icirc": 206, "Igrave": 204, "Iuml": 207, "Ntilde": 209, "Oacute": 211, "Ocirc": 212, "Ograve": 210, "Oslash": 216, "Otilde": 213, "Ouml": 214, "THORN": 222, "Uacute": 218, "Ucirc": 219, "Ugrave": 217, "Uuml": 220, "Yacute": 221, "aacute": 225, "acirc": 226, "aelig": 230, "agrave": 224, "aring": 229, "atilde": 227, "auml": 228, "ccedil": 231, "eacute": 233, "ecirc": 234, "egrave": 232, "eth": 240, "euml": 235, "iacute": 237, "icirc": 238, "igrave": 236, "iuml": 239, "ntilde": 241, "oacute": 243, "ocirc": 244, "ograve": 242, "oslash": 248, "otilde": 245, "ouml": 246, "szlig": 223, "thorn": 254, "uacute": 250, "ucirc": 251, "ugrave": 249, "uuml": 252, "yacute": 253, "yuml": 255, "copy": 169, "reg": 174, "nbsp": 160, "iexcl": 161, "cent": 162, "pound": 163, "curren": 164, "yen": 165, "brvbar": 166, "sect": 167, "uml": 168, "ordf": 170, "laquo": 171, "not": 172, "shy": 173, "macr": 175, "deg": 176, "plusmn": 177, "sup1": 185, "sup2": 178, "sup3": 179, "acute": 180, "micro": 181, "para": 182, "middot": 183, "cedil": 184, "ordm": 186, "raquo": 187, "frac14": 188, "frac12": 189, "frac34": 190, "iquest": 191, "times": 215, "divide": 247, "OElig": 338, "oelig": 339, "Scaron": 352, "scaron": 353, "Yuml": 376, "fnof": 402, "circ": 710, "tilde": 732, "Alpha": 913, "Beta": 914, "Gamma": 915, "Delta": 916, "Epsilon": 917, "Zeta": 918, "Eta": 919, "Theta": 920, "Iota": 921, "Kappa": 922, "Lambda": 923, "Mu": 924, "Nu": 925, "Xi": 926, "Omicron": 927, "Pi": 928, "Rho": 929, "Sigma": 931, "Tau": 932, "Upsilon": 933, "Phi": 934, "Chi": 935, "Psi": 936, "Omega": 937, "alpha": 945, "beta": 946, "gamma": 947, "delta": 948, "epsilon": 949, "zeta": 950, "eta": 951, "theta": 952, "iota": 953, "kappa": 954, "lambda": 955, "mu": 956, "nu": 957, "xi": 958, "omicron": 959, "pi": 960, "rho": 961, "sigmaf": 962, "sigma": 963, "tau": 964, "upsilon": 965, "phi": 966, "chi": 967, "psi": 968, "omega": 969, "thetasym": 977, "upsih": 978, "piv": 982, "ensp": 8194, "emsp": 8195, "thinsp": 8201, "zwnj": 8204, "zwj": 8205, "lrm": 8206, "rlm": 8207, "ndash": 8211, "mdash": 8212, "lsquo": 8216, "rsquo": 8217, "sbquo": 8218, "ldquo": 8220, "rdquo": 8221, "bdquo": 8222, "dagger": 8224, "Dagger": 8225, "bull": 8226, "hellip": 8230, "permil": 8240, "prime": 8242, "Prime": 8243, "lsaquo": 8249, "rsaquo": 8250, "oline": 8254, "frasl": 8260, "euro": 8364, "image": 8465, "weierp": 8472, "real": 8476, "trade": 8482, "alefsym": 8501, "larr": 8592, "uarr": 8593, "rarr": 8594, "darr": 8595, "harr": 8596, "crarr": 8629, "lArr": 8656, "uArr": 8657, "rArr": 8658, "dArr": 8659, "hArr": 8660, "forall": 8704, "part": 8706, "exist": 8707, "empty": 8709, "nabla": 8711, "isin": 8712, "notin": 8713, "ni": 8715, "prod": 8719, "sum": 8721, "minus": 8722, "lowast": 8727, "radic": 8730, "prop": 8733, "infin": 8734, "ang": 8736, "and": 8743, "or": 8744, "cap": 8745, "cup": 8746, "int": 8747, "there4": 8756, "sim": 8764, "cong": 8773, "asymp": 8776, "ne": 8800, "equiv": 8801, "le": 8804, "ge": 8805, "sub": 8834, "sup": 8835, "nsub": 8836, "sube": 8838, "supe": 8839, "oplus": 8853, "otimes": 8855, "perp": 8869, "sdot": 8901, "lceil": 8968, "rceil": 8969, "lfloor": 8970, "rfloor": 8971, "lang": 9001, "rang": 9002, "loz": 9674, "spades": 9824, "clubs": 9827, "hearts": 9829, "diams": 9830 };
              Object.keys(sax.ENTITIES).forEach(function(key) {
                var e2 = sax.ENTITIES[key];
                var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
                sax.ENTITIES[key] = s3;
              });
              for (var s2 in sax.STATE) {
                sax.STATE[sax.STATE[s2]] = s2;
              }
              S2 = sax.STATE;
              function emit(parser, event, data) {
                parser[event] && parser[event](data);
              }
              function emitNode(parser, nodeType, data) {
                if (parser.textNode)
                  closeText(parser);
                emit(parser, nodeType, data);
              }
              function closeText(parser) {
                parser.textNode = textopts(parser.opt, parser.textNode);
                if (parser.textNode)
                  emit(parser, "ontext", parser.textNode);
                parser.textNode = "";
              }
              function textopts(opt, text2) {
                if (opt.trim)
                  text2 = text2.trim();
                if (opt.normalize)
                  text2 = text2.replace(/\s+/g, " ");
                return text2;
              }
              function error(parser, er) {
                closeText(parser);
                if (parser.trackPosition) {
                  er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
                }
                er = new Error(er);
                parser.error = er;
                emit(parser, "onerror", er);
                return parser;
              }
              function end(parser) {
                if (parser.sawRoot && !parser.closedRoot)
                  strictFail(parser, "Unclosed root tag");
                if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
                  error(parser, "Unexpected end");
                }
                closeText(parser);
                parser.c = "";
                parser.closed = true;
                emit(parser, "onend");
                SAXParser.call(parser, parser.strict, parser.opt);
                return parser;
              }
              function strictFail(parser, message) {
                if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
                  throw new Error("bad call to strictFail");
                }
                if (parser.strict) {
                  error(parser, message);
                }
              }
              function newTag(parser) {
                if (!parser.strict)
                  parser.tagName = parser.tagName[parser.looseCase]();
                var parent = parser.tags[parser.tags.length - 1] || parser;
                var tag = parser.tag = { name: parser.tagName, attributes: {} };
                if (parser.opt.xmlns) {
                  tag.ns = parent.ns;
                }
                parser.attribList.length = 0;
                emitNode(parser, "onopentagstart", tag);
              }
              function qname(name2, attribute) {
                var i3 = name2.indexOf(":");
                var qualName = i3 < 0 ? ["", name2] : name2.split(":");
                var prefix = qualName[0];
                var local = qualName[1];
                if (attribute && name2 === "xmlns") {
                  prefix = "xmlns";
                  local = "";
                }
                return { prefix, local };
              }
              function attrib(parser) {
                if (!parser.strict) {
                  parser.attribName = parser.attribName[parser.looseCase]();
                }
                if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                  parser.attribName = parser.attribValue = "";
                  return;
                }
                if (parser.opt.xmlns) {
                  var qn = qname(parser.attribName, true);
                  var prefix = qn.prefix;
                  var local = qn.local;
                  if (prefix === "xmlns") {
                    if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                      strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
                    } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                      strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
                    } else {
                      var tag = parser.tag;
                      var parent = parser.tags[parser.tags.length - 1] || parser;
                      if (tag.ns === parent.ns) {
                        tag.ns = Object.create(parent.ns);
                      }
                      tag.ns[local] = parser.attribValue;
                    }
                  }
                  parser.attribList.push([parser.attribName, parser.attribValue]);
                } else {
                  parser.tag.attributes[parser.attribName] = parser.attribValue;
                  emitNode(parser, "onattribute", { name: parser.attribName, value: parser.attribValue });
                }
                parser.attribName = parser.attribValue = "";
              }
              function openTag(parser, selfClosing) {
                if (parser.opt.xmlns) {
                  var tag = parser.tag;
                  var qn = qname(parser.tagName);
                  tag.prefix = qn.prefix;
                  tag.local = qn.local;
                  tag.uri = tag.ns[qn.prefix] || "";
                  if (tag.prefix && !tag.uri) {
                    strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                    tag.uri = qn.prefix;
                  }
                  var parent = parser.tags[parser.tags.length - 1] || parser;
                  if (tag.ns && parent.ns !== tag.ns) {
                    Object.keys(tag.ns).forEach(function(p2) {
                      emitNode(parser, "onopennamespace", { prefix: p2, uri: tag.ns[p2] });
                    });
                  }
                  for (var i3 = 0, l2 = parser.attribList.length; i3 < l2; i3++) {
                    var nv = parser.attribList[i3];
                    var name2 = nv[0];
                    var value = nv[1];
                    var qualName = qname(name2, true);
                    var prefix = qualName.prefix;
                    var local = qualName.local;
                    var uri = prefix === "" ? "" : tag.ns[prefix] || "";
                    var a2 = { name: name2, value, prefix, local, uri };
                    if (prefix && prefix !== "xmlns" && !uri) {
                      strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                      a2.uri = prefix;
                    }
                    parser.tag.attributes[name2] = a2;
                    emitNode(parser, "onattribute", a2);
                  }
                  parser.attribList.length = 0;
                }
                parser.tag.isSelfClosing = !!selfClosing;
                parser.sawRoot = true;
                parser.tags.push(parser.tag);
                emitNode(parser, "onopentag", parser.tag);
                if (!selfClosing) {
                  if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                    parser.state = S2.SCRIPT;
                  } else {
                    parser.state = S2.TEXT;
                  }
                  parser.tag = null;
                  parser.tagName = "";
                }
                parser.attribName = parser.attribValue = "";
                parser.attribList.length = 0;
              }
              function closeTag(parser) {
                if (!parser.tagName) {
                  strictFail(parser, "Weird empty close tag.");
                  parser.textNode += "</>";
                  parser.state = S2.TEXT;
                  return;
                }
                if (parser.script) {
                  if (parser.tagName !== "script") {
                    parser.script += "</" + parser.tagName + ">";
                    parser.tagName = "";
                    parser.state = S2.SCRIPT;
                    return;
                  }
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                }
                var t2 = parser.tags.length;
                var tagName = parser.tagName;
                if (!parser.strict) {
                  tagName = tagName[parser.looseCase]();
                }
                var closeTo = tagName;
                while (t2--) {
                  var close = parser.tags[t2];
                  if (close.name !== closeTo) {
                    strictFail(parser, "Unexpected close tag");
                  } else {
                    break;
                  }
                }
                if (t2 < 0) {
                  strictFail(parser, "Unmatched closing tag: " + parser.tagName);
                  parser.textNode += "</" + parser.tagName + ">";
                  parser.state = S2.TEXT;
                  return;
                }
                parser.tagName = tagName;
                var s3 = parser.tags.length;
                while (s3-- > t2) {
                  var tag = parser.tag = parser.tags.pop();
                  parser.tagName = parser.tag.name;
                  emitNode(parser, "onclosetag", parser.tagName);
                  var x2 = {};
                  for (var i3 in tag.ns) {
                    x2[i3] = tag.ns[i3];
                  }
                  var parent = parser.tags[parser.tags.length - 1] || parser;
                  if (parser.opt.xmlns && tag.ns !== parent.ns) {
                    Object.keys(tag.ns).forEach(function(p2) {
                      var n2 = tag.ns[p2];
                      emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
                    });
                  }
                }
                if (t2 === 0)
                  parser.closedRoot = true;
                parser.tagName = parser.attribValue = parser.attribName = "";
                parser.attribList.length = 0;
                parser.state = S2.TEXT;
              }
              function parseEntity(parser) {
                var entity = parser.entity;
                var entityLC = entity.toLowerCase();
                var num;
                var numStr = "";
                if (parser.ENTITIES[entity]) {
                  return parser.ENTITIES[entity];
                }
                if (parser.ENTITIES[entityLC]) {
                  return parser.ENTITIES[entityLC];
                }
                entity = entityLC;
                if (entity.charAt(0) === "#") {
                  if (entity.charAt(1) === "x") {
                    entity = entity.slice(2);
                    num = parseInt(entity, 16);
                    numStr = num.toString(16);
                  } else {
                    entity = entity.slice(1);
                    num = parseInt(entity, 10);
                    numStr = num.toString(10);
                  }
                }
                entity = entity.replace(/^0+/, "");
                if (isNaN(num) || numStr.toLowerCase() !== entity) {
                  strictFail(parser, "Invalid character entity");
                  return "&" + parser.entity + ";";
                }
                return String.fromCodePoint(num);
              }
              function beginWhiteSpace(parser, c2) {
                if (c2 === "<") {
                  parser.state = S2.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else if (!isWhitespace(c2)) {
                  strictFail(parser, "Non-whitespace before first tag.");
                  parser.textNode = c2;
                  parser.state = S2.TEXT;
                }
              }
              function charAt(chunk, i3) {
                var result = "";
                if (i3 < chunk.length) {
                  result = chunk.charAt(i3);
                }
                return result;
              }
              function write(chunk) {
                var parser = this;
                if (this.error) {
                  throw this.error;
                }
                if (parser.closed) {
                  return error(parser, "Cannot write after close. Assign an onready handler.");
                }
                if (chunk === null) {
                  return end(parser);
                }
                if (typeof chunk === "object") {
                  chunk = chunk.toString();
                }
                var i3 = 0;
                var c2 = "";
                while (true) {
                  c2 = charAt(chunk, i3++);
                  parser.c = c2;
                  if (!c2) {
                    break;
                  }
                  if (parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                  switch (parser.state) {
                    case S2.BEGIN:
                      parser.state = S2.BEGIN_WHITESPACE;
                      if (c2 === "\uFEFF") {
                        continue;
                      }
                      beginWhiteSpace(parser, c2);
                      continue;
                    case S2.BEGIN_WHITESPACE:
                      beginWhiteSpace(parser, c2);
                      continue;
                    case S2.TEXT:
                      if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i3 - 1;
                        while (c2 && c2 !== "<" && c2 !== "&") {
                          c2 = charAt(chunk, i3++);
                          if (c2 && parser.trackPosition) {
                            parser.position++;
                            if (c2 === "\n") {
                              parser.line++;
                              parser.column = 0;
                            } else {
                              parser.column++;
                            }
                          }
                        }
                        parser.textNode += chunk.substring(starti, i3 - 1);
                      }
                      if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S2.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                      } else {
                        if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                          strictFail(parser, "Text data outside of root node.");
                        }
                        if (c2 === "&") {
                          parser.state = S2.TEXT_ENTITY;
                        } else {
                          parser.textNode += c2;
                        }
                      }
                      continue;
                    case S2.SCRIPT:
                      if (c2 === "<") {
                        parser.state = S2.SCRIPT_ENDING;
                      } else {
                        parser.script += c2;
                      }
                      continue;
                    case S2.SCRIPT_ENDING:
                      if (c2 === "/") {
                        parser.state = S2.CLOSE_TAG;
                      } else {
                        parser.script += "<" + c2;
                        parser.state = S2.SCRIPT;
                      }
                      continue;
                    case S2.OPEN_WAKA:
                      if (c2 === "!") {
                        parser.state = S2.SGML_DECL;
                        parser.sgmlDecl = "";
                      } else if (isWhitespace(c2))
                        ;
                      else if (isMatch(nameStart, c2)) {
                        parser.state = S2.OPEN_TAG;
                        parser.tagName = c2;
                      } else if (c2 === "/") {
                        parser.state = S2.CLOSE_TAG;
                        parser.tagName = "";
                      } else if (c2 === "?") {
                        parser.state = S2.PROC_INST;
                        parser.procInstName = parser.procInstBody = "";
                      } else {
                        strictFail(parser, "Unencoded <");
                        if (parser.startTagPosition + 1 < parser.position) {
                          var pad = parser.position - parser.startTagPosition;
                          c2 = new Array(pad).join(" ") + c2;
                        }
                        parser.textNode += "<" + c2;
                        parser.state = S2.TEXT;
                      }
                      continue;
                    case S2.SGML_DECL:
                      if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                        emitNode(parser, "onopencdata");
                        parser.state = S2.CDATA;
                        parser.sgmlDecl = "";
                        parser.cdata = "";
                      } else if (parser.sgmlDecl + c2 === "--") {
                        parser.state = S2.COMMENT;
                        parser.comment = "";
                        parser.sgmlDecl = "";
                      } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                        parser.state = S2.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) {
                          strictFail(parser, "Inappropriately located doctype declaration");
                        }
                        parser.doctype = "";
                        parser.sgmlDecl = "";
                      } else if (c2 === ">") {
                        emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                        parser.sgmlDecl = "";
                        parser.state = S2.TEXT;
                      } else if (isQuote(c2)) {
                        parser.state = S2.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c2;
                      } else {
                        parser.sgmlDecl += c2;
                      }
                      continue;
                    case S2.SGML_DECL_QUOTED:
                      if (c2 === parser.q) {
                        parser.state = S2.SGML_DECL;
                        parser.q = "";
                      }
                      parser.sgmlDecl += c2;
                      continue;
                    case S2.DOCTYPE:
                      if (c2 === ">") {
                        parser.state = S2.TEXT;
                        emitNode(parser, "ondoctype", parser.doctype);
                        parser.doctype = true;
                      } else {
                        parser.doctype += c2;
                        if (c2 === "[") {
                          parser.state = S2.DOCTYPE_DTD;
                        } else if (isQuote(c2)) {
                          parser.state = S2.DOCTYPE_QUOTED;
                          parser.q = c2;
                        }
                      }
                      continue;
                    case S2.DOCTYPE_QUOTED:
                      parser.doctype += c2;
                      if (c2 === parser.q) {
                        parser.q = "";
                        parser.state = S2.DOCTYPE;
                      }
                      continue;
                    case S2.DOCTYPE_DTD:
                      parser.doctype += c2;
                      if (c2 === "]") {
                        parser.state = S2.DOCTYPE;
                      } else if (isQuote(c2)) {
                        parser.state = S2.DOCTYPE_DTD_QUOTED;
                        parser.q = c2;
                      }
                      continue;
                    case S2.DOCTYPE_DTD_QUOTED:
                      parser.doctype += c2;
                      if (c2 === parser.q) {
                        parser.state = S2.DOCTYPE_DTD;
                        parser.q = "";
                      }
                      continue;
                    case S2.COMMENT:
                      if (c2 === "-") {
                        parser.state = S2.COMMENT_ENDING;
                      } else {
                        parser.comment += c2;
                      }
                      continue;
                    case S2.COMMENT_ENDING:
                      if (c2 === "-") {
                        parser.state = S2.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) {
                          emitNode(parser, "oncomment", parser.comment);
                        }
                        parser.comment = "";
                      } else {
                        parser.comment += "-" + c2;
                        parser.state = S2.COMMENT;
                      }
                      continue;
                    case S2.COMMENT_ENDED:
                      if (c2 !== ">") {
                        strictFail(parser, "Malformed comment");
                        parser.comment += "--" + c2;
                        parser.state = S2.COMMENT;
                      } else {
                        parser.state = S2.TEXT;
                      }
                      continue;
                    case S2.CDATA:
                      if (c2 === "]") {
                        parser.state = S2.CDATA_ENDING;
                      } else {
                        parser.cdata += c2;
                      }
                      continue;
                    case S2.CDATA_ENDING:
                      if (c2 === "]") {
                        parser.state = S2.CDATA_ENDING_2;
                      } else {
                        parser.cdata += "]" + c2;
                        parser.state = S2.CDATA;
                      }
                      continue;
                    case S2.CDATA_ENDING_2:
                      if (c2 === ">") {
                        if (parser.cdata) {
                          emitNode(parser, "oncdata", parser.cdata);
                        }
                        emitNode(parser, "onclosecdata");
                        parser.cdata = "";
                        parser.state = S2.TEXT;
                      } else if (c2 === "]") {
                        parser.cdata += "]";
                      } else {
                        parser.cdata += "]]" + c2;
                        parser.state = S2.CDATA;
                      }
                      continue;
                    case S2.PROC_INST:
                      if (c2 === "?") {
                        parser.state = S2.PROC_INST_ENDING;
                      } else if (isWhitespace(c2)) {
                        parser.state = S2.PROC_INST_BODY;
                      } else {
                        parser.procInstName += c2;
                      }
                      continue;
                    case S2.PROC_INST_BODY:
                      if (!parser.procInstBody && isWhitespace(c2)) {
                        continue;
                      } else if (c2 === "?") {
                        parser.state = S2.PROC_INST_ENDING;
                      } else {
                        parser.procInstBody += c2;
                      }
                      continue;
                    case S2.PROC_INST_ENDING:
                      if (c2 === ">") {
                        emitNode(parser, "onprocessinginstruction", { name: parser.procInstName, body: parser.procInstBody });
                        parser.procInstName = parser.procInstBody = "";
                        parser.state = S2.TEXT;
                      } else {
                        parser.procInstBody += "?" + c2;
                        parser.state = S2.PROC_INST_BODY;
                      }
                      continue;
                    case S2.OPEN_TAG:
                      if (isMatch(nameBody, c2)) {
                        parser.tagName += c2;
                      } else {
                        newTag(parser);
                        if (c2 === ">") {
                          openTag(parser);
                        } else if (c2 === "/") {
                          parser.state = S2.OPEN_TAG_SLASH;
                        } else {
                          if (!isWhitespace(c2)) {
                            strictFail(parser, "Invalid character in tag name");
                          }
                          parser.state = S2.ATTRIB;
                        }
                      }
                      continue;
                    case S2.OPEN_TAG_SLASH:
                      if (c2 === ">") {
                        openTag(parser, true);
                        closeTag(parser);
                      } else {
                        strictFail(parser, "Forward-slash in opening tag not followed by >");
                        parser.state = S2.ATTRIB;
                      }
                      continue;
                    case S2.ATTRIB:
                      if (isWhitespace(c2)) {
                        continue;
                      } else if (c2 === ">") {
                        openTag(parser);
                      } else if (c2 === "/") {
                        parser.state = S2.OPEN_TAG_SLASH;
                      } else if (isMatch(nameStart, c2)) {
                        parser.attribName = c2;
                        parser.attribValue = "";
                        parser.state = S2.ATTRIB_NAME;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                      }
                      continue;
                    case S2.ATTRIB_NAME:
                      if (c2 === "=") {
                        parser.state = S2.ATTRIB_VALUE;
                      } else if (c2 === ">") {
                        strictFail(parser, "Attribute without value");
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                      } else if (isWhitespace(c2)) {
                        parser.state = S2.ATTRIB_NAME_SAW_WHITE;
                      } else if (isMatch(nameBody, c2)) {
                        parser.attribName += c2;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                      }
                      continue;
                    case S2.ATTRIB_NAME_SAW_WHITE:
                      if (c2 === "=") {
                        parser.state = S2.ATTRIB_VALUE;
                      } else if (isWhitespace(c2)) {
                        continue;
                      } else {
                        strictFail(parser, "Attribute without value");
                        parser.tag.attributes[parser.attribName] = "";
                        parser.attribValue = "";
                        emitNode(parser, "onattribute", { name: parser.attribName, value: "" });
                        parser.attribName = "";
                        if (c2 === ">") {
                          openTag(parser);
                        } else if (isMatch(nameStart, c2)) {
                          parser.attribName = c2;
                          parser.state = S2.ATTRIB_NAME;
                        } else {
                          strictFail(parser, "Invalid attribute name");
                          parser.state = S2.ATTRIB;
                        }
                      }
                      continue;
                    case S2.ATTRIB_VALUE:
                      if (isWhitespace(c2)) {
                        continue;
                      } else if (isQuote(c2)) {
                        parser.q = c2;
                        parser.state = S2.ATTRIB_VALUE_QUOTED;
                      } else {
                        strictFail(parser, "Unquoted attribute value");
                        parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c2;
                      }
                      continue;
                    case S2.ATTRIB_VALUE_QUOTED:
                      if (c2 !== parser.q) {
                        if (c2 === "&") {
                          parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                        } else {
                          parser.attribValue += c2;
                        }
                        continue;
                      }
                      attrib(parser);
                      parser.q = "";
                      parser.state = S2.ATTRIB_VALUE_CLOSED;
                      continue;
                    case S2.ATTRIB_VALUE_CLOSED:
                      if (isWhitespace(c2)) {
                        parser.state = S2.ATTRIB;
                      } else if (c2 === ">") {
                        openTag(parser);
                      } else if (c2 === "/") {
                        parser.state = S2.OPEN_TAG_SLASH;
                      } else if (isMatch(nameStart, c2)) {
                        strictFail(parser, "No whitespace between attributes");
                        parser.attribName = c2;
                        parser.attribValue = "";
                        parser.state = S2.ATTRIB_NAME;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                      }
                      continue;
                    case S2.ATTRIB_VALUE_UNQUOTED:
                      if (!isAttribEnd(c2)) {
                        if (c2 === "&") {
                          parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                        } else {
                          parser.attribValue += c2;
                        }
                        continue;
                      }
                      attrib(parser);
                      if (c2 === ">") {
                        openTag(parser);
                      } else {
                        parser.state = S2.ATTRIB;
                      }
                      continue;
                    case S2.CLOSE_TAG:
                      if (!parser.tagName) {
                        if (isWhitespace(c2)) {
                          continue;
                        } else if (notMatch(nameStart, c2)) {
                          if (parser.script) {
                            parser.script += "</" + c2;
                            parser.state = S2.SCRIPT;
                          } else {
                            strictFail(parser, "Invalid tagname in closing tag.");
                          }
                        } else {
                          parser.tagName = c2;
                        }
                      } else if (c2 === ">") {
                        closeTag(parser);
                      } else if (isMatch(nameBody, c2)) {
                        parser.tagName += c2;
                      } else if (parser.script) {
                        parser.script += "</" + parser.tagName;
                        parser.tagName = "";
                        parser.state = S2.SCRIPT;
                      } else {
                        if (!isWhitespace(c2)) {
                          strictFail(parser, "Invalid tagname in closing tag");
                        }
                        parser.state = S2.CLOSE_TAG_SAW_WHITE;
                      }
                      continue;
                    case S2.CLOSE_TAG_SAW_WHITE:
                      if (isWhitespace(c2)) {
                        continue;
                      }
                      if (c2 === ">") {
                        closeTag(parser);
                      } else {
                        strictFail(parser, "Invalid characters in closing tag");
                      }
                      continue;
                    case S2.TEXT_ENTITY:
                    case S2.ATTRIB_VALUE_ENTITY_Q:
                    case S2.ATTRIB_VALUE_ENTITY_U:
                      var returnState;
                      var buffer;
                      switch (parser.state) {
                        case S2.TEXT_ENTITY:
                          returnState = S2.TEXT;
                          buffer = "textNode";
                          break;
                        case S2.ATTRIB_VALUE_ENTITY_Q:
                          returnState = S2.ATTRIB_VALUE_QUOTED;
                          buffer = "attribValue";
                          break;
                        case S2.ATTRIB_VALUE_ENTITY_U:
                          returnState = S2.ATTRIB_VALUE_UNQUOTED;
                          buffer = "attribValue";
                          break;
                      }
                      if (c2 === ";") {
                        parser[buffer] += parseEntity(parser);
                        parser.entity = "";
                        parser.state = returnState;
                      } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                        parser.entity += c2;
                      } else {
                        strictFail(parser, "Invalid character in entity name");
                        parser[buffer] += "&" + parser.entity + c2;
                        parser.entity = "";
                        parser.state = returnState;
                      }
                      continue;
                    default:
                      throw new Error(parser, "Unknown state: " + parser.state);
                  }
                }
                if (parser.position >= parser.bufferCheckPosition) {
                  checkBufferLength(parser);
                }
                return parser;
              }
              /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
              if (!String.fromCodePoint) {
                (function() {
                  var stringFromCharCode = String.fromCharCode;
                  var floor = Math.floor;
                  var fromCodePoint = function() {
                    var MAX_SIZE = 16384;
                    var codeUnits = [];
                    var highSurrogate;
                    var lowSurrogate;
                    var index2 = -1;
                    var length = arguments.length;
                    if (!length) {
                      return "";
                    }
                    var result = "";
                    while (++index2 < length) {
                      var codePoint = Number(arguments[index2]);
                      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                      codePoint < 0 || // not a valid Unicode code point
                      codePoint > 1114111 || // not a valid Unicode code point
                      floor(codePoint) !== codePoint) {
                        throw RangeError("Invalid code point: " + codePoint);
                      }
                      if (codePoint <= 65535) {
                        codeUnits.push(codePoint);
                      } else {
                        codePoint -= 65536;
                        highSurrogate = (codePoint >> 10) + 55296;
                        lowSurrogate = codePoint % 1024 + 56320;
                        codeUnits.push(highSurrogate, lowSurrogate);
                      }
                      if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                      }
                    }
                    return result;
                  };
                  if (Object.defineProperty) {
                    Object.defineProperty(String, "fromCodePoint", { value: fromCodePoint, configurable: true, writable: true });
                  } else {
                    String.fromCodePoint = fromCodePoint;
                  }
                })();
              }
            })(typeof exports2 === "undefined" ? this.sax = {} : exports2);
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 90, "stream": 398, "string_decoder": 413 }], 398: [function(require2, module2, exports2) {
        module2.exports = Stream;
        var EE = require2("events").EventEmitter;
        var inherits2 = require2("inherits");
        inherits2(Stream, EE);
        Stream.Readable = require2("readable-stream/lib/_stream_readable.js");
        Stream.Writable = require2("readable-stream/lib/_stream_writable.js");
        Stream.Duplex = require2("readable-stream/lib/_stream_duplex.js");
        Stream.Transform = require2("readable-stream/lib/_stream_transform.js");
        Stream.PassThrough = require2("readable-stream/lib/_stream_passthrough.js");
        Stream.finished = require2("readable-stream/lib/internal/streams/end-of-stream.js");
        Stream.pipeline = require2("readable-stream/lib/internal/streams/pipeline.js");
        Stream.Stream = Stream;
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on("data", ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on("drain", ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === "function")
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
              throw er;
            }
          }
          source.on("error", onerror);
          dest.on("error", onerror);
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
          }
          source.on("end", cleanup);
          source.on("close", cleanup);
          dest.on("close", cleanup);
          dest.emit("pipe", source);
          return dest;
        };
      }, { "events": 344, "inherits": 364, "readable-stream/lib/_stream_duplex.js": 400, "readable-stream/lib/_stream_passthrough.js": 401, "readable-stream/lib/_stream_readable.js": 402, "readable-stream/lib/_stream_transform.js": 403, "readable-stream/lib/_stream_writable.js": 404, "readable-stream/lib/internal/streams/end-of-stream.js": 408, "readable-stream/lib/internal/streams/pipeline.js": 410 }], 399: [function(require2, module2, exports2) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var codes = {};
        function createErrorType(code, message, Base) {
          if (!Base) {
            Base = Error;
          }
          function getMessage(arg1, arg2, arg3) {
            if (typeof message === "string") {
              return message;
            } else {
              return message(arg1, arg2, arg3);
            }
          }
          var NodeError = /* @__PURE__ */ function(_Base) {
            _inheritsLoose(NodeError2, _Base);
            function NodeError2(arg1, arg2, arg3) {
              return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
            }
            return NodeError2;
          }(Base);
          NodeError.prototype.name = Base.name;
          NodeError.prototype.code = code;
          codes[code] = NodeError;
        }
        function oneOf(expected, thing) {
          if (Array.isArray(expected)) {
            var len = expected.length;
            expected = expected.map(function(i3) {
              return String(i3);
            });
            if (len > 2) {
              return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
            } else if (len === 2) {
              return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
            } else {
              return "of ".concat(thing, " ").concat(expected[0]);
            }
          } else {
            return "of ".concat(thing, " ").concat(String(expected));
          }
        }
        function startsWith(str, search2, pos) {
          return str.substr(!pos || pos < 0 ? 0 : +pos, search2.length) === search2;
        }
        function endsWith2(str, search2, this_len) {
          if (this_len === void 0 || this_len > str.length) {
            this_len = str.length;
          }
          return str.substring(this_len - search2.length, this_len) === search2;
        }
        function includes(str, search2, start) {
          if (typeof start !== "number") {
            start = 0;
          }
          if (start + search2.length > str.length) {
            return false;
          } else {
            return str.indexOf(search2, start) !== -1;
          }
        }
        createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
          return 'The value "' + value + '" is invalid for option "' + name2 + '"';
        }, TypeError);
        createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
          var determiner;
          if (typeof expected === "string" && startsWith(expected, "not ")) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          var msg;
          if (endsWith2(name2, " argument")) {
            msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          } else {
            var type2 = includes(name2, ".") ? "property" : "argument";
            msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          }
          msg += ". Received type ".concat(typeof actual);
          return msg;
        }, TypeError);
        createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
        createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
          return "The " + name2 + " method is not implemented";
        });
        createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
        createErrorType("ERR_STREAM_DESTROYED", function(name2) {
          return "Cannot call " + name2 + " after a stream was destroyed";
        });
        createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
        createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
        createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
          return "Unknown encoding: " + arg;
        }, TypeError);
        createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
        module2.exports.codes = codes;
      }, {}], 400: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var objectKeys = Object.keys || function(obj) {
              var keys2 = [];
              for (var key in obj)
                keys2.push(key);
              return keys2;
            };
            module2.exports = Duplex;
            var Readable = require2("./_stream_readable");
            var Writable = require2("./_stream_writable");
            require2("inherits")(Duplex, Readable);
            {
              var keys = objectKeys(Writable.prototype);
              for (var v3 = 0; v3 < keys.length; v3++) {
                var method = keys[v3];
                if (!Duplex.prototype[method])
                  Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options) {
              if (!(this instanceof Duplex))
                return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              this.allowHalfOpen = true;
              if (options) {
                if (options.readable === false)
                  this.readable = false;
                if (options.writable === false)
                  this.writable = false;
                if (options.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function onend() {
              if (this._writableState.ended)
                return;
              process.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set(value) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            });
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./_stream_readable": 402, "./_stream_writable": 404, "_process": 467, "inherits": 364 }], 401: [function(require2, module2, exports2) {
        module2.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        require2("inherits")(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 403, "inherits": 364 }], 402: [function(require2, module2, exports2) {
        (function(process, global3) {
          (function() {
            module2.exports = Readable;
            var Duplex;
            Readable.ReadableState = ReadableState;
            require2("events").EventEmitter;
            var EElistenerCount = function EElistenerCount2(emitter, type2) {
              return emitter.listeners(type2).length;
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("buffer").Buffer;
            var OurUint8Array = (typeof global3 !== "undefined" ? global3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var debugUtil = require2("util");
            var debug;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug2() {
              };
            }
            var BufferList = require2("./internal/streams/buffer_list");
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from;
            require2("inherits")(Readable, Stream);
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require2("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!(this instanceof Readable))
                return new Readable(options);
              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options, this, isDuplex);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function set(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err2, cb) {
              cb(err2);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer2.from(chunk, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk);
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state.destroyed) {
                    return false;
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                  maybeReadMore(stream, state);
                }
              }
              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                state.awaitDrain = 0;
                stream.emit("data", chunk);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
              }
              return er;
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              var p2 = this._readableState.buffer.head;
              var content = "";
              while (p2 !== null) {
                content += decoder.write(p2.data);
                p2 = p2.next;
              }
              this._readableState.buffer.clear();
              if (content !== "")
                this._readableState.buffer.push(content);
              this._readableState.length = content.length;
              return this;
            };
            var MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n2) {
              if (n2 >= MAX_HWM) {
                n2 = MAX_HWM;
              } else {
                n2--;
                n2 |= n2 >>> 1;
                n2 |= n2 >>> 2;
                n2 |= n2 >>> 4;
                n2 |= n2 >>> 8;
                n2 |= n2 >>> 16;
                n2++;
              }
              return n2;
            }
            function howMuchToRead(n2, state) {
              if (n2 <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n2 !== n2) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n2 > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n2);
              if (n2 <= state.length)
                return n2;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n2) {
              debug("read", n2);
              n2 = parseInt(n2, 10);
              var state = this._readableState;
              var nOrig = n2;
              if (n2 !== 0)
                state.emittedReadable = false;
              if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n2 = howMuchToRead(n2, state);
              if (n2 === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n2 < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n2 = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n2 > 0)
                ret = fromList(n2, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n2 = 0;
              } else {
                state.length -= n2;
                state.awaitDrain = 0;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n2 && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              if (state.sync) {
                emitReadable(stream);
              } else {
                state.needReadable = false;
                if (!state.emittedReadable) {
                  state.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              var state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);
              if (!state.destroyed && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              }
              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                var len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n2) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                process.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                var ret = dest.write(chunk);
                debug("dest.write", ret);
                if (ret === false) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  errorOrDestroy(dest, er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function pipeOnDrainFunctionResult() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = { hasUnpiped: false };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i3 = 0; i3 < len; i3++)
                  dests[i3].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var index2 = indexOf(state.pipes, dest);
              if (index2 === -1)
                return this;
              state.pipes.splice(index2, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state = this._readableState;
              if (ev === "data") {
                state.readableListening = this.listenerCount("readable") > 0;
                if (state.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);
                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.removeAllListeners = function(ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              var state = self2._readableState;
              state.readableListening = self2.listenerCount("readable") > 0;
              if (state.resumeScheduled && !state.paused) {
                state.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = !state.readableListening;
                resume(this, state);
              }
              state.paused = false;
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              debug("resume", state.reading);
              if (!state.reading) {
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState.paused = true;
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null)
                ;
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i3 in stream) {
                if (this[i3] === void 0 && typeof stream[i3] === "function") {
                  this[i3] = function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i3);
                }
              }
              for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
                stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
              }
              this._read = function(n3) {
                debug("wrapped _read", n3);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function() {
                if (createReadableStreamAsyncIterator === void 0) {
                  createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
                }
                return createReadableStreamAsyncIterator(this);
              };
            }
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.highWaterMark;
              }
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState && this._readableState.buffer;
              }
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.flowing;
              },
              set: function set(state) {
                if (this._readableState) {
                  this._readableState.flowing = state;
                }
              }
            });
            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.length;
              }
            });
            function fromList(n2, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n2 || n2 >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.first();
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = state.buffer.consume(n2, state.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              debug("endReadable", state.endEmitted);
              if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length);
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
                if (state.autoDestroy) {
                  var wState = stream._writableState;
                  if (!wState || wState.autoDestroy && wState.finished) {
                    stream.destroy();
                  }
                }
              }
            }
            if (typeof Symbol === "function") {
              Readable.from = function(iterable, opts) {
                if (from === void 0) {
                  from = require2("./internal/streams/from");
                }
                return from(Readable, iterable, opts);
              };
            }
            function indexOf(xs, x2) {
              for (var i3 = 0, l2 = xs.length; i3 < l2; i3++) {
                if (xs[i3] === x2)
                  return i3;
              }
              return -1;
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 399, "./_stream_duplex": 400, "./internal/streams/async_iterator": 405, "./internal/streams/buffer_list": 406, "./internal/streams/destroy": 407, "./internal/streams/from": 409, "./internal/streams/state": 411, "./internal/streams/stream": 412, "_process": 467, "buffer": 90, "events": 344, "inherits": 364, "string_decoder/": 413, "util": 89 }], 403: [function(require2, module2, exports2) {
        module2.exports = Transform;
        var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
        var Duplex = require2("./_stream_duplex");
        require2("inherits")(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (cb === null) {
            return this.emit("error", new ERR_MULTIPLE_CALLBACK());
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function" && !this._readableState.destroyed) {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n2) {
          var ts = this._transformState;
          if (ts.writechunk !== null && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err2, cb) {
          Duplex.prototype._destroy.call(this, err2, function(err22) {
            cb(err22);
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new ERR_TRANSFORM_WITH_LENGTH_0();
          if (stream._transformState.transforming)
            throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
          return stream.push(null);
        }
      }, { "../errors": 399, "./_stream_duplex": 400, "inherits": 364 }], 404: [function(require2, module2, exports2) {
        (function(process, global3) {
          (function() {
            module2.exports = Writable;
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var Duplex;
            Writable.WritableState = WritableState;
            var internalUtil = { deprecate: require2("util-deprecate") };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("buffer").Buffer;
            var OurUint8Array = (typeof global3 !== "undefined" ? global3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            require2("inherits")(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function writableStateBufferGetter() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (_2) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(object) {
                if (realHasInstance.call(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              } });
            } else {
              realHasInstance = function realHasInstance2(object) {
                return object instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this))
                return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END();
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var er;
              if (chunk === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk !== "string" && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
              }
              if (er) {
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
                return false;
              }
              return true;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer2.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ending)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new ERR_UNKNOWN_ENCODING(encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer2.from(chunk, encoding);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed)
                state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                process.nextTick(cb, er);
                process.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              if (typeof cb !== "function")
                throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state) || stream.destroyed;
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  process.nextTick(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l2 = state.bufferedRequestCount;
                var buffer = new Array(l2);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending)
                endWritable(this, state, cb);
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err2) {
                state.pendingcb--;
                if (err2) {
                  errorOrDestroy(stream, err2);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.pendingcb++;
                  state.finalCalled = true;
                  process.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                  if (state.autoDestroy) {
                    var rState = stream._readableState;
                    if (!rState || rState.autoDestroy && rState.endEmitted) {
                      stream.destroy();
                    }
                  }
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  process.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err2) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err2);
                entry = entry.next;
              }
              state.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function set(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err2, cb) {
              cb(err2);
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 399, "./_stream_duplex": 400, "./internal/streams/destroy": 407, "./internal/streams/state": 411, "./internal/streams/stream": 412, "_process": 467, "buffer": 90, "inherits": 364, "util-deprecate": 416 }], 405: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var _Object$setPrototypeO;
            function _defineProperty(obj, key, value) {
              key = _toPropertyKey(key);
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive(input, hint) {
              if (typeof input !== "object" || input === null)
                return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object")
                  return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            var finished = require2("./end-of-stream");
            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");
            function createIterResult(value, done) {
              return { value, done };
            }
            function readAndResolve(iter) {
              var resolve = iter[kLastResolve];
              if (resolve !== null) {
                var data = iter[kStream].read();
                if (data !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve(createIterResult(data, false));
                }
              }
            }
            function onReadable(iter) {
              process.nextTick(readAndResolve, iter);
            }
            function wrapForNext(lastPromise, iter) {
              return function(resolve, reject) {
                lastPromise.then(function() {
                  if (iter[kEnded]) {
                    resolve(createIterResult(void 0, true));
                    return;
                  }
                  iter[kHandlePromise](resolve, reject);
                }, reject);
              };
            }
            var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
            });
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = { get stream() {
              return this[kStream];
            }, next: function next() {
              var _this = this;
              var error = this[kError];
              if (error !== null) {
                return Promise.reject(error);
              }
              if (this[kEnded]) {
                return Promise.resolve(createIterResult(void 0, true));
              }
              if (this[kStream].destroyed) {
                return new Promise(function(resolve, reject) {
                  process.nextTick(function() {
                    if (_this[kError]) {
                      reject(_this[kError]);
                    } else {
                      resolve(createIterResult(void 0, true));
                    }
                  });
                });
              }
              var lastPromise = this[kLastPromise];
              var promise2;
              if (lastPromise) {
                promise2 = new Promise(wrapForNext(lastPromise, this));
              } else {
                var data = this[kStream].read();
                if (data !== null) {
                  return Promise.resolve(createIterResult(data, false));
                }
                promise2 = new Promise(this[kHandlePromise]);
              }
              this[kLastPromise] = promise2;
              return promise2;
            } }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
              return this;
            }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
              var _this2 = this;
              return new Promise(function(resolve, reject) {
                _this2[kStream].destroy(null, function(err2) {
                  if (err2) {
                    reject(err2);
                    return;
                  }
                  resolve(createIterResult(void 0, true));
                });
              });
            }), _Object$setPrototypeO), AsyncIteratorPrototype);
            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
              var _Object$create;
              var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, { value: stream, writable: true }), _defineProperty(_Object$create, kLastResolve, { value: null, writable: true }), _defineProperty(_Object$create, kLastReject, { value: null, writable: true }), _defineProperty(_Object$create, kError, { value: null, writable: true }), _defineProperty(_Object$create, kEnded, { value: stream._readableState.endEmitted, writable: true }), _defineProperty(_Object$create, kHandlePromise, { value: function value(resolve, reject) {
                var data = iterator[kStream].read();
                if (data) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(data, false));
                } else {
                  iterator[kLastResolve] = resolve;
                  iterator[kLastReject] = reject;
                }
              }, writable: true }), _Object$create));
              iterator[kLastPromise] = null;
              finished(stream, function(err2) {
                if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject];
                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err2);
                  }
                  iterator[kError] = err2;
                  return;
                }
                var resolve = iterator[kLastResolve];
                if (resolve !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(void 0, true));
                }
                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };
            module2.exports = createReadableStreamAsyncIterator;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./end-of-stream": 408, "_process": 467 }], 406: [function(require2, module2, exports2) {
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i3 = 1; i3 < arguments.length; i3++) {
            var source = null != arguments[i3] ? arguments[i3] : {};
            i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i3 = 0; i3 < props.length; i3++) {
            var descriptor = props[i3];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return typeof key === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
          if (typeof input !== "object" || input === null)
            return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== void 0) {
            var res = prim.call(input, hint || "default");
            if (typeof res !== "object")
              return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        var _require = require2("buffer"), Buffer2 = _require.Buffer;
        var _require2 = require2("util"), inspect = _require2.inspect;
        var custom = inspect && inspect.custom || "inspect";
        function copyBuffer(src, target, offset2) {
          Buffer2.prototype.copy.call(src, target, offset2);
        }
        module2.exports = /* @__PURE__ */ function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          _createClass(BufferList, [{ key: "push", value: function push(v3) {
            var entry = { data: v3, next: null };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          } }, { key: "unshift", value: function unshift(v3) {
            var entry = { data: v3, next: this.head };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          } }, { key: "shift", value: function shift2() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          } }, { key: "clear", value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          } }, { key: "join", value: function join(s2) {
            if (this.length === 0)
              return "";
            var p2 = this.head;
            var ret = "" + p2.data;
            while (p2 = p2.next)
              ret += s2 + p2.data;
            return ret;
          } }, {
            key: "concat",
            value: function concat(n2) {
              if (this.length === 0)
                return Buffer2.alloc(0);
              var ret = Buffer2.allocUnsafe(n2 >>> 0);
              var p2 = this.head;
              var i3 = 0;
              while (p2) {
                copyBuffer(p2.data, ret, i3);
                i3 += p2.data.length;
                p2 = p2.next;
              }
              return ret;
            }
            // Consumes a specified amount of bytes or characters from the buffered data.
          }, { key: "consume", value: function consume(n2, hasStrings) {
            var ret;
            if (n2 < this.head.data.length) {
              ret = this.head.data.slice(0, n2);
              this.head.data = this.head.data.slice(n2);
            } else if (n2 === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
            }
            return ret;
          } }, {
            key: "first",
            value: function first() {
              return this.head.data;
            }
            // Consumes a specified amount of characters from the buffered data.
          }, {
            key: "_getString",
            value: function _getString(n2) {
              var p2 = this.head;
              var c2 = 1;
              var ret = p2.data;
              n2 -= ret.length;
              while (p2 = p2.next) {
                var str = p2.data;
                var nb = n2 > str.length ? str.length : n2;
                if (nb === str.length)
                  ret += str;
                else
                  ret += str.slice(0, n2);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === str.length) {
                    ++c2;
                    if (p2.next)
                      this.head = p2.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p2;
                    p2.data = str.slice(nb);
                  }
                  break;
                }
                ++c2;
              }
              this.length -= c2;
              return ret;
            }
            // Consumes a specified amount of bytes from the buffered data.
          }, {
            key: "_getBuffer",
            value: function _getBuffer(n2) {
              var ret = Buffer2.allocUnsafe(n2);
              var p2 = this.head;
              var c2 = 1;
              p2.data.copy(ret);
              n2 -= p2.data.length;
              while (p2 = p2.next) {
                var buf = p2.data;
                var nb = n2 > buf.length ? buf.length : n2;
                buf.copy(ret, ret.length - n2, 0, nb);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === buf.length) {
                    ++c2;
                    if (p2.next)
                      this.head = p2.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p2;
                    p2.data = buf.slice(nb);
                  }
                  break;
                }
                ++c2;
              }
              this.length -= c2;
              return ret;
            }
            // Make sure the linked list only shows the minimal necessary information.
          }, { key: custom, value: function value(_2, options) {
            return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          } }]);
          return BufferList;
        }();
      }, { "buffer": 90, "util": 89 }], 407: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            function destroy(err2, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err2);
                } else if (err2) {
                  if (!this._writableState) {
                    process.nextTick(emitErrorNT, this, err2);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorNT, this, err2);
                  }
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err2 || null, function(err3) {
                if (!cb && err3) {
                  if (!_this._writableState) {
                    process.nextTick(emitErrorAndCloseNT, _this, err3);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorAndCloseNT, _this, err3);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process.nextTick(emitCloseNT, _this);
                  cb(err3);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              });
              return this;
            }
            function emitErrorAndCloseNT(self2, err2) {
              emitErrorNT(self2, err2);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              if (self2._writableState && !self2._writableState.emitClose)
                return;
              if (self2._readableState && !self2._readableState.emitClose)
                return;
              self2.emit("close");
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err2) {
              self2.emit("error", err2);
            }
            function errorOrDestroy(stream, err2) {
              var rState = stream._readableState;
              var wState = stream._writableState;
              if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                stream.destroy(err2);
              else
                stream.emit("error", err2);
            }
            module2.exports = { destroy, undestroy, errorOrDestroy };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 467 }], 408: [function(require2, module2, exports2) {
        var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            callback.apply(this, args);
          };
        }
        function noop2() {
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function eos(stream, opts, callback) {
          if (typeof opts === "function")
            return eos(stream, null, opts);
          if (!opts)
            opts = {};
          callback = once(callback || noop2);
          var readable = opts.readable || opts.readable !== false && stream.readable;
          var writable = opts.writable || opts.writable !== false && stream.writable;
          var onlegacyfinish = function onlegacyfinish2() {
            if (!stream.writable)
              onfinish();
          };
          var writableEnded = stream._writableState && stream._writableState.finished;
          var onfinish = function onfinish2() {
            writable = false;
            writableEnded = true;
            if (!readable)
              callback.call(stream);
          };
          var readableEnded = stream._readableState && stream._readableState.endEmitted;
          var onend = function onend2() {
            readable = false;
            readableEnded = true;
            if (!writable)
              callback.call(stream);
          };
          var onerror = function onerror2(err2) {
            callback.call(stream, err2);
          };
          var onclose = function onclose2() {
            var err2;
            if (readable && !readableEnded) {
              if (!stream._readableState || !stream._readableState.ended)
                err2 = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err2);
            }
            if (writable && !writableEnded) {
              if (!stream._writableState || !stream._writableState.ended)
                err2 = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err2);
            }
          };
          var onrequest = function onrequest2() {
            stream.req.on("finish", onfinish);
          };
          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req)
              onrequest();
            else
              stream.on("request", onrequest);
          } else if (writable && !stream._writableState) {
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }
          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false)
            stream.on("error", onerror);
          stream.on("close", onclose);
          return function() {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req)
              stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        }
        module2.exports = eos;
      }, { "../../../errors": 399 }], 409: [function(require2, module2, exports2) {
        module2.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 410: [function(require2, module2, exports2) {
        var eos;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            callback.apply(void 0, arguments);
          };
        }
        var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
        function noop2(err2) {
          if (err2)
            throw err2;
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function destroyer(stream, reading, writing, callback) {
          callback = once(callback);
          var closed = false;
          stream.on("close", function() {
            closed = true;
          });
          if (eos === void 0)
            eos = require2("./end-of-stream");
          eos(stream, { readable: reading, writable: writing }, function(err2) {
            if (err2)
              return callback(err2);
            closed = true;
            callback();
          });
          var destroyed = false;
          return function(err2) {
            if (closed)
              return;
            if (destroyed)
              return;
            destroyed = true;
            if (isRequest(stream))
              return stream.abort();
            if (typeof stream.destroy === "function")
              return stream.destroy();
            callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
          };
        }
        function call(fn) {
          fn();
        }
        function pipe(from, to) {
          return from.pipe(to);
        }
        function popCallback(streams) {
          if (!streams.length)
            return noop2;
          if (typeof streams[streams.length - 1] !== "function")
            return noop2;
          return streams.pop();
        }
        function pipeline() {
          for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
            streams[_key] = arguments[_key];
          }
          var callback = popCallback(streams);
          if (Array.isArray(streams[0]))
            streams = streams[0];
          if (streams.length < 2) {
            throw new ERR_MISSING_ARGS("streams");
          }
          var error;
          var destroys = streams.map(function(stream, i3) {
            var reading = i3 < streams.length - 1;
            var writing = i3 > 0;
            return destroyer(stream, reading, writing, function(err2) {
              if (!error)
                error = err2;
              if (err2)
                destroys.forEach(call);
              if (reading)
                return;
              destroys.forEach(call);
              callback(error);
            });
          });
          return streams.reduce(pipe);
        }
        module2.exports = pipeline;
      }, { "../../../errors": 399, "./end-of-stream": 408 }], 411: [function(require2, module2, exports2) {
        var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }
        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
          if (hwm != null) {
            if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
              var name2 = isDuplex ? duplexKey : "highWaterMark";
              throw new ERR_INVALID_OPT_VALUE(name2, hwm);
            }
            return Math.floor(hwm);
          }
          return state.objectMode ? 16 : 16 * 1024;
        }
        module2.exports = { getHighWaterMark };
      }, { "../../../errors": 399 }], 412: [function(require2, module2, exports2) {
        arguments[4][393][0].apply(exports2, arguments);
      }, { "dup": 393, "events": 344 }], 413: [function(require2, module2, exports2) {
        var Buffer2 = require2("safe-buffer").Buffer;
        var isEncoding = Buffer2.isEncoding || function(encoding) {
          encoding = "" + encoding;
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports2.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer2.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r2;
          var i3;
          if (this.lastNeed) {
            r2 = this.fillLast(buf);
            if (r2 === void 0)
              return "";
            i3 = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i3 = 0;
          }
          if (i3 < buf.length)
            return r2 ? r2 + this.text(buf, i3) : this.text(buf, i3);
          return r2 || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return byte >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i3) {
          var j2 = buf.length - 1;
          if (j2 < i3)
            return 0;
          var nb = utf8CheckByte(buf[j2]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j2 < i3 || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j2]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j2 < i3 || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j2]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p2) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "�";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "�";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "�";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p2 = this.lastTotal - this.lastNeed;
          var r2 = utf8CheckExtraBytes(this, buf);
          if (r2 !== void 0)
            return r2;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p2, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p2, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i3) {
          var total = utf8CheckIncomplete(this, buf, i3);
          if (!this.lastNeed)
            return buf.toString("utf8", i3);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i3, end);
        }
        function utf8End(buf) {
          var r2 = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r2 + "�";
          return r2;
        }
        function utf16Text(buf, i3) {
          if ((buf.length - i3) % 2 === 0) {
            var r2 = buf.toString("utf16le", i3);
            if (r2) {
              var c2 = r2.charCodeAt(r2.length - 1);
              if (c2 >= 55296 && c2 <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r2.slice(0, -1);
              }
            }
            return r2;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i3, buf.length - 1);
        }
        function utf16End(buf) {
          var r2 = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r2 + this.lastChar.toString("utf16le", 0, end);
          }
          return r2;
        }
        function base64Text(buf, i3) {
          var n2 = (buf.length - i3) % 3;
          if (n2 === 0)
            return buf.toString("base64", i3);
          this.lastNeed = 3 - n2;
          this.lastTotal = 3;
          if (n2 === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i3, buf.length - n2);
        }
        function base64End(buf) {
          var r2 = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r2;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }, { "safe-buffer": 396 }], 414: [function(require2, module2, exports2) {
        (function(setImmediate, clearImmediate) {
          (function() {
            var nextTick2 = require2("process/browser.js").nextTick;
            var apply2 = Function.prototype.apply;
            var slice = Array.prototype.slice;
            var immediateIds = {};
            var nextImmediateId = 0;
            exports2.setTimeout = function() {
              return new Timeout(apply2.call(setTimeout, window, arguments), clearTimeout);
            };
            exports2.setInterval = function() {
              return new Timeout(apply2.call(setInterval, window, arguments), clearInterval);
            };
            exports2.clearTimeout = exports2.clearInterval = function(timeout2) {
              timeout2.close();
            };
            function Timeout(id, clearFn) {
              this._id = id;
              this._clearFn = clearFn;
            }
            Timeout.prototype.unref = Timeout.prototype.ref = function() {
            };
            Timeout.prototype.close = function() {
              this._clearFn.call(window, this._id);
            };
            exports2.enroll = function(item, msecs) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = msecs;
            };
            exports2.unenroll = function(item) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = -1;
            };
            exports2._unrefActive = exports2.active = function(item) {
              clearTimeout(item._idleTimeoutId);
              var msecs = item._idleTimeout;
              if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                  if (item._onTimeout)
                    item._onTimeout();
                }, msecs);
              }
            };
            exports2.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
              var id = nextImmediateId++;
              var args = arguments.length < 2 ? false : slice.call(arguments, 1);
              immediateIds[id] = true;
              nextTick2(function onNextTick() {
                if (immediateIds[id]) {
                  if (args) {
                    fn.apply(null, args);
                  } else {
                    fn.call(null);
                  }
                  exports2.clearImmediate(id);
                }
              });
              return id;
            };
            exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
              delete immediateIds[id];
            };
          }).call(this);
        }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
      }, { "process/browser.js": 381, "timers": 414 }], 415: [function(require2, module2, exports2) {
        var Buffer2 = require2("buffer").Buffer;
        module2.exports = function(buf) {
          if (buf instanceof Uint8Array) {
            if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
              return buf.buffer;
            } else if (typeof buf.buffer.slice === "function") {
              return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            }
          }
          if (Buffer2.isBuffer(buf)) {
            var arrayCopy = new Uint8Array(buf.length);
            var len = buf.length;
            for (var i3 = 0; i3 < len; i3++) {
              arrayCopy[i3] = buf[i3];
            }
            return arrayCopy.buffer;
          } else {
            throw new Error("Argument must be a Buffer");
          }
        };
      }, { "buffer": 90 }], 416: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            module2.exports = deprecate;
            function deprecate(fn, msg) {
              if (config("noDeprecation")) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config(name2) {
              try {
                if (!global3.localStorage)
                  return false;
              } catch (_2) {
                return false;
              }
              var val = global3.localStorage[name2];
              if (null == val)
                return false;
              return String(val).toLowerCase() === "true";
            }
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 417: [function(require2, module2, exports2) {
        arguments[4][84][0].apply(exports2, arguments);
      }, { "dup": 84 }], 418: [function(require2, module2, exports2) {
        var isArgumentsObject = require2("is-arguments");
        var isGeneratorFunction = require2("is-generator-function");
        var whichTypedArray = require2("which-typed-array");
        var isTypedArray2 = require2("is-typed-array");
        function uncurryThis(f2) {
          return f2.call.bind(f2);
        }
        var BigIntSupported = typeof BigInt !== "undefined";
        var SymbolSupported = typeof Symbol !== "undefined";
        var ObjectToString = uncurryThis(Object.prototype.toString);
        var numberValue = uncurryThis(Number.prototype.valueOf);
        var stringValue = uncurryThis(String.prototype.valueOf);
        var booleanValue = uncurryThis(Boolean.prototype.valueOf);
        if (BigIntSupported) {
          var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
        }
        if (SymbolSupported) {
          var symbolValue = uncurryThis(Symbol.prototype.valueOf);
        }
        function checkBoxedPrimitive(value, prototypeValueOf) {
          if (typeof value !== "object") {
            return false;
          }
          try {
            prototypeValueOf(value);
            return true;
          } catch (e2) {
            return false;
          }
        }
        exports2.isArgumentsObject = isArgumentsObject;
        exports2.isGeneratorFunction = isGeneratorFunction;
        exports2.isTypedArray = isTypedArray2;
        function isPromise(input) {
          return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
        }
        exports2.isPromise = isPromise;
        function isArrayBufferView2(value) {
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
            return ArrayBuffer.isView(value);
          }
          return isTypedArray2(value) || isDataView(value);
        }
        exports2.isArrayBufferView = isArrayBufferView2;
        function isUint8Array(value) {
          return whichTypedArray(value) === "Uint8Array";
        }
        exports2.isUint8Array = isUint8Array;
        function isUint8ClampedArray(value) {
          return whichTypedArray(value) === "Uint8ClampedArray";
        }
        exports2.isUint8ClampedArray = isUint8ClampedArray;
        function isUint16Array(value) {
          return whichTypedArray(value) === "Uint16Array";
        }
        exports2.isUint16Array = isUint16Array;
        function isUint32Array(value) {
          return whichTypedArray(value) === "Uint32Array";
        }
        exports2.isUint32Array = isUint32Array;
        function isInt8Array(value) {
          return whichTypedArray(value) === "Int8Array";
        }
        exports2.isInt8Array = isInt8Array;
        function isInt16Array(value) {
          return whichTypedArray(value) === "Int16Array";
        }
        exports2.isInt16Array = isInt16Array;
        function isInt32Array(value) {
          return whichTypedArray(value) === "Int32Array";
        }
        exports2.isInt32Array = isInt32Array;
        function isFloat32Array(value) {
          return whichTypedArray(value) === "Float32Array";
        }
        exports2.isFloat32Array = isFloat32Array;
        function isFloat64Array(value) {
          return whichTypedArray(value) === "Float64Array";
        }
        exports2.isFloat64Array = isFloat64Array;
        function isBigInt64Array(value) {
          return whichTypedArray(value) === "BigInt64Array";
        }
        exports2.isBigInt64Array = isBigInt64Array;
        function isBigUint64Array(value) {
          return whichTypedArray(value) === "BigUint64Array";
        }
        exports2.isBigUint64Array = isBigUint64Array;
        function isMapToString(value) {
          return ObjectToString(value) === "[object Map]";
        }
        isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
        function isMap(value) {
          if (typeof Map === "undefined") {
            return false;
          }
          return isMapToString.working ? isMapToString(value) : value instanceof Map;
        }
        exports2.isMap = isMap;
        function isSetToString(value) {
          return ObjectToString(value) === "[object Set]";
        }
        isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
        function isSet(value) {
          if (typeof Set === "undefined") {
            return false;
          }
          return isSetToString.working ? isSetToString(value) : value instanceof Set;
        }
        exports2.isSet = isSet;
        function isWeakMapToString(value) {
          return ObjectToString(value) === "[object WeakMap]";
        }
        isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
        function isWeakMap(value) {
          if (typeof WeakMap === "undefined") {
            return false;
          }
          return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
        }
        exports2.isWeakMap = isWeakMap;
        function isWeakSetToString(value) {
          return ObjectToString(value) === "[object WeakSet]";
        }
        isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
        function isWeakSet(value) {
          return isWeakSetToString(value);
        }
        exports2.isWeakSet = isWeakSet;
        function isArrayBufferToString(value) {
          return ObjectToString(value) === "[object ArrayBuffer]";
        }
        isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
        function isArrayBuffer2(value) {
          if (typeof ArrayBuffer === "undefined") {
            return false;
          }
          return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
        }
        exports2.isArrayBuffer = isArrayBuffer2;
        function isDataViewToString(value) {
          return ObjectToString(value) === "[object DataView]";
        }
        isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
        function isDataView(value) {
          if (typeof DataView === "undefined") {
            return false;
          }
          return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
        }
        exports2.isDataView = isDataView;
        var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
        function isSharedArrayBufferToString(value) {
          return ObjectToString(value) === "[object SharedArrayBuffer]";
        }
        function isSharedArrayBuffer(value) {
          if (typeof SharedArrayBufferCopy === "undefined") {
            return false;
          }
          if (typeof isSharedArrayBufferToString.working === "undefined") {
            isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
          }
          return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
        }
        exports2.isSharedArrayBuffer = isSharedArrayBuffer;
        function isAsyncFunction(value) {
          return ObjectToString(value) === "[object AsyncFunction]";
        }
        exports2.isAsyncFunction = isAsyncFunction;
        function isMapIterator(value) {
          return ObjectToString(value) === "[object Map Iterator]";
        }
        exports2.isMapIterator = isMapIterator;
        function isSetIterator(value) {
          return ObjectToString(value) === "[object Set Iterator]";
        }
        exports2.isSetIterator = isSetIterator;
        function isGeneratorObject(value) {
          return ObjectToString(value) === "[object Generator]";
        }
        exports2.isGeneratorObject = isGeneratorObject;
        function isWebAssemblyCompiledModule(value) {
          return ObjectToString(value) === "[object WebAssembly.Module]";
        }
        exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
        function isNumberObject(value) {
          return checkBoxedPrimitive(value, numberValue);
        }
        exports2.isNumberObject = isNumberObject;
        function isStringObject(value) {
          return checkBoxedPrimitive(value, stringValue);
        }
        exports2.isStringObject = isStringObject;
        function isBooleanObject(value) {
          return checkBoxedPrimitive(value, booleanValue);
        }
        exports2.isBooleanObject = isBooleanObject;
        function isBigIntObject(value) {
          return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
        }
        exports2.isBigIntObject = isBigIntObject;
        function isSymbolObject(value) {
          return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
        }
        exports2.isSymbolObject = isSymbolObject;
        function isBoxedPrimitive(value) {
          return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
        }
        exports2.isBoxedPrimitive = isBoxedPrimitive;
        function isAnyArrayBuffer(value) {
          return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value) || isSharedArrayBuffer(value));
        }
        exports2.isAnyArrayBuffer = isAnyArrayBuffer;
        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
          Object.defineProperty(exports2, method, { enumerable: false, value: function() {
            throw new Error(method + " is not supported in userland");
          } });
        });
      }, { "is-arguments": 365, "is-generator-function": 368, "is-typed-array": 369, "which-typed-array": 420 }], 419: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
              var keys = Object.keys(obj);
              var descriptors2 = {};
              for (var i3 = 0; i3 < keys.length; i3++) {
                descriptors2[keys[i3]] = Object.getOwnPropertyDescriptor(obj, keys[i3]);
              }
              return descriptors2;
            };
            var formatRegExp = /%[sdj%]/g;
            exports2.format = function(f2) {
              if (!isString2(f2)) {
                var objects = [];
                for (var i3 = 0; i3 < arguments.length; i3++) {
                  objects.push(inspect(arguments[i3]));
                }
                return objects.join(" ");
              }
              var i3 = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f2).replace(formatRegExp, function(x3) {
                if (x3 === "%%")
                  return "%";
                if (i3 >= len)
                  return x3;
                switch (x3) {
                  case "%s":
                    return String(args[i3++]);
                  case "%d":
                    return Number(args[i3++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i3++]);
                    } catch (_2) {
                      return "[Circular]";
                    }
                  default:
                    return x3;
                }
              });
              for (var x2 = args[i3]; i3 < len; x2 = args[++i3]) {
                if (isNull(x2) || !isObject2(x2)) {
                  str += " " + x2;
                } else {
                  str += " " + inspect(x2);
                }
              }
              return str;
            };
            exports2.deprecate = function(fn, msg) {
              if (typeof process !== "undefined" && process.noDeprecation === true) {
                return fn;
              }
              if (typeof process === "undefined") {
                return function() {
                  return exports2.deprecate(fn, msg).apply(this, arguments);
                };
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnvRegex = /^$/;
            if ({}.NODE_DEBUG) {
              var debugEnv = {}.NODE_DEBUG;
              debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
              debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
            }
            exports2.debuglog = function(set) {
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (debugEnvRegex.test(set)) {
                  var pid = process.pid;
                  debugs[set] = function() {
                    var msg = exports2.format.apply(exports2, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {
                  };
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = { seen: [], stylize: stylizeNoColor };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean2(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports2._extend(ctx, opts);
              }
              if (isUndefined2(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined2(ctx.depth))
                ctx.depth = 2;
              if (isUndefined2(ctx.colors))
                ctx.colors = false;
              if (isUndefined2(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports2.inspect = inspect;
            inspect.colors = { "bold": [1, 22], "italic": [3, 23], "underline": [4, 24], "inverse": [7, 27], "white": [37, 39], "grey": [90, 39], "black": [30, 39], "blue": [34, 39], "cyan": [36, 39], "green": [32, 39], "magenta": [35, 39], "red": [31, 39], "yellow": [33, 39] };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              // "name": intentionally not styling
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style2 = inspect.styles[styleType];
              if (style2) {
                return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash2 = {};
              array.forEach(function(val, idx) {
                hash2[val] = true;
              });
              return hash2;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
              value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString2(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction2(value)) {
                  var name2 = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name2 + "]", "special");
                }
                if (isRegExp2(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate2(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array = false, braces = ["{", "}"];
              if (isArray2(value)) {
                array = true;
                braces = ["[", "]"];
              }
              if (isFunction2(value)) {
                var n2 = value.name ? ": " + value.name : "";
                base = " [Function" + n2 + "]";
              }
              if (isRegExp2(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate2(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp2(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined2(value))
                return ctx.stylize("undefined", "undefined");
              if (isString2(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber2(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean2(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i3 = 0, l2 = value.length; i3 < l2; ++i3) {
                if (hasOwnProperty2(value, String(i3))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i3), true));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name2, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty2(visibleKeys, key)) {
                name2 = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str.split("\n").map(function(line) {
                        return "  " + line;
                      }).join("\n").slice(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined2(name2)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name2 = JSON.stringify("" + key);
                if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name2 = name2.slice(1, -1);
                  name2 = ctx.stylize(name2, "name");
                } else {
                  name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name2 = ctx.stylize(name2, "string");
                }
              }
              return name2 + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var length = output.reduce(function(prev, cur) {
                if (cur.indexOf("\n") >= 0)
                  ;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            exports2.types = require2("./support/types");
            function isArray2(ar) {
              return Array.isArray(ar);
            }
            exports2.isArray = isArray2;
            function isBoolean2(arg) {
              return typeof arg === "boolean";
            }
            exports2.isBoolean = isBoolean2;
            function isNull(arg) {
              return arg === null;
            }
            exports2.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports2.isNullOrUndefined = isNullOrUndefined;
            function isNumber2(arg) {
              return typeof arg === "number";
            }
            exports2.isNumber = isNumber2;
            function isString2(arg) {
              return typeof arg === "string";
            }
            exports2.isString = isString2;
            function isSymbol(arg) {
              return typeof arg === "symbol";
            }
            exports2.isSymbol = isSymbol;
            function isUndefined2(arg) {
              return arg === void 0;
            }
            exports2.isUndefined = isUndefined2;
            function isRegExp2(re2) {
              return isObject2(re2) && objectToString(re2) === "[object RegExp]";
            }
            exports2.isRegExp = isRegExp2;
            exports2.types.isRegExp = isRegExp2;
            function isObject2(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports2.isObject = isObject2;
            function isDate2(d2) {
              return isObject2(d2) && objectToString(d2) === "[object Date]";
            }
            exports2.isDate = isDate2;
            exports2.types.isDate = isDate2;
            function isError(e2) {
              return isObject2(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
            }
            exports2.isError = isError;
            exports2.types.isNativeError = isError;
            function isFunction2(arg) {
              return typeof arg === "function";
            }
            exports2.isFunction = isFunction2;
            function isPrimitive(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined";
            }
            exports2.isPrimitive = isPrimitive;
            exports2.isBuffer = require2("./support/isBuffer");
            function objectToString(o2) {
              return Object.prototype.toString.call(o2);
            }
            function pad(n2) {
              return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
            }
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            function timestamp() {
              var d2 = /* @__PURE__ */ new Date();
              var time = [pad(d2.getHours()), pad(d2.getMinutes()), pad(d2.getSeconds())].join(":");
              return [d2.getDate(), months[d2.getMonth()], time].join(" ");
            }
            exports2.log = function() {
              console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
            };
            exports2.inherits = require2("inherits");
            exports2._extend = function(origin, add) {
              if (!add || !isObject2(add))
                return origin;
              var keys = Object.keys(add);
              var i3 = keys.length;
              while (i3--) {
                origin[keys[i3]] = add[keys[i3]];
              }
              return origin;
            };
            function hasOwnProperty2(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
            exports2.promisify = function promisify(original) {
              if (typeof original !== "function")
                throw new TypeError('The "original" argument must be of type Function');
              if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                var fn = original[kCustomPromisifiedSymbol];
                if (typeof fn !== "function") {
                  throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                }
                Object.defineProperty(fn, kCustomPromisifiedSymbol, { value: fn, enumerable: false, writable: false, configurable: true });
                return fn;
              }
              function fn() {
                var promiseResolve2, promiseReject;
                var promise2 = new Promise(function(resolve, reject) {
                  promiseResolve2 = resolve;
                  promiseReject = reject;
                });
                var args = [];
                for (var i3 = 0; i3 < arguments.length; i3++) {
                  args.push(arguments[i3]);
                }
                args.push(function(err2, value) {
                  if (err2) {
                    promiseReject(err2);
                  } else {
                    promiseResolve2(value);
                  }
                });
                try {
                  original.apply(this, args);
                } catch (err2) {
                  promiseReject(err2);
                }
                return promise2;
              }
              Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
              if (kCustomPromisifiedSymbol)
                Object.defineProperty(fn, kCustomPromisifiedSymbol, { value: fn, enumerable: false, writable: false, configurable: true });
              return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
            };
            exports2.promisify.custom = kCustomPromisifiedSymbol;
            function callbackifyOnRejected(reason, cb) {
              if (!reason) {
                var newReason = new Error("Promise was rejected with a falsy value");
                newReason.reason = reason;
                reason = newReason;
              }
              return cb(reason);
            }
            function callbackify(original) {
              if (typeof original !== "function") {
                throw new TypeError('The "original" argument must be of type Function');
              }
              function callbackified() {
                var args = [];
                for (var i3 = 0; i3 < arguments.length; i3++) {
                  args.push(arguments[i3]);
                }
                var maybeCb = args.pop();
                if (typeof maybeCb !== "function") {
                  throw new TypeError("The last argument must be of type Function");
                }
                var self2 = this;
                var cb = function() {
                  return maybeCb.apply(self2, arguments);
                };
                original.apply(this, args).then(function(ret) {
                  process.nextTick(cb.bind(null, null, ret));
                }, function(rej) {
                  process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                });
              }
              Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
              Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
              return callbackified;
            }
            exports2.callbackify = callbackify;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./support/isBuffer": 417, "./support/types": 418, "_process": 467, "inherits": 364 }], 420: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            var forEach2 = require2("for-each");
            var availableTypedArrays = require2("available-typed-arrays");
            var callBind = require2("call-bind");
            var callBound = require2("call-bind/callBound");
            var gOPD = require2("gopd");
            var $toString = callBound("Object.prototype.toString");
            var hasToStringTag = require2("has-tostringtag/shams")();
            var g2 = typeof globalThis === "undefined" ? global3 : globalThis;
            var typedArrays = availableTypedArrays();
            var $slice = callBound("String.prototype.slice");
            var getPrototypeOf2 = Object.getPrototypeOf;
            var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
              for (var i3 = 0; i3 < array.length; i3 += 1) {
                if (array[i3] === value) {
                  return i3;
                }
              }
              return -1;
            };
            var cache2 = { __proto__: null };
            if (hasToStringTag && gOPD && getPrototypeOf2) {
              forEach2(typedArrays, function(typedArray) {
                var arr = new g2[typedArray]();
                if (Symbol.toStringTag in arr) {
                  var proto = getPrototypeOf2(arr);
                  var descriptor = gOPD(proto, Symbol.toStringTag);
                  if (!descriptor) {
                    var superProto = getPrototypeOf2(proto);
                    descriptor = gOPD(superProto, Symbol.toStringTag);
                  }
                  cache2["$" + typedArray] = callBind(descriptor.get);
                }
              });
            } else {
              forEach2(typedArrays, function(typedArray) {
                var arr = new g2[typedArray]();
                cache2["$" + typedArray] = callBind(arr.slice);
              });
            }
            var tryTypedArrays = function tryAllTypedArrays(value) {
              var found = false;
              forEach2(cache2, function(getter, typedArray) {
                if (!found) {
                  try {
                    if ("$" + getter(value) === typedArray) {
                      found = $slice(typedArray, 1);
                    }
                  } catch (e2) {
                  }
                }
              });
              return found;
            };
            var trySlices = function tryAllSlices(value) {
              var found = false;
              forEach2(cache2, function(getter, name2) {
                if (!found) {
                  try {
                    getter(value);
                    found = $slice(name2, 1);
                  } catch (e2) {
                  }
                }
              });
              return found;
            };
            module2.exports = function whichTypedArray(value) {
              if (!value || typeof value !== "object") {
                return false;
              }
              if (!hasToStringTag) {
                var tag = $slice($toString(value), 8, -1);
                if ($indexOf(typedArrays, tag) > -1) {
                  return tag;
                }
                if (tag !== "Object") {
                  return false;
                }
                return trySlices(value);
              }
              if (!gOPD) {
                return null;
              }
              return tryTypedArrays(value);
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "available-typed-arrays": 86, "call-bind": 93, "call-bind/callBound": 92, "for-each": 345, "gopd": 349, "has-tostringtag/shams": 353 }], 421: [function(require2, module2, exports2) {
        (function() {
          exports2.stripBOM = function(str) {
            if (str[0] === "\uFEFF") {
              return str.substring(1);
            } else {
              return str;
            }
          };
        }).call(this);
      }, {}], 422: [function(require2, module2, exports2) {
        (function() {
          var builder, defaults2, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
          builder = require2("xmlbuilder");
          defaults2 = require2("./defaults").defaults;
          requiresCDATA = function(entry) {
            return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
          };
          wrapCDATA = function(entry) {
            return "<![CDATA[" + escapeCDATA(entry) + "]]>";
          };
          escapeCDATA = function(entry) {
            return entry.replace("]]>", "]]]]><![CDATA[>");
          };
          exports2.Builder = function() {
            function Builder(opts) {
              var key, ref2, value;
              this.options = {};
              ref2 = defaults2["0.2"];
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this.options[key] = value;
              }
              for (key in opts) {
                if (!hasProp.call(opts, key))
                  continue;
                value = opts[key];
                this.options[key] = value;
              }
            }
            Builder.prototype.buildObject = function(rootObj) {
              var attrkey, charkey, render2, rootElement, rootName;
              attrkey = this.options.attrkey;
              charkey = this.options.charkey;
              if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults2["0.2"].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
              } else {
                rootName = this.options.rootName;
              }
              render2 = function(_this) {
                return function(element, obj) {
                  var attr, child, entry, index2, key, value;
                  if (typeof obj !== "object") {
                    if (_this.options.cdata && requiresCDATA(obj)) {
                      element.raw(wrapCDATA(obj));
                    } else {
                      element.txt(obj);
                    }
                  } else if (Array.isArray(obj)) {
                    for (index2 in obj) {
                      if (!hasProp.call(obj, index2))
                        continue;
                      child = obj[index2];
                      for (key in child) {
                        entry = child[key];
                        element = render2(element.ele(key), entry).up();
                      }
                    }
                  } else {
                    for (key in obj) {
                      if (!hasProp.call(obj, key))
                        continue;
                      child = obj[key];
                      if (key === attrkey) {
                        if (typeof child === "object") {
                          for (attr in child) {
                            value = child[attr];
                            element = element.att(attr, value);
                          }
                        }
                      } else if (key === charkey) {
                        if (_this.options.cdata && requiresCDATA(child)) {
                          element = element.raw(wrapCDATA(child));
                        } else {
                          element = element.txt(child);
                        }
                      } else if (Array.isArray(child)) {
                        for (index2 in child) {
                          if (!hasProp.call(child, index2))
                            continue;
                          entry = child[index2];
                          if (typeof entry === "string") {
                            if (_this.options.cdata && requiresCDATA(entry)) {
                              element = element.ele(key).raw(wrapCDATA(entry)).up();
                            } else {
                              element = element.ele(key, entry).up();
                            }
                          } else {
                            element = render2(element.ele(key), entry).up();
                          }
                        }
                      } else if (typeof child === "object") {
                        element = render2(element.ele(key), child).up();
                      } else {
                        if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                          element = element.ele(key).raw(wrapCDATA(child)).up();
                        } else {
                          if (child == null) {
                            child = "";
                          }
                          element = element.ele(key, child.toString()).up();
                        }
                      }
                    }
                  }
                  return element;
                };
              }(this);
              rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, { headless: this.options.headless, allowSurrogateChars: this.options.allowSurrogateChars });
              return render2(rootElement, rootObj).end(this.options.renderOpts);
            };
            return Builder;
          }();
        }).call(this);
      }, { "./defaults": 423, "xmlbuilder": 459 }], 423: [function(require2, module2, exports2) {
        (function() {
          exports2.defaults = { "0.1": { explicitCharkey: false, trim: true, normalize: true, normalizeTags: false, attrkey: "@", charkey: "#", explicitArray: false, ignoreAttrs: false, mergeAttrs: false, explicitRoot: false, validator: null, xmlns: false, explicitChildren: false, childkey: "@@", charsAsChildren: false, includeWhiteChars: false, async: false, strict: true, attrNameProcessors: null, attrValueProcessors: null, tagNameProcessors: null, valueProcessors: null, emptyTag: "" }, "0.2": { explicitCharkey: false, trim: false, normalize: false, normalizeTags: false, attrkey: "$", charkey: "_", explicitArray: true, ignoreAttrs: false, mergeAttrs: false, explicitRoot: true, validator: null, xmlns: false, explicitChildren: false, preserveChildrenOrder: false, childkey: "$$", charsAsChildren: false, includeWhiteChars: false, async: false, strict: true, attrNameProcessors: null, attrValueProcessors: null, tagNameProcessors: null, valueProcessors: null, rootName: "root", xmldec: { "version": "1.0", "encoding": "UTF-8", "standalone": true }, doctype: null, renderOpts: { "pretty": true, "indent": "  ", "newline": "\n" }, headless: false, chunkSize: 1e4, emptyTag: "", cdata: false } };
        }).call(this);
      }, {}], 424: [function(require2, module2, exports2) {
        (function() {
          var bom, defaults2, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind2 = function(fn, me2) {
            return function() {
              return fn.apply(me2, arguments);
            };
          }, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          sax = require2("sax");
          events = require2("events");
          bom = require2("./bom");
          processors = require2("./processors");
          setImmediate = require2("timers").setImmediate;
          defaults2 = require2("./defaults").defaults;
          isEmpty = function(thing) {
            return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
          };
          processItem = function(processors2, item, key) {
            var i3, len, process;
            for (i3 = 0, len = processors2.length; i3 < len; i3++) {
              process = processors2[i3];
              item = process(item, key);
            }
            return item;
          };
          defineProperty = function(obj, key, value) {
            var descriptor;
            descriptor = /* @__PURE__ */ Object.create(null);
            descriptor.value = value;
            descriptor.writable = true;
            descriptor.enumerable = true;
            descriptor.configurable = true;
            return Object.defineProperty(obj, key, descriptor);
          };
          exports2.Parser = function(superClass) {
            extend2(Parser2, superClass);
            function Parser2(opts) {
              this.parseStringPromise = bind2(this.parseStringPromise, this);
              this.parseString = bind2(this.parseString, this);
              this.reset = bind2(this.reset, this);
              this.assignOrPush = bind2(this.assignOrPush, this);
              this.processAsync = bind2(this.processAsync, this);
              var key, ref2, value;
              if (!(this instanceof exports2.Parser)) {
                return new exports2.Parser(opts);
              }
              this.options = {};
              ref2 = defaults2["0.2"];
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this.options[key] = value;
              }
              for (key in opts) {
                if (!hasProp.call(opts, key))
                  continue;
                value = opts[key];
                this.options[key] = value;
              }
              if (this.options.xmlns) {
                this.options.xmlnskey = this.options.attrkey + "ns";
              }
              if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) {
                  this.options.tagNameProcessors = [];
                }
                this.options.tagNameProcessors.unshift(processors.normalize);
              }
              this.reset();
            }
            Parser2.prototype.processAsync = function() {
              var chunk, err2;
              try {
                if (this.remaining.length <= this.options.chunkSize) {
                  chunk = this.remaining;
                  this.remaining = "";
                  this.saxParser = this.saxParser.write(chunk);
                  return this.saxParser.close();
                } else {
                  chunk = this.remaining.substr(0, this.options.chunkSize);
                  this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                  this.saxParser = this.saxParser.write(chunk);
                  return setImmediate(this.processAsync);
                }
              } catch (error1) {
                err2 = error1;
                if (!this.saxParser.errThrown) {
                  this.saxParser.errThrown = true;
                  return this.emit(err2);
                }
              }
            };
            Parser2.prototype.assignOrPush = function(obj, key, newValue) {
              if (!(key in obj)) {
                if (!this.options.explicitArray) {
                  return defineProperty(obj, key, newValue);
                } else {
                  return defineProperty(obj, key, [newValue]);
                }
              } else {
                if (!(obj[key] instanceof Array)) {
                  defineProperty(obj, key, [obj[key]]);
                }
                return obj[key].push(newValue);
              }
            };
            Parser2.prototype.reset = function() {
              var attrkey, charkey, ontext, stack2;
              this.removeAllListeners();
              this.saxParser = sax.parser(this.options.strict, { trim: false, normalize: false, xmlns: this.options.xmlns });
              this.saxParser.errThrown = false;
              this.saxParser.onerror = function(_this) {
                return function(error) {
                  _this.saxParser.resume();
                  if (!_this.saxParser.errThrown) {
                    _this.saxParser.errThrown = true;
                    return _this.emit("error", error);
                  }
                };
              }(this);
              this.saxParser.onend = function(_this) {
                return function() {
                  if (!_this.saxParser.ended) {
                    _this.saxParser.ended = true;
                    return _this.emit("end", _this.resultObject);
                  }
                };
              }(this);
              this.saxParser.ended = false;
              this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
              this.resultObject = null;
              stack2 = [];
              attrkey = this.options.attrkey;
              charkey = this.options.charkey;
              this.saxParser.onopentag = function(_this) {
                return function(node2) {
                  var key, newValue, obj, processedKey, ref2;
                  obj = {};
                  obj[charkey] = "";
                  if (!_this.options.ignoreAttrs) {
                    ref2 = node2.attributes;
                    for (key in ref2) {
                      if (!hasProp.call(ref2, key))
                        continue;
                      if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                        obj[attrkey] = {};
                      }
                      newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node2.attributes[key], key) : node2.attributes[key];
                      processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                      if (_this.options.mergeAttrs) {
                        _this.assignOrPush(obj, processedKey, newValue);
                      } else {
                        defineProperty(obj[attrkey], processedKey, newValue);
                      }
                    }
                  }
                  obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node2.name) : node2.name;
                  if (_this.options.xmlns) {
                    obj[_this.options.xmlnskey] = { uri: node2.uri, local: node2.local };
                  }
                  return stack2.push(obj);
                };
              }(this);
              this.saxParser.onclosetag = function(_this) {
                return function() {
                  var cdata, emptyStr, key, node2, nodeName, obj, objClone, old, s2, xpath;
                  obj = stack2.pop();
                  nodeName = obj["#name"];
                  if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                    delete obj["#name"];
                  }
                  if (obj.cdata === true) {
                    cdata = obj.cdata;
                    delete obj.cdata;
                  }
                  s2 = stack2[stack2.length - 1];
                  if (obj[charkey].match(/^\s*$/) && !cdata) {
                    emptyStr = obj[charkey];
                    delete obj[charkey];
                  } else {
                    if (_this.options.trim) {
                      obj[charkey] = obj[charkey].trim();
                    }
                    if (_this.options.normalize) {
                      obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                    }
                    obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                      obj = obj[charkey];
                    }
                  }
                  if (isEmpty(obj)) {
                    if (typeof _this.options.emptyTag === "function") {
                      obj = _this.options.emptyTag();
                    } else {
                      obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                    }
                  }
                  if (_this.options.validator != null) {
                    xpath = "/" + function() {
                      var i3, len, results;
                      results = [];
                      for (i3 = 0, len = stack2.length; i3 < len; i3++) {
                        node2 = stack2[i3];
                        results.push(node2["#name"]);
                      }
                      return results;
                    }().concat(nodeName).join("/");
                    (function() {
                      var err2;
                      try {
                        return obj = _this.options.validator(xpath, s2 && s2[nodeName], obj);
                      } catch (error1) {
                        err2 = error1;
                        return _this.emit("error", err2);
                      }
                    })();
                  }
                  if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                    if (!_this.options.preserveChildrenOrder) {
                      node2 = {};
                      if (_this.options.attrkey in obj) {
                        node2[_this.options.attrkey] = obj[_this.options.attrkey];
                        delete obj[_this.options.attrkey];
                      }
                      if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                        node2[_this.options.charkey] = obj[_this.options.charkey];
                        delete obj[_this.options.charkey];
                      }
                      if (Object.getOwnPropertyNames(obj).length > 0) {
                        node2[_this.options.childkey] = obj;
                      }
                      obj = node2;
                    } else if (s2) {
                      s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                      objClone = {};
                      for (key in obj) {
                        if (!hasProp.call(obj, key))
                          continue;
                        defineProperty(objClone, key, obj[key]);
                      }
                      s2[_this.options.childkey].push(objClone);
                      delete obj["#name"];
                      if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                        obj = obj[charkey];
                      }
                    }
                  }
                  if (stack2.length > 0) {
                    return _this.assignOrPush(s2, nodeName, obj);
                  } else {
                    if (_this.options.explicitRoot) {
                      old = obj;
                      obj = {};
                      defineProperty(obj, nodeName, old);
                    }
                    _this.resultObject = obj;
                    _this.saxParser.ended = true;
                    return _this.emit("end", _this.resultObject);
                  }
                };
              }(this);
              ontext = function(_this) {
                return function(text2) {
                  var charChild, s2;
                  s2 = stack2[stack2.length - 1];
                  if (s2) {
                    s2[charkey] += text2;
                    if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text2.replace(/\\n/g, "").trim() !== "")) {
                      s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                      charChild = { "#name": "__text__" };
                      charChild[charkey] = text2;
                      if (_this.options.normalize) {
                        charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                      }
                      s2[_this.options.childkey].push(charChild);
                    }
                    return s2;
                  }
                };
              }(this);
              this.saxParser.ontext = ontext;
              return this.saxParser.oncdata = function(_this) {
                return function(text2) {
                  var s2;
                  s2 = ontext(text2);
                  if (s2) {
                    return s2.cdata = true;
                  }
                };
              }();
            };
            Parser2.prototype.parseString = function(str, cb) {
              var err2;
              if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                  this.reset();
                  return cb(null, result);
                });
                this.on("error", function(err3) {
                  this.reset();
                  return cb(err3);
                });
              }
              try {
                str = str.toString();
                if (str.trim() === "") {
                  this.emit("end", null);
                  return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                  this.remaining = str;
                  setImmediate(this.processAsync);
                  return this.saxParser;
                }
                return this.saxParser.write(str).close();
              } catch (error1) {
                err2 = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                  this.emit("error", err2);
                  return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) {
                  throw err2;
                }
              }
            };
            Parser2.prototype.parseStringPromise = function(str) {
              return new Promise(function(_this) {
                return function(resolve, reject) {
                  return _this.parseString(str, function(err2, value) {
                    if (err2) {
                      return reject(err2);
                    } else {
                      return resolve(value);
                    }
                  });
                };
              }(this));
            };
            return Parser2;
          }(events);
          exports2.parseString = function(str, a2, b2) {
            var cb, options, parser;
            if (b2 != null) {
              if (typeof b2 === "function") {
                cb = b2;
              }
              if (typeof a2 === "object") {
                options = a2;
              }
            } else {
              if (typeof a2 === "function") {
                cb = a2;
              }
              options = {};
            }
            parser = new exports2.Parser(options);
            return parser.parseString(str, cb);
          };
          exports2.parseStringPromise = function(str, a2) {
            var options, parser;
            if (typeof a2 === "object") {
              options = a2;
            }
            parser = new exports2.Parser(options);
            return parser.parseStringPromise(str);
          };
        }).call(this);
      }, { "./bom": 421, "./defaults": 423, "./processors": 425, "events": 344, "sax": 397, "timers": 414 }], 425: [function(require2, module2, exports2) {
        (function() {
          var prefixMatch;
          prefixMatch = new RegExp(/(?!xmlns)^.*:/);
          exports2.normalize = function(str) {
            return str.toLowerCase();
          };
          exports2.firstCharLowerCase = function(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
          };
          exports2.stripPrefix = function(str) {
            return str.replace(prefixMatch, "");
          };
          exports2.parseNumbers = function(str) {
            if (!isNaN(str)) {
              str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
            }
            return str;
          };
          exports2.parseBooleans = function(str) {
            if (/^(?:true|false)$/i.test(str)) {
              str = str.toLowerCase() === "true";
            }
            return str;
          };
        }).call(this);
      }, {}], 426: [function(require2, module2, exports2) {
        (function() {
          var builder, defaults2, parser, processors, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          defaults2 = require2("./defaults");
          builder = require2("./builder");
          parser = require2("./parser");
          processors = require2("./processors");
          exports2.defaults = defaults2.defaults;
          exports2.processors = processors;
          exports2.ValidationError = function(superClass) {
            extend2(ValidationError, superClass);
            function ValidationError(message) {
              this.message = message;
            }
            return ValidationError;
          }(Error);
          exports2.Builder = builder.Builder;
          exports2.Parser = parser.Parser;
          exports2.parseString = parser.parseString;
          exports2.parseStringPromise = parser.parseStringPromise;
        }).call(this);
      }, { "./builder": 422, "./defaults": 423, "./parser": 424, "./processors": 425 }], 427: [function(require2, module2, exports2) {
        (function() {
          module2.exports = { Disconnected: 1, Preceding: 2, Following: 4, Contains: 8, ContainedBy: 16, ImplementationSpecific: 32 };
        }).call(this);
      }, {}], 428: [function(require2, module2, exports2) {
        (function() {
          module2.exports = { Element: 1, Attribute: 2, Text: 3, CData: 4, EntityReference: 5, EntityDeclaration: 6, ProcessingInstruction: 7, Comment: 8, Document: 9, DocType: 10, DocumentFragment: 11, NotationDeclaration: 12, Declaration: 201, Raw: 202, AttributeDeclaration: 203, ElementDeclaration: 204, Dummy: 205 };
        }).call(this);
      }, {}], 429: [function(require2, module2, exports2) {
        (function() {
          var assign, getValue, isArray2, isEmpty, isFunction2, isObject2, isPlainObject2, slice = [].slice, hasProp = {}.hasOwnProperty;
          assign = function() {
            var i3, key, len, source, sources, target;
            target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (isFunction2(Object.assign)) {
              Object.assign.apply(null, arguments);
            } else {
              for (i3 = 0, len = sources.length; i3 < len; i3++) {
                source = sources[i3];
                if (source != null) {
                  for (key in source) {
                    if (!hasProp.call(source, key))
                      continue;
                    target[key] = source[key];
                  }
                }
              }
            }
            return target;
          };
          isFunction2 = function(val) {
            return !!val && Object.prototype.toString.call(val) === "[object Function]";
          };
          isObject2 = function(val) {
            var ref2;
            return !!val && ((ref2 = typeof val) === "function" || ref2 === "object");
          };
          isArray2 = function(val) {
            if (isFunction2(Array.isArray)) {
              return Array.isArray(val);
            } else {
              return Object.prototype.toString.call(val) === "[object Array]";
            }
          };
          isEmpty = function(val) {
            var key;
            if (isArray2(val)) {
              return !val.length;
            } else {
              for (key in val) {
                if (!hasProp.call(val, key))
                  continue;
                return false;
              }
              return true;
            }
          };
          isPlainObject2 = function(val) {
            var ctor, proto;
            return isObject2(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
          };
          getValue = function(obj) {
            if (isFunction2(obj.valueOf)) {
              return obj.valueOf();
            } else {
              return obj;
            }
          };
          module2.exports.assign = assign;
          module2.exports.isFunction = isFunction2;
          module2.exports.isObject = isObject2;
          module2.exports.isArray = isArray2;
          module2.exports.isEmpty = isEmpty;
          module2.exports.isPlainObject = isPlainObject2;
          module2.exports.getValue = getValue;
        }).call(this);
      }, {}], 430: [function(require2, module2, exports2) {
        (function() {
          module2.exports = { None: 0, OpenTag: 1, InsideTag: 2, CloseTag: 3 };
        }).call(this);
      }, {}], 431: [function(require2, module2, exports2) {
        (function() {
          var NodeType;
          NodeType = require2("./NodeType");
          require2("./XMLNode");
          module2.exports = function() {
            function XMLAttribute(parent, name2, value) {
              this.parent = parent;
              if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
              }
              if (name2 == null) {
                throw new Error("Missing attribute name. " + this.debugInfo(name2));
              }
              this.name = this.stringify.name(name2);
              this.value = this.stringify.attValue(value);
              this.type = NodeType.Attribute;
              this.isId = false;
              this.schemaTypeInfo = null;
            }
            Object.defineProperty(XMLAttribute.prototype, "nodeType", { get: function() {
              return this.type;
            } });
            Object.defineProperty(XMLAttribute.prototype, "ownerElement", { get: function() {
              return this.parent;
            } });
            Object.defineProperty(XMLAttribute.prototype, "textContent", { get: function() {
              return this.value;
            }, set: function(value) {
              return this.value = value || "";
            } });
            Object.defineProperty(XMLAttribute.prototype, "namespaceURI", { get: function() {
              return "";
            } });
            Object.defineProperty(XMLAttribute.prototype, "prefix", { get: function() {
              return "";
            } });
            Object.defineProperty(XMLAttribute.prototype, "localName", { get: function() {
              return this.name;
            } });
            Object.defineProperty(XMLAttribute.prototype, "specified", { get: function() {
              return true;
            } });
            XMLAttribute.prototype.clone = function() {
              return Object.create(this);
            };
            XMLAttribute.prototype.toString = function(options) {
              return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
            };
            XMLAttribute.prototype.debugInfo = function(name2) {
              name2 = name2 || this.name;
              if (name2 == null) {
                return "parent: <" + this.parent.name + ">";
              } else {
                return "attribute: {" + name2 + "}, parent: <" + this.parent.name + ">";
              }
            };
            XMLAttribute.prototype.isEqualNode = function(node2) {
              if (node2.namespaceURI !== this.namespaceURI) {
                return false;
              }
              if (node2.prefix !== this.prefix) {
                return false;
              }
              if (node2.localName !== this.localName) {
                return false;
              }
              if (node2.value !== this.value) {
                return false;
              }
              return true;
            };
            return XMLAttribute;
          }();
        }).call(this);
      }, { "./NodeType": 428, "./XMLNode": 450 }], 432: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module2.exports = function(superClass) {
            extend2(XMLCData, superClass);
            function XMLCData(parent, text2) {
              XMLCData.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing CDATA text. " + this.debugInfo());
              }
              this.name = "#cdata-section";
              this.type = NodeType.CData;
              this.value = this.stringify.cdata(text2);
            }
            XMLCData.prototype.clone = function() {
              return Object.create(this);
            };
            XMLCData.prototype.toString = function(options) {
              return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
            };
            return XMLCData;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 428, "./XMLCharacterData": 433 }], 433: [function(require2, module2, exports2) {
        (function() {
          var XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          module2.exports = function(superClass) {
            extend2(XMLCharacterData, superClass);
            function XMLCharacterData(parent) {
              XMLCharacterData.__super__.constructor.call(this, parent);
              this.value = "";
            }
            Object.defineProperty(XMLCharacterData.prototype, "data", { get: function() {
              return this.value;
            }, set: function(value) {
              return this.value = value || "";
            } });
            Object.defineProperty(XMLCharacterData.prototype, "length", { get: function() {
              return this.value.length;
            } });
            Object.defineProperty(XMLCharacterData.prototype, "textContent", { get: function() {
              return this.value;
            }, set: function(value) {
              return this.value = value || "";
            } });
            XMLCharacterData.prototype.clone = function() {
              return Object.create(this);
            };
            XMLCharacterData.prototype.substringData = function(offset2, count) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.appendData = function(arg) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.insertData = function(offset2, arg) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.deleteData = function(offset2, count) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.replaceData = function(offset2, count, arg) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.isEqualNode = function(node2) {
              if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                return false;
              }
              if (node2.data !== this.data) {
                return false;
              }
              return true;
            };
            return XMLCharacterData;
          }(XMLNode);
        }).call(this);
      }, { "./XMLNode": 450 }], 434: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module2.exports = function(superClass) {
            extend2(XMLComment, superClass);
            function XMLComment(parent, text2) {
              XMLComment.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing comment text. " + this.debugInfo());
              }
              this.name = "#comment";
              this.type = NodeType.Comment;
              this.value = this.stringify.comment(text2);
            }
            XMLComment.prototype.clone = function() {
              return Object.create(this);
            };
            XMLComment.prototype.toString = function(options) {
              return this.options.writer.comment(this, this.options.writer.filterOptions(options));
            };
            return XMLComment;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 428, "./XMLCharacterData": 433 }], 435: [function(require2, module2, exports2) {
        (function() {
          var XMLDOMErrorHandler, XMLDOMStringList;
          XMLDOMErrorHandler = require2("./XMLDOMErrorHandler");
          XMLDOMStringList = require2("./XMLDOMStringList");
          module2.exports = function() {
            function XMLDOMConfiguration() {
              this.defaultParams = { "canonical-form": false, "cdata-sections": false, "comments": false, "datatype-normalization": false, "element-content-whitespace": true, "entities": true, "error-handler": new XMLDOMErrorHandler(), "infoset": true, "validate-if-schema": false, "namespaces": true, "namespace-declarations": true, "normalize-characters": false, "schema-location": "", "schema-type": "", "split-cdata-sections": true, "validate": false, "well-formed": true };
              this.params = Object.create(this.defaultParams);
            }
            Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", { get: function() {
              return new XMLDOMStringList(Object.keys(this.defaultParams));
            } });
            XMLDOMConfiguration.prototype.getParameter = function(name2) {
              if (this.params.hasOwnProperty(name2)) {
                return this.params[name2];
              } else {
                return null;
              }
            };
            XMLDOMConfiguration.prototype.canSetParameter = function(name2, value) {
              return true;
            };
            XMLDOMConfiguration.prototype.setParameter = function(name2, value) {
              if (value != null) {
                return this.params[name2] = value;
              } else {
                return delete this.params[name2];
              }
            };
            return XMLDOMConfiguration;
          }();
        }).call(this);
      }, { "./XMLDOMErrorHandler": 436, "./XMLDOMStringList": 438 }], 436: [function(require2, module2, exports2) {
        (function() {
          module2.exports = function() {
            function XMLDOMErrorHandler() {
            }
            XMLDOMErrorHandler.prototype.handleError = function(error) {
              throw new Error(error);
            };
            return XMLDOMErrorHandler;
          }();
        }).call(this);
      }, {}], 437: [function(require2, module2, exports2) {
        (function() {
          module2.exports = function() {
            function XMLDOMImplementation() {
            }
            XMLDOMImplementation.prototype.hasFeature = function(feature, version2) {
              return true;
            };
            XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation.prototype.getFeature = function(feature, version2) {
              throw new Error("This DOM method is not implemented.");
            };
            return XMLDOMImplementation;
          }();
        }).call(this);
      }, {}], 438: [function(require2, module2, exports2) {
        (function() {
          module2.exports = function() {
            function XMLDOMStringList(arr) {
              this.arr = arr || [];
            }
            Object.defineProperty(XMLDOMStringList.prototype, "length", { get: function() {
              return this.arr.length;
            } });
            XMLDOMStringList.prototype.item = function(index2) {
              return this.arr[index2] || null;
            };
            XMLDOMStringList.prototype.contains = function(str) {
              return this.arr.indexOf(str) !== -1;
            };
            return XMLDOMStringList;
          }();
        }).call(this);
      }, {}], 439: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module2.exports = function(superClass) {
            extend2(XMLDTDAttList, superClass);
            function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              XMLDTDAttList.__super__.constructor.call(this, parent);
              if (elementName == null) {
                throw new Error("Missing DTD element name. " + this.debugInfo());
              }
              if (attributeName == null) {
                throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
              }
              if (!attributeType) {
                throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
              }
              if (!defaultValueType) {
                throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
              }
              if (defaultValueType.indexOf("#") !== 0) {
                defaultValueType = "#" + defaultValueType;
              }
              if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
                throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
              }
              if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
                throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
              }
              this.elementName = this.stringify.name(elementName);
              this.type = NodeType.AttributeDeclaration;
              this.attributeName = this.stringify.name(attributeName);
              this.attributeType = this.stringify.dtdAttType(attributeType);
              if (defaultValue) {
                this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
              }
              this.defaultValueType = defaultValueType;
            }
            XMLDTDAttList.prototype.toString = function(options) {
              return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDAttList;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./XMLNode": 450 }], 440: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module2.exports = function(superClass) {
            extend2(XMLDTDElement, superClass);
            function XMLDTDElement(parent, name2, value) {
              XMLDTDElement.__super__.constructor.call(this, parent);
              if (name2 == null) {
                throw new Error("Missing DTD element name. " + this.debugInfo());
              }
              if (!value) {
                value = "(#PCDATA)";
              }
              if (Array.isArray(value)) {
                value = "(" + value.join(",") + ")";
              }
              this.name = this.stringify.name(name2);
              this.type = NodeType.ElementDeclaration;
              this.value = this.stringify.dtdElementValue(value);
            }
            XMLDTDElement.prototype.toString = function(options) {
              return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDElement;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./XMLNode": 450 }], 441: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, isObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isObject2 = require2("./Utility").isObject;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module2.exports = function(superClass) {
            extend2(XMLDTDEntity, superClass);
            function XMLDTDEntity(parent, pe2, name2, value) {
              XMLDTDEntity.__super__.constructor.call(this, parent);
              if (name2 == null) {
                throw new Error("Missing DTD entity name. " + this.debugInfo(name2));
              }
              if (value == null) {
                throw new Error("Missing DTD entity value. " + this.debugInfo(name2));
              }
              this.pe = !!pe2;
              this.name = this.stringify.name(name2);
              this.type = NodeType.EntityDeclaration;
              if (!isObject2(value)) {
                this.value = this.stringify.dtdEntityValue(value);
                this.internal = true;
              } else {
                if (!value.pubID && !value.sysID) {
                  throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name2));
                }
                if (value.pubID && !value.sysID) {
                  throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name2));
                }
                this.internal = false;
                if (value.pubID != null) {
                  this.pubID = this.stringify.dtdPubID(value.pubID);
                }
                if (value.sysID != null) {
                  this.sysID = this.stringify.dtdSysID(value.sysID);
                }
                if (value.nData != null) {
                  this.nData = this.stringify.dtdNData(value.nData);
                }
                if (this.pe && this.nData) {
                  throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name2));
                }
              }
            }
            Object.defineProperty(XMLDTDEntity.prototype, "publicId", { get: function() {
              return this.pubID;
            } });
            Object.defineProperty(XMLDTDEntity.prototype, "systemId", { get: function() {
              return this.sysID;
            } });
            Object.defineProperty(XMLDTDEntity.prototype, "notationName", { get: function() {
              return this.nData || null;
            } });
            Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", { get: function() {
              return null;
            } });
            Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", { get: function() {
              return null;
            } });
            Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", { get: function() {
              return null;
            } });
            XMLDTDEntity.prototype.toString = function(options) {
              return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDEntity;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./XMLNode": 450 }], 442: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module2.exports = function(superClass) {
            extend2(XMLDTDNotation, superClass);
            function XMLDTDNotation(parent, name2, value) {
              XMLDTDNotation.__super__.constructor.call(this, parent);
              if (name2 == null) {
                throw new Error("Missing DTD notation name. " + this.debugInfo(name2));
              }
              if (!value.pubID && !value.sysID) {
                throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name2));
              }
              this.name = this.stringify.name(name2);
              this.type = NodeType.NotationDeclaration;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
            }
            Object.defineProperty(XMLDTDNotation.prototype, "publicId", { get: function() {
              return this.pubID;
            } });
            Object.defineProperty(XMLDTDNotation.prototype, "systemId", { get: function() {
              return this.sysID;
            } });
            XMLDTDNotation.prototype.toString = function(options) {
              return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDNotation;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./XMLNode": 450 }], 443: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, isObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isObject2 = require2("./Utility").isObject;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module2.exports = function(superClass) {
            extend2(XMLDeclaration, superClass);
            function XMLDeclaration(parent, version2, encoding, standalone) {
              var ref2;
              XMLDeclaration.__super__.constructor.call(this, parent);
              if (isObject2(version2)) {
                ref2 = version2, version2 = ref2.version, encoding = ref2.encoding, standalone = ref2.standalone;
              }
              if (!version2) {
                version2 = "1.0";
              }
              this.type = NodeType.Declaration;
              this.version = this.stringify.xmlVersion(version2);
              if (encoding != null) {
                this.encoding = this.stringify.xmlEncoding(encoding);
              }
              if (standalone != null) {
                this.standalone = this.stringify.xmlStandalone(standalone);
              }
            }
            XMLDeclaration.prototype.toString = function(options) {
              return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
            };
            return XMLDeclaration;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./XMLNode": 450 }], 444: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNamedNodeMap, XMLNode, isObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isObject2 = require2("./Utility").isObject;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          XMLDTDAttList = require2("./XMLDTDAttList");
          XMLDTDEntity = require2("./XMLDTDEntity");
          XMLDTDElement = require2("./XMLDTDElement");
          XMLDTDNotation = require2("./XMLDTDNotation");
          XMLNamedNodeMap = require2("./XMLNamedNodeMap");
          module2.exports = function(superClass) {
            extend2(XMLDocType, superClass);
            function XMLDocType(parent, pubID, sysID) {
              var child, i3, len, ref2, ref1, ref22;
              XMLDocType.__super__.constructor.call(this, parent);
              this.type = NodeType.DocType;
              if (parent.children) {
                ref2 = parent.children;
                for (i3 = 0, len = ref2.length; i3 < len; i3++) {
                  child = ref2[i3];
                  if (child.type === NodeType.Element) {
                    this.name = child.name;
                    break;
                  }
                }
              }
              this.documentObject = parent;
              if (isObject2(pubID)) {
                ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
              }
              if (sysID == null) {
                ref22 = [pubID, sysID], sysID = ref22[0], pubID = ref22[1];
              }
              if (pubID != null) {
                this.pubID = this.stringify.dtdPubID(pubID);
              }
              if (sysID != null) {
                this.sysID = this.stringify.dtdSysID(sysID);
              }
            }
            Object.defineProperty(XMLDocType.prototype, "entities", { get: function() {
              var child, i3, len, nodes, ref2;
              nodes = {};
              ref2 = this.children;
              for (i3 = 0, len = ref2.length; i3 < len; i3++) {
                child = ref2[i3];
                if (child.type === NodeType.EntityDeclaration && !child.pe) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            } });
            Object.defineProperty(XMLDocType.prototype, "notations", { get: function() {
              var child, i3, len, nodes, ref2;
              nodes = {};
              ref2 = this.children;
              for (i3 = 0, len = ref2.length; i3 < len; i3++) {
                child = ref2[i3];
                if (child.type === NodeType.NotationDeclaration) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            } });
            Object.defineProperty(XMLDocType.prototype, "publicId", { get: function() {
              return this.pubID;
            } });
            Object.defineProperty(XMLDocType.prototype, "systemId", { get: function() {
              return this.sysID;
            } });
            Object.defineProperty(XMLDocType.prototype, "internalSubset", { get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            } });
            XMLDocType.prototype.element = function(name2, value) {
              var child;
              child = new XMLDTDElement(this, name2, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              var child;
              child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.entity = function(name2, value) {
              var child;
              child = new XMLDTDEntity(this, false, name2, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.pEntity = function(name2, value) {
              var child;
              child = new XMLDTDEntity(this, true, name2, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.notation = function(name2, value) {
              var child;
              child = new XMLDTDNotation(this, name2, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.toString = function(options) {
              return this.options.writer.docType(this, this.options.writer.filterOptions(options));
            };
            XMLDocType.prototype.ele = function(name2, value) {
              return this.element(name2, value);
            };
            XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
            };
            XMLDocType.prototype.ent = function(name2, value) {
              return this.entity(name2, value);
            };
            XMLDocType.prototype.pent = function(name2, value) {
              return this.pEntity(name2, value);
            };
            XMLDocType.prototype.not = function(name2, value) {
              return this.notation(name2, value);
            };
            XMLDocType.prototype.up = function() {
              return this.root() || this.documentObject;
            };
            XMLDocType.prototype.isEqualNode = function(node2) {
              if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                return false;
              }
              if (node2.name !== this.name) {
                return false;
              }
              if (node2.publicId !== this.publicId) {
                return false;
              }
              if (node2.systemId !== this.systemId) {
                return false;
              }
              return true;
            };
            return XMLDocType;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./XMLDTDAttList": 439, "./XMLDTDElement": 440, "./XMLDTDEntity": 441, "./XMLDTDNotation": 442, "./XMLNamedNodeMap": 449, "./XMLNode": 450 }], 445: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isPlainObject2 = require2("./Utility").isPlainObject;
          XMLDOMImplementation = require2("./XMLDOMImplementation");
          XMLDOMConfiguration = require2("./XMLDOMConfiguration");
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          XMLStringifier = require2("./XMLStringifier");
          XMLStringWriter = require2("./XMLStringWriter");
          module2.exports = function(superClass) {
            extend2(XMLDocument, superClass);
            function XMLDocument(options) {
              XMLDocument.__super__.constructor.call(this, null);
              this.name = "#document";
              this.type = NodeType.Document;
              this.documentURI = null;
              this.domConfig = new XMLDOMConfiguration();
              options || (options = {});
              if (!options.writer) {
                options.writer = new XMLStringWriter();
              }
              this.options = options;
              this.stringify = new XMLStringifier(options);
            }
            Object.defineProperty(XMLDocument.prototype, "implementation", { value: new XMLDOMImplementation() });
            Object.defineProperty(XMLDocument.prototype, "doctype", { get: function() {
              var child, i3, len, ref2;
              ref2 = this.children;
              for (i3 = 0, len = ref2.length; i3 < len; i3++) {
                child = ref2[i3];
                if (child.type === NodeType.DocType) {
                  return child;
                }
              }
              return null;
            } });
            Object.defineProperty(XMLDocument.prototype, "documentElement", { get: function() {
              return this.rootObject || null;
            } });
            Object.defineProperty(XMLDocument.prototype, "inputEncoding", { get: function() {
              return null;
            } });
            Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", { get: function() {
              return false;
            } });
            Object.defineProperty(XMLDocument.prototype, "xmlEncoding", { get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].encoding;
              } else {
                return null;
              }
            } });
            Object.defineProperty(XMLDocument.prototype, "xmlStandalone", { get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].standalone === "yes";
              } else {
                return false;
              }
            } });
            Object.defineProperty(XMLDocument.prototype, "xmlVersion", { get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].version;
              } else {
                return "1.0";
              }
            } });
            Object.defineProperty(XMLDocument.prototype, "URL", { get: function() {
              return this.documentURI;
            } });
            Object.defineProperty(XMLDocument.prototype, "origin", { get: function() {
              return null;
            } });
            Object.defineProperty(XMLDocument.prototype, "compatMode", { get: function() {
              return null;
            } });
            Object.defineProperty(XMLDocument.prototype, "characterSet", { get: function() {
              return null;
            } });
            Object.defineProperty(XMLDocument.prototype, "contentType", { get: function() {
              return null;
            } });
            XMLDocument.prototype.end = function(writer) {
              var writerOptions;
              writerOptions = {};
              if (!writer) {
                writer = this.options.writer;
              } else if (isPlainObject2(writer)) {
                writerOptions = writer;
                writer = this.options.writer;
              }
              return writer.document(this, writer.filterOptions(writerOptions));
            };
            XMLDocument.prototype.toString = function(options) {
              return this.options.writer.document(this, this.options.writer.filterOptions(options));
            };
            XMLDocument.prototype.createElement = function(tagName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createDocumentFragment = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createTextNode = function(data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createComment = function(data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createCDATASection = function(data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createProcessingInstruction = function(target, data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createAttribute = function(name2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createEntityReference = function(name2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementsByTagName = function(tagname) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.importNode = function(importedNode, deep) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementById = function(elementId) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.adoptNode = function(source) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.normalizeDocument = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.renameNode = function(node2, namespaceURI, qualifiedName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementsByClassName = function(classNames) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createEvent = function(eventInterface) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createRange = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            return XMLDocument;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./XMLDOMConfiguration": 435, "./XMLDOMImplementation": 437, "./XMLNode": 450, "./XMLStringWriter": 455, "./XMLStringifier": 456 }], 446: [function(require2, module2, exports2) {
        (function() {
          var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction2, isObject2, isPlainObject2, ref2, hasProp = {}.hasOwnProperty;
          ref2 = require2("./Utility"), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, isPlainObject2 = ref2.isPlainObject, getValue = ref2.getValue;
          NodeType = require2("./NodeType");
          XMLDocument = require2("./XMLDocument");
          XMLElement = require2("./XMLElement");
          XMLCData = require2("./XMLCData");
          XMLComment = require2("./XMLComment");
          XMLRaw = require2("./XMLRaw");
          XMLText = require2("./XMLText");
          XMLProcessingInstruction = require2("./XMLProcessingInstruction");
          XMLDeclaration = require2("./XMLDeclaration");
          XMLDocType = require2("./XMLDocType");
          XMLDTDAttList = require2("./XMLDTDAttList");
          XMLDTDEntity = require2("./XMLDTDEntity");
          XMLDTDElement = require2("./XMLDTDElement");
          XMLDTDNotation = require2("./XMLDTDNotation");
          XMLAttribute = require2("./XMLAttribute");
          XMLStringifier = require2("./XMLStringifier");
          XMLStringWriter = require2("./XMLStringWriter");
          WriterState = require2("./WriterState");
          module2.exports = function() {
            function XMLDocumentCB(options, onData, onEnd) {
              var writerOptions;
              this.name = "?xml";
              this.type = NodeType.Document;
              options || (options = {});
              writerOptions = {};
              if (!options.writer) {
                options.writer = new XMLStringWriter();
              } else if (isPlainObject2(options.writer)) {
                writerOptions = options.writer;
                options.writer = new XMLStringWriter();
              }
              this.options = options;
              this.writer = options.writer;
              this.writerOptions = this.writer.filterOptions(writerOptions);
              this.stringify = new XMLStringifier(options);
              this.onDataCallback = onData || function() {
              };
              this.onEndCallback = onEnd || function() {
              };
              this.currentNode = null;
              this.currentLevel = -1;
              this.openTags = {};
              this.documentStarted = false;
              this.documentCompleted = false;
              this.root = null;
            }
            XMLDocumentCB.prototype.createChildNode = function(node2) {
              var att, attName, attributes, child, i3, len, ref1, ref22;
              switch (node2.type) {
                case NodeType.CData:
                  this.cdata(node2.value);
                  break;
                case NodeType.Comment:
                  this.comment(node2.value);
                  break;
                case NodeType.Element:
                  attributes = {};
                  ref1 = node2.attribs;
                  for (attName in ref1) {
                    if (!hasProp.call(ref1, attName))
                      continue;
                    att = ref1[attName];
                    attributes[attName] = att.value;
                  }
                  this.node(node2.name, attributes);
                  break;
                case NodeType.Dummy:
                  this.dummy();
                  break;
                case NodeType.Raw:
                  this.raw(node2.value);
                  break;
                case NodeType.Text:
                  this.text(node2.value);
                  break;
                case NodeType.ProcessingInstruction:
                  this.instruction(node2.target, node2.value);
                  break;
                default:
                  throw new Error("This XML node type is not supported in a JS object: " + node2.constructor.name);
              }
              ref22 = node2.children;
              for (i3 = 0, len = ref22.length; i3 < len; i3++) {
                child = ref22[i3];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.dummy = function() {
              return this;
            };
            XMLDocumentCB.prototype.node = function(name2, attributes, text2) {
              var ref1;
              if (name2 == null) {
                throw new Error("Missing node name.");
              }
              if (this.root && this.currentLevel === -1) {
                throw new Error("Document can only have one root node. " + this.debugInfo(name2));
              }
              this.openCurrent();
              name2 = getValue(name2);
              if (attributes == null) {
                attributes = {};
              }
              attributes = getValue(attributes);
              if (!isObject2(attributes)) {
                ref1 = [attributes, text2], text2 = ref1[0], attributes = ref1[1];
              }
              this.currentNode = new XMLElement(this, name2, attributes);
              this.currentNode.children = false;
              this.currentLevel++;
              this.openTags[this.currentLevel] = this.currentNode;
              if (text2 != null) {
                this.text(text2);
              }
              return this;
            };
            XMLDocumentCB.prototype.element = function(name2, attributes, text2) {
              var child, i3, len, oldValidationFlag, ref1, root;
              if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                this.dtdElement.apply(this, arguments);
              } else {
                if (Array.isArray(name2) || isObject2(name2) || isFunction2(name2)) {
                  oldValidationFlag = this.options.noValidation;
                  this.options.noValidation = true;
                  root = new XMLDocument(this.options).element("TEMP_ROOT");
                  root.element(name2);
                  this.options.noValidation = oldValidationFlag;
                  ref1 = root.children;
                  for (i3 = 0, len = ref1.length; i3 < len; i3++) {
                    child = ref1[i3];
                    this.createChildNode(child);
                    if (child.type === NodeType.Element) {
                      this.up();
                    }
                  }
                } else {
                  this.node(name2, attributes, text2);
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.attribute = function(name2, value) {
              var attName, attValue;
              if (!this.currentNode || this.currentNode.children) {
                throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name2));
              }
              if (name2 != null) {
                name2 = getValue(name2);
              }
              if (isObject2(name2)) {
                for (attName in name2) {
                  if (!hasProp.call(name2, attName))
                    continue;
                  attValue = name2[attName];
                  this.attribute(attName, attValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                if (this.options.keepNullAttributes && value == null) {
                  this.currentNode.attribs[name2] = new XMLAttribute(this, name2, "");
                } else if (value != null) {
                  this.currentNode.attribs[name2] = new XMLAttribute(this, name2, value);
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.text = function(value) {
              var node2;
              this.openCurrent();
              node2 = new XMLText(this, value);
              this.onData(this.writer.text(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.cdata = function(value) {
              var node2;
              this.openCurrent();
              node2 = new XMLCData(this, value);
              this.onData(this.writer.cdata(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.comment = function(value) {
              var node2;
              this.openCurrent();
              node2 = new XMLComment(this, value);
              this.onData(this.writer.comment(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.raw = function(value) {
              var node2;
              this.openCurrent();
              node2 = new XMLRaw(this, value);
              this.onData(this.writer.raw(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.instruction = function(target, value) {
              var i3, insTarget, insValue, len, node2;
              this.openCurrent();
              if (target != null) {
                target = getValue(target);
              }
              if (value != null) {
                value = getValue(value);
              }
              if (Array.isArray(target)) {
                for (i3 = 0, len = target.length; i3 < len; i3++) {
                  insTarget = target[i3];
                  this.instruction(insTarget);
                }
              } else if (isObject2(target)) {
                for (insTarget in target) {
                  if (!hasProp.call(target, insTarget))
                    continue;
                  insValue = target[insTarget];
                  this.instruction(insTarget, insValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                node2 = new XMLProcessingInstruction(this, target, value);
                this.onData(this.writer.processingInstruction(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              }
              return this;
            };
            XMLDocumentCB.prototype.declaration = function(version2, encoding, standalone) {
              var node2;
              this.openCurrent();
              if (this.documentStarted) {
                throw new Error("declaration() must be the first node.");
              }
              node2 = new XMLDeclaration(this, version2, encoding, standalone);
              this.onData(this.writer.declaration(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
              this.openCurrent();
              if (root == null) {
                throw new Error("Missing root node name.");
              }
              if (this.root) {
                throw new Error("dtd() must come before the root node.");
              }
              this.currentNode = new XMLDocType(this, pubID, sysID);
              this.currentNode.rootNodeName = root;
              this.currentNode.children = false;
              this.currentLevel++;
              this.openTags[this.currentLevel] = this.currentNode;
              return this;
            };
            XMLDocumentCB.prototype.dtdElement = function(name2, value) {
              var node2;
              this.openCurrent();
              node2 = new XMLDTDElement(this, name2, value);
              this.onData(this.writer.dtdElement(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              var node2;
              this.openCurrent();
              node2 = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
              this.onData(this.writer.dtdAttList(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.entity = function(name2, value) {
              var node2;
              this.openCurrent();
              node2 = new XMLDTDEntity(this, false, name2, value);
              this.onData(this.writer.dtdEntity(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.pEntity = function(name2, value) {
              var node2;
              this.openCurrent();
              node2 = new XMLDTDEntity(this, true, name2, value);
              this.onData(this.writer.dtdEntity(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.notation = function(name2, value) {
              var node2;
              this.openCurrent();
              node2 = new XMLDTDNotation(this, name2, value);
              this.onData(this.writer.dtdNotation(node2, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.up = function() {
              if (this.currentLevel < 0) {
                throw new Error("The document node has no parent.");
              }
              if (this.currentNode) {
                if (this.currentNode.children) {
                  this.closeNode(this.currentNode);
                } else {
                  this.openNode(this.currentNode);
                }
                this.currentNode = null;
              } else {
                this.closeNode(this.openTags[this.currentLevel]);
              }
              delete this.openTags[this.currentLevel];
              this.currentLevel--;
              return this;
            };
            XMLDocumentCB.prototype.end = function() {
              while (this.currentLevel >= 0) {
                this.up();
              }
              return this.onEnd();
            };
            XMLDocumentCB.prototype.openCurrent = function() {
              if (this.currentNode) {
                this.currentNode.children = true;
                return this.openNode(this.currentNode);
              }
            };
            XMLDocumentCB.prototype.openNode = function(node2) {
              var att, chunk, name2, ref1;
              if (!node2.isOpen) {
                if (!this.root && this.currentLevel === 0 && node2.type === NodeType.Element) {
                  this.root = node2;
                }
                chunk = "";
                if (node2.type === NodeType.Element) {
                  this.writerOptions.state = WriterState.OpenTag;
                  chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "<" + node2.name;
                  ref1 = node2.attribs;
                  for (name2 in ref1) {
                    if (!hasProp.call(ref1, name2))
                      continue;
                    att = ref1[name2];
                    chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                  }
                  chunk += (node2.children ? ">" : "/>") + this.writer.endline(node2, this.writerOptions, this.currentLevel);
                  this.writerOptions.state = WriterState.InsideTag;
                } else {
                  this.writerOptions.state = WriterState.OpenTag;
                  chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node2.rootNodeName;
                  if (node2.pubID && node2.sysID) {
                    chunk += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
                  } else if (node2.sysID) {
                    chunk += ' SYSTEM "' + node2.sysID + '"';
                  }
                  if (node2.children) {
                    chunk += " [";
                    this.writerOptions.state = WriterState.InsideTag;
                  } else {
                    this.writerOptions.state = WriterState.CloseTag;
                    chunk += ">";
                  }
                  chunk += this.writer.endline(node2, this.writerOptions, this.currentLevel);
                }
                this.onData(chunk, this.currentLevel);
                return node2.isOpen = true;
              }
            };
            XMLDocumentCB.prototype.closeNode = function(node2) {
              var chunk;
              if (!node2.isClosed) {
                chunk = "";
                this.writerOptions.state = WriterState.CloseTag;
                if (node2.type === NodeType.Element) {
                  chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "</" + node2.name + ">" + this.writer.endline(node2, this.writerOptions, this.currentLevel);
                } else {
                  chunk = this.writer.indent(node2, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node2, this.writerOptions, this.currentLevel);
                }
                this.writerOptions.state = WriterState.None;
                this.onData(chunk, this.currentLevel);
                return node2.isClosed = true;
              }
            };
            XMLDocumentCB.prototype.onData = function(chunk, level) {
              this.documentStarted = true;
              return this.onDataCallback(chunk, level + 1);
            };
            XMLDocumentCB.prototype.onEnd = function() {
              this.documentCompleted = true;
              return this.onEndCallback();
            };
            XMLDocumentCB.prototype.debugInfo = function(name2) {
              if (name2 == null) {
                return "";
              } else {
                return "node: <" + name2 + ">";
              }
            };
            XMLDocumentCB.prototype.ele = function() {
              return this.element.apply(this, arguments);
            };
            XMLDocumentCB.prototype.nod = function(name2, attributes, text2) {
              return this.node(name2, attributes, text2);
            };
            XMLDocumentCB.prototype.txt = function(value) {
              return this.text(value);
            };
            XMLDocumentCB.prototype.dat = function(value) {
              return this.cdata(value);
            };
            XMLDocumentCB.prototype.com = function(value) {
              return this.comment(value);
            };
            XMLDocumentCB.prototype.ins = function(target, value) {
              return this.instruction(target, value);
            };
            XMLDocumentCB.prototype.dec = function(version2, encoding, standalone) {
              return this.declaration(version2, encoding, standalone);
            };
            XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
              return this.doctype(root, pubID, sysID);
            };
            XMLDocumentCB.prototype.e = function(name2, attributes, text2) {
              return this.element(name2, attributes, text2);
            };
            XMLDocumentCB.prototype.n = function(name2, attributes, text2) {
              return this.node(name2, attributes, text2);
            };
            XMLDocumentCB.prototype.t = function(value) {
              return this.text(value);
            };
            XMLDocumentCB.prototype.d = function(value) {
              return this.cdata(value);
            };
            XMLDocumentCB.prototype.c = function(value) {
              return this.comment(value);
            };
            XMLDocumentCB.prototype.r = function(value) {
              return this.raw(value);
            };
            XMLDocumentCB.prototype.i = function(target, value) {
              return this.instruction(target, value);
            };
            XMLDocumentCB.prototype.att = function() {
              if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                return this.attList.apply(this, arguments);
              } else {
                return this.attribute.apply(this, arguments);
              }
            };
            XMLDocumentCB.prototype.a = function() {
              if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                return this.attList.apply(this, arguments);
              } else {
                return this.attribute.apply(this, arguments);
              }
            };
            XMLDocumentCB.prototype.ent = function(name2, value) {
              return this.entity(name2, value);
            };
            XMLDocumentCB.prototype.pent = function(name2, value) {
              return this.pEntity(name2, value);
            };
            XMLDocumentCB.prototype.not = function(name2, value) {
              return this.notation(name2, value);
            };
            return XMLDocumentCB;
          }();
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./WriterState": 430, "./XMLAttribute": 431, "./XMLCData": 432, "./XMLComment": 434, "./XMLDTDAttList": 439, "./XMLDTDElement": 440, "./XMLDTDEntity": 441, "./XMLDTDNotation": 442, "./XMLDeclaration": 443, "./XMLDocType": 444, "./XMLDocument": 445, "./XMLElement": 448, "./XMLProcessingInstruction": 452, "./XMLRaw": 453, "./XMLStringWriter": 455, "./XMLStringifier": 456, "./XMLText": 457 }], 447: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module2.exports = function(superClass) {
            extend2(XMLDummy, superClass);
            function XMLDummy(parent) {
              XMLDummy.__super__.constructor.call(this, parent);
              this.type = NodeType.Dummy;
            }
            XMLDummy.prototype.clone = function() {
              return Object.create(this);
            };
            XMLDummy.prototype.toString = function(options) {
              return "";
            };
            return XMLDummy;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./XMLNode": 450 }], 448: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLAttribute, XMLNamedNodeMap, XMLNode, getValue, isFunction2, isObject2, ref2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          ref2 = require2("./Utility"), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, getValue = ref2.getValue;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          XMLAttribute = require2("./XMLAttribute");
          XMLNamedNodeMap = require2("./XMLNamedNodeMap");
          module2.exports = function(superClass) {
            extend2(XMLElement, superClass);
            function XMLElement(parent, name2, attributes) {
              var child, j2, len, ref1;
              XMLElement.__super__.constructor.call(this, parent);
              if (name2 == null) {
                throw new Error("Missing element name. " + this.debugInfo());
              }
              this.name = this.stringify.name(name2);
              this.type = NodeType.Element;
              this.attribs = {};
              this.schemaTypeInfo = null;
              if (attributes != null) {
                this.attribute(attributes);
              }
              if (parent.type === NodeType.Document) {
                this.isRoot = true;
                this.documentObject = parent;
                parent.rootObject = this;
                if (parent.children) {
                  ref1 = parent.children;
                  for (j2 = 0, len = ref1.length; j2 < len; j2++) {
                    child = ref1[j2];
                    if (child.type === NodeType.DocType) {
                      child.name = this.name;
                      break;
                    }
                  }
                }
              }
            }
            Object.defineProperty(XMLElement.prototype, "tagName", { get: function() {
              return this.name;
            } });
            Object.defineProperty(XMLElement.prototype, "namespaceURI", { get: function() {
              return "";
            } });
            Object.defineProperty(XMLElement.prototype, "prefix", { get: function() {
              return "";
            } });
            Object.defineProperty(XMLElement.prototype, "localName", { get: function() {
              return this.name;
            } });
            Object.defineProperty(XMLElement.prototype, "id", { get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            } });
            Object.defineProperty(XMLElement.prototype, "className", { get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            } });
            Object.defineProperty(XMLElement.prototype, "classList", { get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            } });
            Object.defineProperty(XMLElement.prototype, "attributes", { get: function() {
              if (!this.attributeMap || !this.attributeMap.nodes) {
                this.attributeMap = new XMLNamedNodeMap(this.attribs);
              }
              return this.attributeMap;
            } });
            XMLElement.prototype.clone = function() {
              var att, attName, clonedSelf, ref1;
              clonedSelf = Object.create(this);
              if (clonedSelf.isRoot) {
                clonedSelf.documentObject = null;
              }
              clonedSelf.attribs = {};
              ref1 = this.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                clonedSelf.attribs[attName] = att.clone();
              }
              clonedSelf.children = [];
              this.children.forEach(function(child) {
                var clonedChild;
                clonedChild = child.clone();
                clonedChild.parent = clonedSelf;
                return clonedSelf.children.push(clonedChild);
              });
              return clonedSelf;
            };
            XMLElement.prototype.attribute = function(name2, value) {
              var attName, attValue;
              if (name2 != null) {
                name2 = getValue(name2);
              }
              if (isObject2(name2)) {
                for (attName in name2) {
                  if (!hasProp.call(name2, attName))
                    continue;
                  attValue = name2[attName];
                  this.attribute(attName, attValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                if (this.options.keepNullAttributes && value == null) {
                  this.attribs[name2] = new XMLAttribute(this, name2, "");
                } else if (value != null) {
                  this.attribs[name2] = new XMLAttribute(this, name2, value);
                }
              }
              return this;
            };
            XMLElement.prototype.removeAttribute = function(name2) {
              var attName, j2, len;
              if (name2 == null) {
                throw new Error("Missing attribute name. " + this.debugInfo());
              }
              name2 = getValue(name2);
              if (Array.isArray(name2)) {
                for (j2 = 0, len = name2.length; j2 < len; j2++) {
                  attName = name2[j2];
                  delete this.attribs[attName];
                }
              } else {
                delete this.attribs[name2];
              }
              return this;
            };
            XMLElement.prototype.toString = function(options) {
              return this.options.writer.element(this, this.options.writer.filterOptions(options));
            };
            XMLElement.prototype.att = function(name2, value) {
              return this.attribute(name2, value);
            };
            XMLElement.prototype.a = function(name2, value) {
              return this.attribute(name2, value);
            };
            XMLElement.prototype.getAttribute = function(name2) {
              if (this.attribs.hasOwnProperty(name2)) {
                return this.attribs[name2].value;
              } else {
                return null;
              }
            };
            XMLElement.prototype.setAttribute = function(name2, value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getAttributeNode = function(name2) {
              if (this.attribs.hasOwnProperty(name2)) {
                return this.attribs[name2];
              } else {
                return null;
              }
            };
            XMLElement.prototype.setAttributeNode = function(newAttr) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.removeAttributeNode = function(oldAttr) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagName = function(name2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.hasAttribute = function(name2) {
              return this.attribs.hasOwnProperty(name2);
            };
            XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setIdAttribute = function(name2, isId) {
              if (this.attribs.hasOwnProperty(name2)) {
                return this.attribs[name2].isId;
              } else {
                return isId;
              }
            };
            XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagName = function(tagname) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByClassName = function(classNames) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.isEqualNode = function(node2) {
              var i3, j2, ref1;
              if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                return false;
              }
              if (node2.namespaceURI !== this.namespaceURI) {
                return false;
              }
              if (node2.prefix !== this.prefix) {
                return false;
              }
              if (node2.localName !== this.localName) {
                return false;
              }
              if (node2.attribs.length !== this.attribs.length) {
                return false;
              }
              for (i3 = j2 = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j2 <= ref1 : j2 >= ref1; i3 = 0 <= ref1 ? ++j2 : --j2) {
                if (!this.attribs[i3].isEqualNode(node2.attribs[i3])) {
                  return false;
                }
              }
              return true;
            };
            return XMLElement;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./XMLAttribute": 431, "./XMLNamedNodeMap": 449, "./XMLNode": 450 }], 449: [function(require2, module2, exports2) {
        (function() {
          module2.exports = function() {
            function XMLNamedNodeMap(nodes) {
              this.nodes = nodes;
            }
            Object.defineProperty(XMLNamedNodeMap.prototype, "length", { get: function() {
              return Object.keys(this.nodes).length || 0;
            } });
            XMLNamedNodeMap.prototype.clone = function() {
              return this.nodes = null;
            };
            XMLNamedNodeMap.prototype.getNamedItem = function(name2) {
              return this.nodes[name2];
            };
            XMLNamedNodeMap.prototype.setNamedItem = function(node2) {
              var oldNode;
              oldNode = this.nodes[node2.nodeName];
              this.nodes[node2.nodeName] = node2;
              return oldNode || null;
            };
            XMLNamedNodeMap.prototype.removeNamedItem = function(name2) {
              var oldNode;
              oldNode = this.nodes[name2];
              delete this.nodes[name2];
              return oldNode || null;
            };
            XMLNamedNodeMap.prototype.item = function(index2) {
              return this.nodes[Object.keys(this.nodes)[index2]] || null;
            };
            XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLNamedNodeMap.prototype.setNamedItemNS = function(node2) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented.");
            };
            return XMLNamedNodeMap;
          }();
        }).call(this);
      }, {}], 450: [function(require2, module2, exports2) {
        (function() {
          var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction2, isObject2, ref1, hasProp = {}.hasOwnProperty;
          ref1 = require2("./Utility"), isObject2 = ref1.isObject, isFunction2 = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
          XMLElement = null;
          XMLCData = null;
          XMLComment = null;
          XMLDeclaration = null;
          XMLDocType = null;
          XMLRaw = null;
          XMLText = null;
          XMLProcessingInstruction = null;
          XMLDummy = null;
          NodeType = null;
          XMLNodeList = null;
          DocumentPosition = null;
          module2.exports = function() {
            function XMLNode(parent1) {
              this.parent = parent1;
              if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
              }
              this.value = null;
              this.children = [];
              this.baseURI = null;
              if (!XMLElement) {
                XMLElement = require2("./XMLElement");
                XMLCData = require2("./XMLCData");
                XMLComment = require2("./XMLComment");
                XMLDeclaration = require2("./XMLDeclaration");
                XMLDocType = require2("./XMLDocType");
                XMLRaw = require2("./XMLRaw");
                XMLText = require2("./XMLText");
                XMLProcessingInstruction = require2("./XMLProcessingInstruction");
                XMLDummy = require2("./XMLDummy");
                NodeType = require2("./NodeType");
                XMLNodeList = require2("./XMLNodeList");
                require2("./XMLNamedNodeMap");
                DocumentPosition = require2("./DocumentPosition");
              }
            }
            Object.defineProperty(XMLNode.prototype, "nodeName", { get: function() {
              return this.name;
            } });
            Object.defineProperty(XMLNode.prototype, "nodeType", { get: function() {
              return this.type;
            } });
            Object.defineProperty(XMLNode.prototype, "nodeValue", { get: function() {
              return this.value;
            } });
            Object.defineProperty(XMLNode.prototype, "parentNode", { get: function() {
              return this.parent;
            } });
            Object.defineProperty(XMLNode.prototype, "childNodes", { get: function() {
              if (!this.childNodeList || !this.childNodeList.nodes) {
                this.childNodeList = new XMLNodeList(this.children);
              }
              return this.childNodeList;
            } });
            Object.defineProperty(XMLNode.prototype, "firstChild", { get: function() {
              return this.children[0] || null;
            } });
            Object.defineProperty(XMLNode.prototype, "lastChild", { get: function() {
              return this.children[this.children.length - 1] || null;
            } });
            Object.defineProperty(XMLNode.prototype, "previousSibling", { get: function() {
              var i3;
              i3 = this.parent.children.indexOf(this);
              return this.parent.children[i3 - 1] || null;
            } });
            Object.defineProperty(XMLNode.prototype, "nextSibling", { get: function() {
              var i3;
              i3 = this.parent.children.indexOf(this);
              return this.parent.children[i3 + 1] || null;
            } });
            Object.defineProperty(XMLNode.prototype, "ownerDocument", { get: function() {
              return this.document() || null;
            } });
            Object.defineProperty(XMLNode.prototype, "textContent", { get: function() {
              var child, j2, len, ref2, str;
              if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                str = "";
                ref2 = this.children;
                for (j2 = 0, len = ref2.length; j2 < len; j2++) {
                  child = ref2[j2];
                  if (child.textContent) {
                    str += child.textContent;
                  }
                }
                return str;
              } else {
                return null;
              }
            }, set: function(value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            } });
            XMLNode.prototype.setParent = function(parent) {
              var child, j2, len, ref2, results;
              this.parent = parent;
              if (parent) {
                this.options = parent.options;
                this.stringify = parent.stringify;
              }
              ref2 = this.children;
              results = [];
              for (j2 = 0, len = ref2.length; j2 < len; j2++) {
                child = ref2[j2];
                results.push(child.setParent(this));
              }
              return results;
            };
            XMLNode.prototype.element = function(name2, attributes, text2) {
              var childNode, item, j2, k2, key, lastChild, len, len1, ref2, ref3, val;
              lastChild = null;
              if (attributes === null && text2 == null) {
                ref2 = [{}, null], attributes = ref2[0], text2 = ref2[1];
              }
              if (attributes == null) {
                attributes = {};
              }
              attributes = getValue(attributes);
              if (!isObject2(attributes)) {
                ref3 = [attributes, text2], text2 = ref3[0], attributes = ref3[1];
              }
              if (name2 != null) {
                name2 = getValue(name2);
              }
              if (Array.isArray(name2)) {
                for (j2 = 0, len = name2.length; j2 < len; j2++) {
                  item = name2[j2];
                  lastChild = this.element(item);
                }
              } else if (isFunction2(name2)) {
                lastChild = this.element(name2.apply());
              } else if (isObject2(name2)) {
                for (key in name2) {
                  if (!hasProp.call(name2, key))
                    continue;
                  val = name2[key];
                  if (isFunction2(val)) {
                    val = val.apply();
                  }
                  if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                    lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                  } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                    lastChild = this.dummy();
                  } else if (isObject2(val) && isEmpty(val)) {
                    lastChild = this.element(key);
                  } else if (!this.options.keepNullNodes && val == null) {
                    lastChild = this.dummy();
                  } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                    for (k2 = 0, len1 = val.length; k2 < len1; k2++) {
                      item = val[k2];
                      childNode = {};
                      childNode[key] = item;
                      lastChild = this.element(childNode);
                    }
                  } else if (isObject2(val)) {
                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                      lastChild = this.element(val);
                    } else {
                      lastChild = this.element(key);
                      lastChild.element(val);
                    }
                  } else {
                    lastChild = this.element(key, val);
                  }
                }
              } else if (!this.options.keepNullNodes && text2 === null) {
                lastChild = this.dummy();
              } else {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name2.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.text(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name2.indexOf(this.stringify.convertCDataKey) === 0) {
                  lastChild = this.cdata(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name2.indexOf(this.stringify.convertCommentKey) === 0) {
                  lastChild = this.comment(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name2.indexOf(this.stringify.convertRawKey) === 0) {
                  lastChild = this.raw(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name2.indexOf(this.stringify.convertPIKey) === 0) {
                  lastChild = this.instruction(name2.substr(this.stringify.convertPIKey.length), text2);
                } else {
                  lastChild = this.node(name2, attributes, text2);
                }
              }
              if (lastChild == null) {
                throw new Error("Could not create any elements with: " + name2 + ". " + this.debugInfo());
              }
              return lastChild;
            };
            XMLNode.prototype.insertBefore = function(name2, attributes, text2) {
              var child, i3, newChild, refChild, removed;
              if (name2 != null ? name2.type : void 0) {
                newChild = name2;
                refChild = attributes;
                newChild.setParent(this);
                if (refChild) {
                  i3 = children.indexOf(refChild);
                  removed = children.splice(i3);
                  children.push(newChild);
                  Array.prototype.push.apply(children, removed);
                } else {
                  children.push(newChild);
                }
                return newChild;
              } else {
                if (this.isRoot) {
                  throw new Error("Cannot insert elements at root level. " + this.debugInfo(name2));
                }
                i3 = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i3);
                child = this.parent.element(name2, attributes, text2);
                Array.prototype.push.apply(this.parent.children, removed);
                return child;
              }
            };
            XMLNode.prototype.insertAfter = function(name2, attributes, text2) {
              var child, i3, removed;
              if (this.isRoot) {
                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name2));
              }
              i3 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i3 + 1);
              child = this.parent.element(name2, attributes, text2);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            };
            XMLNode.prototype.remove = function() {
              var i3;
              if (this.isRoot) {
                throw new Error("Cannot remove the root element. " + this.debugInfo());
              }
              i3 = this.parent.children.indexOf(this);
              [].splice.apply(this.parent.children, [i3, i3 - i3 + 1].concat([]));
              return this.parent;
            };
            XMLNode.prototype.node = function(name2, attributes, text2) {
              var child, ref2;
              if (name2 != null) {
                name2 = getValue(name2);
              }
              attributes || (attributes = {});
              attributes = getValue(attributes);
              if (!isObject2(attributes)) {
                ref2 = [attributes, text2], text2 = ref2[0], attributes = ref2[1];
              }
              child = new XMLElement(this, name2, attributes);
              if (text2 != null) {
                child.text(text2);
              }
              this.children.push(child);
              return child;
            };
            XMLNode.prototype.text = function(value) {
              var child;
              if (isObject2(value)) {
                this.element(value);
              }
              child = new XMLText(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.cdata = function(value) {
              var child;
              child = new XMLCData(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.comment = function(value) {
              var child;
              child = new XMLComment(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.commentBefore = function(value) {
              var i3, removed;
              i3 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i3);
              this.parent.comment(value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.commentAfter = function(value) {
              var i3, removed;
              i3 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i3 + 1);
              this.parent.comment(value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.raw = function(value) {
              var child;
              child = new XMLRaw(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.dummy = function() {
              var child;
              child = new XMLDummy(this);
              return child;
            };
            XMLNode.prototype.instruction = function(target, value) {
              var insTarget, insValue, instruction, j2, len;
              if (target != null) {
                target = getValue(target);
              }
              if (value != null) {
                value = getValue(value);
              }
              if (Array.isArray(target)) {
                for (j2 = 0, len = target.length; j2 < len; j2++) {
                  insTarget = target[j2];
                  this.instruction(insTarget);
                }
              } else if (isObject2(target)) {
                for (insTarget in target) {
                  if (!hasProp.call(target, insTarget))
                    continue;
                  insValue = target[insTarget];
                  this.instruction(insTarget, insValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                instruction = new XMLProcessingInstruction(this, target, value);
                this.children.push(instruction);
              }
              return this;
            };
            XMLNode.prototype.instructionBefore = function(target, value) {
              var i3, removed;
              i3 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i3);
              this.parent.instruction(target, value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.instructionAfter = function(target, value) {
              var i3, removed;
              i3 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i3 + 1);
              this.parent.instruction(target, value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.declaration = function(version2, encoding, standalone) {
              var doc, xmldec;
              doc = this.document();
              xmldec = new XMLDeclaration(doc, version2, encoding, standalone);
              if (doc.children.length === 0) {
                doc.children.unshift(xmldec);
              } else if (doc.children[0].type === NodeType.Declaration) {
                doc.children[0] = xmldec;
              } else {
                doc.children.unshift(xmldec);
              }
              return doc.root() || doc;
            };
            XMLNode.prototype.dtd = function(pubID, sysID) {
              var child, doc, doctype, i3, j2, k2, len, len1, ref2, ref3;
              doc = this.document();
              doctype = new XMLDocType(doc, pubID, sysID);
              ref2 = doc.children;
              for (i3 = j2 = 0, len = ref2.length; j2 < len; i3 = ++j2) {
                child = ref2[i3];
                if (child.type === NodeType.DocType) {
                  doc.children[i3] = doctype;
                  return doctype;
                }
              }
              ref3 = doc.children;
              for (i3 = k2 = 0, len1 = ref3.length; k2 < len1; i3 = ++k2) {
                child = ref3[i3];
                if (child.isRoot) {
                  doc.children.splice(i3, 0, doctype);
                  return doctype;
                }
              }
              doc.children.push(doctype);
              return doctype;
            };
            XMLNode.prototype.up = function() {
              if (this.isRoot) {
                throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
              }
              return this.parent;
            };
            XMLNode.prototype.root = function() {
              var node2;
              node2 = this;
              while (node2) {
                if (node2.type === NodeType.Document) {
                  return node2.rootObject;
                } else if (node2.isRoot) {
                  return node2;
                } else {
                  node2 = node2.parent;
                }
              }
            };
            XMLNode.prototype.document = function() {
              var node2;
              node2 = this;
              while (node2) {
                if (node2.type === NodeType.Document) {
                  return node2;
                } else {
                  node2 = node2.parent;
                }
              }
            };
            XMLNode.prototype.end = function(options) {
              return this.document().end(options);
            };
            XMLNode.prototype.prev = function() {
              var i3;
              i3 = this.parent.children.indexOf(this);
              if (i3 < 1) {
                throw new Error("Already at the first node. " + this.debugInfo());
              }
              return this.parent.children[i3 - 1];
            };
            XMLNode.prototype.next = function() {
              var i3;
              i3 = this.parent.children.indexOf(this);
              if (i3 === -1 || i3 === this.parent.children.length - 1) {
                throw new Error("Already at the last node. " + this.debugInfo());
              }
              return this.parent.children[i3 + 1];
            };
            XMLNode.prototype.importDocument = function(doc) {
              var clonedRoot;
              clonedRoot = doc.root().clone();
              clonedRoot.parent = this;
              clonedRoot.isRoot = false;
              this.children.push(clonedRoot);
              return this;
            };
            XMLNode.prototype.debugInfo = function(name2) {
              var ref2, ref3;
              name2 = name2 || this.name;
              if (name2 == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
                return "";
              } else if (name2 == null) {
                return "parent: <" + this.parent.name + ">";
              } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
                return "node: <" + name2 + ">";
              } else {
                return "node: <" + name2 + ">, parent: <" + this.parent.name + ">";
              }
            };
            XMLNode.prototype.ele = function(name2, attributes, text2) {
              return this.element(name2, attributes, text2);
            };
            XMLNode.prototype.nod = function(name2, attributes, text2) {
              return this.node(name2, attributes, text2);
            };
            XMLNode.prototype.txt = function(value) {
              return this.text(value);
            };
            XMLNode.prototype.dat = function(value) {
              return this.cdata(value);
            };
            XMLNode.prototype.com = function(value) {
              return this.comment(value);
            };
            XMLNode.prototype.ins = function(target, value) {
              return this.instruction(target, value);
            };
            XMLNode.prototype.doc = function() {
              return this.document();
            };
            XMLNode.prototype.dec = function(version2, encoding, standalone) {
              return this.declaration(version2, encoding, standalone);
            };
            XMLNode.prototype.e = function(name2, attributes, text2) {
              return this.element(name2, attributes, text2);
            };
            XMLNode.prototype.n = function(name2, attributes, text2) {
              return this.node(name2, attributes, text2);
            };
            XMLNode.prototype.t = function(value) {
              return this.text(value);
            };
            XMLNode.prototype.d = function(value) {
              return this.cdata(value);
            };
            XMLNode.prototype.c = function(value) {
              return this.comment(value);
            };
            XMLNode.prototype.r = function(value) {
              return this.raw(value);
            };
            XMLNode.prototype.i = function(target, value) {
              return this.instruction(target, value);
            };
            XMLNode.prototype.u = function() {
              return this.up();
            };
            XMLNode.prototype.importXMLBuilder = function(doc) {
              return this.importDocument(doc);
            };
            XMLNode.prototype.replaceChild = function(newChild, oldChild) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.removeChild = function(oldChild) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.appendChild = function(newChild) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.hasChildNodes = function() {
              return this.children.length !== 0;
            };
            XMLNode.prototype.cloneNode = function(deep) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.normalize = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.isSupported = function(feature, version2) {
              return true;
            };
            XMLNode.prototype.hasAttributes = function() {
              return this.attribs.length !== 0;
            };
            XMLNode.prototype.compareDocumentPosition = function(other) {
              var ref2, res;
              ref2 = this;
              if (ref2 === other) {
                return 0;
              } else if (this.document() !== other.document()) {
                res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                if (Math.random() < 0.5) {
                  res |= DocumentPosition.Preceding;
                } else {
                  res |= DocumentPosition.Following;
                }
                return res;
              } else if (ref2.isAncestor(other)) {
                return DocumentPosition.Contains | DocumentPosition.Preceding;
              } else if (ref2.isDescendant(other)) {
                return DocumentPosition.Contains | DocumentPosition.Following;
              } else if (ref2.isPreceding(other)) {
                return DocumentPosition.Preceding;
              } else {
                return DocumentPosition.Following;
              }
            };
            XMLNode.prototype.isSameNode = function(other) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.lookupPrefix = function(namespaceURI) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.lookupNamespaceURI = function(prefix) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.isEqualNode = function(node2) {
              var i3, j2, ref2;
              if (node2.nodeType !== this.nodeType) {
                return false;
              }
              if (node2.children.length !== this.children.length) {
                return false;
              }
              for (i3 = j2 = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j2 <= ref2 : j2 >= ref2; i3 = 0 <= ref2 ? ++j2 : --j2) {
                if (!this.children[i3].isEqualNode(node2.children[i3])) {
                  return false;
                }
              }
              return true;
            };
            XMLNode.prototype.getFeature = function(feature, version2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.setUserData = function(key, data, handler) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.getUserData = function(key) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.contains = function(other) {
              if (!other) {
                return false;
              }
              return other === this || this.isDescendant(other);
            };
            XMLNode.prototype.isDescendant = function(node2) {
              var child, isDescendantChild, j2, len, ref2;
              ref2 = this.children;
              for (j2 = 0, len = ref2.length; j2 < len; j2++) {
                child = ref2[j2];
                if (node2 === child) {
                  return true;
                }
                isDescendantChild = child.isDescendant(node2);
                if (isDescendantChild) {
                  return true;
                }
              }
              return false;
            };
            XMLNode.prototype.isAncestor = function(node2) {
              return node2.isDescendant(this);
            };
            XMLNode.prototype.isPreceding = function(node2) {
              var nodePos, thisPos;
              nodePos = this.treePosition(node2);
              thisPos = this.treePosition(this);
              if (nodePos === -1 || thisPos === -1) {
                return false;
              } else {
                return nodePos < thisPos;
              }
            };
            XMLNode.prototype.isFollowing = function(node2) {
              var nodePos, thisPos;
              nodePos = this.treePosition(node2);
              thisPos = this.treePosition(this);
              if (nodePos === -1 || thisPos === -1) {
                return false;
              } else {
                return nodePos > thisPos;
              }
            };
            XMLNode.prototype.treePosition = function(node2) {
              var found, pos;
              pos = 0;
              found = false;
              this.foreachTreeNode(this.document(), function(childNode) {
                pos++;
                if (!found && childNode === node2) {
                  return found = true;
                }
              });
              if (found) {
                return pos;
              } else {
                return -1;
              }
            };
            XMLNode.prototype.foreachTreeNode = function(node2, func) {
              var child, j2, len, ref2, res;
              node2 || (node2 = this.document());
              ref2 = node2.children;
              for (j2 = 0, len = ref2.length; j2 < len; j2++) {
                child = ref2[j2];
                if (res = func(child)) {
                  return res;
                } else {
                  res = this.foreachTreeNode(child, func);
                  if (res) {
                    return res;
                  }
                }
              }
            };
            return XMLNode;
          }();
        }).call(this);
      }, { "./DocumentPosition": 427, "./NodeType": 428, "./Utility": 429, "./XMLCData": 432, "./XMLComment": 434, "./XMLDeclaration": 443, "./XMLDocType": 444, "./XMLDummy": 447, "./XMLElement": 448, "./XMLNamedNodeMap": 449, "./XMLNodeList": 451, "./XMLProcessingInstruction": 452, "./XMLRaw": 453, "./XMLText": 457 }], 451: [function(require2, module2, exports2) {
        (function() {
          module2.exports = function() {
            function XMLNodeList(nodes) {
              this.nodes = nodes;
            }
            Object.defineProperty(XMLNodeList.prototype, "length", { get: function() {
              return this.nodes.length || 0;
            } });
            XMLNodeList.prototype.clone = function() {
              return this.nodes = null;
            };
            XMLNodeList.prototype.item = function(index2) {
              return this.nodes[index2] || null;
            };
            return XMLNodeList;
          }();
        }).call(this);
      }, {}], 452: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module2.exports = function(superClass) {
            extend2(XMLProcessingInstruction, superClass);
            function XMLProcessingInstruction(parent, target, value) {
              XMLProcessingInstruction.__super__.constructor.call(this, parent);
              if (target == null) {
                throw new Error("Missing instruction target. " + this.debugInfo());
              }
              this.type = NodeType.ProcessingInstruction;
              this.target = this.stringify.insTarget(target);
              this.name = this.target;
              if (value) {
                this.value = this.stringify.insValue(value);
              }
            }
            XMLProcessingInstruction.prototype.clone = function() {
              return Object.create(this);
            };
            XMLProcessingInstruction.prototype.toString = function(options) {
              return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
            };
            XMLProcessingInstruction.prototype.isEqualNode = function(node2) {
              if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node2)) {
                return false;
              }
              if (node2.target !== this.target) {
                return false;
              }
              return true;
            };
            return XMLProcessingInstruction;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 428, "./XMLCharacterData": 433 }], 453: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLNode = require2("./XMLNode");
          module2.exports = function(superClass) {
            extend2(XMLRaw, superClass);
            function XMLRaw(parent, text2) {
              XMLRaw.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing raw text. " + this.debugInfo());
              }
              this.type = NodeType.Raw;
              this.value = this.stringify.raw(text2);
            }
            XMLRaw.prototype.clone = function() {
              return Object.create(this);
            };
            XMLRaw.prototype.toString = function(options) {
              return this.options.writer.raw(this, this.options.writer.filterOptions(options));
            };
            return XMLRaw;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 428, "./XMLNode": 450 }], 454: [function(require2, module2, exports2) {
        (function() {
          var NodeType, WriterState, XMLWriterBase, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLWriterBase = require2("./XMLWriterBase");
          WriterState = require2("./WriterState");
          module2.exports = function(superClass) {
            extend2(XMLStreamWriter, superClass);
            function XMLStreamWriter(stream, options) {
              this.stream = stream;
              XMLStreamWriter.__super__.constructor.call(this, options);
            }
            XMLStreamWriter.prototype.endline = function(node2, options, level) {
              if (node2.isLastRootNode && options.state === WriterState.CloseTag) {
                return "";
              } else {
                return XMLStreamWriter.__super__.endline.call(this, node2, options, level);
              }
            };
            XMLStreamWriter.prototype.document = function(doc, options) {
              var child, i3, j2, k2, len, len1, ref2, ref1, results;
              ref2 = doc.children;
              for (i3 = j2 = 0, len = ref2.length; j2 < len; i3 = ++j2) {
                child = ref2[i3];
                child.isLastRootNode = i3 === doc.children.length - 1;
              }
              options = this.filterOptions(options);
              ref1 = doc.children;
              results = [];
              for (k2 = 0, len1 = ref1.length; k2 < len1; k2++) {
                child = ref1[k2];
                results.push(this.writeChildNode(child, options, 0));
              }
              return results;
            };
            XMLStreamWriter.prototype.attribute = function(att, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
            };
            XMLStreamWriter.prototype.cdata = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.comment = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.declaration = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.docType = function(node2, options, level) {
              var child, j2, len, ref2;
              level || (level = 0);
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              this.stream.write(this.indent(node2, options, level));
              this.stream.write("<!DOCTYPE " + node2.root().name);
              if (node2.pubID && node2.sysID) {
                this.stream.write(' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"');
              } else if (node2.sysID) {
                this.stream.write(' SYSTEM "' + node2.sysID + '"');
              }
              if (node2.children.length > 0) {
                this.stream.write(" [");
                this.stream.write(this.endline(node2, options, level));
                options.state = WriterState.InsideTag;
                ref2 = node2.children;
                for (j2 = 0, len = ref2.length; j2 < len; j2++) {
                  child = ref2[j2];
                  this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write("]");
              }
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + ">");
              this.stream.write(this.endline(node2, options, level));
              options.state = WriterState.None;
              return this.closeNode(node2, options, level);
            };
            XMLStreamWriter.prototype.element = function(node2, options, level) {
              var att, child, childNodeCount, firstChildNode, j2, len, name2, ref2, ref1;
              level || (level = 0);
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              this.stream.write(this.indent(node2, options, level) + "<" + node2.name);
              ref2 = node2.attribs;
              for (name2 in ref2) {
                if (!hasProp.call(ref2, name2))
                  continue;
                att = ref2[name2];
                this.attribute(att, options, level);
              }
              childNodeCount = node2.children.length;
              firstChildNode = childNodeCount === 0 ? null : node2.children[0];
              if (childNodeCount === 0 || node2.children.every(function(e2) {
                return (e2.type === NodeType.Text || e2.type === NodeType.Raw) && e2.value === "";
              })) {
                if (options.allowEmpty) {
                  this.stream.write(">");
                  options.state = WriterState.CloseTag;
                  this.stream.write("</" + node2.name + ">");
                } else {
                  options.state = WriterState.CloseTag;
                  this.stream.write(options.spaceBeforeSlash + "/>");
                }
              } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                this.stream.write(">");
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                options.state = WriterState.CloseTag;
                this.stream.write("</" + node2.name + ">");
              } else {
                this.stream.write(">" + this.endline(node2, options, level));
                options.state = WriterState.InsideTag;
                ref1 = node2.children;
                for (j2 = 0, len = ref1.length; j2 < len; j2++) {
                  child = ref1[j2];
                  this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(this.indent(node2, options, level) + "</" + node2.name + ">");
              }
              this.stream.write(this.endline(node2, options, level));
              options.state = WriterState.None;
              return this.closeNode(node2, options, level);
            };
            XMLStreamWriter.prototype.processingInstruction = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.raw = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.text = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.text.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.dtdAttList = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.dtdElement = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.dtdEntity = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node2, options, level));
            };
            XMLStreamWriter.prototype.dtdNotation = function(node2, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node2, options, level));
            };
            return XMLStreamWriter;
          }(XMLWriterBase);
        }).call(this);
      }, { "./NodeType": 428, "./WriterState": 430, "./XMLWriterBase": 458 }], 455: [function(require2, module2, exports2) {
        (function() {
          var XMLWriterBase, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLWriterBase = require2("./XMLWriterBase");
          module2.exports = function(superClass) {
            extend2(XMLStringWriter, superClass);
            function XMLStringWriter(options) {
              XMLStringWriter.__super__.constructor.call(this, options);
            }
            XMLStringWriter.prototype.document = function(doc, options) {
              var child, i3, len, r2, ref2;
              options = this.filterOptions(options);
              r2 = "";
              ref2 = doc.children;
              for (i3 = 0, len = ref2.length; i3 < len; i3++) {
                child = ref2[i3];
                r2 += this.writeChildNode(child, options, 0);
              }
              if (options.pretty && r2.slice(-options.newline.length) === options.newline) {
                r2 = r2.slice(0, -options.newline.length);
              }
              return r2;
            };
            return XMLStringWriter;
          }(XMLWriterBase);
        }).call(this);
      }, { "./XMLWriterBase": 458 }], 456: [function(require2, module2, exports2) {
        (function() {
          var bind2 = function(fn, me2) {
            return function() {
              return fn.apply(me2, arguments);
            };
          }, hasProp = {}.hasOwnProperty;
          module2.exports = function() {
            function XMLStringifier(options) {
              this.assertLegalName = bind2(this.assertLegalName, this);
              this.assertLegalChar = bind2(this.assertLegalChar, this);
              var key, ref2, value;
              options || (options = {});
              this.options = options;
              if (!this.options.version) {
                this.options.version = "1.0";
              }
              ref2 = options.stringify || {};
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this[key] = value;
              }
            }
            XMLStringifier.prototype.name = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalName("" + val || "");
            };
            XMLStringifier.prototype.text = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar(this.textEscape("" + val || ""));
            };
            XMLStringifier.prototype.cdata = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              val = val.replace("]]>", "]]]]><![CDATA[>");
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.comment = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (val.match(/--/)) {
                throw new Error("Comment text cannot contain double-hypen: " + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.raw = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return "" + val || "";
            };
            XMLStringifier.prototype.attValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar(this.attEscape(val = "" + val || ""));
            };
            XMLStringifier.prototype.insTarget = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.insValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (val.match(/\?>/)) {
                throw new Error("Invalid processing instruction value: " + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.xmlVersion = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (!val.match(/1\.[0-9]+/)) {
                throw new Error("Invalid version number: " + val);
              }
              return val;
            };
            XMLStringifier.prototype.xmlEncoding = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
                throw new Error("Invalid encoding: " + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.xmlStandalone = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              if (val) {
                return "yes";
              } else {
                return "no";
              }
            };
            XMLStringifier.prototype.dtdPubID = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdSysID = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdElementValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdAttType = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdAttDefault = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdEntityValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdNData = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.convertAttKey = "@";
            XMLStringifier.prototype.convertPIKey = "?";
            XMLStringifier.prototype.convertTextKey = "#text";
            XMLStringifier.prototype.convertCDataKey = "#cdata";
            XMLStringifier.prototype.convertCommentKey = "#comment";
            XMLStringifier.prototype.convertRawKey = "#raw";
            XMLStringifier.prototype.assertLegalChar = function(str) {
              var regex, res;
              if (this.options.noValidation) {
                return str;
              }
              regex = "";
              if (this.options.version === "1.0") {
                regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) {
                  throw new Error("Invalid character in string: " + str + " at index " + res.index);
                }
              } else if (this.options.version === "1.1") {
                regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) {
                  throw new Error("Invalid character in string: " + str + " at index " + res.index);
                }
              }
              return str;
            };
            XMLStringifier.prototype.assertLegalName = function(str) {
              var regex;
              if (this.options.noValidation) {
                return str;
              }
              this.assertLegalChar(str);
              regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
              if (!str.match(regex)) {
                throw new Error("Invalid character in name");
              }
              return str;
            };
            XMLStringifier.prototype.textEscape = function(str) {
              var ampregex;
              if (this.options.noValidation) {
                return str;
              }
              ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
              return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
            };
            XMLStringifier.prototype.attEscape = function(str) {
              var ampregex;
              if (this.options.noValidation) {
                return str;
              }
              ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
              return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
            };
            return XMLStringifier;
          }();
        }).call(this);
      }, {}], 457: [function(require2, module2, exports2) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module2.exports = function(superClass) {
            extend2(XMLText, superClass);
            function XMLText(parent, text2) {
              XMLText.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing element text. " + this.debugInfo());
              }
              this.name = "#text";
              this.type = NodeType.Text;
              this.value = this.stringify.text(text2);
            }
            Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", { get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            } });
            Object.defineProperty(XMLText.prototype, "wholeText", { get: function() {
              var next, prev, str;
              str = "";
              prev = this.previousSibling;
              while (prev) {
                str = prev.data + str;
                prev = prev.previousSibling;
              }
              str += this.data;
              next = this.nextSibling;
              while (next) {
                str = str + next.data;
                next = next.nextSibling;
              }
              return str;
            } });
            XMLText.prototype.clone = function() {
              return Object.create(this);
            };
            XMLText.prototype.toString = function(options) {
              return this.options.writer.text(this, this.options.writer.filterOptions(options));
            };
            XMLText.prototype.splitText = function(offset2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLText.prototype.replaceWholeText = function(content) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            return XMLText;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 428, "./XMLCharacterData": 433 }], 458: [function(require2, module2, exports2) {
        (function() {
          var NodeType, WriterState, assign, hasProp = {}.hasOwnProperty;
          assign = require2("./Utility").assign;
          NodeType = require2("./NodeType");
          require2("./XMLDeclaration");
          require2("./XMLDocType");
          require2("./XMLCData");
          require2("./XMLComment");
          require2("./XMLElement");
          require2("./XMLRaw");
          require2("./XMLText");
          require2("./XMLProcessingInstruction");
          require2("./XMLDummy");
          require2("./XMLDTDAttList");
          require2("./XMLDTDElement");
          require2("./XMLDTDEntity");
          require2("./XMLDTDNotation");
          WriterState = require2("./WriterState");
          module2.exports = function() {
            function XMLWriterBase(options) {
              var key, ref2, value;
              options || (options = {});
              this.options = options;
              ref2 = options.writer || {};
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this["_" + key] = this[key];
                this[key] = value;
              }
            }
            XMLWriterBase.prototype.filterOptions = function(options) {
              var filteredOptions, ref2, ref1, ref22, ref3, ref4, ref5, ref6;
              options || (options = {});
              options = assign({}, this.options, options);
              filteredOptions = { writer: this };
              filteredOptions.pretty = options.pretty || false;
              filteredOptions.allowEmpty = options.allowEmpty || false;
              filteredOptions.indent = (ref2 = options.indent) != null ? ref2 : "  ";
              filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
              filteredOptions.offset = (ref22 = options.offset) != null ? ref22 : 0;
              filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
              filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
              if (filteredOptions.spaceBeforeSlash === true) {
                filteredOptions.spaceBeforeSlash = " ";
              }
              filteredOptions.suppressPrettyCount = 0;
              filteredOptions.user = {};
              filteredOptions.state = WriterState.None;
              return filteredOptions;
            };
            XMLWriterBase.prototype.indent = function(node2, options, level) {
              var indentLevel;
              if (!options.pretty || options.suppressPrettyCount) {
                return "";
              } else if (options.pretty) {
                indentLevel = (level || 0) + options.offset + 1;
                if (indentLevel > 0) {
                  return new Array(indentLevel).join(options.indent);
                }
              }
              return "";
            };
            XMLWriterBase.prototype.endline = function(node2, options, level) {
              if (!options.pretty || options.suppressPrettyCount) {
                return "";
              } else {
                return options.newline;
              }
            };
            XMLWriterBase.prototype.attribute = function(att, options, level) {
              var r2;
              this.openAttribute(att, options, level);
              r2 = " " + att.name + '="' + att.value + '"';
              this.closeAttribute(att, options, level);
              return r2;
            };
            XMLWriterBase.prototype.cdata = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<![CDATA[";
              options.state = WriterState.InsideTag;
              r2 += node2.value;
              options.state = WriterState.CloseTag;
              r2 += "]]>" + this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.comment = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<!-- ";
              options.state = WriterState.InsideTag;
              r2 += node2.value;
              options.state = WriterState.CloseTag;
              r2 += " -->" + this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.declaration = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<?xml";
              options.state = WriterState.InsideTag;
              r2 += ' version="' + node2.version + '"';
              if (node2.encoding != null) {
                r2 += ' encoding="' + node2.encoding + '"';
              }
              if (node2.standalone != null) {
                r2 += ' standalone="' + node2.standalone + '"';
              }
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + "?>";
              r2 += this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.docType = function(node2, options, level) {
              var child, i3, len, r2, ref2;
              level || (level = 0);
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level);
              r2 += "<!DOCTYPE " + node2.root().name;
              if (node2.pubID && node2.sysID) {
                r2 += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
              } else if (node2.sysID) {
                r2 += ' SYSTEM "' + node2.sysID + '"';
              }
              if (node2.children.length > 0) {
                r2 += " [";
                r2 += this.endline(node2, options, level);
                options.state = WriterState.InsideTag;
                ref2 = node2.children;
                for (i3 = 0, len = ref2.length; i3 < len; i3++) {
                  child = ref2[i3];
                  r2 += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r2 += "]";
              }
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + ">";
              r2 += this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.element = function(node2, options, level) {
              var att, child, childNodeCount, firstChildNode, i3, j2, len, len1, name2, prettySuppressed, r2, ref2, ref1, ref22;
              level || (level = 0);
              prettySuppressed = false;
              r2 = "";
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 += this.indent(node2, options, level) + "<" + node2.name;
              ref2 = node2.attribs;
              for (name2 in ref2) {
                if (!hasProp.call(ref2, name2))
                  continue;
                att = ref2[name2];
                r2 += this.attribute(att, options, level);
              }
              childNodeCount = node2.children.length;
              firstChildNode = childNodeCount === 0 ? null : node2.children[0];
              if (childNodeCount === 0 || node2.children.every(function(e2) {
                return (e2.type === NodeType.Text || e2.type === NodeType.Raw) && e2.value === "";
              })) {
                if (options.allowEmpty) {
                  r2 += ">";
                  options.state = WriterState.CloseTag;
                  r2 += "</" + node2.name + ">" + this.endline(node2, options, level);
                } else {
                  options.state = WriterState.CloseTag;
                  r2 += options.spaceBeforeSlash + "/>" + this.endline(node2, options, level);
                }
              } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                r2 += ">";
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                r2 += this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                r2 += "</" + node2.name + ">" + this.endline(node2, options, level);
              } else {
                if (options.dontPrettyTextNodes) {
                  ref1 = node2.children;
                  for (i3 = 0, len = ref1.length; i3 < len; i3++) {
                    child = ref1[i3];
                    if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                      options.suppressPrettyCount++;
                      prettySuppressed = true;
                      break;
                    }
                  }
                }
                r2 += ">" + this.endline(node2, options, level);
                options.state = WriterState.InsideTag;
                ref22 = node2.children;
                for (j2 = 0, len1 = ref22.length; j2 < len1; j2++) {
                  child = ref22[j2];
                  r2 += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r2 += this.indent(node2, options, level) + "</" + node2.name + ">";
                if (prettySuppressed) {
                  options.suppressPrettyCount--;
                }
                r2 += this.endline(node2, options, level);
                options.state = WriterState.None;
              }
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.writeChildNode = function(node2, options, level) {
              switch (node2.type) {
                case NodeType.CData:
                  return this.cdata(node2, options, level);
                case NodeType.Comment:
                  return this.comment(node2, options, level);
                case NodeType.Element:
                  return this.element(node2, options, level);
                case NodeType.Raw:
                  return this.raw(node2, options, level);
                case NodeType.Text:
                  return this.text(node2, options, level);
                case NodeType.ProcessingInstruction:
                  return this.processingInstruction(node2, options, level);
                case NodeType.Dummy:
                  return "";
                case NodeType.Declaration:
                  return this.declaration(node2, options, level);
                case NodeType.DocType:
                  return this.docType(node2, options, level);
                case NodeType.AttributeDeclaration:
                  return this.dtdAttList(node2, options, level);
                case NodeType.ElementDeclaration:
                  return this.dtdElement(node2, options, level);
                case NodeType.EntityDeclaration:
                  return this.dtdEntity(node2, options, level);
                case NodeType.NotationDeclaration:
                  return this.dtdNotation(node2, options, level);
                default:
                  throw new Error("Unknown XML node type: " + node2.constructor.name);
              }
            };
            XMLWriterBase.prototype.processingInstruction = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<?";
              options.state = WriterState.InsideTag;
              r2 += node2.target;
              if (node2.value) {
                r2 += " " + node2.value;
              }
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + "?>";
              r2 += this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.raw = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level);
              options.state = WriterState.InsideTag;
              r2 += node2.value;
              options.state = WriterState.CloseTag;
              r2 += this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.text = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level);
              options.state = WriterState.InsideTag;
              r2 += node2.value;
              options.state = WriterState.CloseTag;
              r2 += this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.dtdAttList = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<!ATTLIST";
              options.state = WriterState.InsideTag;
              r2 += " " + node2.elementName + " " + node2.attributeName + " " + node2.attributeType;
              if (node2.defaultValueType !== "#DEFAULT") {
                r2 += " " + node2.defaultValueType;
              }
              if (node2.defaultValue) {
                r2 += ' "' + node2.defaultValue + '"';
              }
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + ">" + this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.dtdElement = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<!ELEMENT";
              options.state = WriterState.InsideTag;
              r2 += " " + node2.name + " " + node2.value;
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + ">" + this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.dtdEntity = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<!ENTITY";
              options.state = WriterState.InsideTag;
              if (node2.pe) {
                r2 += " %";
              }
              r2 += " " + node2.name;
              if (node2.value) {
                r2 += ' "' + node2.value + '"';
              } else {
                if (node2.pubID && node2.sysID) {
                  r2 += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
                } else if (node2.sysID) {
                  r2 += ' SYSTEM "' + node2.sysID + '"';
                }
                if (node2.nData) {
                  r2 += " NDATA " + node2.nData;
                }
              }
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + ">" + this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.dtdNotation = function(node2, options, level) {
              var r2;
              this.openNode(node2, options, level);
              options.state = WriterState.OpenTag;
              r2 = this.indent(node2, options, level) + "<!NOTATION";
              options.state = WriterState.InsideTag;
              r2 += " " + node2.name;
              if (node2.pubID && node2.sysID) {
                r2 += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
              } else if (node2.pubID) {
                r2 += ' PUBLIC "' + node2.pubID + '"';
              } else if (node2.sysID) {
                r2 += ' SYSTEM "' + node2.sysID + '"';
              }
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + ">" + this.endline(node2, options, level);
              options.state = WriterState.None;
              this.closeNode(node2, options, level);
              return r2;
            };
            XMLWriterBase.prototype.openNode = function(node2, options, level) {
            };
            XMLWriterBase.prototype.closeNode = function(node2, options, level) {
            };
            XMLWriterBase.prototype.openAttribute = function(att, options, level) {
            };
            XMLWriterBase.prototype.closeAttribute = function(att, options, level) {
            };
            return XMLWriterBase;
          }();
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./WriterState": 430, "./XMLCData": 432, "./XMLComment": 434, "./XMLDTDAttList": 439, "./XMLDTDElement": 440, "./XMLDTDEntity": 441, "./XMLDTDNotation": 442, "./XMLDeclaration": 443, "./XMLDocType": 444, "./XMLDummy": 447, "./XMLElement": 448, "./XMLProcessingInstruction": 452, "./XMLRaw": 453, "./XMLText": 457 }], 459: [function(require2, module2, exports2) {
        (function() {
          var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction2, ref2;
          ref2 = require2("./Utility"), assign = ref2.assign, isFunction2 = ref2.isFunction;
          XMLDOMImplementation = require2("./XMLDOMImplementation");
          XMLDocument = require2("./XMLDocument");
          XMLDocumentCB = require2("./XMLDocumentCB");
          XMLStringWriter = require2("./XMLStringWriter");
          XMLStreamWriter = require2("./XMLStreamWriter");
          NodeType = require2("./NodeType");
          WriterState = require2("./WriterState");
          module2.exports.create = function(name2, xmldec, doctype, options) {
            var doc, root;
            if (name2 == null) {
              throw new Error("Root element needs a name.");
            }
            options = assign({}, xmldec, doctype, options);
            doc = new XMLDocument(options);
            root = doc.element(name2);
            if (!options.headless) {
              doc.declaration(options);
              if (options.pubID != null || options.sysID != null) {
                doc.dtd(options);
              }
            }
            return root;
          };
          module2.exports.begin = function(options, onData, onEnd) {
            var ref1;
            if (isFunction2(options)) {
              ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
              options = {};
            }
            if (onData) {
              return new XMLDocumentCB(options, onData, onEnd);
            } else {
              return new XMLDocument(options);
            }
          };
          module2.exports.stringWriter = function(options) {
            return new XMLStringWriter(options);
          };
          module2.exports.streamWriter = function(stream, options) {
            return new XMLStreamWriter(stream, options);
          };
          module2.exports.implementation = new XMLDOMImplementation();
          module2.exports.nodeType = NodeType;
          module2.exports.writerState = WriterState;
        }).call(this);
      }, { "./NodeType": 428, "./Utility": 429, "./WriterState": 430, "./XMLDOMImplementation": 437, "./XMLDocument": 445, "./XMLDocumentCB": 446, "./XMLStreamWriter": 454, "./XMLStringWriter": 455 }], 460: [function(require2, module2, exports2) {
        module2.exports = extend2;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function extend2() {
          var target = {};
          for (var i3 = 0; i3 < arguments.length; i3++) {
            var source = arguments[i3];
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      }, {}], 461: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.fill.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/es.array.join.js");
        require2("core-js/modules/es.array.slice.js");
        var Buffer2 = require2("buffer").Buffer;
        var sha = require2("./sha");
        var md52 = require2("./md5");
        var algorithms = { sha1: sha, md5: md52 };
        var blocksize = 64;
        var zeroBuffer = Buffer2.alloc(blocksize);
        zeroBuffer.fill(0);
        function hmac(fn, key, data) {
          if (!Buffer2.isBuffer(key))
            key = Buffer2.from(key);
          if (!Buffer2.isBuffer(data))
            data = Buffer2.from(data);
          if (key.length > blocksize) {
            key = fn(key);
          } else if (key.length < blocksize) {
            key = Buffer2.concat([key, zeroBuffer], blocksize);
          }
          var ipad = Buffer2.alloc(blocksize), opad = Buffer2.alloc(blocksize);
          for (var i3 = 0; i3 < blocksize; i3++) {
            ipad[i3] = key[i3] ^ 54;
            opad[i3] = key[i3] ^ 92;
          }
          var hash3 = fn(Buffer2.concat([ipad, data]));
          return fn(Buffer2.concat([opad, hash3]));
        }
        function hash2(alg, key) {
          alg = alg || "sha1";
          var fn = algorithms[alg];
          var bufs = [];
          var length = 0;
          if (!fn)
            error("algorithm:", alg, "is not yet supported");
          return { update: function update(data) {
            if (!Buffer2.isBuffer(data))
              data = Buffer2.from(data);
            bufs.push(data);
            length += data.length;
            return this;
          }, digest: function digest(enc) {
            var buf = Buffer2.concat(bufs);
            var r2 = key ? hmac(fn, key, buf) : fn(buf);
            bufs = null;
            return enc ? r2.toString(enc) : r2;
          } };
        }
        function error() {
          var m2 = [].slice.call(arguments).join(" ");
          throw new Error([m2, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
        }
        exports2.createHash = function(alg) {
          return hash2(alg);
        };
        exports2.createHmac = function(alg, key) {
          return hash2(alg, key);
        };
        exports2.createCredentials = function() {
          error("sorry,createCredentials is not implemented yet");
        };
        exports2.createCipher = function() {
          error("sorry,createCipher is not implemented yet");
        };
        exports2.createCipheriv = function() {
          error("sorry,createCipheriv is not implemented yet");
        };
        exports2.createDecipher = function() {
          error("sorry,createDecipher is not implemented yet");
        };
        exports2.createDecipheriv = function() {
          error("sorry,createDecipheriv is not implemented yet");
        };
        exports2.createSign = function() {
          error("sorry,createSign is not implemented yet");
        };
        exports2.createVerify = function() {
          error("sorry,createVerify is not implemented yet");
        };
        exports2.createDiffieHellman = function() {
          error("sorry,createDiffieHellman is not implemented yet");
        };
        exports2.pbkdf2 = function() {
          error("sorry,pbkdf2 is not implemented yet");
        };
      }, { "./md5": 463, "./sha": 464, "buffer": 90, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.fill.js": 273, "core-js/modules/es.array.join.js": 279, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.regexp.to-string.js": 301 }], 462: [function(require2, module2, exports2) {
        require2("core-js/modules/es.array.fill.js");
        require2("core-js/modules/es.array.concat.js");
        var Buffer2 = require2("buffer").Buffer;
        var intSize = 4;
        var zeroBuffer = Buffer2.alloc(intSize);
        zeroBuffer.fill(0);
        var chrsz = 8;
        function toArray2(buf, bigEndian) {
          if (buf.length % intSize !== 0) {
            var len = buf.length + (intSize - buf.length % intSize);
            buf = Buffer2.concat([buf, zeroBuffer], len);
          }
          var arr = [];
          var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
          for (var i3 = 0; i3 < buf.length; i3 += intSize) {
            arr.push(fn.call(buf, i3));
          }
          return arr;
        }
        function toBuffer(arr, size2, bigEndian) {
          var buf = Buffer2.alloc(size2);
          var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
          for (var i3 = 0; i3 < arr.length; i3++) {
            fn.call(buf, arr[i3], i3 * 4, true);
          }
          return buf;
        }
        function hash2(buf, fn, hashSize, bigEndian) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          var arr = fn(toArray2(buf, bigEndian), buf.length * chrsz);
          return toBuffer(arr, hashSize, bigEndian);
        }
        module2.exports = { hash: hash2 };
      }, { "buffer": 90, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.fill.js": 273 }], 463: [function(require2, module2, exports2) {
        var helpers = require2("./helpers");
        function core_md5(x2, len) {
          x2[len >> 5] |= 128 << len % 32;
          x2[(len + 64 >>> 9 << 4) + 14] = len;
          var a2 = 1732584193;
          var b2 = -271733879;
          var c2 = -1732584194;
          var d2 = 271733878;
          for (var i3 = 0; i3 < x2.length; i3 += 16) {
            var olda = a2;
            var oldb = b2;
            var oldc = c2;
            var oldd = d2;
            a2 = md5_ff(a2, b2, c2, d2, x2[i3 + 0], 7, -680876936);
            d2 = md5_ff(d2, a2, b2, c2, x2[i3 + 1], 12, -389564586);
            c2 = md5_ff(c2, d2, a2, b2, x2[i3 + 2], 17, 606105819);
            b2 = md5_ff(b2, c2, d2, a2, x2[i3 + 3], 22, -1044525330);
            a2 = md5_ff(a2, b2, c2, d2, x2[i3 + 4], 7, -176418897);
            d2 = md5_ff(d2, a2, b2, c2, x2[i3 + 5], 12, 1200080426);
            c2 = md5_ff(c2, d2, a2, b2, x2[i3 + 6], 17, -1473231341);
            b2 = md5_ff(b2, c2, d2, a2, x2[i3 + 7], 22, -45705983);
            a2 = md5_ff(a2, b2, c2, d2, x2[i3 + 8], 7, 1770035416);
            d2 = md5_ff(d2, a2, b2, c2, x2[i3 + 9], 12, -1958414417);
            c2 = md5_ff(c2, d2, a2, b2, x2[i3 + 10], 17, -42063);
            b2 = md5_ff(b2, c2, d2, a2, x2[i3 + 11], 22, -1990404162);
            a2 = md5_ff(a2, b2, c2, d2, x2[i3 + 12], 7, 1804603682);
            d2 = md5_ff(d2, a2, b2, c2, x2[i3 + 13], 12, -40341101);
            c2 = md5_ff(c2, d2, a2, b2, x2[i3 + 14], 17, -1502002290);
            b2 = md5_ff(b2, c2, d2, a2, x2[i3 + 15], 22, 1236535329);
            a2 = md5_gg(a2, b2, c2, d2, x2[i3 + 1], 5, -165796510);
            d2 = md5_gg(d2, a2, b2, c2, x2[i3 + 6], 9, -1069501632);
            c2 = md5_gg(c2, d2, a2, b2, x2[i3 + 11], 14, 643717713);
            b2 = md5_gg(b2, c2, d2, a2, x2[i3 + 0], 20, -373897302);
            a2 = md5_gg(a2, b2, c2, d2, x2[i3 + 5], 5, -701558691);
            d2 = md5_gg(d2, a2, b2, c2, x2[i3 + 10], 9, 38016083);
            c2 = md5_gg(c2, d2, a2, b2, x2[i3 + 15], 14, -660478335);
            b2 = md5_gg(b2, c2, d2, a2, x2[i3 + 4], 20, -405537848);
            a2 = md5_gg(a2, b2, c2, d2, x2[i3 + 9], 5, 568446438);
            d2 = md5_gg(d2, a2, b2, c2, x2[i3 + 14], 9, -1019803690);
            c2 = md5_gg(c2, d2, a2, b2, x2[i3 + 3], 14, -187363961);
            b2 = md5_gg(b2, c2, d2, a2, x2[i3 + 8], 20, 1163531501);
            a2 = md5_gg(a2, b2, c2, d2, x2[i3 + 13], 5, -1444681467);
            d2 = md5_gg(d2, a2, b2, c2, x2[i3 + 2], 9, -51403784);
            c2 = md5_gg(c2, d2, a2, b2, x2[i3 + 7], 14, 1735328473);
            b2 = md5_gg(b2, c2, d2, a2, x2[i3 + 12], 20, -1926607734);
            a2 = md5_hh(a2, b2, c2, d2, x2[i3 + 5], 4, -378558);
            d2 = md5_hh(d2, a2, b2, c2, x2[i3 + 8], 11, -2022574463);
            c2 = md5_hh(c2, d2, a2, b2, x2[i3 + 11], 16, 1839030562);
            b2 = md5_hh(b2, c2, d2, a2, x2[i3 + 14], 23, -35309556);
            a2 = md5_hh(a2, b2, c2, d2, x2[i3 + 1], 4, -1530992060);
            d2 = md5_hh(d2, a2, b2, c2, x2[i3 + 4], 11, 1272893353);
            c2 = md5_hh(c2, d2, a2, b2, x2[i3 + 7], 16, -155497632);
            b2 = md5_hh(b2, c2, d2, a2, x2[i3 + 10], 23, -1094730640);
            a2 = md5_hh(a2, b2, c2, d2, x2[i3 + 13], 4, 681279174);
            d2 = md5_hh(d2, a2, b2, c2, x2[i3 + 0], 11, -358537222);
            c2 = md5_hh(c2, d2, a2, b2, x2[i3 + 3], 16, -722521979);
            b2 = md5_hh(b2, c2, d2, a2, x2[i3 + 6], 23, 76029189);
            a2 = md5_hh(a2, b2, c2, d2, x2[i3 + 9], 4, -640364487);
            d2 = md5_hh(d2, a2, b2, c2, x2[i3 + 12], 11, -421815835);
            c2 = md5_hh(c2, d2, a2, b2, x2[i3 + 15], 16, 530742520);
            b2 = md5_hh(b2, c2, d2, a2, x2[i3 + 2], 23, -995338651);
            a2 = md5_ii(a2, b2, c2, d2, x2[i3 + 0], 6, -198630844);
            d2 = md5_ii(d2, a2, b2, c2, x2[i3 + 7], 10, 1126891415);
            c2 = md5_ii(c2, d2, a2, b2, x2[i3 + 14], 15, -1416354905);
            b2 = md5_ii(b2, c2, d2, a2, x2[i3 + 5], 21, -57434055);
            a2 = md5_ii(a2, b2, c2, d2, x2[i3 + 12], 6, 1700485571);
            d2 = md5_ii(d2, a2, b2, c2, x2[i3 + 3], 10, -1894986606);
            c2 = md5_ii(c2, d2, a2, b2, x2[i3 + 10], 15, -1051523);
            b2 = md5_ii(b2, c2, d2, a2, x2[i3 + 1], 21, -2054922799);
            a2 = md5_ii(a2, b2, c2, d2, x2[i3 + 8], 6, 1873313359);
            d2 = md5_ii(d2, a2, b2, c2, x2[i3 + 15], 10, -30611744);
            c2 = md5_ii(c2, d2, a2, b2, x2[i3 + 6], 15, -1560198380);
            b2 = md5_ii(b2, c2, d2, a2, x2[i3 + 13], 21, 1309151649);
            a2 = md5_ii(a2, b2, c2, d2, x2[i3 + 4], 6, -145523070);
            d2 = md5_ii(d2, a2, b2, c2, x2[i3 + 11], 10, -1120210379);
            c2 = md5_ii(c2, d2, a2, b2, x2[i3 + 2], 15, 718787259);
            b2 = md5_ii(b2, c2, d2, a2, x2[i3 + 9], 21, -343485551);
            a2 = safe_add(a2, olda);
            b2 = safe_add(b2, oldb);
            c2 = safe_add(c2, oldc);
            d2 = safe_add(d2, oldd);
          }
          return Array(a2, b2, c2, d2);
        }
        function md5_cmn(q2, a2, b2, x2, s2, t2) {
          return safe_add(bit_rol(safe_add(safe_add(a2, q2), safe_add(x2, t2)), s2), b2);
        }
        function md5_ff(a2, b2, c2, d2, x2, s2, t2) {
          return md5_cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
        }
        function md5_gg(a2, b2, c2, d2, x2, s2, t2) {
          return md5_cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
        }
        function md5_hh(a2, b2, c2, d2, x2, s2, t2) {
          return md5_cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
        }
        function md5_ii(a2, b2, c2, d2, x2, s2, t2) {
          return md5_cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
        }
        function safe_add(x2, y3) {
          var lsw = (x2 & 65535) + (y3 & 65535);
          var msw = (x2 >> 16) + (y3 >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        }
        function bit_rol(num, cnt) {
          return num << cnt | num >>> 32 - cnt;
        }
        module2.exports = function md52(buf) {
          return helpers.hash(buf, core_md5, 16);
        };
      }, { "./helpers": 462 }], 464: [function(require2, module2, exports2) {
        var helpers = require2("./helpers");
        function core_sha1(x2, len) {
          x2[len >> 5] |= 128 << 24 - len % 32;
          x2[(len + 64 >> 9 << 4) + 15] = len;
          var w2 = Array(80);
          var a2 = 1732584193;
          var b2 = -271733879;
          var c2 = -1732584194;
          var d2 = 271733878;
          var e2 = -1009589776;
          for (var i3 = 0; i3 < x2.length; i3 += 16) {
            var olda = a2;
            var oldb = b2;
            var oldc = c2;
            var oldd = d2;
            var olde = e2;
            for (var j2 = 0; j2 < 80; j2++) {
              if (j2 < 16)
                w2[j2] = x2[i3 + j2];
              else
                w2[j2] = rol(w2[j2 - 3] ^ w2[j2 - 8] ^ w2[j2 - 14] ^ w2[j2 - 16], 1);
              var t2 = safe_add(safe_add(rol(a2, 5), sha1_ft(j2, b2, c2, d2)), safe_add(safe_add(e2, w2[j2]), sha1_kt(j2)));
              e2 = d2;
              d2 = c2;
              c2 = rol(b2, 30);
              b2 = a2;
              a2 = t2;
            }
            a2 = safe_add(a2, olda);
            b2 = safe_add(b2, oldb);
            c2 = safe_add(c2, oldc);
            d2 = safe_add(d2, oldd);
            e2 = safe_add(e2, olde);
          }
          return Array(a2, b2, c2, d2, e2);
        }
        function sha1_ft(t2, b2, c2, d2) {
          if (t2 < 20)
            return b2 & c2 | ~b2 & d2;
          if (t2 < 40)
            return b2 ^ c2 ^ d2;
          if (t2 < 60)
            return b2 & c2 | b2 & d2 | c2 & d2;
          return b2 ^ c2 ^ d2;
        }
        function sha1_kt(t2) {
          return t2 < 20 ? 1518500249 : t2 < 40 ? 1859775393 : t2 < 60 ? -1894007588 : -899497514;
        }
        function safe_add(x2, y3) {
          var lsw = (x2 & 65535) + (y3 & 65535);
          var msw = (x2 >> 16) + (y3 >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        }
        function rol(num, cnt) {
          return num << cnt | num >>> 32 - cnt;
        }
        module2.exports = function sha1(buf) {
          return helpers.hash(buf, core_sha1, 20, true);
        };
      }, { "./helpers": 462 }], 465: [function(require2, module2, exports2) {
        module2.exports = function() {
          return function() {
          };
        };
      }, {}], 466: [function(require2, module2, exports2) {
        (function(Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
            var _require = require2("stream"), Stream = _require.Stream;
            var _require2 = require2("../lib/common/utils/isArray"), isArray2 = _require2.isArray;
            module2.exports.string = function isString2(obj) {
              return typeof obj === "string";
            };
            module2.exports.array = isArray2;
            module2.exports.buffer = Buffer2.isBuffer;
            function isStream2(obj) {
              return obj instanceof Stream;
            }
            module2.exports.writableStream = function isWritableStream(obj) {
              return isStream2(obj) && typeof obj._write === "function" && (0, _typeof2.default)(obj._writableState) === "object";
            };
          }).call(this);
        }).call(this, { "isBuffer": require2("../node_modules/is-buffer/index.js") });
      }, { "../lib/common/utils/isArray": 63, "../node_modules/is-buffer/index.js": 366, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79, "stream": 398 }], 467: [function(require2, module2, exports2) {
        var immediate = require2("immediate");
        var process = module2.exports = {};
        process.nextTick = immediate;
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop2() {
        }
        process.on = noop2;
        process.addListener = noop2;
        process.once = noop2;
        process.off = noop2;
        process.removeListener = noop2;
        process.removeAllListeners = noop2;
        process.emit = noop2;
        process.prependListener = noop2;
        process.prependOnceListener = noop2;
        process.listeners = function(name2) {
          return [];
        };
        process.binding = function(name2) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, { "immediate": 358 }], 468: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.search.js");
            var ClientRequest = require2("./lib/request");
            var response = require2("./lib/response");
            var extend2 = require2("xtend");
            var statusCodes = require2("builtin-status-codes");
            var url = require2("url");
            var http = exports2;
            http.request = function(opts, cb) {
              if (typeof opts === "string")
                opts = url.parse(opts);
              else
                opts = extend2(opts);
              var defaultProtocol = global3.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
              var protocol2 = opts.protocol || defaultProtocol;
              var host = opts.hostname || opts.host;
              var port = opts.port;
              var path = opts.path || "/";
              if (host && host.indexOf(":") !== -1)
                host = "[" + host + "]";
              opts.url = (host ? protocol2 + "//" + host : "") + (port ? ":" + port : "") + path;
              opts.method = (opts.method || "GET").toUpperCase();
              opts.headers = opts.headers || {};
              var req = new ClientRequest(opts);
              if (cb)
                req.on("response", cb);
              return req;
            };
            http.get = function get(opts, cb) {
              var req = http.request(opts, cb);
              req.end();
              return req;
            };
            http.ClientRequest = ClientRequest;
            http.IncomingMessage = response.IncomingMessage;
            http.Agent = function() {
            };
            http.Agent.defaultMaxSockets = 4;
            http.globalAgent = new http.Agent();
            http.STATUS_CODES = statusCodes;
            http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./lib/request": 470, "./lib/response": 471, "builtin-status-codes": 91, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.search.js": 306, "url": 472, "xtend": 460 }], 469: [function(require2, module2, exports2) {
        (function(global3) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.array-buffer.constructor.js");
            require2("core-js/modules/es.array-buffer.slice.js");
            require2("core-js/modules/es.array.slice.js");
            exports2.fetch = isFunction2(global3.fetch) && isFunction2(global3.ReadableStream);
            exports2.writableStream = isFunction2(global3.WritableStream);
            exports2.abortController = isFunction2(global3.AbortController);
            exports2.blobConstructor = false;
            try {
              new Blob([new ArrayBuffer(1)]);
              exports2.blobConstructor = true;
            } catch (e2) {
            }
            var xhr;
            function getXHR() {
              if (xhr !== void 0)
                return xhr;
              if (global3.XMLHttpRequest) {
                xhr = new global3.XMLHttpRequest();
                try {
                  xhr.open("GET", global3.XDomainRequest ? "/" : "https://example.com");
                } catch (e2) {
                  xhr = null;
                }
              } else {
                xhr = null;
              }
              return xhr;
            }
            function checkTypeSupport(type2) {
              var xhr2 = getXHR();
              if (!xhr2)
                return false;
              try {
                xhr2.responseType = type2;
                return xhr2.responseType === type2;
              } catch (e2) {
              }
              return false;
            }
            var haveArrayBuffer = typeof global3.ArrayBuffer !== "undefined";
            var haveSlice = haveArrayBuffer && isFunction2(global3.ArrayBuffer.prototype.slice);
            exports2.arraybuffer = exports2.fetch || haveArrayBuffer && checkTypeSupport("arraybuffer");
            exports2.msstream = !exports2.fetch && haveSlice && checkTypeSupport("ms-stream");
            exports2.mozchunkedarraybuffer = !exports2.fetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
            exports2.overrideMimeType = exports2.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
            exports2.vbArray = isFunction2(global3.VBArray);
            function isFunction2(value) {
              return typeof value === "function";
            }
            xhr = null;
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "core-js/modules/es.array-buffer.constructor.js": 270, "core-js/modules/es.array-buffer.slice.js": 271, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295 }], 470: [function(require2, module2, exports2) {
        (function(process, global3, Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.keys.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.split.js");
            var capability = require2("./capability");
            var inherits2 = require2("inherits");
            var response = require2("./response");
            var stream = require2("readable-stream");
            var toArrayBuffer = require2("to-arraybuffer");
            var IncomingMessage = response.IncomingMessage;
            var rStates = response.readyStates;
            function decideMode(preferBinary, useFetch) {
              if (capability.fetch && useFetch) {
                return "fetch";
              } else if (capability.mozchunkedarraybuffer) {
                return "moz-chunked-arraybuffer";
              } else if (capability.msstream) {
                return "ms-stream";
              } else if (capability.arraybuffer && preferBinary) {
                return "arraybuffer";
              } else if (capability.vbArray && preferBinary) {
                return "text:vbarray";
              } else {
                return "text";
              }
            }
            var ClientRequest = module2.exports = function(opts) {
              var self2 = this;
              stream.Writable.call(self2);
              self2._opts = opts;
              self2._body = [];
              self2._headers = {};
              if (opts.auth)
                self2.setHeader("Authorization", "Basic " + new Buffer2(opts.auth).toString("base64"));
              Object.keys(opts.headers).forEach(function(name2) {
                self2.setHeader(name2, opts.headers[name2]);
              });
              var preferBinary;
              var useFetch = true;
              if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
                useFetch = false;
                preferBinary = true;
              } else if (opts.mode === "prefer-streaming") {
                preferBinary = false;
              } else if (opts.mode === "allow-wrong-content-type") {
                preferBinary = !capability.overrideMimeType;
              } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
                preferBinary = true;
              } else {
                throw new Error("Invalid value for opts.mode");
              }
              self2._mode = decideMode(preferBinary, useFetch);
              self2._fetchTimer = null;
              self2.on("finish", function() {
                self2._onFinish();
              });
            };
            inherits2(ClientRequest, stream.Writable);
            ClientRequest.prototype.setHeader = function(name2, value) {
              var self2 = this;
              var lowerName = name2.toLowerCase();
              if (unsafeHeaders.indexOf(lowerName) !== -1)
                return;
              self2._headers[lowerName] = { name: name2, value };
            };
            ClientRequest.prototype.getHeader = function(name2) {
              var header = this._headers[name2.toLowerCase()];
              if (header)
                return header.value;
              return null;
            };
            ClientRequest.prototype.removeHeader = function(name2) {
              var self2 = this;
              delete self2._headers[name2.toLowerCase()];
            };
            ClientRequest.prototype._onFinish = function() {
              var self2 = this;
              if (self2._destroyed)
                return;
              var opts = self2._opts;
              var headersObj = self2._headers;
              var body = null;
              if (opts.method !== "GET" && opts.method !== "HEAD") {
                if (capability.arraybuffer) {
                  body = toArrayBuffer(Buffer2.concat(self2._body));
                } else if (capability.blobConstructor) {
                  body = new global3.Blob(self2._body.map(function(buffer) {
                    return toArrayBuffer(buffer);
                  }), { type: (headersObj["content-type"] || {}).value || "" });
                } else {
                  body = Buffer2.concat(self2._body).toString();
                }
              }
              var headersList = [];
              Object.keys(headersObj).forEach(function(keyName) {
                var name2 = headersObj[keyName].name;
                var value = headersObj[keyName].value;
                if (Array.isArray(value)) {
                  value.forEach(function(v3) {
                    headersList.push([name2, v3]);
                  });
                } else {
                  headersList.push([name2, value]);
                }
              });
              if (self2._mode === "fetch") {
                var signal = null;
                if (capability.abortController) {
                  var controller = new AbortController();
                  signal = controller.signal;
                  self2._fetchAbortController = controller;
                  if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                    self2._fetchTimer = global3.setTimeout(function() {
                      self2.emit("requestTimeout");
                      if (self2._fetchAbortController)
                        self2._fetchAbortController.abort();
                    }, opts.requestTimeout);
                  }
                }
                global3.fetch(self2._opts.url, { method: self2._opts.method, headers: headersList, body: body || void 0, mode: "cors", credentials: opts.withCredentials ? "include" : "same-origin", signal }).then(function(response2) {
                  self2._fetchResponse = response2;
                  self2._connect();
                }, function(reason) {
                  global3.clearTimeout(self2._fetchTimer);
                  if (!self2._destroyed)
                    self2.emit("error", reason);
                });
              } else {
                var xhr = self2._xhr = new global3.XMLHttpRequest();
                try {
                  xhr.open(self2._opts.method, self2._opts.url, true);
                } catch (err2) {
                  process.nextTick(function() {
                    self2.emit("error", err2);
                  });
                  return;
                }
                if ("responseType" in xhr)
                  xhr.responseType = self2._mode.split(":")[0];
                if ("withCredentials" in xhr)
                  xhr.withCredentials = !!opts.withCredentials;
                if (self2._mode === "text" && "overrideMimeType" in xhr)
                  xhr.overrideMimeType("text/plain; charset=x-user-defined");
                if ("requestTimeout" in opts) {
                  xhr.timeout = opts.requestTimeout;
                  xhr.ontimeout = function() {
                    self2.emit("requestTimeout");
                  };
                }
                headersList.forEach(function(header) {
                  xhr.setRequestHeader(header[0], header[1]);
                });
                self2._response = null;
                xhr.onreadystatechange = function() {
                  switch (xhr.readyState) {
                    case rStates.LOADING:
                    case rStates.DONE:
                      self2._onXHRProgress();
                      break;
                  }
                };
                if (self2._mode === "moz-chunked-arraybuffer") {
                  xhr.onprogress = function() {
                    self2._onXHRProgress();
                  };
                }
                xhr.onerror = function() {
                  if (self2._destroyed)
                    return;
                  self2.emit("error", new Error("XHR error"));
                };
                try {
                  xhr.send(body);
                } catch (err2) {
                  process.nextTick(function() {
                    self2.emit("error", err2);
                  });
                  return;
                }
              }
            };
            function statusValid(xhr) {
              try {
                var status = xhr.status;
                return status !== null && status !== 0;
              } catch (e2) {
                return false;
              }
            }
            ClientRequest.prototype._onXHRProgress = function() {
              var self2 = this;
              if (!statusValid(self2._xhr) || self2._destroyed)
                return;
              if (!self2._response)
                self2._connect();
              self2._response._onXHRProgress();
            };
            ClientRequest.prototype._connect = function() {
              var self2 = this;
              if (self2._destroyed)
                return;
              self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._fetchTimer);
              self2._response.on("error", function(err2) {
                self2.emit("error", err2);
              });
              self2.emit("response", self2._response);
            };
            ClientRequest.prototype._write = function(chunk, encoding, cb) {
              var self2 = this;
              self2._body.push(chunk);
              cb();
            };
            ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
              var self2 = this;
              self2._destroyed = true;
              global3.clearTimeout(self2._fetchTimer);
              if (self2._response)
                self2._response._destroyed = true;
              if (self2._xhr)
                self2._xhr.abort();
              else if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
            };
            ClientRequest.prototype.end = function(data, encoding, cb) {
              var self2 = this;
              if (typeof data === "function") {
                cb = data;
                data = void 0;
              }
              stream.Writable.prototype.end.call(self2, data, encoding, cb);
            };
            ClientRequest.prototype.flushHeaders = function() {
            };
            ClientRequest.prototype.setTimeout = function() {
            };
            ClientRequest.prototype.setNoDelay = function() {
            };
            ClientRequest.prototype.setSocketKeepAlive = function() {
            };
            var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
      }, { "./capability": 469, "./response": 471, "_process": 467, "buffer": 90, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.map.js": 280, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.regexp.to-string.js": 301, "core-js/modules/es.string.split.js": 307, "core-js/modules/web.dom-collections.for-each.js": 339, "inherits": 364, "readable-stream": 394, "to-arraybuffer": 415 }], 471: [function(require2, module2, exports2) {
        (function(process, global3, Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.split.js");
            require2("core-js/modules/es.string.match.js");
            require2("core-js/modules/es.array.iterator.js");
            require2("core-js/modules/es.array-buffer.slice.js");
            require2("core-js/modules/es.typed-array.uint8-array.js");
            require2("core-js/modules/es.typed-array.copy-within.js");
            require2("core-js/modules/es.typed-array.every.js");
            require2("core-js/modules/es.typed-array.fill.js");
            require2("core-js/modules/es.typed-array.filter.js");
            require2("core-js/modules/es.typed-array.find.js");
            require2("core-js/modules/es.typed-array.find-index.js");
            require2("core-js/modules/es.typed-array.for-each.js");
            require2("core-js/modules/es.typed-array.includes.js");
            require2("core-js/modules/es.typed-array.index-of.js");
            require2("core-js/modules/es.typed-array.iterator.js");
            require2("core-js/modules/es.typed-array.join.js");
            require2("core-js/modules/es.typed-array.last-index-of.js");
            require2("core-js/modules/es.typed-array.map.js");
            require2("core-js/modules/es.typed-array.reduce.js");
            require2("core-js/modules/es.typed-array.reduce-right.js");
            require2("core-js/modules/es.typed-array.reverse.js");
            require2("core-js/modules/es.typed-array.set.js");
            require2("core-js/modules/es.typed-array.slice.js");
            require2("core-js/modules/es.typed-array.some.js");
            require2("core-js/modules/es.typed-array.sort.js");
            require2("core-js/modules/es.typed-array.subarray.js");
            require2("core-js/modules/es.typed-array.to-locale-string.js");
            require2("core-js/modules/es.typed-array.to-string.js");
            require2("core-js/modules/es.array.slice.js");
            var capability = require2("./capability");
            var inherits2 = require2("inherits");
            var stream = require2("readable-stream");
            var rStates = exports2.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 };
            var IncomingMessage = exports2.IncomingMessage = function(xhr, response, mode, fetchTimer) {
              var self2 = this;
              stream.Readable.call(self2);
              self2._mode = mode;
              self2.headers = {};
              self2.rawHeaders = [];
              self2.trailers = {};
              self2.rawTrailers = [];
              self2.on("end", function() {
                process.nextTick(function() {
                  self2.emit("close");
                });
              });
              if (mode === "fetch") {
                var read = function read2() {
                  reader.read().then(function(result) {
                    if (self2._destroyed)
                      return;
                    if (result.done) {
                      global3.clearTimeout(fetchTimer);
                      self2.push(null);
                      return;
                    }
                    self2.push(new Buffer2(result.value));
                    read2();
                  }).catch(function(err2) {
                    global3.clearTimeout(fetchTimer);
                    if (!self2._destroyed)
                      self2.emit("error", err2);
                  });
                };
                self2._fetchResponse = response;
                self2.url = response.url;
                self2.statusCode = response.status;
                self2.statusMessage = response.statusText;
                response.headers.forEach(function(header, key) {
                  self2.headers[key.toLowerCase()] = header;
                  self2.rawHeaders.push(key, header);
                });
                if (capability.writableStream) {
                  var writable = new WritableStream({ write: function write(chunk) {
                    return new Promise(function(resolve, reject) {
                      if (self2._destroyed) {
                        reject();
                      } else if (self2.push(new Buffer2(chunk))) {
                        resolve();
                      } else {
                        self2._resumeFetch = resolve;
                      }
                    });
                  }, close: function close() {
                    global3.clearTimeout(fetchTimer);
                    if (!self2._destroyed)
                      self2.push(null);
                  }, abort: function abort(err2) {
                    if (!self2._destroyed)
                      self2.emit("error", err2);
                  } });
                  try {
                    response.body.pipeTo(writable).catch(function(err2) {
                      global3.clearTimeout(fetchTimer);
                      if (!self2._destroyed)
                        self2.emit("error", err2);
                    });
                    return;
                  } catch (e2) {
                  }
                }
                var reader = response.body.getReader();
                read();
              } else {
                self2._xhr = xhr;
                self2._pos = 0;
                self2.url = xhr.responseURL;
                self2.statusCode = xhr.status;
                self2.statusMessage = xhr.statusText;
                var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                headers.forEach(function(header) {
                  var matches = header.match(/^([^:]+):\s*(.*)/);
                  if (matches) {
                    var key = matches[1].toLowerCase();
                    if (key === "set-cookie") {
                      if (self2.headers[key] === void 0) {
                        self2.headers[key] = [];
                      }
                      self2.headers[key].push(matches[2]);
                    } else if (self2.headers[key] !== void 0) {
                      self2.headers[key] += ", " + matches[2];
                    } else {
                      self2.headers[key] = matches[2];
                    }
                    self2.rawHeaders.push(matches[1], matches[2]);
                  }
                });
                self2._charset = "x-user-defined";
                if (!capability.overrideMimeType) {
                  var mimeType = self2.rawHeaders["mime-type"];
                  if (mimeType) {
                    var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                    if (charsetMatch) {
                      self2._charset = charsetMatch[1].toLowerCase();
                    }
                  }
                  if (!self2._charset)
                    self2._charset = "utf-8";
                }
              }
            };
            inherits2(IncomingMessage, stream.Readable);
            IncomingMessage.prototype._read = function() {
              var self2 = this;
              var resolve = self2._resumeFetch;
              if (resolve) {
                self2._resumeFetch = null;
                resolve();
              }
            };
            IncomingMessage.prototype._onXHRProgress = function() {
              var self2 = this;
              var xhr = self2._xhr;
              var response = null;
              switch (self2._mode) {
                case "text:vbarray":
                  if (xhr.readyState !== rStates.DONE)
                    break;
                  try {
                    response = new global3.VBArray(xhr.responseBody).toArray();
                  } catch (e2) {
                  }
                  if (response !== null) {
                    self2.push(new Buffer2(response));
                    break;
                  }
                case "text":
                  try {
                    response = xhr.responseText;
                  } catch (e2) {
                    self2._mode = "text:vbarray";
                    break;
                  }
                  if (response.length > self2._pos) {
                    var newData = response.substr(self2._pos);
                    if (self2._charset === "x-user-defined") {
                      var buffer = new Buffer2(newData.length);
                      for (var i3 = 0; i3 < newData.length; i3++) {
                        buffer[i3] = newData.charCodeAt(i3) & 255;
                      }
                      self2.push(buffer);
                    } else {
                      self2.push(newData, self2._charset);
                    }
                    self2._pos = response.length;
                  }
                  break;
                case "arraybuffer":
                  if (xhr.readyState !== rStates.DONE || !xhr.response)
                    break;
                  response = xhr.response;
                  self2.push(new Buffer2(new Uint8Array(response)));
                  break;
                case "moz-chunked-arraybuffer":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING || !response)
                    break;
                  self2.push(new Buffer2(new Uint8Array(response)));
                  break;
                case "ms-stream":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING)
                    break;
                  var reader = new global3.MSStreamReader();
                  reader.onprogress = function() {
                    if (reader.result.byteLength > self2._pos) {
                      self2.push(new Buffer2(new Uint8Array(reader.result.slice(self2._pos))));
                      self2._pos = reader.result.byteLength;
                    }
                  };
                  reader.onload = function() {
                    self2.push(null);
                  };
                  reader.readAsArrayBuffer(response);
                  break;
              }
              if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
                self2.push(null);
              }
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
      }, { "./capability": 469, "_process": 467, "buffer": 90, "core-js/modules/es.array-buffer.slice.js": 271, "core-js/modules/es.array.iterator.js": 278, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.match.js": 304, "core-js/modules/es.string.split.js": 307, "core-js/modules/es.typed-array.copy-within.js": 315, "core-js/modules/es.typed-array.every.js": 316, "core-js/modules/es.typed-array.fill.js": 317, "core-js/modules/es.typed-array.filter.js": 318, "core-js/modules/es.typed-array.find-index.js": 319, "core-js/modules/es.typed-array.find.js": 320, "core-js/modules/es.typed-array.for-each.js": 321, "core-js/modules/es.typed-array.includes.js": 322, "core-js/modules/es.typed-array.index-of.js": 323, "core-js/modules/es.typed-array.iterator.js": 324, "core-js/modules/es.typed-array.join.js": 325, "core-js/modules/es.typed-array.last-index-of.js": 326, "core-js/modules/es.typed-array.map.js": 327, "core-js/modules/es.typed-array.reduce-right.js": 328, "core-js/modules/es.typed-array.reduce.js": 329, "core-js/modules/es.typed-array.reverse.js": 330, "core-js/modules/es.typed-array.set.js": 331, "core-js/modules/es.typed-array.slice.js": 332, "core-js/modules/es.typed-array.some.js": 333, "core-js/modules/es.typed-array.sort.js": 334, "core-js/modules/es.typed-array.subarray.js": 335, "core-js/modules/es.typed-array.to-locale-string.js": 336, "core-js/modules/es.typed-array.to-string.js": 337, "core-js/modules/es.typed-array.uint8-array.js": 338, "core-js/modules/web.dom-collections.for-each.js": 339, "inherits": 364, "readable-stream": 394 }], 472: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.search.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.string.split.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.array.join.js");
        require2("core-js/modules/es.string.trim.js");
        require2("core-js/modules/es.string.match.js");
        require2("core-js/modules/es.array.slice.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.splice.js");
        var punycode = require2("punycode");
        var util = require2("./util");
        exports2.parse = urlParse;
        exports2.resolve = urlResolve;
        exports2.resolveObject = urlResolveObject;
        exports2.format = urlFormat;
        exports2.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = { javascript: true, "javascript:": true }, hostlessProtocol = { javascript: true, "javascript:": true }, slashedProtocol = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, querystring2 = require2("querystring");
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url)
            return url;
          var u3 = new Url();
          u3.parse(url, parseQueryString, slashesDenoteHost);
          return u3;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + (0, _typeof2.default)(url));
          }
          var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);
          var rest = url;
          rest = rest.trim();
          if (!slashesDenoteHost && url.split("#").length === 1) {
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring2.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            var hostEnd = -1;
            for (var i3 = 0; i3 < hostEndingChars.length; i3++) {
              var hec = rest.indexOf(hostEndingChars[i3]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            var auth, atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf("@");
            } else {
              atSign = rest.lastIndexOf("@", hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i3 = 0; i3 < nonHostChars.length; i3++) {
              var hec = rest.indexOf(nonHostChars[i3]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || "";
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(".");
              for (var i3 = 0, l2 = hostparts.length; i3 < l2; i3++) {
                var part = hostparts[i3];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
                    if (part.charCodeAt(j2) > 127) {
                      newpart += "x";
                    } else {
                      newpart += part[j2];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i3);
                    var notHost = hostparts.slice(i3 + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              this.hostname = punycode.toASCII(this.hostname);
            }
            var p2 = this.port ? ":" + this.port : "";
            var h2 = this.hostname || "";
            this.host = h2 + p2;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i3 = 0, l2 = autoEscape.length; i3 < l2; i3++) {
              var ae2 = autoEscape[i3];
              if (rest.indexOf(ae2) === -1)
                continue;
              var esc = encodeURIComponent(ae2);
              if (esc === ae2) {
                esc = escape(ae2);
              }
              rest = rest.split(ae2).join(esc);
            }
          }
          var hash2 = rest.indexOf("#");
          if (hash2 !== -1) {
            this.hash = rest.substr(hash2);
            rest = rest.slice(0, hash2);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring2.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }
          if (this.pathname || this.search) {
            var p2 = this.pathname || "";
            var s2 = this.search || "";
            this.path = p2 + s2;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (util.isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }
          var protocol2 = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }
          if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
            query = querystring2.stringify(this.query);
          }
          var search2 = this.search || query && "?" + query || "";
          if (protocol2 && protocol2.substr(-1) !== ":")
            protocol2 += ":";
          if (this.slashes || (!protocol2 || slashedProtocol[protocol2]) && host !== false) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/")
              pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }
          if (hash2 && hash2.charAt(0) !== "#")
            hash2 = "#" + hash2;
          if (search2 && search2.charAt(0) !== "?")
            search2 = "?" + search2;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search2 = search2.replace("#", "%23");
          return protocol2 + host + pathname + search2 + hash2;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }
          result.hash = relative.hash;
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol")
                result[rkey] = relative[rkey];
            }
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v3 = 0; v3 < keys.length; v3++) {
                var k2 = keys[v3];
                result[k2] = relative[k2];
              }
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift())) {
              }
              if (!relative.host)
                relative.host = "";
              if (!relative.hostname)
                relative.hostname = "";
              if (relPath[0] !== "")
                relPath.unshift("");
              if (relPath.length < 2)
                relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p2 = result.pathname || "";
              var s2 = result.search || "";
              result.path = p2 + s2;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "")
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "")
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }
          if (isRelAbs) {
            result.host = relative.host || relative.host === "" ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
          var up = 0;
          for (var i3 = srcPath.length; i3 >= 0; i3--) {
            last = srcPath[i3];
            if (last === ".") {
              srcPath.splice(i3, 1);
            } else if (last === "..") {
              srcPath.splice(i3, 1);
              up++;
            } else if (up) {
              srcPath.splice(i3, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }
          if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
          }
          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }
          var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
      }, { "./util": 473, "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.array.join.js": 279, "core-js/modules/es.array.slice.js": 281, "core-js/modules/es.array.splice.js": 283, "core-js/modules/es.object.keys.js": 290, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.match.js": 304, "core-js/modules/es.string.replace.js": 305, "core-js/modules/es.string.search.js": 306, "core-js/modules/es.string.split.js": 307, "core-js/modules/es.string.trim.js": 308, "punycode": 382, "querystring": 385 }], 473: [function(require2, module2, exports2) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        module2.exports = { isString: function isString2(arg) {
          return typeof arg === "string";
        }, isObject: function isObject2(arg) {
          return (0, _typeof2.default)(arg) === "object" && arg !== null;
        }, isNull: function isNull(arg) {
          return arg === null;
        }, isNullOrUndefined: function isNullOrUndefined(arg) {
          return arg == null;
        } };
      }, { "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79 }], 474: [function(require2, module2, exports2) {
        require2("core-js/modules/es.number.constructor.js");
        exports2.encodeURIComponent = function(text2) {
          try {
            return encodeURIComponent(text2);
          } catch (e2) {
            return text2;
          }
        };
        exports2.escape = require2("escape-html");
        exports2.timestamp = function timestamp(t2) {
          if (t2) {
            var v3 = t2;
            if (typeof v3 === "string") {
              v3 = Number(v3);
            }
            if (String(t2).length === 10) {
              v3 *= 1e3;
            }
            return new Date(v3);
          }
          return Math.round(Date.now() / 1e3);
        };
      }, { "core-js/modules/es.number.constructor.js": 286, "escape-html": 343 }], 475: [function(require2, module2, exports2) {
        (function(process, Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
            require2("core-js/modules/es.string.trim.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.split.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.array.concat.js");
            var util = require2("util");
            var urlutil = require2("url");
            var http = require2("http");
            var https = require2("https");
            var debug = require2("debug")("urllib");
            var ms = require2("humanize-ms");
            var REQUEST_ID = 0;
            var MAX_VALUE = Math.pow(2, 31) - 10;
            var PROTO_RE = /^https?:\/\//i;
            function getAgent(agent, defaultAgent) {
              return agent === void 0 ? defaultAgent : agent;
            }
            function parseContentType(str) {
              if (!str) {
                return "";
              }
              return str.split(";")[0].trim().toLowerCase();
            }
            function makeCallback(resolve, reject) {
              return function(err2, data, res) {
                if (err2) {
                  return reject(err2);
                }
                resolve({ data, status: res.statusCode, headers: res.headers, res });
              };
            }
            exports2.TIMEOUTS = [ms("300s"), ms("300s")];
            var TEXT_DATA_TYPES = ["json", "text"];
            exports2.request = function request(url, args, callback) {
              if (arguments.length === 2 && typeof args === "function") {
                callback = args;
                args = null;
              }
              if (typeof callback === "function") {
                return exports2.requestWithCallback(url, args, callback);
              }
              return new Promise(function(resolve, reject) {
                exports2.requestWithCallback(url, args, makeCallback(resolve, reject));
              });
            };
            exports2.requestWithCallback = function requestWithCallback(url, args, callback) {
              if (!url || typeof url !== "string" && (0, _typeof2.default)(url) !== "object") {
                var msg = util.format("expect request url to be a string or a http request options, but got %j", url);
                throw new Error(msg);
              }
              if (arguments.length === 2 && typeof args === "function") {
                callback = args;
                args = null;
              }
              args = args || {};
              if (REQUEST_ID >= MAX_VALUE) {
                REQUEST_ID = 0;
              }
              var reqId = ++REQUEST_ID;
              args.requestUrls = args.requestUrls || [];
              var reqMeta = { requestId: reqId, url, args, ctx: args.ctx };
              if (args.emitter) {
                args.emitter.emit("request", reqMeta);
              }
              args.timeout = args.timeout || exports2.TIMEOUTS;
              args.maxRedirects = args.maxRedirects || 10;
              args.streaming = args.streaming || args.customResponse;
              var requestStartTime = Date.now();
              var parsedUrl;
              if (typeof url === "string") {
                if (!PROTO_RE.test(url)) {
                  url = "https://" + url;
                }
                parsedUrl = urlutil.parse(url);
              } else {
                parsedUrl = url;
              }
              var method = (args.type || args.method || parsedUrl.method || "GET").toUpperCase();
              var port = parsedUrl.port || 80;
              var httplib = http;
              var agent = getAgent(args.agent, exports2.agent);
              var fixJSONCtlChars = args.fixJSONCtlChars;
              if (parsedUrl.protocol === "https:") {
                httplib = https;
                agent = getAgent(args.httpsAgent, exports2.httpsAgent);
                if (!parsedUrl.port) {
                  port = 443;
                }
              }
              var options = {
                host: parsedUrl.hostname || parsedUrl.host || "localhost",
                path: parsedUrl.path || "/",
                method,
                port,
                agent,
                headers: args.headers || {},
                // default is dns.lookup
                // https://github.com/nodejs/node/blob/master/lib/net.js#L986
                // custom dnslookup require node >= 4.0.0
                // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952
                lookup: args.lookup
              };
              if (Array.isArray(args.timeout)) {
                options.requestTimeout = args.timeout[args.timeout.length - 1];
              } else if (typeof args.timeout !== "undefined") {
                options.requestTimeout = args.timeout;
              }
              var auth = args.auth || parsedUrl.auth;
              if (auth) {
                options.auth = auth;
              }
              var body = args.content || args.data;
              var dataAsQueryString = method === "GET" || method === "HEAD" || args.dataAsQueryString;
              if (!args.content) {
                if (body && !(typeof body === "string" || Buffer2.isBuffer(body))) {
                  if (dataAsQueryString) {
                    body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
                  } else {
                    var contentType = options.headers["Content-Type"] || options.headers["content-type"];
                    if (!contentType) {
                      if (args.contentType === "json") {
                        contentType = "application/json";
                      } else {
                        contentType = "application/x-www-form-urlencoded";
                      }
                      options.headers["Content-Type"] = contentType;
                    }
                    if (parseContentType(contentType) === "application/json") {
                      body = JSON.stringify(body);
                    } else {
                      body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
                    }
                  }
                }
              }
              if (dataAsQueryString && body) {
                options.path += (parsedUrl.query ? "&" : "?") + body;
                body = null;
              }
              var requestSize = 0;
              if (body) {
                var length = body.length;
                if (!Buffer2.isBuffer(body)) {
                  length = Buffer2.byteLength(body);
                }
                requestSize = options.headers["Content-Length"] = length;
              }
              if (args.dataType === "json") {
                options.headers.Accept = "application/json";
              }
              if (typeof args.beforeRequest === "function") {
                args.beforeRequest(options);
              }
              var connectTimer = null;
              var responseTimer = null;
              var __err = null;
              var connected = false;
              var keepAliveSocket = false;
              var responseSize = 0;
              var statusCode = -1;
              var responseAborted = false;
              var remoteAddress = "";
              var remotePort = "";
              var timing = null;
              if (args.timing) {
                timing = {
                  // socket assigned
                  queuing: 0,
                  // dns lookup time
                  dnslookup: 0,
                  // socket connected
                  connected: 0,
                  // request sent
                  requestSent: 0,
                  // Time to first byte (TTFB)
                  waiting: 0,
                  contentDownload: 0
                };
              }
              function cancelConnectTimer() {
                if (connectTimer) {
                  clearTimeout(connectTimer);
                  connectTimer = null;
                }
              }
              function cancelResponseTimer() {
                if (responseTimer) {
                  clearTimeout(responseTimer);
                  responseTimer = null;
                }
              }
              function done(err2, data, res) {
                cancelResponseTimer();
                if (!callback) {
                  console.warn("[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!", Date(), reqId, process.pid, options.method, url);
                  if (err2) {
                    console.warn("[urllib:warn] [%s] [%s] [worker:%s] %s: %s\nstack: %s", Date(), reqId, process.pid, err2.name, err2.message, err2.stack);
                  }
                  return;
                }
                var cb = callback;
                callback = null;
                var headers = {};
                if (res) {
                  statusCode = res.statusCode;
                  headers = res.headers;
                }
                var requestUseTime = Date.now() - requestStartTime;
                if (timing) {
                  timing.contentDownload = requestUseTime;
                }
                debug("[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j", requestUseTime, responseSize, statusCode, options.method, options.host, options.path, keepAliveSocket, timing);
                var response = { status: statusCode, statusCode, headers, size: responseSize, aborted: responseAborted, rt: requestUseTime, keepAliveSocket, data, requestUrls: args.requestUrls, timing, remoteAddress, remotePort };
                if (err2) {
                  var agentStatus = "";
                  if (agent && typeof agent.getCurrentStatus === "function") {
                    agentStatus = ", agent status: " + JSON.stringify(agent.getCurrentStatus());
                  }
                  err2.message += ", " + options.method + " " + url + " " + statusCode + " (connected: " + connected + ", keepalive socket: " + keepAliveSocket + agentStatus + ")\nheaders: " + JSON.stringify(headers);
                  err2.data = data;
                  err2.path = options.path;
                  err2.status = statusCode;
                  err2.headers = headers;
                  err2.res = response;
                }
                cb(err2, data, args.streaming ? res : response);
                if (args.emitter) {
                  reqMeta.url = url;
                  reqMeta.socket = req && req.connection;
                  reqMeta.options = options;
                  reqMeta.size = requestSize;
                  args.emitter.emit("response", { requestId: reqId, error: err2, ctx: args.ctx, req: reqMeta, res: response });
                }
              }
              function handleRedirect(res) {
                var err2 = null;
                if (args.followRedirect && statuses.redirect[res.statusCode]) {
                  args._followRedirectCount = (args._followRedirectCount || 0) + 1;
                  var location2 = res.headers.location;
                  if (!location2) {
                    err2 = new Error("Got statusCode " + res.statusCode + " but cannot resolve next location from headers");
                    err2.name = "FollowRedirectError";
                  } else if (args._followRedirectCount > args.maxRedirects) {
                    err2 = new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + url);
                    err2.name = "MaxRedirectError";
                  } else {
                    var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location2) : urlutil.resolve(url, location2);
                    debug("Request#%d %s: `redirected` from %s to %s", reqId, options.path, url, newUrl);
                    cancelResponseTimer();
                    if (args.headers && args.headers.Host && PROTO_RE.test(location2)) {
                      args.headers.Host = null;
                    }
                    var cb = callback;
                    callback = null;
                    exports2.requestWithCallback(newUrl, args, cb);
                    return { redirect: true, error: null };
                  }
                }
                return { redirect: false, error: err2 };
              }
              if (args.gzip) {
                if (!options.headers["Accept-Encoding"] && !options.headers["accept-encoding"]) {
                  options.headers["Accept-Encoding"] = "gzip";
                }
              }
              function decodeContent(res, body2, cb) {
                var encoding = res.headers["content-encoding"];
                return cb(null, body2, encoding);
              }
              var writeStream = args.writeStream;
              debug("Request#%d %s %s with headers %j, options.path: %s", reqId, method, url, options.headers, options.path);
              args.requestUrls.push(url);
              function onResponse(res) {
                if (timing) {
                  timing.waiting = Date.now() - requestStartTime;
                }
                debug("Request#%d %s `req response` event emit: status %d, headers: %j", reqId, url, res.statusCode, res.headers);
                if (args.streaming) {
                  var result = handleRedirect(res);
                  if (result.redirect) {
                    res.resume();
                    return;
                  }
                  if (result.error) {
                    res.resume();
                    return done(result.error, null, res);
                  }
                  return done(null, null, res);
                }
                res.on("close", function() {
                  debug("Request#%d %s: `res close` event emit, total size %d", reqId, url, responseSize);
                });
                res.on("error", function() {
                  debug("Request#%d %s: `res error` event emit, total size %d", reqId, url, responseSize);
                });
                res.on("aborted", function() {
                  responseAborted = true;
                  debug("Request#%d %s: `res aborted` event emit, total size %d", reqId, url, responseSize);
                });
                if (writeStream) {
                  var _result = handleRedirect(res);
                  if (_result.redirect) {
                    res.resume();
                    return;
                  }
                  if (_result.error) {
                    res.resume();
                    writeStream.end();
                    return done(_result.error, null, res);
                  }
                  if (args.consumeWriteStream === false) {
                    res.on("end", done.bind(null, null, null, res));
                  } else {
                    {
                      writeStream.on("close", function() {
                        debug("Request#%d %s: writeStream close event emitted", reqId, url);
                        done(__err || null, null, res);
                      });
                    }
                  }
                  return res.pipe(writeStream);
                }
                var chunks = [];
                res.on("data", function(chunk) {
                  debug("Request#%d %s: `res data` event emit, size %d", reqId, url, chunk.length);
                  responseSize += chunk.length;
                  chunks.push(chunk);
                });
                res.on("end", function() {
                  var body2 = Buffer2.concat(chunks, responseSize);
                  debug("Request#%d %s: `res end` event emit, total size %d, _dumped: %s", reqId, url, responseSize, res._dumped);
                  if (__err) {
                    return done(__err, body2, res);
                  }
                  var result2 = handleRedirect(res);
                  if (result2.error) {
                    return done(result2.error, body2, res);
                  }
                  if (result2.redirect) {
                    return;
                  }
                  decodeContent(res, body2, function(err2, data, encoding) {
                    if (err2) {
                      return done(err2, body2, res);
                    }
                    if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {
                      try {
                        data = decodeBodyByCharset(data, res);
                      } catch (e2) {
                        debug("decodeBodyByCharset error: %s", e2);
                        return done(null, data, res);
                      }
                      if (args.dataType === "json") {
                        if (responseSize === 0) {
                          data = null;
                        } else {
                          var r2 = parseJSON(data, fixJSONCtlChars);
                          if (r2.error) {
                            err2 = r2.error;
                          } else {
                            data = r2.data;
                          }
                        }
                      }
                    }
                    if (responseAborted) {
                      debug("Request#%d %s: Remote socket was terminated before `response.end()` was called", reqId, url);
                    }
                    done(err2, data, res);
                  });
                });
              }
              var connectTimeout, responseTimeout;
              if (Array.isArray(args.timeout)) {
                connectTimeout = ms(args.timeout[0]);
                responseTimeout = ms(args.timeout[1]);
              } else {
                connectTimeout = responseTimeout = ms(args.timeout);
              }
              debug("ConnectTimeout: %d, ResponseTimeout: %d", connectTimeout, responseTimeout);
              function startConnectTimer() {
                debug("Connect timer ticking, timeout: %d", connectTimeout);
                connectTimer = setTimeout(function() {
                  connectTimer = null;
                  if (statusCode === -1) {
                    statusCode = -2;
                  }
                  var msg2 = "Connect timeout for " + connectTimeout + "ms";
                  var errorName = "ConnectionTimeoutError";
                  if (!req.socket) {
                    errorName = "SocketAssignTimeoutError";
                    msg2 += ", working sockets is full";
                  }
                  __err = new Error(msg2);
                  __err.name = errorName;
                  __err.requestId = reqId;
                  debug("ConnectTimeout: Request#%d %s %s: %s, connected: %s", reqId, url, __err.name, msg2, connected);
                  abortRequest();
                }, connectTimeout);
              }
              function startResposneTimer() {
                debug("Response timer ticking, timeout: %d", responseTimeout);
                responseTimer = setTimeout(function() {
                  responseTimer = null;
                  var msg2 = "Response timeout for " + responseTimeout + "ms";
                  var errorName = "ResponseTimeoutError";
                  __err = new Error(msg2);
                  __err.name = errorName;
                  __err.requestId = reqId;
                  debug("ResponseTimeout: Request#%d %s %s: %s, connected: %s", reqId, url, __err.name, msg2, connected);
                  abortRequest();
                }, responseTimeout);
              }
              var req;
              options.mode = args.mode ? args.mode : "";
              try {
                req = httplib.request(options, onResponse);
              } catch (err2) {
                return done(err2);
              }
              if (typeof window === "undefined") {
                startConnectTimer();
              } else {
                req.on("requestTimeout", function() {
                  if (statusCode === -1) {
                    statusCode = -2;
                  }
                  var msg2 = "Connect timeout for " + connectTimeout + "ms";
                  var errorName = "ConnectionTimeoutError";
                  __err = new Error(msg2);
                  __err.name = errorName;
                  __err.requestId = reqId;
                  abortRequest();
                });
              }
              function abortRequest() {
                debug("Request#%d %s abort, connected: %s", reqId, url, connected);
                if (!req.socket) {
                  __err.noSocket = true;
                  done(__err);
                }
                req.abort();
              }
              if (timing) {
                req.on("finish", function() {
                  timing.requestSent = Date.now() - requestStartTime;
                });
              }
              req.once("socket", function(socket) {
                if (timing) {
                  timing.queuing = Date.now() - requestStartTime;
                }
                var readyState = socket.readyState;
                if (readyState === "opening") {
                  socket.once("lookup", function(err2, ip, addressType) {
                    debug("Request#%d %s lookup: %s, %s, %s", reqId, url, err2, ip, addressType);
                    if (timing) {
                      timing.dnslookup = Date.now() - requestStartTime;
                    }
                    if (ip) {
                      remoteAddress = ip;
                    }
                  });
                  socket.once("connect", function() {
                    if (timing) {
                      timing.connected = Date.now() - requestStartTime;
                    }
                    cancelConnectTimer();
                    startResposneTimer();
                    debug("Request#%d %s new socket connected", reqId, url);
                    connected = true;
                    if (!remoteAddress) {
                      remoteAddress = socket.remoteAddress;
                    }
                    remotePort = socket.remotePort;
                  });
                  return;
                }
                debug("Request#%d %s reuse socket connected, readyState: %s", reqId, url, readyState);
                connected = true;
                keepAliveSocket = true;
                if (!remoteAddress) {
                  remoteAddress = socket.remoteAddress;
                }
                remotePort = socket.remotePort;
                cancelConnectTimer();
                startResposneTimer();
              });
              req.on("error", function(err2) {
                if (err2.name === "Error" || err2.name === "TypeError") {
                  err2.name = connected ? "ResponseError" : "RequestError";
                }
                err2.message += ' (req "error")';
                debug("Request#%d %s `req error` event emit, %s: %s", reqId, url, err2.name, err2.message);
                done(__err || err2);
              });
              if (writeStream) {
                writeStream.once("error", function(err2) {
                  err2.message += ' (writeStream "error")';
                  __err = err2;
                  debug("Request#%d %s `writeStream error` event emit, %s: %s", reqId, url, err2.name, err2.message);
                  abortRequest();
                });
              }
              if (args.stream) {
                args.stream.pipe(req);
                args.stream.once("error", function(err2) {
                  err2.message += ' (stream "error")';
                  __err = err2;
                  debug("Request#%d %s `readStream error` event emit, %s: %s", reqId, url, err2.name, err2.message);
                  abortRequest();
                });
              } else {
                req.end(body);
              }
              req.requestId = reqId;
              return req;
            };
          }).call(this);
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 78, "@babel/runtime/helpers/typeof": 79, "_process": 467, "buffer": 90, "core-js/modules/es.array.concat.js": 272, "core-js/modules/es.function.name.js": 284, "core-js/modules/es.object.to-string.js": 291, "core-js/modules/es.promise.js": 295, "core-js/modules/es.regexp.exec.js": 300, "core-js/modules/es.string.split.js": 307, "core-js/modules/es.string.trim.js": 308, "debug": 465, "http": 468, "https": 355, "humanize-ms": 356, "url": 472, "util": 419 }] }, {}, [1])(1);
    });
  })(window);
})(aliyunOssSdk);
var aliyunOssSdkExports = aliyunOssSdk.exports;
const OSS = /* @__PURE__ */ getDefaultExportFromCjs(aliyunOssSdkExports);
const token = useAccessToken();
const userInfo = useUserInfo();
function Api(serverURL) {
  this.req = axios$1.create({
    baseURL: getServerURL(serverURL),
    headers: {
      Authorization: token.value ? `Bearer ${token.value}` : null
    }
  });
  getClientIP().then((res) => this.ip = res);
  const api = this;
  this.req.interceptors.request.use(function(config) {
    config.headers.Authorization = token.value ? `Bearer ${token.value}` : null;
    config.headers["X-Real-IP"] = api.ip;
    config.headers["X-Forwarded-For"] = api.ip;
    return config;
  }, function(error) {
    console.error("REQ ERROR", error.request);
    return Promise.reject(error.request);
  });
  this.req.interceptors.response.use(function(resp) {
    var _a3;
    const curToken = token.value;
    const {
      authorization: auth
    } = resp.headers;
    const respToken = ((_a3 = auth == null ? void 0 : auth.match(/^Bearer (.*)/)) == null ? void 0 : _a3[1]) ?? null;
    if (respToken !== null && (!curToken || curToken !== respToken)) {
      token.value = respToken;
    }
    return resp.data;
  }, function(error) {
    if (error.response.status === 401) {
      token.value = "";
      userInfo.value = {};
      window.dispatchEvent(new Event("autologout"));
    }
    console.error("RESP ERROR", error.response ?? error);
    return Promise.reject(error.response);
  });
}
Api.prototype.getSTSToken = function() {
  return this.req.post("/sts");
};
Api.prototype.getCommitsInfo = function(repo, page, pageSize) {
  return this.req.post("/git/commits", {
    repo,
    page,
    pageSize
  });
};
__vitePreload(() => import("./captcha-edebc16e.js"), true ? [] : void 0);
__vitePreload(() => import("./user-9d7cd672.js"), true ? [] : void 0);
__vitePreload(() => import("./article-dd91e54a.js"), true ? [] : void 0);
__vitePreload(() => import("./comment-f81989b1.js"), true ? [] : void 0);
const serverApi = new Api("https://www.lancree.xyz/api");
let oss = ref(null);
const region = "oss-cn-wulanchabu";
const bucket = "lancree-blog-pics";
const refreshOSS = (accessKeyId, accessKeySecret, stsToken) => new OSS({
  region,
  accessKeyId,
  accessKeySecret,
  stsToken,
  bucket,
  secure: true,
  async refreshSTSToken() {
    const res = await serverApi.getSTSToken();
    const {
      data
    } = res;
    return {
      accessKeyId: data.AccessKeyId,
      accessKeySecret: data.AccessKeySecret,
      stsToken: data.SecurityToken
    };
  }
});
let stsProm = new Promise((res) => setTimeout(res, 1e3));
let timeout = null;
const refresh = () => Promise.resolve().then(() => serverApi.getSTSToken()).then((res) => {
  oss.value = refreshOSS(res.data.AccessKeyId, res.data.AccessKeySecret, res.data.SecurityToken);
  if (!timeout)
    timeout = setTimeout(refresh, Date.parse(res.data.Expiration) - Date.now() + 500);
}, (err2) => console.error("STS Token Fetching Error", err2));
{
  stsProm = refresh();
}
const bucketUrl = `${bucket}.${region}.aliyuncs.com`;
const ossGetNameByUrl = (url) => {
  var _a3;
  return ((_a3 = url.match(new RegExp(`^https?://${bucketUrl}/(.*)$`))) == null ? void 0 : _a3[1]) ?? null;
};
const ossPutImage = async (file, filename = file.name) => {
  if (!oss.value)
    await stsProm;
  const res = await oss.value.put("imgs/" + filename, file);
  return res.url.replace(/^https?/, "https");
};
const ossGetImage = async (name2) => {
  if (!oss.value)
    await stsProm;
  const res = await oss.value.get(name2);
  return res.content;
};
const ossGetImageBlobUrl = async (name2) => {
  const content = await ossGetImage(name2);
  const ext = getFileExtension(name2, false);
  const blob = new Blob([content], {
    type: "image/" + ext
  });
  return URL.createObjectURL(blob);
};
const ossSignUrl = async (name2, opts) => {
  if (!oss.value)
    await stsProm;
  return oss.value.signatureUrl(name2, opts);
};
const getFileExtension = (filename, withdot = true) => {
  var _a3;
  return ((_a3 = filename.match(withdot ? /\.[^.]+$/ : /[^.]+$/)) == null ? void 0 : _a3[0]) ?? "";
};
const parseHTMLText = (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
function passTo(val, dest, step = 1) {
  if (dest < val) {
    val = Math.max(val - step, dest);
  } else if (dest > val) {
    val = Math.min(val + step, dest);
  }
  return val;
}
const signMap = {};
new Proxy(signMap, {
  get(target, url) {
    if (!url) {
      return ref(void 0);
    }
    const now2 = Date.now() / 1e3;
    let signUrlRef = target[url];
    if (!signUrlRef || !signUrlRef.value || signUrlRef.value.expires <= now2) {
      const expires = 1800;
      const name2 = ossGetNameByUrl(url);
      if (name2 === null) {
        throw "Url Error: Not OSS Bucket url" + url;
      }
      if (!signUrlRef)
        target[url] = signUrlRef = ref({
          url: "",
          expires: now2
        });
      ossSignUrl(name2, {
        expires
      }).then((signUrlStr) => {
        const signUrl = {
          url: signUrlStr,
          expires: now2 + expires
        };
        signUrlRef.value = signUrl;
      });
    }
    return signUrlRef;
  },
  set() {
    throw "Can not manually SET this proxy.";
  },
  deleteProperty() {
    throw "Can not manually DELETE this proxy.";
  }
});
const blobUrlMap = {};
const proxy = new Proxy(blobUrlMap, {
  get(target, url) {
    if (!url || false) {
      return ref("");
    }
    let urlRef = target[url];
    if (!urlRef || !urlRef.value) {
      const name2 = ossGetNameByUrl(url);
      if (!urlRef) {
        target[url] = urlRef = ref("");
      }
      if (name2 === null) {
        fetch(url).then((res) => res.arrayBuffer()).then((res) => {
          if (!res.byteLength) {
            delete target[url];
            return;
          }
          const blob = new Blob([res]);
          const blobUrl = URL.createObjectURL(blob);
          urlRef.value = blobUrl;
        });
      } else {
        ossGetImageBlobUrl(name2).then((blobUrl) => urlRef.value = blobUrl).catch(() => delete target[url]);
      }
    }
    return urlRef;
  },
  set(target, url, value) {
    if (!url) {
      return false;
    }
    if (typeof value === "string" || typeof value === "function") {
      if (typeof value === "function") {
        value = value();
      }
      let urlRef = target[url];
      if (!urlRef) {
        target[url] = ref(value);
      } else
        urlRef.value = value;
    } else {
      target[url] = value;
    }
    return true;
  },
  deleteProperty(target, url) {
    return delete target[url];
  }
});
const useImageCache = () => proxy;
const siteData$1 = useSiteData();
const pageMap = computed(() => siteData$1.value.pageIdMap);
const usePageMap = () => pageMap;
const ARTICLE_ID_KEY = Symbol("articleId");
const ARTICLE_INFO_KEY = Symbol("articleInfo");
const _hoisted_1$1k = {
  key: 0,
  class: "wl-reaction"
};
const _hoisted_2$Y = ["textContent"];
const _hoisted_3$O = {
  class: "wl-reaction-list"
};
const _hoisted_4$D = ["onClick"];
const _hoisted_5$s = ["src", "alt"];
const _hoisted_6$n = ["textContent"];
const _hoisted_7$g = ["textContent"];
const _hoisted_8$d = ["textContent"];
const _sfc_main$1D = /* @__PURE__ */ defineComponent({
  __name: "ArticleReaction",
  setup(__props, {
    expose: __expose
  }) {
    __expose();
    const config = inject("config");
    const articleId = inject(ARTICLE_ID_KEY);
    const articleInfo = inject(ARTICLE_INFO_KEY);
    const api = inject("api");
    const msg = inject("msg");
    const token2 = useAccessToken();
    const userInfo2 = useUserInfo();
    const trends = computed(() => (articleInfo == null ? void 0 : articleInfo.value.trends) ?? {});
    const isLogin = computed(() => !!token2.value);
    const votingIndex = ref(-1);
    const locale = computed(() => config.value.locale);
    const reactionsInfo = ref([
      // ["//unpkg.com/@waline/emojis/tieba/tieba_agree.png", "点赞", "good"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_look_down.png", "好逗", "funny"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png", "哇塞", "amazing"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png", "期待", "hopeful"],
      // ["//unpkg.com/@waline/emojis/tieba/tieba_awkward.png", "摸摸", "pitiful"],
      ["(ง •̀ω•́)ง✧⃛", "点赞", "good"],
      ["╰(๑´ㅂ`๑)╯", "好逗", "funny"],
      ["∑(ʘдʘ)!!", "哇塞", "amazing"],
      ["(☆▽☆)", "期待", "hopeful"],
      ["ଘ(੭•ω•)੭( )", "摸摸", "pitiful"]
    ].map((e2) => ({
      icon: e2[0],
      desc: e2[1],
      field: e2[2]
    })));
    const active = computed(() => reactionsInfo.value.map(({
      field
    }) => {
      var _a3;
      return ((_a3 = trends.value[field]) == null ? void 0 : _a3.includes(userInfo2.value.id)) ?? false;
    }));
    let abort;
    const vote = async (index2) => {
      if (!isLogin.value) {
        msg({
          type: "warn",
          text: "登录后才能表态哦(ノ｀Д)ノ~"
        });
        return;
      }
      if (votingIndex.value === -1) {
        const userId = userInfo2.value.id;
        const field = reactionsInfo.value[index2].field;
        const ids = trends.value[field];
        const hasTrend = (ids == null ? void 0 : ids.includes(userId)) ?? false;
        votingIndex.value = index2;
        try {
          await api.toggleArticleTrend(articleId.value, userId, index2, !hasTrend);
          if (hasTrend) {
            trends.value[field].splice(ids.indexOf(userId, 1));
          } else {
            trends.value[field] ? trends.value[field].push(userId) : trends.value[field] = reactive([userId]);
          }
        } catch {
        }
        votingIndex.value = -1;
      }
    };
    onUnmounted(() => abort == null ? void 0 : abort());
    return (_ctx, _cache) => {
      return reactionsInfo.value.length ? (openBlock(), createElementBlock("div", _hoisted_1$1k, [createElementVNode("div", {
        class: "wl-reaction-title",
        textContent: toDisplayString(locale.value.reactionTitle)
      }, null, 8, _hoisted_2$Y), createElementVNode("ul", _hoisted_3$O, [(openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(reactionsInfo.value, ({
          icon,
          field,
          desc
        }, index2) => {
          var _a3;
          return openBlock(), createElementBlock("li", {
            key: index2,
            class: normalizeClass(["wl-reaction-item", {
              active: active.value[index2]
            }]),
            onClick: ($event) => vote(index2)
          }, [createElementVNode(
            "div",
            {
              class: normalizeClass(["wl-reaction-img", {
                "kaomoji-mode": !unref(isLinkHttp)(icon)
              }])
            },
            [unref(isLinkHttp)(icon) ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: icon,
              alt: desc
            }, null, 8, _hoisted_5$s)) : (openBlock(), createElementBlock("span", {
              key: 1,
              class: "kaomoji-text",
              textContent: toDisplayString(icon)
            }, null, 8, _hoisted_6$n)), votingIndex.value === index2 ? (openBlock(), createBlock(unref(LoadingIcon), {
              key: 2,
              class: "wl-reaction-loading"
            })) : (openBlock(), createElementBlock("div", {
              key: 3,
              class: "wl-reaction-votes",
              textContent: toDisplayString(((_a3 = trends.value[field]) == null ? void 0 : _a3.length) || 0)
            }, null, 8, _hoisted_7$g))],
            2
            /* CLASS */
          ), createElementVNode("div", {
            class: "wl-reaction-text",
            textContent: toDisplayString(desc)
          }, null, 8, _hoisted_8$d)], 10, _hoisted_4$D);
        }),
        128
        /* KEYED_FRAGMENT */
      ))])])) : createCommentVNode("v-if", true);
    };
  }
});
const ArticleReaction_vue_vue_type_style_index_0_lang = "";
const Reaction = /* @__PURE__ */ _export_sfc$1(_sfc_main$1D, [["__file", "ArticleReaction.vue"]]);
var e$5 = /* @__PURE__ */ new Map();
function t$5(t2) {
  var o2 = e$5.get(t2);
  o2 && o2.destroy();
}
function o$5(t2) {
  var o2 = e$5.get(t2);
  o2 && o2.update();
}
var r$7 = null;
"undefined" == typeof window ? ((r$7 = function(e2) {
  return e2;
}).destroy = function(e2) {
  return e2;
}, r$7.update = function(e2) {
  return e2;
}) : ((r$7 = function(t2, o2) {
  return t2 && Array.prototype.forEach.call(t2.length ? t2 : [t2], function(t3) {
    return function(t4) {
      if (t4 && t4.nodeName && "TEXTAREA" === t4.nodeName && !e$5.has(t4)) {
        var o3, r2 = null, n2 = window.getComputedStyle(t4), i3 = (o3 = t4.value, function() {
          a2({
            testForHeightReduction: "" === o3 || !t4.value.startsWith(o3),
            restoreTextAlign: null
          }), o3 = t4.value;
        }), l2 = (function(o4) {
          t4.removeEventListener("autosize:destroy", l2), t4.removeEventListener("autosize:update", s2), t4.removeEventListener("input", i3), window.removeEventListener("resize", s2), Object.keys(o4).forEach(function(e2) {
            return t4.style[e2] = o4[e2];
          }), e$5.delete(t4);
        }).bind(t4, {
          height: t4.style.height,
          resize: t4.style.resize,
          textAlign: t4.style.textAlign,
          overflowY: t4.style.overflowY,
          overflowX: t4.style.overflowX,
          wordWrap: t4.style.wordWrap
        });
        t4.addEventListener("autosize:destroy", l2), t4.addEventListener("autosize:update", s2), t4.addEventListener("input", i3), window.addEventListener("resize", s2), t4.style.overflowX = "hidden", t4.style.wordWrap = "break-word", e$5.set(t4, {
          destroy: l2,
          update: s2
        }), s2();
      }
      function a2(e2) {
        var o4, i4, l3 = e2.restoreTextAlign, s3 = void 0 === l3 ? null : l3, d2 = e2.testForHeightReduction, u3 = void 0 === d2 || d2, c2 = n2.overflowY;
        if (0 !== t4.scrollHeight && ("vertical" === n2.resize ? t4.style.resize = "none" : "both" === n2.resize && (t4.style.resize = "horizontal"), u3 && (o4 = function(e3) {
          for (var t5 = []; e3 && e3.parentNode && e3.parentNode instanceof Element; )
            e3.parentNode.scrollTop && t5.push([e3.parentNode, e3.parentNode.scrollTop]), e3 = e3.parentNode;
          return function() {
            return t5.forEach(function(e4) {
              var t6 = e4[0], o5 = e4[1];
              t6.style.scrollBehavior = "auto", t6.scrollTop = o5, t6.style.scrollBehavior = null;
            });
          };
        }(t4), t4.style.height = ""), i4 = "content-box" === n2.boxSizing ? t4.scrollHeight - (parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom)) : t4.scrollHeight + parseFloat(n2.borderTopWidth) + parseFloat(n2.borderBottomWidth), "none" !== n2.maxHeight && i4 > parseFloat(n2.maxHeight) ? ("hidden" === n2.overflowY && (t4.style.overflow = "scroll"), i4 = parseFloat(n2.maxHeight)) : "hidden" !== n2.overflowY && (t4.style.overflow = "hidden"), t4.style.height = i4 + "px", s3 && (t4.style.textAlign = s3), o4 && o4(), r2 !== i4 && (t4.dispatchEvent(new Event("autosize:resized", {
          bubbles: true
        })), r2 = i4), c2 !== n2.overflow && !s3)) {
          var v3 = n2.textAlign;
          "hidden" === n2.overflow && (t4.style.textAlign = "start" === v3 ? "end" : "start"), a2({
            restoreTextAlign: v3,
            testForHeightReduction: true
          });
        }
      }
      function s2() {
        a2({
          testForHeightReduction: true,
          restoreTextAlign: null
        });
      }
    }(t3);
  }), t2;
}).destroy = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], t$5), e2;
}, r$7.update = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], o$5), e2;
});
var n$7 = r$7;
const publicKey = "-----BEGIN RSA Public Key-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzoqS0WWXcXSt1dRIwMyz\nkRf7nO3I90yKRVcft+UB9UXRBR+JA/mQMFM1ITiPYcgCRfRpzRObX9WL7Ic4KRTk\nqppa7zsAnkuDbLhQdaK6AE4uyjaYu2Rf6iS8B2gkUjdi3mNM/CDQw2t2Nh0omkcI\n1ynUnpEb/G4oXMR6dSc9E7m3G9Ky/i5kBufPJj92Lx7jxN5qBzEa4aYfG1Y7uT2r\nf4QueinHeMSq659v83kIQxc6Hq9QQpwfq6W/g3oMBQOxER+jpBZyR7pmb/HH/6SL\nE96EagKSqwhReqB3TP72/Wkr1IAf3lmjyV/CNUJhqvMYvuYLr5EJhHRL678vfzV2\nawIDAQAB\n-----END RSA Public Key-----\n";
const Captcha_vue_vue_type_style_index_0_scoped_a5a46ca8_lang = "";
const _sfc_main$1C = {
  name: "GoCaptcha",
  props: {
    value: Boolean,
    width: {
      type: String,
      default: "300px"
    },
    height: {
      type: String,
      default: "240px"
    },
    calcPosType: {
      type: String,
      default: "dom",
      validator: (value) => ["dom", "screen"].includes(value)
    },
    maxDot: {
      type: Number,
      default: 5
      // validator: value => value > 10
    },
    imageBase64: String,
    thumbBase64: String
  },
  data() {
    return {
      dots: [],
      imageBase64Code: "",
      thumbBase64Code: ""
    };
  },
  watch: {
    value() {
      this.dots = [];
      this.imageBase64Code = "";
      this.thumbBase64Code = "";
    },
    imageBase64(val) {
      this.dots = [];
      this.imageBase64Code = val;
    },
    thumbBase64(val) {
      this.dots = [];
      this.thumbBase64Code = val;
    }
  },
  computed: {
    style() {
      return `width:${this.width}; height:${this.height};`;
    }
  },
  methods: {
    /**
     * @Description: 处理关闭事件
     */
    handleCloseEvent() {
      this.$emit("close");
      this.dots = [];
      this.imageBase64Code = "";
      this.thumbBase64Code = "";
    },
    /**
     * @Description: 处理刷新事件
     */
    handleRefreshEvent() {
      this.dots = [];
      this.$emit("refresh");
    },
    /**
     * @Description: 处理确认事件
     */
    handleConfirmEvent() {
      this.$emit("confirm", this.dots);
    },
    /**
     * @Description: 处理dot
     * @param ev
     */
    handleClickPos(ev) {
      if (this.dots.length >= this.maxDot) {
        return;
      }
      const e2 = ev || window.event;
      e2.preventDefault();
      const dom = e2.currentTarget;
      const {
        domX,
        domY
      } = this.getDomXY(dom);
      let mouseX = navigator.appName === "Netscape" ? e2.pageX : e2.x + document.body.offsetTop;
      let mouseY = navigator.appName === "Netscape" ? e2.pageY : e2.y + document.body.offsetTop;
      if (this.calcPosType === "screen") {
        mouseX = navigator.appName === "Netscape" ? e2.clientX : e2.x;
        mouseY = navigator.appName === "Netscape" ? e2.clientY : e2.y;
      }
      const xPos = mouseX - domX;
      const yPos = mouseY - domY;
      const xp = parseInt(xPos.toString());
      const yp = parseInt(yPos.toString());
      console.log(xp - 11, yp - 11);
      this.dots.push({
        x: xp - 11,
        y: yp - 11,
        index: this.dots.length + 1
      });
      return false;
    },
    /**
     * @Description: 找到元素的屏幕位置
     * @param el
     */
    calcLocationLeft(el) {
      let tmp = el.offsetLeft;
      let val = el.offsetParent;
      while (val != null) {
        tmp += val.offsetLeft;
        val = val.offsetParent;
      }
      return tmp;
    },
    /**
     * @Description: 找到元素的屏幕位置
     * @param el
     */
    calcLocationTop(el) {
      let tmp = el.offsetTop;
      let val = el.offsetParent;
      while (val != null) {
        tmp += val.offsetTop;
        val = val.offsetParent;
      }
      return tmp;
    },
    /**
     * @Description: 找到元素的屏幕位置
     * @param dom
     */
    getDomXY(dom) {
      let x2 = 0;
      let y3 = 0;
      if (dom.getBoundingClientRect) {
        let box = dom.getBoundingClientRect();
        let D2 = document.documentElement;
        x2 = box.left + Math.max(D2.scrollLeft, document.body.scrollLeft) - D2.clientLeft;
        y3 = box.top + Math.max(D2.scrollTop, document.body.scrollTop) - D2.clientTop;
      } else {
        while (dom !== document.body) {
          x2 += dom.offsetLeft;
          y3 += dom.offsetTop;
          dom = dom.offsetParent;
        }
      }
      return {
        domX: x2,
        domY: y3
      };
    }
  }
};
const _withScopeId$8 = (n2) => (pushScopeId("data-v-a5a46ca8"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1j = {
  class: "wg-cap-wrap"
};
const _hoisted_2$X = {
  class: "wg-cap-wrap__header"
};
const _hoisted_3$N = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode(
  "span",
  null,
  [/* @__PURE__ */ createTextVNode("请在下图"), /* @__PURE__ */ createElementVNode("em", null, "依次"), /* @__PURE__ */ createTextVNode("点击：")],
  -1
  /* HOISTED */
));
const _hoisted_4$C = ["src"];
const _hoisted_5$r = ["src"];
const _hoisted_6$m = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode(
  "img",
  {
    class: "wg-cap-wrap__loading",
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBzdHlsZT0ibWFyZ2luOiBhdXRvOyBiYWNrZ3JvdW5kOiByZ2JhKDI0MSwgMjQyLCAyNDMsIDApOyBkaXNwbGF5OiBibG9jazsgc2hhcGUtcmVuZGVyaW5nOiBhdXRvOyIgd2lkdGg9IjY0cHgiIGhlaWdodD0iNjRweCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIj4KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjM2LjgxMDEiIHI9IjEzIiBmaWxsPSIjM2U3Y2ZmIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImN5IiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgY2FsY01vZGU9InNwbGluZSIga2V5U3BsaW5lcz0iMC40NSAwIDAuOSAwLjU1OzAgMC40NSAwLjU1IDAuOSIga2V5VGltZXM9IjA7MC41OzEiIHZhbHVlcz0iMjM7Nzc7MjMiPjwvYW5pbWF0ZT4KICA8L2NpcmNsZT4KPC9zdmc+",
    alt: "正在加载中..."
  },
  null,
  -1
  /* HOISTED */
));
const _hoisted_7$f = {
  class: "wg-cap-wrap__footer"
};
const _hoisted_8$c = {
  class: "wg-cap-wrap__ico"
};
const _hoisted_9$a = {
  class: "wg-cap-wrap__btn"
};
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1j, [createElementVNode("div", _hoisted_2$X, [_hoisted_3$N, $data.thumbBase64Code ? (openBlock(), createElementBlock("img", {
    key: 0,
    class: "wg-cap-wrap__thumb",
    src: $data.thumbBase64Code,
    alt: " "
  }, null, 8, _hoisted_4$C)) : createCommentVNode("v-if", true)]), createElementVNode(
    "div",
    {
      class: "wg-cap-wrap__body",
      style: normalizeStyle($options.style)
    },
    [$data.imageBase64Code ? (openBlock(), createElementBlock("img", {
      key: 0,
      class: "wg-cap-wrap__picture",
      src: $data.imageBase64Code,
      alt: " ",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.handleClickPos($event))
    }, null, 8, _hoisted_5$r)) : createCommentVNode("v-if", true), _hoisted_6$m, (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList($data.dots, (dot, key) => {
        return openBlock(), createElementBlock(
          "div",
          {
            key,
            class: "wg-cap-wrap__dot",
            style: normalizeStyle(`top: ${dot.y}px; left:${dot.x}px;`)
          },
          [createElementVNode(
            "span",
            null,
            toDisplayString(dot.index),
            1
            /* TEXT */
          )],
          4
          /* STYLE */
        );
      }),
      128
      /* KEYED_FRAGMENT */
    ))],
    4
    /* STYLE */
  ), createElementVNode("div", _hoisted_7$f, [createElementVNode("div", _hoisted_8$c, [createElementVNode("img", {
    onClick: _cache[1] || (_cache[1] = (...args) => $options.handleCloseEvent && $options.handleCloseEvent(...args)),
    src: "data:image/svg+xml;base64,PHN2ZyB0PSIxNjI2NjE0NDM5NDIzIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9Ijg2NzUiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNNTEyIDIzLjI3MjcyN2MyNjkuOTE3MDkxIDAgNDg4LjcyNzI3MyAyMTguODEwMTgyIDQ4OC43MjcyNzMgNDg4LjcyNzI3M2E0ODYuNjMyNzI3IDQ4Ni42MzI3MjcgMCAwIDEtODQuOTQ1NDU1IDI3NS40MDk0NTUgNDYuNTQ1NDU1IDQ2LjU0NTQ1NSAwIDAgMS03Ni44NDY1NDUtNTIuNTI2NTQ2QTM5My41NDE4MTggMzkzLjU0MTgxOCAwIDAgMCA5MDcuNjM2MzY0IDUxMmMwLTIxOC41MDc2MzYtMTc3LjEyODcyNy0zOTUuNjM2MzY0LTM5NS42MzYzNjQtMzk1LjYzNjM2NFMxMTYuMzYzNjM2IDI5My40OTIzNjQgMTE2LjM2MzYzNiA1MTJzMTc3LjEyODcyNyAzOTUuNjM2MzY0IDM5NS42MzYzNjQgMzk1LjYzNjM2NGEzOTUuMTcwOTA5IDM5NS4xNzA5MDkgMCAwIDAgMTI1LjQ0LTIwLjI5MzgxOSA0Ni41NDU0NTUgNDYuNTQ1NDU1IDAgMCAxIDI5LjQ4NjU0NSA4OC4yOTY3MjhBNDg4LjI2MTgxOCA0ODguMjYxODE4IDAgMCAxIDUxMiAxMDAwLjcyNzI3M0MyNDIuMDgyOTA5IDEwMDAuNzI3MjczIDIzLjI3MjcyNyA3ODEuOTE3MDkxIDIzLjI3MjcyNyA1MTJTMjQyLjA4MjkwOSAyMy4yNzI3MjcgNTEyIDIzLjI3MjcyN3ogbS0xMTUuMiAzMDcuNzEyTDUxMiA0NDYuMTM4MTgybDExNS4yLTExNS4yYTQ2LjU0NTQ1NSA0Ni41NDU0NTUgMCAxIDEgNjUuODE1MjczIDY1Ljg2MTgxOEw1NzcuODYxODE4IDUxMmwxMTUuMiAxMTUuMmE0Ni41NDU0NTUgNDYuNTQ1NDU1IDAgMSAxLTY1Ljg2MTgxOCA2NS44MTUyNzNMNTEyIDU3Ny44NjE4MThsLTExNS4yIDExNS4yYTQ2LjU0NTQ1NSA0Ni41NDU0NTUgMCAxIDEtNjUuODE1MjczLTY1Ljg2MTgxOEw0NDYuMTM4MTgyIDUxMmwtMTE1LjItMTE1LjJhNDYuNTQ1NDU1IDQ2LjU0NTQ1NSAwIDEgMSA2NS44NjE4MTgtNjUuODE1MjczeiIgcC1pZD0iODY3NiIgZmlsbD0iIzcwNzA3MCI+PC9wYXRoPjwvc3ZnPg==",
    alt: "关闭"
  }), createElementVNode("img", {
    onClick: _cache[2] || (_cache[2] = (...args) => $options.handleRefreshEvent && $options.handleRefreshEvent(...args)),
    src: "data:image/svg+xml;base64,PHN2ZyB0PSIxNjI2NjE0NDk5NjM4IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEzNjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMTg3LjQ1NiA0MjUuMDI0YTMzNiAzMzYgMCAwIDAgMzY4LjM4NCA0MjAuMjI0IDQ4IDQ4IDAgMCAxIDEyLjU0NCA5NS4xNjggNDMyIDQzMiAwIDAgMS00NzMuNjY0LTU0MC4xNmwtNTcuMjgtMTUuMzZhMTIuOCAxMi44IDAgMCAxLTYuMjcyLTIwLjkyOGwxNTkuMTY4LTE3OS40NTZhMTIuOCAxMi44IDAgMCAxIDIyLjE0NCA1Ljg4OGw0OC4wNjQgMjM1LjA3MmExMi44IDEyLjggMCAwIDEtMTUuODA4IDE0LjkxMmwtNTcuMjgtMTUuMzZ6TTgzNi40OCA1OTkuMDRhMzM2IDMzNiAwIDAgMC0zNjguMzg0LTQyMC4yMjQgNDggNDggMCAxIDEtMTIuNTQ0LTk1LjE2OCA0MzIgNDMyIDAgMCAxIDQ3My42NjQgNTQwLjE2bDU3LjI4IDE1LjM2YTEyLjggMTIuOCAwIDAgMSA2LjI3MiAyMC45MjhsLTE1OS4xNjggMTc5LjQ1NmExMi44IDEyLjggMCAwIDEtMjIuMTQ0LTUuODg4bC00OC4wNjQtMjM1LjA3MmExMi44IDEyLjggMCAwIDEgMTUuODA4LTE0LjkxMmw1Ny4yOCAxNS4zNnoiIGZpbGw9IiM3MDcwNzAiIHAtaWQ9IjEzNjEiPjwvcGF0aD48L3N2Zz4=",
    alt: "刷新"
  })]), createElementVNode("div", _hoisted_9$a, [createElementVNode("button", {
    onClick: _cache[3] || (_cache[3] = (...args) => $options.handleConfirmEvent && $options.handleConfirmEvent(...args))
  }, "确认")])])]);
}
const GoCaptcha = /* @__PURE__ */ _export_sfc$1(_sfc_main$1C, [["render", _sfc_render$Q], ["__scopeId", "data-v-a5a46ca8"], ["__file", "Captcha.vue"]]);
const CaptchaBtn_vue_vue_type_style_index_0_scoped_b53be06d_lang = "";
const _sfc_main$1B = {
  name: "GoCaptchaBtn",
  components: {
    GoCaptcha
  },
  props: {
    captStatus: {
      type: String,
      default: "default",
      validator: (value) => ["default", "check", "error", "over", "success"].includes(value)
    },
    width: String,
    height: String,
    maxDot: {
      type: Number,
      default: 5
    },
    imageBase64: String,
    thumbBase64: String
  },
  data() {
    return {
      popoverVisible: false
      // captStatus: 'default'
    };
  },
  watch: {
    popoverVisible(val) {
      if (val) {
        this.$emit("refresh");
      }
    },
    captStatus(val) {
      if (val === "over" || val === "success") {
        this.popoverVisible = false;
      }
    }
  },
  emits: ["confirm", "refresh"],
  computed: {
    style() {
      return `width:${this.width}; height:${this.height};`;
    },
    activeClass() {
      let activeClass = this.captStatus;
      return `wg-cap-active__${activeClass}`;
    }
  },
  methods: {
    handleBtnEvent() {
      setTimeout(() => {
        this.popoverVisible = true;
      }, 0);
    },
    handleRefreshEvent() {
      this.$emit("refresh");
    },
    handleConfirmEvent(data) {
      this.$emit("confirm", data);
    },
    handleCloseEvent() {
      this.popoverVisible = false;
    }
  }
};
const _withScopeId$7 = (n2) => (pushScopeId("data-v-b53be06d"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1i = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico wg-cap-btn__verify"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSLlm77lsYJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDIwMCAyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDIwMCAyMDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojM0U3Q0ZGO30KCS5zdDF7ZmlsbDojRkZGRkZGO30KPC9zdHlsZT4KPGNpcmNsZSBjbGFzcz0ic3QwIiBjeD0iMTAwIiBjeT0iMTAwIiByPSI5Ni4zIi8+CjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDAuOCw2NC40bC0zOS42LTExLjloLTIuNEw1OS4yLDY0LjRjLTEuNiwwLjgtMi44LDIuNC0yLjgsNHYyNC4xYzAsMjUuMywxNS44LDQ1LjksNDIuMyw1NC42CgljMC40LDAsMC44LDAuNCwxLjIsMC40YzAuNCwwLDAuOCwwLDEuMi0wLjRjMjYuNS04LjcsNDIuMy0yOC45LDQyLjMtNTQuNlY2OC4zQzE0My41LDY2LjgsMTQyLjMsNjUuMiwxNDAuOCw2NC40eiIvPgo8L3N2Zz4K"
  })]), /* @__PURE__ */ createElementVNode("span", {
    class: "wg-cap-btn__text"
  }, "点击按键进行人机验证")],
  -1
  /* HOISTED */
));
const _hoisted_2$W = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PHN2ZyB0PSIxNjI3MDU1NTg2NTk0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEyMTEiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMTIwLjI1OTQ1NiA1MTIuMDAxMDIzbS0xMTcuOTIzNzYgMGExMTUuMjM4IDExNS4yMzggMCAxIDAgMjM1Ljg0NzUxOSAwIDExNS4yMzggMTE1LjIzOCAwIDEgMC0yMzUuODQ3NTE5IDBaIiBwLWlkPSIxMjEyIiBmaWxsPSIjZmZhMDAwIj48L3BhdGg+PHBhdGggZD0iTTUxMS45OTk0ODggNTEyLjAwMTAyM20tMTE3LjkyMTcxMyAwYTExNS4yMzYgMTE1LjIzNiAwIDEgMCAyMzUuODQzNDI2IDAgMTE1LjIzNiAxMTUuMjM2IDAgMSAwLTIzNS44NDM0MjYgMFoiIHAtaWQ9IjEyMTMiIGZpbGw9IiNmZmEwMDAiPjwvcGF0aD48cGF0aCBkPSJNOTAzLjczOTUyMSA1MTIuMDAxMDIzbS0xMTcuOTIzNzYgMGExMTUuMjM4IDExNS4yMzggMCAxIDAgMjM1Ljg0NzUxOSAwIDExNS4yMzggMTE1LjIzOCAwIDEgMC0yMzUuODQ3NTE5IDBaIiBwLWlkPSIxMjE0IiBmaWxsPSIjZmZhMDAwIj48L3BhdGg+PC9zdmc+",
    alt: ""
  })]), /* @__PURE__ */ createElementVNode("span", {
    class: "wg-cap-btn__text"
  }, "正在进行人机验证...")],
  -1
  /* HOISTED */
));
const _hoisted_3$M = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDAgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDAgMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0VENDYzMDt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xODQsMjYuNkwxMDIuNCwyLjFoLTQuOUwxNiwyNi42Yy0zLjMsMS42LTUuNyw0LjktNS43LDguMnY0OS44YzAsNTIuMiwzMi42LDk0LjcsODcuMywxMTIuNgoJYzAuOCwwLDEuNiwwLjgsMi40LDAuOHMxLjYsMCwyLjQtMC44YzU0LjctMTgsODcuMy01OS42LDg3LjMtMTEyLjZWMzQuN0MxODkuOCwzMS41LDE4Ny4zLDI4LjIsMTg0LDI2LjZ6IE0xMzQuNSwxMjMuMQoJYzMuMSwzLjEsMy4xLDguMiwwLDExLjNjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zcy00LjEtMC44LTUuNy0yLjNMMTAwLDExMS4zbC0yMy4xLDIzLjFjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zCgljLTIsMC00LjEtMC44LTUuNy0yLjNjLTMuMS0zLjEtMy4xLTguMiwwLTExLjNMODguNywxMDBMNjUuNSw3Ni45Yy0zLjEtMy4xLTMuMS04LjIsMC0xMS4zYzMuMS0zLjEsOC4yLTMuMSwxMS4zLDBMMTAwLDg4LjcKCWwyMy4xLTIzLjFjMy4xLTMuMSw4LjItMy4xLDExLjMsMGMzLjEsMy4xLDMuMSw4LjIsMCwxMS4zTDExMS4zLDEwMEwxMzQuNSwxMjMuMXoiLz4KPC9zdmc+Cg==",
    alt: "失败"
  })]), /* @__PURE__ */ createElementVNode("span", null, [/* @__PURE__ */ createTextVNode("人机验证失败 "), /* @__PURE__ */ createElementVNode("em", null, "点击重试")])],
  -1
  /* HOISTED */
));
const _hoisted_4$B = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wg-cap-state__inner"
  },
  [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDAgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDAgMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0VENDYzMDt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xODQsMjYuNkwxMDIuNCwyLjFoLTQuOUwxNiwyNi42Yy0zLjMsMS42LTUuNyw0LjktNS43LDguMnY0OS44YzAsNTIuMiwzMi42LDk0LjcsODcuMywxMTIuNgoJYzAuOCwwLDEuNiwwLjgsMi40LDAuOHMxLjYsMCwyLjQtMC44YzU0LjctMTgsODcuMy01OS42LDg3LjMtMTEyLjZWMzQuN0MxODkuOCwzMS41LDE4Ny4zLDI4LjIsMTg0LDI2LjZ6IE0xMzQuNSwxMjMuMQoJYzMuMSwzLjEsMy4xLDguMiwwLDExLjNjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zcy00LjEtMC44LTUuNy0yLjNMMTAwLDExMS4zbC0yMy4xLDIzLjFjLTEuNiwxLjYtMy42LDIuMy01LjcsMi4zCgljLTIsMC00LjEtMC44LTUuNy0yLjNjLTMuMS0zLjEtMy4xLTguMiwwLTExLjNMODguNywxMDBMNjUuNSw3Ni45Yy0zLjEtMy4xLTMuMS04LjIsMC0xMS4zYzMuMS0zLjEsOC4yLTMuMSwxMS4zLDBMMTAwLDg4LjcKCWwyMy4xLTIzLjFjMy4xLTMuMSw4LjItMy4xLDExLjMsMGMzLjEsMy4xLDMuMSw4LjIsMCwxMS4zTDExMS4zLDEwMEwxMzQuNSwxMjMuMXoiLz4KPC9zdmc+Cg==",
    alt: "失败"
  })]), /* @__PURE__ */ createElementVNode("span", null, [/* @__PURE__ */ createTextVNode("点击次数过多 "), /* @__PURE__ */ createElementVNode("em", null, "点击重试")])],
  -1
  /* HOISTED */
));
const _hoisted_5$q = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    onClick: () => false,
    class: "wg-cap-state__success"
  },
  [/* @__PURE__ */ createCommentVNode(" 验证成功状态 "), /* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-state__inner"
  }, [/* @__PURE__ */ createElementVNode("div", {
    class: "wg-cap-btn__ico"
  }, [/* @__PURE__ */ createElementVNode("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAyMDAgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDAgMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6IzVFQUEyRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xODMuMywyNy4yTDEwMi40LDIuOWgtNC45TDE2LjcsMjcuMkMxMy40LDI4LjgsMTEsMzIsMTEsMzUuM3Y0OS40YzAsNTEuOCwzMi40LDkzLjksODYuNiwxMTEuNwoJYzAuOCwwLDEuNiwwLjgsMi40LDAuOGMwLjgsMCwxLjYsMCwyLjQtMC44YzU0LjItMTcuOCw4Ni42LTU5LjEsODYuNi0xMTEuN1YzNS4zQzE4OSwzMiwxODYuNiwyOC44LDE4My4zLDI3LjJ6IE0xNDYuMSw4MS40CglsLTQ4LjUsNDguNWMtMS42LDEuNi0zLjIsMi40LTUuNywyLjRjLTIuNCwwLTQtMC44LTUuNy0yLjRMNjIsMTA1LjdjLTMuMi0zLjItMy4yLTguMSwwLTExLjNjMy4yLTMuMiw4LjEtMy4yLDExLjMsMGwxOC42LDE4LjYKCWw0Mi45LTQyLjljMy4yLTMuMiw4LjEtMy4yLDExLjMsMEMxNDkuNCw3My4zLDE0OS40LDc4LjIsMTQ2LjEsODEuNEwxNDYuMSw4MS40eiIvPgo8L3N2Zz4K",
    alt: "成功"
  })]), /* @__PURE__ */ createElementVNode("span", null, "人机验证已通过")])],
  -1
  /* HOISTED */
));
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_go_captcha = resolveComponent("go-captcha");
  const _component_v_dropdown = resolveComponent("v-dropdown");
  return openBlock(), createElementBlock(
    "div",
    {
      class: "wg-cap-btn",
      style: normalizeStyle($options.style)
    },
    [createElementVNode(
      "div",
      {
        class: normalizeClass(["wg-cap-btn__inner", $options.activeClass])
      },
      [createCommentVNode(" wg-cap-active__default wg-cap-active__error wg-cap-active__over wg-cap-active__success "), createVNode(_component_v_dropdown, {
        triggers: ["click"],
        shown: $data.popoverVisible,
        placement: "top"
      }, {
        popper: withCtx(() => [createVNode(_component_go_captcha, {
          modelValue: $data.popoverVisible,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.popoverVisible = $event),
          width: "300px",
          height: "240px",
          "max-dot": $props.maxDot,
          "image-base64": $props.imageBase64,
          "thumb-base64": $props.thumbBase64,
          onClose: $options.handleCloseEvent,
          onRefresh: $options.handleRefreshEvent,
          onConfirm: $options.handleConfirmEvent
        }, null, 8, ["modelValue", "max-dot", "image-base64", "thumb-base64", "onClose", "onRefresh", "onConfirm"])]),
        default: withCtx(() => [createElementVNode("div", {
          onClick: _cache[1] || (_cache[1] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__default"
        }, [createCommentVNode(" 初始状态 "), _hoisted_1$1i]), createElementVNode("div", {
          onClick: _cache[2] || (_cache[2] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__check"
        }, [createCommentVNode(" 验证状态 "), _hoisted_2$W]), createElementVNode("div", {
          onClick: _cache[3] || (_cache[3] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__error"
        }, [createCommentVNode(" 验证失败状态 "), _hoisted_3$M]), createElementVNode("div", {
          onClick: _cache[4] || (_cache[4] = (...args) => $options.handleBtnEvent && $options.handleBtnEvent(...args)),
          class: "wg-cap-state__over"
        }, [createCommentVNode(" 验证次数过多状态 "), _hoisted_4$B]), _hoisted_5$q]),
        _: 1
        /* STABLE */
      }, 8, ["shown"])],
      2
      /* CLASS */
    )],
    4
    /* STYLE */
  );
}
const GoCaptchaBtn = /* @__PURE__ */ _export_sfc$1(_sfc_main$1B, [["render", _sfc_render$P], ["__scopeId", "data-v-b53be06d"], ["__file", "CaptchaBtn.vue"]]);
const _sfc_main$1A = {
  components: {
    GoCaptchaBtn
    // GoCaptchaBtnDialog
  },
  data() {
    return {
      // 验证码数据
      captBase64: "",
      captThumbBase64: "",
      captKey: "",
      captStatus: "default",
      captExpires: 0,
      captAutoRefreshCount: 0
    };
  },
  mounted() {
    this.init();
  },
  emits: {
    over(data) {
      return true;
    }
  },
  methods: {
    init() {
      this.captStatus = "default";
      this.captAutoRefreshCount = 0;
    },
    /**
     * 处理请求验证码
     */
    handleRequestCaptCode() {
      this.captBase64 = "";
      this.captThumbBase64 = "";
      this.captKey = "";
      this.$api.getCaptcha().then((resp) => {
        const {
          data = {}
        } = resp;
        this.captBase64 = data["image_base64"] || "";
        this.captThumbBase64 = data["thumb_base64"] || "";
        this.captKey = data["captcha_key"] || "";
      }).catch((err2) => {
        this.$msg({
          text: `获取人机验证数据失败`,
          type: "warn"
        });
      });
      this.captStatus = "check";
    },
    /**
     * 处理验证码校验请求
     * @param {{ x: number, y: number }[]} dots
     */
    handleConfirm(dots) {
      if ((dots.length ?? 0) <= 0) {
        this.$msg({
          text: `请进行人机验证再操作ヾ(。￣□￣)ﾂ゜゜゜`,
          type: "info"
        });
        this.$emit("over", false);
        return;
      }
      const dotArr = dots.map((dot) => [dot.x, dot.y]).flat();
      const dotArrStr = dotArr.join(",");
      this.$api.validateCaptcha(this.captKey, dotArrStr).then((resp) => {
        this.$msg({
          text: `人机验证成功Ψ(￣∀￣)Ψ`,
          type: "success"
        });
        this.captStatus = "success";
        this.captAutoRefreshCount = 0;
        this.$emit("over", {
          dots: dotArrStr,
          key: this.captKey
        });
      }).catch((err2) => {
        this.$msg({
          text: `人机验证失败|(*′口\`): ${err2.data.what}`,
          type: "warn"
        });
        if (this.captAutoRefreshCount > 5) {
          this.captAutoRefreshCount = 0;
          this.captStatus = "over";
          return;
        }
        this.handleRequestCaptCode();
        this.captAutoRefreshCount += 1;
        this.captStatus = "error";
        this.$emit("over", false);
      });
    }
  }
};
const Index_vue_vue_type_style_index_0_scoped_34e3e3f3_lang = "";
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_go_captcha_btn = resolveComponent("go-captcha-btn");
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [createVNode(_component_go_captcha_btn, {
      class: "go-captcha-btn",
      width: "100%",
      height: "100%",
      captStatus: $data.captStatus,
      "image-base64": $data.captBase64,
      "thumb-base64": $data.captThumbBase64,
      onConfirm: $options.handleConfirm,
      onRefresh: $options.handleRequestCaptCode
    }, null, 8, ["captStatus", "image-base64", "thumb-base64", "onConfirm", "onRefresh"]), createCommentVNode("   弹窗方式   "), createCommentVNode(' <go-captcha-btn-dialog\r\n    class="go-captcha-btn"\r\n    v-model="captStatus"\r\n    width="100%"\r\n    height="50px"\r\n    :image-base64="captBase64"\r\n    :thumb-base64="captThumbBase64"\r\n    @confirm="handleConfirm"\r\n    @refresh="handleRequestCaptCode"\r\n  /> ')],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const Captcha = /* @__PURE__ */ _export_sfc$1(_sfc_main$1A, [["render", _sfc_render$O], ["__scopeId", "data-v-34e3e3f3"], ["__file", "Index.vue"]]);
const _sfc_main$1z = {
  components: {
    CaptchaBtn: Captcha
  },
  props: {
    crypt: {
      required: true,
      type: Object
    }
  },
  setup() {
    const userInfo2 = useUserInfo();
    const username = ref("");
    const password = ref("");
    const ua = ref("");
    const {
      base64
    } = useBase64(password);
    const pswdBase64 = computed(() => base64.value.slice("data:text/plain;base64,".length));
    userAgent().then((res) => ua.value = res);
    const captcha = ref(false);
    return {
      userInfo: userInfo2,
      username,
      password,
      ua,
      pswdBase64,
      captcha
    };
  },
  emits: {
    show(open = true) {
      return typeof open === "boolean";
    },
    toggle(tabName) {
      return true;
    },
    login() {
      return true;
    }
  },
  methods: {
    init() {
      this.captcha = false;
      this.$refs.captchaRef.init();
    },
    login() {
      if (!this.username || !this.password) {
        return;
      }
      if (!this.captcha) {
        this.$msg({
          type: "warn",
          text: "请先进行人机验证ψ(╰_╯)"
        });
        return;
      }
      const usernameEn = encodeURIComponent(this.crypt.encrypt(this.username));
      const passwordEn = encodeURIComponent(this.crypt.encrypt(this.pswdBase64));
      const uaEn = encodeURIComponent(this.crypt.encrypt(this.ua));
      this.captcha.remove = true;
      this.$api.login(usernameEn, passwordEn, uaEn, this.captcha).then((res) => {
        this.$api.getUserInfo(res.data.id).then((res2) => {
          this.userInfo = res2.data;
          console.log("登录成功", res2);
          this.$msg({
            type: "success",
            text: "登录成功ヾ(･ω･`｡)~"
          });
          this.$emit("login");
          this.$emit("show", false);
        }).catch((err2) => {
          var _a3;
          this.$msg({
            type: "error",
            text: "获取用户信息失败ヽ(°◇° )ノ: " + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
          });
          this.init();
        });
      }).catch((err2) => {
        var _a3;
        if (err2.status == 404 || err2.status == 403) {
          this.$msg({
            type: "error",
            text: err2.data.what
          });
        } else {
          this.$msg({
            type: "error",
            text: "登录失败ヽ(≧□≦)ノ: " + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
          });
        }
        this.init();
      });
    }
  }
};
const Login_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$1h = {
  class: "login-form"
};
const _hoisted_2$V = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "邮箱",
  -1
  /* HOISTED */
);
const _hoisted_3$L = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "密码",
  -1
  /* HOISTED */
);
const _hoisted_4$A = {
  class: "btn-row"
};
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CaptchaBtn = resolveComponent("CaptchaBtn");
  return openBlock(), createElementBlock("div", _hoisted_1$1h, [_hoisted_2$V, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "text",
      class: "form-input-login",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.username = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.username]])]), _hoisted_3$L, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "password",
      class: "form-input-login",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.password = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.password]])]), createElementVNode("div", null, [createVNode(
    _component_CaptchaBtn,
    {
      ref: "captchaRef",
      onOver: _cache[2] || (_cache[2] = ($event) => $setup.captcha = $event)
    },
    null,
    512
    /* NEED_PATCH */
  )]), createElementVNode("div", _hoisted_4$A, [createElementVNode("button", {
    class: "btn text",
    onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("toggle", "regis"))
  }, " 注册 "), createElementVNode("button", {
    class: "btn",
    onClick: _cache[4] || (_cache[4] = (...args) => $options.login && $options.login(...args))
  }, " 登录 ")])]);
}
const Login = /* @__PURE__ */ _export_sfc$1(_sfc_main$1z, [["render", _sfc_render$N], ["__file", "Login.vue"]]);
const _sfc_main$1y = {
  components: {
    CaptchaBtn: Captcha
  },
  props: {
    crypt: {
      required: true,
      type: Object
    }
  },
  setup() {
    const email = ref("");
    const nickname = ref("");
    const password = ref("");
    const confpswd = ref("");
    const pswdEqual = computed(() => password.value === confpswd.value);
    const captcha = ref(false);
    return {
      email,
      nickname,
      password,
      confpswd,
      pswdEqual,
      captcha
    };
  },
  emits: {
    show(open = true) {
      return typeof open === "boolean";
    },
    toggle(tabName) {
      return true;
    }
  },
  methods: {
    init() {
      this.captcha = false;
      this.$refs.captchaRef.init();
    },
    register() {
      if (!this.pswdEqual) {
        this.$msg({
          type: "error",
          text: "两次密码输入不一致ヘ(_ _ヘ)"
        });
        return;
      }
      if ([this.email, this.password, this.confpswd].some((e2) => !e2.length)) {
        this.$msg({
          type: "error",
          text: "必填信息为空ヘ(_ _ヘ)"
        });
        return;
      }
      if (!this.captcha) {
        this.$msg({
          type: "info",
          text: "请先进行人机验证ψ(╰_╯)"
        });
        return;
      }
      const emailEn = encodeURIComponent(this.crypt.encrypt(this.email));
      const passwordEn = encodeURIComponent(this.crypt.encrypt(this.password));
      this.$api.regis(this.nickname, emailEn, passwordEn, this.captcha).then(() => {
        this.$msg({
          type: "success",
          text: "注册成功(〃'▽'〃)"
        });
        this.$emit("toggle", "login");
      }).catch((err2) => {
        var _a3;
        this.$msg({
          type: "error",
          text: "注册失败ヽ(≧□≦)ノ: " + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
        });
        this.init();
      });
    }
  }
};
const Regis_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$1g = {
  class: "regis-form"
};
const _hoisted_2$U = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  [/* @__PURE__ */ createTextVNode("注册邮箱"), /* @__PURE__ */ createElementVNode("span", {
    class: "required-mark"
  })],
  -1
  /* HOISTED */
);
const _hoisted_3$K = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "昵称",
  -1
  /* HOISTED */
);
const _hoisted_4$z = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  [/* @__PURE__ */ createTextVNode("密码"), /* @__PURE__ */ createElementVNode("span", {
    class: "required-mark"
  })],
  -1
  /* HOISTED */
);
const _hoisted_5$p = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  [/* @__PURE__ */ createTextVNode("确认密码"), /* @__PURE__ */ createElementVNode("span", {
    class: "required-mark"
  })],
  -1
  /* HOISTED */
);
const _hoisted_6$l = {
  class: "btn-row"
};
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CaptchaBtn = resolveComponent("CaptchaBtn");
  return openBlock(), createElementBlock("div", _hoisted_1$1g, [_hoisted_2$U, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "text",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.email = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.email]])]), _hoisted_3$K, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "text",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.nickname = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.nickname]])]), _hoisted_4$z, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "password",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.password = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.password]])]), _hoisted_5$p, createElementVNode("div", null, [withDirectives(createElementVNode(
    "input",
    {
      type: "password",
      class: "form-input-regis",
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.confpswd = $event)
    },
    null,
    512
    /* NEED_PATCH */
  ), [[vModelText, $setup.confpswd]])]), createElementVNode("div", null, [createVNode(
    _component_CaptchaBtn,
    {
      ref: "captchaRef",
      onOver: _cache[4] || (_cache[4] = ($event) => $setup.captcha = $event)
    },
    null,
    512
    /* NEED_PATCH */
  )]), createElementVNode("div", _hoisted_6$l, [createElementVNode("button", {
    class: "btn text",
    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("toggle", "login"))
  }, " 登录 "), createElementVNode("button", {
    class: "btn",
    onClick: _cache[6] || (_cache[6] = (...args) => $options.register && $options.register(...args))
  }, " 注册 ")])]);
}
const Regis = /* @__PURE__ */ _export_sfc$1(_sfc_main$1y, [["render", _sfc_render$M], ["__file", "Regis.vue"]]);
const _sfc_main$1x = defineComponent({
  components: {
    Login,
    Regis
  },
  setup() {
    const showDialog = ref(false);
    const curTab = ref("login");
    const crypt = ref(null);
    __vitePreload(() => import("./index-c88f9e43.js"), true ? [] : void 0).then(({
      default: JSEncrypt
    }) => {
      crypt.value = new JSEncrypt();
      crypt.value.setPublicKey(publicKey);
    });
    return {
      curTab,
      crypt,
      showDialog
    };
  },
  emits: {
    close(cls) {
      return typeof cls === "boolean";
    },
    login() {
      return true;
    }
  },
  methods: {
    show(open = true) {
      this.showDialog = open;
      this.$emit("close", !open);
    },
    toggle(tabName) {
      this.curTab = tabName;
    }
  }
});
const Index_vue_vue_type_style_index_0_scoped_47ac1abb_lang = "";
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Login = resolveComponent("Login");
  const _component_Regis = resolveComponent("Regis");
  const _component_GDialog = resolveComponent("GDialog");
  return openBlock(), createBlock(_component_GDialog, {
    modelValue: _ctx.showDialog,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.showDialog = $event),
    "max-width": 400
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "dialog"
    }, {
      default: withCtx(() => [_ctx.curTab === "login" ? (openBlock(), createBlock(_component_Login, {
        key: 0,
        crypt: _ctx.crypt,
        onShow: _ctx.show,
        onToggle: _ctx.toggle,
        onLogin: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("login"))
      }, null, 8, ["crypt", "onShow", "onToggle"])) : _ctx.curTab === "regis" ? (openBlock(), createBlock(_component_Regis, {
        key: 1,
        crypt: _ctx.crypt,
        onShow: _ctx.show,
        onToggle: _ctx.toggle
      }, null, 8, ["crypt", "onShow", "onToggle"])) : createCommentVNode("v-if", true)]),
      _: 1
      /* STABLE */
    })]),
    _: 1
    /* STABLE */
  }, 8, ["modelValue"]);
}
const Index = /* @__PURE__ */ _export_sfc$1(_sfc_main$1x, [["render", _sfc_render$L], ["__scopeId", "data-v-47ac1abb"], ["__file", "Index.vue"]]);
const _hoisted_1$1f = {
  key: 0,
  class: "wl-tab-wrapper"
};
const _hoisted_2$T = ["title", "onClick"];
const _hoisted_3$J = ["src", "alt"];
const _hoisted_4$y = {
  key: 0,
  class: "wl-tabs"
};
const _hoisted_5$o = ["onClick"];
const _hoisted_6$k = ["src", "alt", "title"];
const _sfc_main$1w = /* @__PURE__ */ defineComponent({
  __name: "EmojiPopup",
  props: {
    emoji: {},
    showEmoji: {
      type: Boolean
    }
  },
  emits: ["insert"],
  setup(__props) {
    const emojiTabIndex = ref(0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.emoji.tabs, (emojiItem, index2) => {
            return openBlock(), createElementBlock(
              Fragment,
              {
                key: emojiItem.name
              },
              [index2 === emojiTabIndex.value ? (openBlock(), createElementBlock("div", _hoisted_1$1f, [(openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(emojiItem.items, (key) => {
                  return openBlock(), createElementBlock("button", {
                    key,
                    type: "button",
                    title: key,
                    onClick: ($event) => _ctx.$emit("insert", `:${key}:`)
                  }, [_ctx.showEmoji ? (openBlock(), createElementBlock("img", {
                    key: 0,
                    class: "wl-emoji",
                    src: _ctx.emoji.map[key],
                    alt: key,
                    loading: "lazy",
                    referrerPolicy: "no-referrer"
                  }, null, 8, _hoisted_3$J)) : createCommentVNode("v-if", true)], 8, _hoisted_2$T);
                }),
                128
                /* KEYED_FRAGMENT */
              ))])) : createCommentVNode("v-if", true)],
              64
              /* STABLE_FRAGMENT */
            );
          }),
          128
          /* KEYED_FRAGMENT */
        )), _ctx.emoji.tabs.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_4$y, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.emoji.tabs, (emojiItem, index2) => {
            return openBlock(), createElementBlock("button", {
              key: emojiItem.name,
              type: "button",
              class: normalizeClass(["wl-tab", {
                active: emojiTabIndex.value === index2
              }]),
              onClick: ($event) => emojiTabIndex.value = index2
            }, [createElementVNode("img", {
              class: "wl-emoji",
              src: emojiItem.icon,
              alt: emojiItem.name,
              title: emojiItem.name,
              loading: "lazy",
              referrerPolicy: "no-referrer"
            }, null, 8, _hoisted_6$k)], 10, _hoisted_5$o);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])) : createCommentVNode("v-if", true)],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});
const EmojiPopup = /* @__PURE__ */ _export_sfc$1(_sfc_main$1w, [["__file", "EmojiPopup.vue"]]);
const _hoisted_1$1e = ["data-index"];
const _hoisted_2$S = ["src", "title", "onClick"];
const _sfc_main$1v = /* @__PURE__ */ defineComponent({
  __name: "ImageWall",
  props: {
    items: {
      default: () => []
    },
    columnWidth: {
      default: 300
    },
    gap: {
      default: 0
    }
  },
  emits: ["insert"],
  setup(__props, {
    expose: __expose
  }) {
    const props = __props;
    __expose();
    let resizeObserver = null;
    const wall = ref(null);
    const state = ref({});
    const columns = ref([]);
    const getColumnCount = () => {
      const count = Math.floor((wall.value.getBoundingClientRect().width + props.gap) / (props.columnWidth + props.gap));
      return count > 0 ? count : 1;
    };
    const createColumns = (count) => new Array(count).fill(null).map(() => []);
    const fillColumns = async (itemIndex) => {
      var _a3;
      if (itemIndex >= props.items.length)
        return;
      await nextTick();
      const columnDivs = Array.from(((_a3 = wall.value) == null ? void 0 : _a3.children) || []);
      const target = columnDivs.reduce((prev, curr) => curr.getBoundingClientRect().height < prev.getBoundingClientRect().height ? curr : prev);
      columns.value[Number(target.dataset.index)].push(itemIndex);
      await fillColumns(itemIndex + 1);
    };
    const redraw = async (force = false) => {
      if (columns.value.length === getColumnCount() && !force)
        return;
      columns.value = createColumns(getColumnCount());
      const scrollY = window.scrollY;
      await fillColumns(0);
      window.scrollTo({
        top: scrollY
      });
    };
    const imageLoad = (e2) => {
      state.value[e2.target.src] = true;
    };
    onMounted(() => {
      void redraw(true);
      resizeObserver = new ResizeObserver(() => {
        void redraw();
      });
      resizeObserver.observe(wall.value);
      watch(() => [props.items], () => {
        state.value = {};
        void redraw(true);
      });
      watch(() => [props.columnWidth, props.gap], () => {
        void redraw();
      });
    });
    onBeforeUnmount(() => resizeObserver.unobserve(wall.value));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          ref_key: "wall",
          ref: wall,
          class: "wl-gallery",
          style: normalizeStyle({
            gap: `${_ctx.gap}px`
          })
        },
        [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(columns.value, (column, columnIndex) => {
            return openBlock(), createElementBlock("div", {
              key: columnIndex,
              class: "wl-gallery-column",
              "data-index": columnIndex,
              style: normalizeStyle({
                gap: `${_ctx.gap}px`
              })
            }, [(openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(column, (itemIndex) => {
                return openBlock(), createElementBlock(
                  Fragment,
                  {
                    key: itemIndex
                  },
                  [createCommentVNode(" eslint-disable vue/no-static-inline-styles "), !state.value[_ctx.items[itemIndex].src] ? (openBlock(), createBlock(unref(LoadingIcon), {
                    key: 0,
                    size: 36,
                    style: {
                      "margin": "20px auto"
                    }
                  })) : createCommentVNode("v-if", true), createCommentVNode(" eslint-enable vue/no-static-inline-styles "), createElementVNode("img", {
                    class: "wl-gallery-item",
                    src: _ctx.items[itemIndex].src,
                    title: _ctx.items[itemIndex].title,
                    loading: "lazy",
                    onLoad: imageLoad,
                    onClick: ($event) => _ctx.$emit("insert", `![](${_ctx.items[itemIndex].src})`)
                  }, null, 40, _hoisted_2$S)],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))], 12, _hoisted_1$1e);
          }),
          128
          /* KEYED_FRAGMENT */
        ))],
        4
        /* STYLE */
      );
    };
  }
});
const ImageWall = /* @__PURE__ */ _export_sfc$1(_sfc_main$1v, [["__file", "ImageWall.vue"]]);
const _hoisted_1$1d = ["placeholder"];
const _hoisted_2$R = {
  key: 1,
  class: "wl-loading"
};
const _sfc_main$1u = /* @__PURE__ */ defineComponent({
  __name: "GifPopup",
  props: {
    showGif: {
      type: Boolean
    }
  },
  emits: ["insert"],
  setup(__props, {
    emit
  }) {
    const props = __props;
    const isImageListEnd = ref(false);
    const gifSearchInputRef = ref(null);
    const config = inject("config");
    const locale = computed(() => config.value.locale);
    const searchResults = reactive({
      loading: true,
      list: []
    });
    const onImageWallScroll = async (event) => {
      var _a3;
      const {
        scrollTop,
        clientHeight,
        scrollHeight
      } = event.target;
      const percent = (clientHeight + scrollTop) / scrollHeight;
      const searchOptions = config.value.search;
      const keyword = ((_a3 = gifSearchInputRef.value) == null ? void 0 : _a3.value) || "";
      if (percent < 0.9 || searchResults.loading || isImageListEnd.value)
        return;
      searchResults.loading = true;
      const searchResult = searchOptions.more && searchResults.list.length ? await searchOptions.more(keyword, searchResults.list.length) : await searchOptions.search(keyword);
      if (searchResult.length)
        searchResults.list = [...searchResults.list, ...searchOptions.more && searchResults.list.length ? await searchOptions.more(keyword, searchResults.list.length) : await searchOptions.search(keyword)];
      else
        isImageListEnd.value = true;
      searchResults.loading = false;
      setTimeout(() => {
        event.target.scrollTop = scrollTop;
      }, 50);
    };
    const onGifSearch = useDebounceFn((event) => {
      searchResults.list = [];
      isImageListEnd.value = false;
      void onImageWallScroll(event);
    }, 300);
    onMounted(() => {
      const {
        showGif
      } = toRefs(props);
      watch(showGif, async (showGif2) => {
        if (!showGif2)
          return;
        const searchOptions = config.value.search;
        if (gifSearchInputRef.value)
          gifSearchInputRef.value.value = "";
        searchResults.loading = true;
        searchResults.list = searchOptions.default ? await searchOptions.default() : await searchOptions.search("");
        searchResults.loading = false;
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [createElementVNode("input", {
          ref_key: "gifSearchInputRef",
          ref: gifSearchInputRef,
          type: "text",
          placeholder: locale.value.gifSearchPlaceholder,
          onInput: _cache[0] || (_cache[0] = //@ts-ignore
          (...args) => unref(onGifSearch) && unref(onGifSearch)(...args))
        }, null, 40, _hoisted_1$1d), searchResults.list.length ? (openBlock(), createBlock(ImageWall, {
          key: 0,
          items: searchResults.list,
          "column-width": 200,
          gap: 6,
          onInsert: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("insert", $event)),
          onScroll: onImageWallScroll
        }, null, 8, ["items"])) : createCommentVNode("v-if", true), searchResults.loading ? (openBlock(), createElementBlock("div", _hoisted_2$R, [createVNode(unref(LoadingIcon), {
          size: 30
        })])) : createCommentVNode("v-if", true)],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});
const GifPopup = /* @__PURE__ */ _export_sfc$1(_sfc_main$1u, [["__file", "GifPopup.vue"]]);
const _withScopeId$6 = (n2) => (pushScopeId("data-v-fec613ec"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1c = {
  class: "wl-preview"
};
const _hoisted_2$Q = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode(
  "hr",
  null,
  null,
  -1
  /* HOISTED */
));
const _hoisted_3$I = {
  class: "head"
};
const _hoisted_4$x = {
  class: "title"
};
const _hoisted_5$n = {
  for: "show-html",
  class: "toggle-show-html"
};
const _hoisted_6$j = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode(
  "span",
  null,
  "源码",
  -1
  /* HOISTED */
));
const _hoisted_7$e = ["innerHTML"];
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  __name: "Preview",
  props: {
    showPreview: {
      type: Boolean
    }
  },
  setup(__props) {
    const config = inject("config");
    const emoji2 = useEmoji();
    const editor = useEditor();
    const previewText = ref("");
    const showHTML = ref(false);
    const locale = computed(() => config.value.locale);
    onMounted(() => {
      watch([editor, showHTML], ([value, html2]) => {
        const parsed = parseMarkdown(value, {
          emojiMap: emoji2.value.map
        });
        previewText.value = html2 ? parseMarkdown("```html\n" + parsed + "\n```") : parsed;
      });
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock(
        "div",
        _hoisted_1$1c,
        [_hoisted_2$Q, createElementVNode("div", _hoisted_3$I, [createElementVNode(
          "div",
          _hoisted_4$x,
          toDisplayString(locale.value.preview),
          1
          /* TEXT */
        ), createElementVNode("label", _hoisted_5$n, [withDirectives(createElementVNode(
          "input",
          {
            name: "show-html",
            type: "checkbox",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showHTML.value = $event)
          },
          null,
          512
          /* NEED_PATCH */
        ), [[vModelCheckbox, showHTML.value]]), _hoisted_6$j])]), createCommentVNode(" eslint-disable-next-line vue/no-v-html "), createElementVNode("div", {
          class: "wl-content",
          innerHTML: previewText.value
        }, null, 8, _hoisted_7$e)],
        512
        /* NEED_PATCH */
      )), [[vShow, _ctx.showPreview]]);
    };
  }
});
const Preview_vue_vue_type_style_index_0_scoped_fec613ec_lang = "";
const Preview = /* @__PURE__ */ _export_sfc$1(_sfc_main$1t, [["__scopeId", "data-v-fec613ec"], ["__file", "Preview.vue"]]);
const _hoisted_1$1b = {
  class: "wl-footer"
};
const _hoisted_2$P = {
  class: "wl-actions"
};
const _hoisted_3$H = {
  href: "https://guides.github.com/features/mastering-markdown/",
  title: "Markdown Guide",
  "aria-label": "Markdown is supported",
  class: "wl-action",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_4$w = ["title"];
const _hoisted_5$m = ["title"];
const _hoisted_6$i = ["title"];
const _hoisted_7$d = ["title"];
const _hoisted_8$b = {
  class: "wl-info"
};
const _hoisted_9$9 = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "wl-captcha-container"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_10$8 = {
  class: "wl-text-number"
};
const _hoisted_11$7 = {
  key: 0
};
const _hoisted_12$4 = ["textContent"];
const _hoisted_13$4 = ["textContent"];
const _hoisted_14$4 = ["disabled"];
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  __name: "Footer",
  props: {
    wordNumber: {},
    wordLimit: {},
    uploadImage: {
      type: Function
    },
    isLogin: {
      type: Boolean
    },
    isSubmitting: {
      type: Boolean
    },
    isWordNumberLegal: {
      type: Boolean
    }
  },
  emits: ["insert", "change", "login", "submit"],
  setup(__props) {
    const props = __props;
    const emoji2 = inject("emoji");
    const showPreview = ref(false);
    const showEmoji = ref(false);
    const showGif = ref(false);
    const emojiButtonRef = ref(null);
    const emojiPopupRef = ref(null);
    const gifButtonRef = ref(null);
    const gifPopupRef = ref(null);
    const imageUploadRef = ref(null);
    const loginRef = ref(null);
    const config = inject("config");
    const canUploadImage = computed(() => config.value.imageUploader !== false);
    const locale = computed(() => config.value.locale);
    const popupHandler = (event) => {
      var _a3, _b2, _c, _d;
      if (!((_a3 = emojiButtonRef.value) == null ? void 0 : _a3.contains(event.target)) && !((_b2 = emojiPopupRef.value) == null ? void 0 : _b2.contains(event.target)))
        showEmoji.value = false;
      if (!((_c = gifButtonRef.value) == null ? void 0 : _c.contains(event.target)) && !((_d = gifPopupRef.value) == null ? void 0 : _d.contains(event.target)))
        showGif.value = false;
    };
    const onLogin = (event) => {
      event.preventDefault();
      loginRef.value.show(true);
    };
    const onImageUpload = () => {
      const inputElement = imageUploadRef.value;
      if (inputElement.files && canUploadImage.value)
        void props.uploadImage(inputElement.files[0]).then(() => {
          inputElement.value = "";
        });
    };
    onMounted(() => {
      document.body.addEventListener("click", popupHandler);
    }), onUnmounted(() => {
      document.body.removeEventListener("click", popupHandler);
    });
    return (_ctx, _cache) => {
      const _component_ClientOnly = resolveComponent("ClientOnly");
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [createVNode(Preview, {
          "show-preview": showPreview.value
        }, null, 8, ["show-preview"]), createElementVNode("div", _hoisted_1$1b, [createElementVNode("div", _hoisted_2$P, [createElementVNode("a", _hoisted_3$H, [createVNode(unref(MarkdownIcon))]), withDirectives(createElementVNode("button", {
          ref_key: "emojiButtonRef",
          ref: emojiButtonRef,
          type: "button",
          class: normalizeClass(["wl-action", {
            active: showEmoji.value
          }]),
          title: locale.value.emoji,
          onClick: _cache[0] || (_cache[0] = ($event) => showEmoji.value = !showEmoji.value)
        }, [createVNode(unref(EmojiIcon))], 10, _hoisted_4$w), [[vShow, unref(emoji2).tabs.length]]), unref(config).search ? (openBlock(), createElementBlock("button", {
          key: 0,
          ref_key: "gifButtonRef",
          ref: gifButtonRef,
          type: "button",
          class: normalizeClass(["wl-action", {
            active: showGif.value
          }]),
          title: locale.value.gif,
          onClick: _cache[1] || (_cache[1] = ($event) => showGif.value = !showGif.value)
        }, [createVNode(unref(GifIcon))], 10, _hoisted_5$m)) : createCommentVNode("v-if", true), createElementVNode(
          "input",
          {
            id: "wl-image-upload",
            ref_key: "imageUploadRef",
            ref: imageUploadRef,
            class: "upload",
            type: "file",
            accept: ".png,.jpg,.jpeg,.webp,.bmp,.gif",
            onChange: onImageUpload
          },
          null,
          544
          /* HYDRATE_EVENTS, NEED_PATCH */
        ), canUploadImage.value ? (openBlock(), createElementBlock("label", {
          key: 1,
          for: "wl-image-upload",
          class: "wl-action",
          title: locale.value.uploadImage
        }, [createVNode(unref(ImageIcon))], 8, _hoisted_6$i)) : createCommentVNode("v-if", true), createElementVNode("button", {
          type: "button",
          class: normalizeClass(["wl-action", {
            active: showPreview.value
          }]),
          title: locale.value.preview,
          onClick: _cache[2] || (_cache[2] = ($event) => showPreview.value = !showPreview.value)
        }, [createVNode(unref(PreviewIcon))], 10, _hoisted_7$d)]), createElementVNode("div", _hoisted_8$b, [_hoisted_9$9, createElementVNode("div", _hoisted_10$8, [createTextVNode(
          toDisplayString(_ctx.wordNumber) + " ",
          1
          /* TEXT */
        ), unref(config).wordLimit ? (openBlock(), createElementBlock("span", _hoisted_11$7, [createTextVNode("  /  "), createElementVNode("span", {
          class: normalizeClass({
            illegal: !_ctx.isWordNumberLegal
          }),
          textContent: toDisplayString(_ctx.wordLimit)
        }, null, 10, _hoisted_12$4)])) : createCommentVNode("v-if", true), createTextVNode(
          "  " + toDisplayString(locale.value.word),
          1
          /* TEXT */
        )]), unref(config).login !== "disable" && !_ctx.isLogin ? (openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          class: "wl-btn",
          onClick: onLogin,
          textContent: toDisplayString(locale.value.login)
        }, null, 8, _hoisted_13$4)) : createCommentVNode("v-if", true), unref(config).login !== "force" || _ctx.isLogin ? (openBlock(), createElementBlock("button", {
          key: 1,
          type: "submit",
          class: "primary wl-btn",
          title: "Cmd|Ctrl + Enter",
          disabled: _ctx.isSubmitting,
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("submit"))
        }, [_ctx.isSubmitting ? (openBlock(), createBlock(unref(LoadingIcon), {
          key: 0,
          size: 16
        })) : (openBlock(), createElementBlock(
          Fragment,
          {
            key: 1
          },
          [createTextVNode(
            toDisplayString(locale.value.submit),
            1
            /* TEXT */
          )],
          64
          /* STABLE_FRAGMENT */
        ))], 8, _hoisted_14$4)) : createCommentVNode("v-if", true)]), createElementVNode(
          "div",
          {
            ref_key: "gifPopupRef",
            ref: gifPopupRef,
            class: normalizeClass(["wl-gif-popup", {
              display: showGif.value
            }])
          },
          [createVNode(GifPopup, {
            "show-gif": showGif.value,
            onInsert: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("insert", $event))
          }, null, 8, ["show-gif"])],
          2
          /* CLASS */
        ), createElementVNode(
          "div",
          {
            ref_key: "emojiPopupRef",
            ref: emojiPopupRef,
            class: normalizeClass(["wl-emoji-popup", {
              display: showEmoji.value
            }])
          },
          [createVNode(EmojiPopup, {
            emoji: unref(emoji2),
            "show-emoji": showEmoji.value,
            onInsert: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("insert", $event))
          }, null, 8, ["emoji", "show-emoji"])],
          2
          /* CLASS */
        ), createVNode(_component_ClientOnly, null, {
          default: withCtx(() => [createVNode(
            unref(Index),
            {
              ref_key: "loginRef",
              ref: loginRef,
              onLogin: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("login"))
            },
            null,
            512
            /* NEED_PATCH */
          )]),
          _: 1
          /* STABLE */
        })])],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});
const Footer$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1s, [["__file", "Footer.vue"]]);
const _sfc_main$1r = defineComponent({
  setup() {
    const userInfo2 = useUserInfo();
    const showDialog = ref(false);
    const avatarUrl = ref(userInfo2.value.avatar ?? "");
    const oldAvatarUrl = ref(userInfo2.value.avatar ?? "");
    const nickname = ref(userInfo2.value.nickname ?? "");
    const imageValid = ref(false);
    const imageCache = useImageCache();
    const viewAvatarUrl = computed(() => {
      return imageCache[avatarUrl.value].value;
    });
    return {
      userInfo: userInfo2,
      showDialog,
      avatarUrl,
      oldAvatarUrl,
      nickname,
      imageValid,
      imageCache,
      viewAvatarUrl
    };
  },
  watch: {
    showDialog(show) {
      if (show) {
        this.avatarUrl = this.userInfo.avatar ?? "";
        this.oldAvatarUrl = this.userInfo.avatar ?? "";
        this.nickname = this.userInfo.nickname ?? "";
      }
    },
    userInfo(newInfo) {
      this.avatarUrl = newInfo.avatar ?? "";
      this.nickname = newInfo.nickname ?? "";
    }
  },
  methods: {
    show(open = true) {
      this.showDialog = open;
    },
    onUpload() {
      const inputElement = this.$refs.avatarUploadRef;
      if (this.userInfo.id && inputElement.files) {
        const file = inputElement.files[0];
        const suf = getFileExtension(file.name);
        const filename = `avatar/avatar_${this.userInfo.id}_${Date.now().toString(36)}${suf}`;
        ossPutImage(file, filename).then((url) => {
          this.$msg({
            type: "success",
            text: "头像上传成功"
          });
          this.avatarUrl = url;
        }).catch((err2) => {
          this.$msg({
            type: "error",
            text: "头像上传失败: " + err2.message
          });
        });
      }
    },
    async onModify() {
      let succ = true;
      if (this.avatarUrl !== this.userInfo.avatar) {
        succ && (succ = await this.modify("avatar", this.avatarUrl, () => this.userInfo.avatar = this.avatarUrl));
      }
      if (this.nickname !== this.userInfo.nickname) {
        succ && (succ = await this.modify("nickname", this.nickname, () => this.userInfo.nickname = this.nickname));
      }
      if (succ)
        this.show(false);
    },
    async modify(field, value, cb) {
      var _a3;
      try {
        await this.$api.modifyUserInfo(this.userInfo.id, field, value);
        this.oldAvatarUrl = this.avatarUrl;
        cb();
        return true;
      } catch (err2) {
        this.$msg({
          type: "error",
          text: `修改${{
            avatar: "头像",
            nickname: "昵称"
          }[field]}失败: ` + (((_a3 = err2.data) == null ? void 0 : _a3.what) || err2.status)
        });
        return false;
      }
    }
  }
});
const LoginInfoDialog_vue_vue_type_style_index_0_scoped_6a4103bf_lang = "";
const _withScopeId$5 = (n2) => (pushScopeId("data-v-6a4103bf"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1a = {
  class: "form"
};
const _hoisted_2$O = {
  class: "form-avatar-preview"
};
const _hoisted_3$G = ["src"];
const _hoisted_4$v = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "头像",
  -1
  /* HOISTED */
));
const _hoisted_5$l = {
  class: "form-row"
};
const _hoisted_6$h = {
  class: "btn input-right",
  for: "avatarUpload"
};
const _hoisted_7$c = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "form-header"
  },
  "昵称",
  -1
  /* HOISTED */
));
const _hoisted_8$a = {
  class: "btn-row"
};
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  const _component_GDialog = resolveComponent("GDialog");
  return openBlock(), createBlock(_component_GDialog, {
    modelValue: _ctx.showDialog,
    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.showDialog = $event),
    "max-width": 400
  }, {
    default: withCtx(() => [createElementVNode("div", _hoisted_1$1a, [withDirectives(createElementVNode(
      "div",
      _hoisted_2$O,
      [createElementVNode("img", {
        class: "form-img",
        src: _ctx.viewAvatarUrl,
        onLoad: _cache[0] || (_cache[0] = ($event) => _ctx.imageValid = true),
        onError: _cache[1] || (_cache[1] = ($event) => _ctx.imageValid = false)
      }, null, 40, _hoisted_3$G)],
      512
      /* NEED_PATCH */
    ), [[vShow, _ctx.imageValid]]), _hoisted_4$v, createElementVNode("div", _hoisted_5$l, [withDirectives(createElementVNode(
      "input",
      {
        class: "form-input with-btn",
        type: "text",
        placeholder: "输入头像图片地址..",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.avatarUrl = $event)
      },
      null,
      512
      /* NEED_PATCH */
    ), [[vModelText, _ctx.avatarUrl]]), createElementVNode("label", _hoisted_6$h, [createVNode(_component_xicons, {
      icon: "Upload"
    }, {
      default: withCtx(() => [createTextVNode("上传")]),
      _: 1
      /* STABLE */
    })]), withDirectives(createElementVNode(
      "input",
      {
        id: "avatarUpload",
        name: "avatarUpload",
        ref: "avatarUploadRef",
        type: "file",
        accept: ".png,.jpg,.jpeg,.webp,.bmp,.gif",
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.onUpload && _ctx.onUpload(...args))
      },
      null,
      544
      /* HYDRATE_EVENTS, NEED_PATCH */
    ), [[vShow, false]]), createCommentVNode(' <button class="" @click="onUpload"></button> ')]), _hoisted_7$c, createElementVNode("div", null, [withDirectives(createElementVNode(
      "input",
      {
        type: "text",
        placeholder: "输入昵称..",
        class: "form-input",
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.nickname = $event)
      },
      null,
      512
      /* NEED_PATCH */
    ), [[vModelText, _ctx.nickname]])]), createElementVNode("div", _hoisted_8$a, [createElementVNode("button", {
      class: "btn",
      onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onModify && _ctx.onModify(...args))
    }, " 提交 ")])])]),
    _: 1
    /* STABLE */
  }, 8, ["modelValue"]);
}
const LoginInfoDialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$1r, [["render", _sfc_render$K], ["__scopeId", "data-v-6a4103bf"], ["__file", "LoginInfoDialog.vue"]]);
const _hoisted_1$19 = {
  key: 0,
  class: "wl-login-info"
};
const _hoisted_2$N = {
  class: "wl-avatar"
};
const _hoisted_3$F = ["title"];
const _hoisted_4$u = ["src"];
const _hoisted_5$k = {
  key: 1,
  class: "no-indent wl-avatar-alttext"
};
const _hoisted_6$g = ["textContent"];
const _sfc_main$1q = /* @__PURE__ */ defineComponent({
  __name: "LoginInfo",
  props: {
    isLogin: {
      type: Boolean
    },
    cmtEdit: {}
  },
  emits: ["logout"],
  setup(__props, {
    emit
  }) {
    const config = inject("config");
    const token2 = useAccessToken();
    const userInfo2 = useUserInfo();
    const imageCache = useImageCache();
    const dialogRef = ref(null);
    const locale = computed(() => config.value.locale);
    const userDisplayName = computed(() => userInfo2.value.nickname || userInfo2.value.id);
    const viewAvatarUrl = computed(() => imageCache[userInfo2.value.avatar].value);
    const onLogout = () => {
      token2.value = "";
      userInfo2.value = {};
      emit("logout");
    };
    const onProfile = (event) => {
      event.preventDefault();
      dialogRef.value.show();
    };
    return (_ctx, _cache) => {
      var _a3;
      return unref(config).login !== "disable" && _ctx.isLogin && !((_a3 = _ctx.cmtEdit) == null ? void 0 : _a3.id) ? (openBlock(), createElementBlock("div", _hoisted_1$19, [createElementVNode("div", _hoisted_2$N, [createElementVNode("button", {
        type: "submit",
        class: "wl-logout-btn",
        title: locale.value.logout,
        onClick: onLogout
      }, [createVNode(unref(CloseIcon), {
        size: 14
      })], 8, _hoisted_3$F), createElementVNode("a", {
        href: "#",
        class: "wl-login-nick",
        "aria-label": "Profile",
        title: "点击修改头像",
        onClick: onProfile
      }, [unref(userInfo2).avatar ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: viewAvatarUrl.value,
        alt: "avatar"
      }, null, 8, _hoisted_4$u)) : (openBlock(), createElementBlock("p", _hoisted_5$k, "暂无头像"))])]), createElementVNode("a", {
        href: "#",
        class: "wl-login-nick",
        "aria-label": "Profile",
        title: "点击修改头像",
        onClick: onProfile,
        textContent: toDisplayString(userDisplayName.value)
      }, null, 8, _hoisted_6$g), createVNode(
        LoginInfoDialog,
        {
          ref_key: "dialogRef",
          ref: dialogRef
        },
        null,
        512
        /* NEED_PATCH */
      )])) : createCommentVNode("v-if", true);
    };
  }
});
const LoginInfo_vue_vue_type_style_index_0_scoped_f7afdc0a_lang = "";
const LoginInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$1q, [["__scopeId", "data-v-f7afdc0a"], ["__file", "LoginInfo.vue"]]);
const _hoisted_1$18 = {
  class: "wl-comment"
};
const _hoisted_2$M = {
  class: "wl-panel"
};
const _hoisted_3$E = ["placeholder"];
const _hoisted_4$t = ["title"];
const _sfc_main$1p = /* @__PURE__ */ defineComponent({
  __name: "Index",
  props: {
    cmtEdit: {
      default: null
    },
    rootId: {
      default: ""
    },
    replyId: {
      default: ""
    },
    replyUserId: {},
    replyUser: {
      default: ""
    }
  },
  emits: ["log", "cancelEdit", "cancelReply", "submit"],
  setup(__props, {
    expose: __expose,
    emit
  }) {
    const props = __props;
    __expose();
    const articleId = inject("articleId");
    const config = inject("config");
    const api = inject("api");
    inject("emoji");
    const msg = inject("msg");
    const editor = useEditor();
    const userMeta = useUserMeta();
    const userInfo2 = useUserInfo();
    const token2 = useAccessToken();
    ref({});
    const editorRef = ref(null);
    const footerRef = ref(null);
    const wordNumber = ref(0);
    const wordLimit = ref(0);
    const isWordNumberLegal = ref(false);
    const content = ref("");
    const isSubmitting = ref(false);
    const isLogin = computed(() => Boolean(token2.value));
    const locale = computed(() => config.value.locale);
    const canUploadImage = computed(() => config.value.imageUploader !== false);
    const insert = (content2) => {
      const textArea = editorRef.value;
      const startPosition = textArea.selectionStart;
      const endPosition = textArea.selectionEnd || 0;
      const scrollTop = textArea.scrollTop;
      editor.value = textArea.value.substring(0, startPosition) + content2 + textArea.value.substring(endPosition, textArea.value.length);
      textArea.focus();
      textArea.selectionStart = startPosition + content2.length;
      textArea.selectionEnd = startPosition + content2.length;
      textArea.scrollTop = scrollTop;
    };
    const onKeyDown = (event) => {
      const key = event.key;
      if ((event.ctrlKey || event.metaKey) && key === "Enter")
        void submitComment();
    };
    const uploadImage = (file) => {
      const uploadText = `![${config.value.locale.uploading} ${file.name}]()`;
      insert(uploadText);
      isSubmitting.value = true;
      const suf = getFileExtension(file.name);
      const uploadFilename = "image_" + Date.now().toString(36) + suf;
      return Promise.resolve().then(() => imageUpload(file, uploadFilename)).then((url) => {
        editor.value = editor.value.replace(uploadText, `\r
![${file.name}](${url})`);
      }).catch((err2) => {
        msg({
          type: "error",
          text: "图片" + uploadFilename + "上传失败: " + err2.message
        });
        editor.value = editor.value.replace(uploadText, `![上传失败 ${file.name}]()`);
        console.error(err2);
      }).then(() => {
        isSubmitting.value = false;
      });
    };
    const onDrop = (event) => {
      var _a3;
      if ((_a3 = event.dataTransfer) == null ? void 0 : _a3.items) {
        const file = getImageFromDataTransfer(event.dataTransfer.items);
        if (file && canUploadImage.value) {
          void uploadImage(file);
          event.preventDefault();
        }
      }
    };
    const onPaste = (event) => {
      if (event.clipboardData) {
        const file = getImageFromDataTransfer(event.clipboardData.items);
        if (file && canUploadImage.value)
          void uploadImage(file);
      }
    };
    const onClose = () => {
      if (props.replyId) {
        emit("cancelReply");
      } else {
        emit("cancelEdit");
      }
    };
    const submitComment = async () => {
      var _a3, _b2, _c;
      const {
        login,
        wordLimit: wordLimit2,
        // requiredMeta,
        recaptchaV3Key,
        turnstileKey
      } = config.value;
      const cmt = {
        id: articleId.value,
        userId: userMeta.value.nick,
        content: content.value,
        meta: {
          userAgent: await userAgent()
        }
        // email: userMeta.value.mail,
        // link: userMeta.value.link,
        // ua,
      };
      if (token2.value) {
        cmt.userId = userInfo2.value.id;
      } else {
        if (login === "force")
          return;
        if (!cmt.userId)
          cmt.userId = locale.value.anonymous;
      }
      if (!cmt.content) {
        (_a3 = editorRef.value) == null ? void 0 : _a3.focus();
        return;
      }
      if (!isWordNumberLegal.value)
        return alert(locale.value.wordHint.replace("$0", wordLimit2[0].toString()).replace("$1", wordLimit2[1].toString()).replace("$2", wordNumber.value.toString()));
      cmt.content = purify.sanitize(cmt.content);
      cmt.content = encodeURIComponent(cmt.content);
      if (props.replyId && props.rootId) {
        cmt.replyTo = props.replyId;
        cmt.replyUserId = props.replyUserId;
        cmt.replyRoot = props.rootId;
      }
      isSubmitting.value = true;
      try {
        if (recaptchaV3Key)
          cmt.recaptchaV3 = await useReCaptcha(recaptchaV3Key).execute("social");
        if (turnstileKey)
          cmt.turnstile = await useTurnstile(turnstileKey).execute("social");
        const resp = await (props.cmtEdit ? api.editComment(articleId.value, props.cmtEdit.id, cmt.replyRoot ?? props.cmtEdit.id, cmt.content) : api.addComment(articleId.value, userInfo2.value.id, cmt.content, cmt.meta, cmt.replyTo, cmt.replyUserId, cmt.replyRoot));
        const newCmt = props.cmtEdit ? {
          ...props.cmtEdit,
          content: content.value
        } : {
          ...resp.data,
          user: userInfo2.value
        };
        emit("submit", newCmt, !props.cmtEdit);
        isSubmitting.value = false;
        editor.value = "";
        if (props.replyId)
          emit("cancelReply");
        if ((_b2 = props.cmtEdit) == null ? void 0 : _b2.id)
          emit("cancelEdit");
      } catch (err2) {
        isSubmitting.value = false;
        alert(((_c = err2.data) == null ? void 0 : _c.what) || err2.status);
      }
    };
    watch(userInfo2, () => emit("log"));
    watch([config, wordNumber], ([config2, wordNumber2]) => {
      const {
        wordLimit: limit
      } = config2;
      if (limit) {
        if (wordNumber2 < limit[0] && limit[0] !== 0) {
          wordLimit.value = limit[0];
          isWordNumberLegal.value = false;
        } else if (wordNumber2 > limit[1]) {
          wordLimit.value = limit[1];
          isWordNumberLegal.value = false;
        } else {
          wordLimit.value = limit[1];
          isWordNumberLegal.value = true;
        }
      } else {
        wordLimit.value = 0;
        isWordNumberLegal.value = true;
      }
    }, {
      immediate: true
    });
    onMounted(() => {
      var _a3;
      if ((_a3 = props.cmtEdit) == null ? void 0 : _a3.id) {
        editor.value = decodeURIComponent(props.cmtEdit.content);
      }
      watch(() => editor.value, (value) => {
        content.value = value;
        wordNumber.value = getWordNumber(value);
        if (value)
          n$7(editorRef.value);
        else
          n$7.destroy(editorRef.value);
      }, {
        immediate: true
      });
    });
    onUnmounted(() => {
    });
    return (_ctx, _cache) => {
      var _a3;
      return openBlock(), createElementBlock("div", _hoisted_1$18, [createCommentVNode(" 左侧头像昵称信息栏（仅添加评论显示） "), createVNode(LoginInfo, {
        "is-login": isLogin.value,
        "cmt-edit": _ctx.cmtEdit,
        onLogout: _cache[0] || (_cache[0] = () => {
        })
      }, null, 8, ["is-login", "cmt-edit"]), createCommentVNode(" 评论编辑框 "), createElementVNode("div", _hoisted_2$M, [createCommentVNode(' <div v-if="config.login !== \'force\' && config.meta.length && !isLogin" class="wl-header"\r\n        :class="`item${config.meta.length}`">\r\n        <div v-for="kind in config.meta" :key="kind" class="wl-header-item">\r\n          <label :for="`wl-${kind}`" v-text="locale[kind] +\r\n            (config.requiredMeta.includes(kind) || !config.requiredMeta.length\r\n              ? \'\'\r\n              : `(${locale.optional})`)\r\n            " />\r\n\r\n          <input :id="`wl-${kind}`" :ref="(element) => {\r\n              if (element) inputRefs[kind] = element as HTMLInputElement;\r\n            }\r\n            " v-model="userMeta[kind]" class="wl-input" :class="`wl-${kind}`" :name="kind"\r\n            :type="kind === \'mail\' ? \'email\' : \'text\'" />\r\n        </div>\r\n      </div> '), withDirectives(createElementVNode("textarea", {
        id: "wl-edit",
        ref_key: "editorRef",
        ref: editorRef,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(editor) ? editor.value = $event : null),
        class: "wl-editor",
        placeholder: _ctx.replyUser ? `回复 @${_ctx.replyUser}:` : locale.value.placeholder,
        onKeydown: onKeyDown,
        onDrop,
        onPaste
      }, null, 40, _hoisted_3$E), [[vModelText, unref(editor)]]), createVNode(Footer$1, {
        ref_key: "footerRef",
        ref: footerRef,
        "word-number": wordNumber.value,
        "word-limit": wordLimit.value,
        "upload-image": uploadImage,
        "is-submitting": isSubmitting.value,
        "is-login": isLogin.value,
        "is-word-number-legal": isWordNumberLegal.value,
        onInsert: _cache[2] || (_cache[2] = ($event) => insert($event)),
        onLogin: _cache[3] || (_cache[3] = () => {
        }),
        onSubmit: submitComment
      }, null, 8, ["word-number", "word-limit", "is-submitting", "is-login", "is-word-number-legal"])]), _ctx.replyId || ((_a3 = _ctx.cmtEdit) == null ? void 0 : _a3.id) ? (openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: "wl-close",
        title: locale.value.cancelReply,
        onClick: onClose
      }, [createVNode(unref(CloseIcon), {
        size: 24
      })], 8, _hoisted_4$t)) : createCommentVNode("v-if", true)]);
    };
  }
});
const CommentBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$1p, [["__file", "Index.vue"]]);
const _hoisted_1$17 = ["id"];
const _hoisted_2$L = {
  class: "wl-user",
  "aria-hidden": "true"
};
const _hoisted_3$D = ["src"];
const _hoisted_4$s = {
  class: "wl-head"
};
const _hoisted_5$j = {
  class: "wl-nick"
};
const _hoisted_6$f = ["href"];
const _hoisted_7$b = {
  key: 1,
  class: "wl-nick-text"
};
const _hoisted_8$9 = ["textContent"];
const _hoisted_9$8 = ["textContent"];
const _hoisted_10$7 = ["textContent"];
const _hoisted_11$6 = ["textContent"];
const _hoisted_12$3 = ["textContent"];
const _hoisted_13$3 = ["data-value", "textContent"];
const _hoisted_14$3 = {
  class: "wl-comment-actions"
};
const _hoisted_15$1 = ["title"];
const _hoisted_16$1 = ["title"];
const _hoisted_17 = ["textContent"];
const _hoisted_18 = ["title"];
const _hoisted_19 = ["textContent"];
const _hoisted_20 = {
  class: "wl-meta",
  "aria-hidden": "true"
};
const _hoisted_21 = ["data-value", "textContent"];
const _hoisted_22 = ["data-value", "textContent"];
const _hoisted_23 = {
  key: 0,
  class: "wl-reply-name"
};
const _hoisted_24 = {
  key: 1,
  class: "wl-waiting-text"
};
const _hoisted_25 = ["innerHTML"];
const _hoisted_26 = {
  key: 3,
  class: "wl-admin-actions"
};
const _hoisted_27 = {
  class: "wl-comment-status"
};
const _hoisted_28 = ["disabled", "onClick", "textContent"];
const _hoisted_29 = {
  key: 5,
  class: "wl-quote"
};
const _sfc_main$1o = /* @__PURE__ */ defineComponent({
  __name: "CommentCard",
  props: {
    comment: {},
    replyCmt: {},
    rootCmt: {},
    cmtEdit: {
      default: null
    },
    cmtReply: {
      default: null
    }
  },
  emits: ["log", "submit", "delete", "edit", "like", "status", "sticky", "reply"],
  setup(__props) {
    const props = __props;
    inject("articleId");
    const config = inject("config");
    const emoji2 = inject("emoji");
    const commentStatus = ["approved", "waiting", "spam"];
    const {
      comment
    } = toRefs(props);
    const now2 = useNow();
    const token2 = useAccessToken();
    const userInfo2 = useUserInfo();
    const imageCache = useImageCache();
    const locale = computed(() => config.value.locale);
    const link = computed(() => {
      const {
        user
      } = comment.value;
      if (!user)
        return "";
      const link2 = user.meta.link;
      return link2 ? isLinkHttp(link2) ? link2 : `https://${link2}` : "";
    });
    const isLogin = computed(() => !!token2.value);
    const isLiked = computed(() => {
      var _a3, _b2;
      return !!((_b2 = (_a3 = comment.value.meta) == null ? void 0 : _a3.likes) == null ? void 0 : _b2.includes(userInfo2.value.id));
    });
    const time = computed(() => getTimeAgo(new Date(comment.value.time), now2.value, locale.value));
    const viewAvatarUrl = computed(() => {
      var _a3;
      return imageCache[(_a3 = comment.value.user) == null ? void 0 : _a3.avatar].value;
    });
    const contentHTML = computed(() => {
      const {
        content
      } = comment.value;
      const deContent = decodeURIComponent(content);
      return parseMarkdown(deContent, {
        emojiMap: emoji2.value.map
      });
    });
    const replyDisplayname = computed(() => {
      if (!props.replyCmt && props.comment.replyTo !== props.comment.replyRoot) {
        return "(已删除)";
      }
      const {
        replyCmt
      } = props;
      if (!replyCmt || !replyCmt.user) {
        return null;
      }
      const {
        user
      } = replyCmt;
      return user.nickname || user.id || replyCmt.userId;
    });
    const displayName = computed(() => {
      const {
        user
      } = comment.value;
      return (user == null ? void 0 : user.nickname) || (user == null ? void 0 : user.id) || comment.value.userId;
    });
    const displayAddr = computed(() => {
      const {
        meta
      } = comment.value;
      let [country, region2, city] = (meta.addr ?? "||").split("|");
      let m2 = (region2 == null ? void 0 : region2.match(/(.*)[省市]/)) ?? null;
      if (m2 == null ? void 0 : m2[1]) {
        region2 = m2[1];
      }
      region2 = {
        "广西壮族自治区": "广西",
        "新疆维吾尔自治区": "新疆",
        "西藏自治区": "西藏",
        "宁夏回族自治区": "宁夏",
        "内蒙古自治区": "内蒙古",
        "香港特别行政区": "香港",
        "澳门特别行政区": "澳门"
      }[region2] ?? region2;
      m2 = (city == null ? void 0 : city.match(/(.*)市/)) ?? null;
      if (m2 == null ? void 0 : m2[1]) {
        city = m2[1];
      }
      return country !== "中国" ? country === region2 ? country : country + (region2 ?? "") : region2 === city ? region2 : region2 + (city ?? "");
    });
    const isAdmin = computed(() => userInfo2.value.type === "administrator");
    const isOwner = computed(() => props.comment.userId && userInfo2.value.id === props.comment.userId);
    const isReplyingCurrent = computed(() => {
      var _a3;
      return props.comment.id === ((_a3 = props.cmtReply) == null ? void 0 : _a3.id);
    });
    const isEditingCurrent = computed(() => {
      var _a3;
      return props.comment.id === ((_a3 = props.cmtEdit) == null ? void 0 : _a3.id);
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f;
      const _component_CommentCard = resolveComponent("CommentCard", true);
      return openBlock(), createElementBlock("div", {
        id: unref(comment).id,
        class: "wl-card-item"
      }, [createElementVNode("div", _hoisted_2$L, [((_a3 = unref(comment).user) == null ? void 0 : _a3.avatar) ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: viewAvatarUrl.value
      }, null, 8, _hoisted_3$D)) : (openBlock(), createBlock(unref(DefaultUserAvatar), {
        key: 1,
        size: 35,
        style: {
          opacity: 0.6
        }
      })), ((_b2 = unref(comment).user) == null ? void 0 : _b2.type) ? (openBlock(), createBlock(unref(VerifiedIcon), {
        key: 2
      })) : createCommentVNode("v-if", true)]), createElementVNode(
        "div",
        {
          class: normalizeClass(["wl-card", {
            "wl-waiting": unref(comment).status === "waiting"
          }])
        },
        [createElementVNode("div", _hoisted_4$s, [createCommentVNode(" 评论者显示名字(昵称/ID) "), createElementVNode("span", _hoisted_5$j, [link.value ? (openBlock(), createElementBlock("a", {
          key: 0,
          class: "wl-nick-text",
          href: link.value,
          target: "_blank",
          rel: "nofollow noopener noreferrer"
        }, toDisplayString(displayName.value), 9, _hoisted_6$f)) : (openBlock(), createElementBlock(
          "span",
          _hoisted_7$b,
          toDisplayString(displayName.value),
          1
          /* TEXT */
        )), createVNode(unref(VerifiedIcon), {
          class: "sm-hidden"
        })]), createCommentVNode(" 评论者用户类型 "), ((_c = unref(comment).user) == null ? void 0 : _c.type) === "administrator" ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-badge",
          textContent: toDisplayString(locale.value.admin)
        }, null, 8, _hoisted_8$9)) : createCommentVNode("v-if", true), createCommentVNode(" 评论者用户标签 "), (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(comment).meta.labels, (label) => {
            return openBlock(), createElementBlock("span", {
              class: "wl-badge",
              textContent: toDisplayString(label)
            }, null, 8, _hoisted_9$8);
          }),
          256
          /* UNKEYED_FRAGMENT */
        )), createCommentVNode(" 评论置顶标签 "), unref(comment).meta.sticky ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "wl-badge",
          textContent: toDisplayString(locale.value.sticky)
        }, null, 8, _hoisted_10$7)) : createCommentVNode("v-if", true), createCommentVNode(" 评论者等级 "), unref(comment).level !== void 0 && unref(comment).level >= 0 ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(`wl-badge level${unref(comment).level}`),
          textContent: toDisplayString(locale.value[`level${unref(comment).level}`] || `Level ${unref(comment).level}`)
        }, null, 10, _hoisted_11$6)) : createCommentVNode("v-if", true), createCommentVNode(" 评论时间 "), createElementVNode("span", {
          class: "wl-time",
          textContent: toDisplayString(time.value)
        }, null, 8, _hoisted_12$3), createCommentVNode(" 评论者IP所在地 "), unref(comment).meta.addr ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: "wl-addr",
          "data-value": unref(comment).meta.addr,
          textContent: toDisplayString(displayAddr.value)
        }, null, 8, _hoisted_13$3)) : createCommentVNode("v-if", true), createCommentVNode(" 右上角操作按钮 "), createElementVNode("div", _hoisted_14$3, [createCommentVNode(" 编辑评论按钮 "), isAdmin.value || isOwner.value ? (openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          class: normalizeClass(["wl-edit", {
            active: isEditingCurrent.value
          }]),
          title: isEditingCurrent.value ? "取消编辑" : locale.value.reply,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("edit", isEditingCurrent.value ? null : unref(comment)))
        }, [createVNode(unref(EditIcon))], 10, _hoisted_15$1)) : createCommentVNode("v-if", true), createCommentVNode(" 删除评论按钮 "), isAdmin.value || isOwner.value ? (openBlock(), createElementBlock("button", {
          key: 1,
          type: "button",
          class: "wl-delete",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("delete", unref(comment)))
        }, [createVNode(unref(DeleteIcon))])) : createCommentVNode("v-if", true), createCommentVNode(" 点赞评论按钮 "), createElementVNode("button", {
          type: "button",
          class: normalizeClass(["wl-like", {
            "wl-disable-btn": !isLogin.value
          }]),
          title: isLiked.value ? locale.value.cancelLike : locale.value.like,
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("like", unref(comment)))
        }, [createVNode(unref(LikeIcon), {
          active: isLiked.value
        }, null, 8, ["active"]), unref(comment).meta.likes && unref(comment).meta.likes.length ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-actions-count",
          textContent: toDisplayString(unref(comment).meta.likes.length)
        }, null, 8, _hoisted_17)) : createCommentVNode("v-if", true)], 10, _hoisted_16$1), createCommentVNode(" 回复评论按钮 "), createElementVNode("button", {
          type: "button",
          class: normalizeClass(["wl-reply", {
            active: isReplyingCurrent.value,
            "wl-disable-btn": !isLogin.value
          }]),
          title: isReplyingCurrent.value ? locale.value.cancelReply : locale.value.reply,
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("reply", isReplyingCurrent.value ? null : unref(comment)))
        }, [createVNode(unref(ReplyIcon)), unref(comment).replies && unref(comment).replies.length ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-actions-count",
          textContent: toDisplayString(unref(comment).replies.length)
        }, null, 8, _hoisted_19)) : createCommentVNode("v-if", true)], 10, _hoisted_18)])]), createCommentVNode(" 评论附加属性 "), createElementVNode("div", _hoisted_20, [createCommentVNode(" 评论者浏览器 "), unref(comment).meta.browser ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-browser",
          "data-value": unref(comment).meta.browser,
          textContent: toDisplayString(unref(comment).meta.browser.split("/")[0])
        }, null, 8, _hoisted_21)) : createCommentVNode("v-if", true), createCommentVNode(" 评论者操作系统 "), unref(comment).meta.os ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "wl-os",
          "data-value": unref(comment).meta.os,
          textContent: toDisplayString(unref(comment).meta.os.split("/")[0])
        }, null, 8, _hoisted_22)) : createCommentVNode("v-if", true)]), replyDisplayname.value ? (openBlock(), createElementBlock(
          "div",
          _hoisted_23,
          "回复 @" + toDisplayString(replyDisplayname.value) + ":",
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true), createCommentVNode(" 评论内容 "), createCommentVNode(" eslint-disable vue/no-v-html "), !isEditingCurrent.value && !(isAdmin.value || isOwner.value) && unref(comment).status === "waiting" ? (openBlock(), createElementBlock("div", _hoisted_24, " 评论审核中.. ")) : !isEditingCurrent.value ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: "wl-content",
          innerHTML: contentHTML.value
        }, null, 8, _hoisted_25)) : createCommentVNode("v-if", true), createCommentVNode(" 评论管理员操作 "), createCommentVNode(" eslint-enable vue/no-v-html "), isAdmin.value && !isEditingCurrent.value ? (openBlock(), createElementBlock("div", _hoisted_26, [createCommentVNode(" 评论审核状态 "), createElementVNode("span", _hoisted_27, [(openBlock(), createElementBlock(
          Fragment,
          null,
          renderList(commentStatus, (status) => {
            return createElementVNode("button", {
              key: status,
              type: "submit",
              class: normalizeClass(`wl-btn wl-${status}`),
              disabled: unref(comment).status === status,
              onClick: ($event) => _ctx.$emit("status", {
                status,
                comment: unref(comment)
              }),
              textContent: toDisplayString(locale.value[status])
            }, null, 10, _hoisted_28);
          }),
          64
          /* STABLE_FRAGMENT */
        ))]), createCommentVNode(" 评论置顶按钮 "), isAdmin.value && !unref(comment).replyRoot ? (openBlock(), createElementBlock(
          "button",
          {
            key: 0,
            type: "submit",
            class: "wl-btn wl-sticky",
            onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("sticky", unref(comment)))
          },
          toDisplayString(unref(comment).meta.sticky ? locale.value.unsticky : locale.value.sticky),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true), isReplyingCurrent.value || isEditingCurrent.value ? (openBlock(), createElementBlock(
          "div",
          {
            key: 4,
            class: normalizeClass({
              "wl-reply-wrapper": isReplyingCurrent.value,
              "wl-edit-wrapper": isEditingCurrent.value
            })
          },
          [createVNode(unref(CommentBox), {
            "cmt-edit": _ctx.cmtEdit,
            "reply-id": (_d = _ctx.cmtReply) == null ? void 0 : _d.id,
            "reply-user-id": (_e2 = _ctx.cmtReply) == null ? void 0 : _e2.userId,
            "reply-user": displayName.value,
            "root-id": _ctx.rootCmt.id,
            onLog: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("log")),
            onCancelReply: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("reply", null)),
            onCancelEdit: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("edit", null)),
            onSubmit: _cache[8] || (_cache[8] = (cmt, add) => _ctx.$emit("submit", cmt, add))
          }, null, 8, ["cmt-edit", "reply-id", "reply-user-id", "reply-user", "root-id"])],
          2
          /* CLASS */
        )) : createCommentVNode("v-if", true), createCommentVNode(" 评论回复 "), ((_f = unref(comment).replies) == null ? void 0 : _f.length) ? (openBlock(), createElementBlock("div", _hoisted_29, [createCommentVNode(" FIXME: This is a upstream bug "), createCommentVNode(" eslint-disable-next-line vue/no-undef-components "), (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(comment).replies, (child) => {
            var _a4;
            return openBlock(), createBlock(_component_CommentCard, {
              key: child.id,
              comment: child,
              "reply-cmt": (_a4 = unref(comment).replies) == null ? void 0 : _a4.find((r2) => r2.id === child.replyTo),
              "root-cmt": unref(comment),
              "cmt-edit": _ctx.cmtEdit,
              "cmt-reply": _ctx.cmtReply,
              onLog: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("log")),
              onDelete: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("delete", $event)),
              onEdit: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("edit", $event)),
              onLike: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("like", $event)),
              onReply: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("reply", $event)),
              onStatus: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("status", $event)),
              onSticky: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("sticky", $event)),
              onSubmit: _cache[16] || (_cache[16] = (cmt, add) => _ctx.$emit("submit", cmt, add))
            }, null, 8, ["comment", "reply-cmt", "root-cmt", "cmt-edit", "cmt-reply"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])) : createCommentVNode("v-if", true)],
        2
        /* CLASS */
      )], 8, _hoisted_1$17);
    };
  }
});
const CommentCard_vue_vue_type_style_index_0_lang = "";
const CommentCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$1o, [["__file", "CommentCard.vue"]]);
const _hoisted_1$16 = {
  class: "wl-meta-head"
};
const _hoisted_2$K = {
  key: 0,
  class: "wl-count"
};
const _hoisted_3$C = ["textContent"];
const _hoisted_4$r = {
  class: "wl-reply-count"
};
const _hoisted_5$i = ["textContent"];
const _hoisted_6$e = {
  class: "wl-sort"
};
const _hoisted_7$a = ["onClick"];
const _hoisted_8$8 = {
  class: "wl-cards"
};
const _hoisted_9$7 = {
  key: 1,
  class: "wl-operation"
};
const _hoisted_10$6 = ["textContent"];
const _hoisted_11$5 = {
  key: 0,
  class: "wl-loading"
};
const _hoisted_12$2 = ["textContent"];
const _hoisted_13$2 = {
  class: "wl-operation"
};
const _hoisted_14$2 = ["textContent"];
const _hoisted_15 = {
  key: 3,
  class: "wl-power"
};
const _hoisted_16 = /* @__PURE__ */ createElementVNode(
  "a",
  {
    href: "https://github.com/walinejs/waline",
    target: "_blank",
    rel: "noopener noreferrer"
  },
  " Waline ",
  -1
  /* HOISTED */
);
const _sfc_main$1n = /* @__PURE__ */ defineComponent({
  __name: "WalineComment",
  setup(__props) {
    const sortKeyMap = {
      latest: "time_desc",
      oldest: "time_asc",
      hottest: "hot_desc"
    };
    const sortingMethods = Object.keys(sortKeyMap);
    const config = inject("config");
    const articleId = inject("articleId");
    const api = inject("api");
    const userInfo2 = useUserInfo();
    const status = ref("loading");
    const count = ref({
      root: 0,
      total: 0
    });
    const page = ref(1);
    const totalPages = ref(0);
    const walineRef = ref(null);
    const commentSortingRef = ref(config.value.commentSorting);
    const data = ref([]);
    const cmtReply = ref(null);
    const cmtEdit = ref(null);
    const darkmodeStyle = computed(() => getDarkStyle(config.value.dark));
    useStyleTag(darkmodeStyle, {
      id: "waline-darkmode"
    });
    const i18n = computed(() => config.value.locale);
    let abort;
    const getCommentData = (pageNumber) => {
      const {
        pageSize
      } = config.value;
      const controller = new AbortController();
      status.value = "loading";
      abort == null ? void 0 : abort();
      api.getComments(articleId.value, sortKeyMap[commentSortingRef.value], pageNumber, pageSize).then((resp) => {
        status.value = "success";
        if (resp.data) {
          data.value.push(...resp.data);
          page.value = pageNumber;
        }
        if (resp.meta) {
          count.value = resp.meta;
          totalPages.value = Math.ceil(count.value.root / pageSize);
        } else {
          count.value = {
            root: 0,
            total: 0
          };
        }
      }).catch((err2) => {
        if (err2.name !== "AbortError") {
          console.error(err2);
          status.value = "error";
        }
      });
      abort = controller.abort.bind(controller);
    };
    const loadMore = () => getCommentData(page.value + 1);
    const refresh2 = () => {
      count.value = {
        root: 0,
        total: 0
      };
      data.value = [];
      getCommentData(1);
    };
    const onSortByChange = (item) => {
      if (commentSortingRef.value !== item) {
        commentSortingRef.value = item;
        refresh2();
      }
    };
    const onReply = (comment) => {
      cmtReply.value = comment;
    };
    const onEdit = (comment) => {
      cmtEdit.value = comment;
    };
    const onSubmit = (comment, isAdd) => {
      if (isAdd) {
        if (comment.replyTo) {
          const rootIdx = data.value.findIndex(({
            id
          }) => id === comment.replyRoot);
          const rootCmt = data.value[rootIdx];
          if (!rootCmt)
            return;
          if (!Array.isArray(rootCmt.replies))
            rootCmt.replies = [];
          rootCmt.replies.push(comment);
          data.value[rootIdx] = rootCmt;
          count.value = {
            root: count.value.root,
            total: count.value.total + 1
          };
        } else {
          data.value = [comment, ...data.value];
          count.value = {
            root: count.value.root + 1,
            total: count.value.total + 1
          };
        }
      } else {
        const rootIdx = data.value.findIndex(({
          id
        }) => id === (comment.replyRoot || comment.id));
        const rootCmt = data.value[rootIdx];
        if (!rootCmt)
          return;
        if (comment.replyTo) {
          const replyCmt = rootCmt.replies.find(({
            id
          }) => id === comment.id);
          if (!replyCmt)
            return;
          replyCmt.content = comment.content;
          data.value[rootIdx] = rootCmt;
        } else {
          rootCmt.content = comment.content;
        }
        data.value[rootIdx] = rootCmt;
      }
    };
    const onStatusChange = async ({
      comment,
      status: status2
    }) => {
      if (comment.status === status2)
        return;
      try {
        await api.updateComment(articleId.value, comment.id, comment.userId, comment.replyRoot, "status", status2);
        comment.status = status2;
      } catch {
      }
    };
    const onSticky = async (comment) => {
      if (comment.replyRoot)
        return;
      try {
        await api.updateComment(articleId.value, comment.id, comment.userId, comment.replyRoot, "sticky", !comment.meta.sticky);
        comment.meta.sticky = !comment.meta.sticky;
      } catch {
      }
    };
    const onDelete = async ({
      id: commentId,
      userId,
      replyRoot = commentId
    }) => {
      if (!confirm("确定要删除评论?"))
        return;
      try {
        await api.deleteComment(articleId.value, userId, commentId, replyRoot);
        if (commentId === replyRoot) {
          data.value = data.value.filter((item) => item.id !== commentId);
        } else {
          const index2 = data.value.findIndex((it2) => it2.id === replyRoot);
          if (index2 >= 0) {
            const item = data.value[index2];
            item.replies = item.replies.filter((reply) => reply.id !== commentId);
            data.value[index2] = item;
          }
        }
      } catch {
      }
    };
    const onLike = async (comment) => {
      var _a3, _b2;
      const hasLiked = !!((_a3 = comment.meta.likes) == null ? void 0 : _a3.includes(userInfo2.value.id));
      try {
        await api.updateComment(articleId.value, comment.id, comment.userId, comment.replyRoot, hasLiked ? "likes$pull" : "likes$add", userInfo2.value.id);
        if (!hasLiked) {
          comment.meta.likes = (comment.meta.likes || []).concat(userInfo2.value.id);
        } else {
          comment.meta.likes = (_b2 = comment.meta.likes) == null ? void 0 : _b2.filter((userId) => userId !== userInfo2.value.id);
        }
      } catch {
      }
    };
    onMounted(() => {
      watch(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        () => [config.value.id, articleId],
        () => refresh2(),
        {
          immediate: true
        }
      );
    });
    onUnmounted(() => abort == null ? void 0 : abort());
    return (_ctx, _cache) => {
      var _a3, _b2;
      return openBlock(), createElementBlock(
        "div",
        {
          ref_key: "walineRef",
          ref: walineRef,
          "data-waline": ""
        },
        [createVNode(Reaction), !cmtReply.value && !cmtEdit.value ? (openBlock(), createBlock(unref(CommentBox), {
          key: 0,
          "article-id": unref(articleId),
          onLog: refresh2,
          onSubmit
        }, null, 8, ["article-id"])) : createCommentVNode("v-if", true), createElementVNode("div", _hoisted_1$16, [count.value ? (openBlock(), createElementBlock("div", _hoisted_2$K, [((_a3 = count.value) == null ? void 0 : _a3.root) !== void 0 ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "wl-num",
          textContent: toDisplayString(count.value.root)
        }, null, 8, _hoisted_3$C)) : createCommentVNode("v-if", true), createTextVNode(
          " " + toDisplayString(i18n.value.comment) + " ",
          1
          /* TEXT */
        ), createElementVNode("span", _hoisted_4$r, [((_b2 = count.value) == null ? void 0 : _b2.total) !== void 0 ? (openBlock(), createElementBlock("span", {
          key: 0,
          textContent: toDisplayString(count.value.total)
        }, null, 8, _hoisted_5$i)) : createCommentVNode("v-if", true), createTextVNode(" 回复 ")])])) : createCommentVNode("v-if", true), createElementVNode("ul", _hoisted_6$e, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(sortingMethods), (item) => {
            return openBlock(), createElementBlock("li", {
              key: item,
              class: normalizeClass({
                active: item === commentSortingRef.value
              }),
              onClick: ($event) => onSortByChange(item)
            }, toDisplayString(i18n.value[item]), 11, _hoisted_7$a);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])]), createElementVNode("div", _hoisted_8$8, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(data.value, (comment) => {
            return openBlock(), createBlock(CommentCard, {
              key: comment.id,
              "root-cmt": comment,
              comment,
              "cmt-reply": cmtReply.value,
              "cmt-edit": cmtEdit.value,
              onLog: refresh2,
              onReply,
              onEdit,
              onSubmit,
              onStatus: onStatusChange,
              onDelete,
              onSticky,
              onLike
            }, null, 8, ["root-cmt", "comment", "cmt-reply", "cmt-edit"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))]), status.value === "error" ? (openBlock(), createElementBlock("div", _hoisted_9$7, [createElementVNode("button", {
          type: "button",
          class: "wl-btn",
          onClick: refresh2,
          textContent: toDisplayString(i18n.value.refresh)
        }, null, 8, _hoisted_10$6)])) : (openBlock(), createElementBlock(
          Fragment,
          {
            key: 2
          },
          [status.value === "loading" ? (openBlock(), createElementBlock("div", _hoisted_11$5, [createVNode(unref(LoadingIcon), {
            size: 30
          })])) : !data.value.length ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "wl-empty",
            textContent: toDisplayString(i18n.value.sofa)
          }, null, 8, _hoisted_12$2)) : page.value < totalPages.value ? (openBlock(), createElementBlock(
            Fragment,
            {
              key: 2
            },
            [createCommentVNode(" Load more button "), createElementVNode("div", _hoisted_13$2, [createElementVNode("button", {
              type: "button",
              class: "wl-btn",
              onClick: loadMore,
              textContent: toDisplayString(i18n.value.more)
            }, null, 8, _hoisted_14$2)])],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : createCommentVNode("v-if", true)],
          64
          /* STABLE_FRAGMENT */
        )), createCommentVNode(" Copyright Information "), unref(config).copyright ? (openBlock(), createElementBlock("div", _hoisted_15, [createTextVNode(" Based on & Powered by "), _hoisted_16, createCommentVNode(" v{{ version }} ")])) : createCommentVNode("v-if", true)],
        512
        /* NEED_PATCH */
      );
    };
  }
});
const WalineComment_vue_vue_type_style_index_0_lang = "";
const WalineComment = /* @__PURE__ */ _export_sfc$1(_sfc_main$1n, [["__file", "WalineComment.vue"]]);
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  __name: "WalineGlobal",
  props: [
    "id",
    "path",
    "meta",
    "requiredMeta",
    "dark",
    "commentSorting",
    "lang",
    "locale",
    "pageSize",
    "wordLimit",
    // 'emoji',
    "login",
    // 'highlighter',
    // 'texRenderer',
    "imageUploader",
    "search",
    "copyright",
    "recaptchaV3Key",
    "turnstileKey"
    // 'reaction',
  ],
  setup(__props) {
    const props = __props;
    const {
      proxy: proxy2
    } = getCurrentInstance();
    const config = computed(() => getConfig(props));
    const pageData = usePageData$1();
    const articleId = computed(() => config.value.id || props.id || props.path);
    const emoji2 = useEmoji();
    onMounted(() => {
    });
    provide("config", config);
    provide("pageData", pageData);
    provide("articleId", articleId);
    provide("emoji", emoji2);
    provide("api", proxy2 == null ? void 0 : proxy2.$api);
    provide("msg", proxy2 == null ? void 0 : proxy2.$msg);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(WalineComment);
    };
  }
});
const WalineGlobal_vue_vue_type_style_index_0_lang = "";
const Waline$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1m, [["__file", "WalineGlobal.vue"]]);
const index$2 = "";
const waline = "";
const Waline = defineComponent({
  name: "Waline",
  props: {
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props) {
    const {
      options
    } = toRefs(props);
    const lang = usePageLang();
    const pageData = usePageData$1();
    const walineOption = computed(() => {
      var _a3;
      return {
        lang: lang.value || "zh-CN",
        dark: 'html[class="dark"]',
        path: withBase((_a3 = pageData.value) === null || _a3 === void 0 ? void 0 : _a3.path),
        ...options.value,
        pageview: false
      };
    });
    return () => h$5("div", {
      class: "reco-waline-wrapper"
    }, h$5(Waline$1, walineOption.value));
  }
});
const d$7 = ["id", "host", "repo", "repoid", "category", "categoryid", "mapping", "term", "strict", "reactionsenabled", "emitmetadata", "inputposition", "theme", "lang", "loading"], l$4 = /* @__PURE__ */ defineComponent({
  __name: "Giscus",
  props: {
    id: {},
    host: {},
    repo: {},
    repoId: {},
    category: {},
    categoryId: {},
    mapping: {},
    term: {},
    theme: {},
    strict: {},
    reactionsEnabled: {},
    emitMetadata: {},
    inputPosition: {},
    lang: {},
    loading: {}
  },
  setup(s2) {
    const t2 = ref(false);
    return onMounted(() => {
      t2.value = true, __vitePreload(() => import("./giscus-2a044aea-a5732e4a.js"), true ? [] : void 0);
    }), (e2, m2) => t2.value ? (openBlock(), createElementBlock("giscus-widget", {
      key: 0,
      id: e2.id,
      host: e2.host,
      repo: e2.repo,
      repoid: e2.repoId,
      category: e2.category,
      categoryid: e2.categoryId,
      mapping: e2.mapping,
      term: e2.term,
      strict: e2.strict,
      reactionsenabled: e2.reactionsEnabled,
      emitmetadata: e2.emitMetadata,
      inputposition: e2.inputPosition,
      theme: e2.theme,
      lang: e2.lang,
      loading: e2.loading
    }, null, 8, d$7)) : createCommentVNode("", true);
  }
});
const giscus = "";
const giscusTheme = "";
const giscusThemeDark = "";
const Giscus = defineComponent({
  name: "Giscus",
  props: {
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props) {
    const {
      options
    } = toRefs(props);
    const lang = usePageLang();
    const theme = ref("light_tritanopia");
    onMounted(async () => {
      const fn = function() {
        var _a3;
        const dark = (_a3 = document.documentElement.classList) === null || _a3 === void 0 ? void 0 : _a3.contains("dark");
        {
          const baseUrl = window.location.protocol + "//" + window.location.host;
          theme.value = baseUrl + `/assets/giscus-theme${dark ? "-dark" : ""}.css`;
        }
      };
      const mutationObserver = new MutationObserver(fn);
      mutationObserver.observe(document.documentElement, {
        attributes: true
      });
      fn();
    });
    const giscusOption = computed(() => ({
      lang: lang.value || "zh-CN",
      host: "https://giscus.app",
      theme: theme.value,
      ...options.value
    }));
    return () => h$5("div", {
      class: "reco-giscus-wrapper"
    }, h$5(l$4, giscusOption.value));
  }
});
const Comments = defineComponent({
  name: "RecoComments",
  components: {
    Valine,
    Waline,
    Giscus
  },
  props: {
    hideComments: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const {
      solution,
      options
    } = useComment();
    const {
      hideComments
    } = toRefs(props);
    let componentName;
    switch (solution.value) {
      case "valine":
        componentName = Valine;
        break;
      case "waline":
        componentName = Waline;
        break;
      case "giscus":
        componentName = Giscus;
        break;
      default:
        componentName = "";
        break;
    }
    return () => {
      if (componentName) {
        if (hideComments.value) {
          if (solution.value === "valine") {
            return h$5(componentName, {
              options: options.value,
              style: "display: none"
            });
          }
          return null;
        }
        return h$5(componentName, {
          options: options.value
        });
      }
      return null;
    };
  }
});
const ValineViews = defineComponent({
  name: "ValineViews",
  props: {
    idVal: String,
    numStyle: {
      type: Object,
      default: () => ({})
    },
    flagTitle: {
      type: String,
      default: "Your Article Title"
    }
  },
  setup(props) {
    const siteLocal = useSiteLocaleData();
    const route = useRoute();
    const {
      idVal,
      numStyle,
      flagTitle
    } = toRefs(props);
    const getIdVal = (path) => {
      return siteLocal.value.base.slice(0, siteLocal.value.base.length - 1) + path;
    };
    return () => h$5("span", {
      "id": getIdVal(idVal.value || route.path),
      "class": "leancloud-visitors",
      "data-flag-title": flagTitle.value
    }, h$5("a", {
      class: "leancloud-visitors-count",
      style: numStyle.value
    }));
  }
});
const renderVisitorCount = (counts, countElements) => {
  countElements.forEach((element, index2) => {
    element.innerText = counts[index2].toString();
  });
};
const pageviewCount = ({
  serverURL,
  api = serverApi,
  path = window.location.pathname,
  id = usePageFrontmatter().value.id || path,
  selector = ".waline-pageview-count",
  update = true,
  lang = navigator.language
}) => {
  const controller = new AbortController();
  const elements = Array.from(
    // pageview selectors
    document.querySelectorAll(selector)
  );
  const filter2 = (element) => {
    const query = getQuery(element);
    return query !== null && path !== query;
  };
  if (update) {
    const normalElements = elements.filter((element) => !filter2(element));
    api.getArticleInfo(id).then((resp) => {
      api.addPageView(id);
      renderVisitorCount(new Array(normalElements.length).fill(resp.data.pageView + 1), normalElements);
    });
  }
  return controller.abort.bind(controller);
};
const WalineViews$1 = defineComponent({
  name: "WalineViews",
  props: {
    path: String
  },
  setup(props) {
    const {
      path
    } = toRefs(props);
    const {
      options
    } = useComment();
    const route = useRoute();
    const viewFn = function() {
      pageviewCount({
        serverURL: options.value.serverURL,
        path: path.value,
        selector: `[data-path="${path.value}"]`,
        update: route.path === path.value
      });
    };
    onMounted(() => {
      viewFn();
    });
    onUpdated(() => {
      viewFn();
    });
    return () => h$5("span", {
      "class": "waline-pageview-count",
      "data-path": path.value
    });
  }
});
function applyClientEnhance$1({
  app
}) {
  app.component("Comments", (props) => h$5(Comments, {
    ...props
  }));
  app.component("ValineViews", (props) => h$5(ValineViews, {
    ...props
  }));
  app.component("WalineViews", (props) => h$5(WalineViews$1, {
    ...props
  }));
}
const clientConfig1 = defineClientConfig({
  enhance(...args) {
    applyClientEnhance$1(...args);
  }
});
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a3;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a3 = global.perf_hooks) === null || _a3 === void 0 ? void 0 : _a3.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id in plugin2.settings) {
        const item = plugin2.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy2 = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy: proxy2
    });
    if (proxy2)
      setupFn(proxy2.proxiedTarget);
  }
}
const clientConfig2 = defineClientConfig({
  enhance({
    app
  }) {
    const themeData2 = useThemeData();
    const routeLocale = app._context.provides[routeLocaleSymbol];
    const themeLocaleData = computed(() => resolveThemeLocaleData(themeData2.value, routeLocale.value));
    app.provide(themeLocaleDataSymbol, themeLocaleData);
    Object.defineProperties(app.config.globalProperties, {
      $theme: {
        get() {
          return themeData2.value;
        }
      },
      $themeLocale: {
        get() {
          return themeLocaleData.value;
        }
      }
    });
    {
      setupDevtoolsPlugin({
        // fix recursive reference
        app,
        id: "org.vuejs.vuepress.plugin-theme-data",
        label: "VuePress Theme Data Plugin",
        packageName: "@vuepress/plugin-theme-data",
        homepage: "https://v2.vuepress.vuejs.org",
        logo: "https://v2.vuepress.vuejs.org/images/hero.png",
        componentStateTypes: ["VuePress"]
      }, (api) => {
        api.on.inspectComponent((payload) => {
          payload.instanceData.state.push({
            type: "VuePress",
            key: "themeData",
            editable: false,
            value: themeData2.value
          }, {
            type: "VuePress",
            key: "themeLocaleData",
            editable: false,
            value: themeLocaleData.value
          });
        });
      });
    }
  }
});
const isFocusingTextControl = (target) => {
  if (!(target instanceof Element)) {
    return false;
  }
  return document.activeElement === target && (["TEXTAREA", "SELECT", "INPUT"].includes(target.tagName) || target.hasAttribute("contenteditable"));
};
const isKeyMatched = (event, hotKeys2) => hotKeys2.some((item) => {
  if (isString$1(item)) {
    return item === event.key;
  }
  const {
    key,
    ctrl = false,
    shift: shift2 = false,
    alt = false
  } = item;
  return key === event.key && ctrl === event.ctrlKey && shift2 === event.shiftKey && alt === event.altKey;
});
const nonASCIIRegExp = /[^\x00-\x7F]/;
const splitWords = (str) => str.split(/\s+/g).map((str2) => str2.trim()).filter((str2) => !!str2);
const escapeRegExp = (str) => str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
const isQueryMatched = (query, toMatch) => {
  const toMatchStr = toMatch.join(" ");
  const words = splitWords(query);
  if (nonASCIIRegExp.test(query)) {
    return words.some((word) => toMatchStr.toLowerCase().indexOf(word) > -1);
  }
  const hasTrailingSpace = query.endsWith(" ");
  const searchRegex = new RegExp(words.map((word, index2) => {
    if (words.length === index2 + 1 && !hasTrailingSpace) {
      return `(?=.*\\b${escapeRegExp(word)})`;
    }
    return `(?=.*\\b${escapeRegExp(word)}\\b)`;
  }).join("") + ".+", "gi");
  return searchRegex.test(toMatchStr);
};
const useHotKeys = ({
  input,
  hotKeys: hotKeys2
}) => {
  if (hotKeys2.value.length === 0)
    return;
  const onKeydown = (event) => {
    if (!input.value)
      return;
    if (
      // key matches
      isKeyMatched(event, hotKeys2.value) && // event does not come from the search box itself or
      // user isn't focusing (and thus perhaps typing in) a text control
      !isFocusingTextControl(event.target)
    ) {
      event.preventDefault();
      input.value.focus();
    }
  };
  onMounted(() => {
    document.addEventListener("keydown", onKeydown);
  });
  onBeforeUnmount(() => {
    document.removeEventListener("keydown", onKeydown);
  });
};
const searchIndex$1 = [{
  "title": "",
  "headers": [],
  "path": "/timeline/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/posts/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/friendship-link/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/posts/1/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [{
    "level": 2,
    "title": "Hello world.",
    "slug": "hello-world",
    "link": "#hello-world",
    "children": []
  }],
  "path": "/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "画册",
  "headers": [],
  "path": "/albums/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "音乐播放器测试",
  "headers": [],
  "path": "/blogs/blogtest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "9月8日",
  "headers": [],
  "path": "/blogs/shuoshuotest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "梯田",
  "headers": [],
  "path": "/albums/test_album_1/psb.png.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "测试相册1",
  "headers": [],
  "path": "/albums/test_album_1/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "测试相册2",
  "headers": [],
  "path": "/albums/test_album_2/",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "前端实现 - 木棉花落",
  "headers": [{
    "level": 2,
    "title": "Flowers.vue 绘制花瓣飞舞",
    "slug": "flowers-vue-绘制花瓣飞舞",
    "link": "#flowers-vue-绘制花瓣飞舞",
    "children": [{
      "level": 3,
      "title": "脚本实现",
      "slug": "脚本实现",
      "link": "#脚本实现",
      "children": []
    }]
  }, {
    "level": 2,
    "title": "WindBase.vue 随机风力产生",
    "slug": "windbase-vue-随机风力产生",
    "link": "#windbase-vue-随机风力产生",
    "children": []
  }],
  "path": "/docs/tech/flowers.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "前端实现 - 分层背景",
  "headers": [{
    "level": 2,
    "title": "CSS",
    "slug": "css",
    "link": "#css",
    "children": [{
      "level": 3,
      "title": "天空层",
      "slug": "天空层",
      "link": "#天空层",
      "children": []
    }, {
      "level": 3,
      "title": "远景和近景层",
      "slug": "远景和近景层",
      "link": "#远景和近景层",
      "children": []
    }]
  }, {
    "level": 2,
    "title": "脚本",
    "slug": "脚本",
    "link": "#脚本",
    "children": []
  }],
  "path": "/docs/tech/homebg.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "文章测试",
  "headers": [],
  "path": "/docs/test/articletest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "markdown测试",
  "headers": [{
    "level": 3,
    "title": "导航到这里",
    "slug": "导航到这里",
    "link": "#导航到这里",
    "children": []
  }],
  "path": "/docs/test/mdtest.html",
  "pathLocale": "/",
  "extraFields": []
}, {
  "title": "",
  "headers": [],
  "path": "/404.html",
  "pathLocale": "/",
  "extraFields": []
}];
const searchIndex = ref(searchIndex$1);
const useSearchIndex = () => searchIndex;
const useSearchSuggestions = ({
  searchIndex: searchIndex2,
  routeLocale,
  query,
  maxSuggestions: maxSuggestions2
}) => {
  const localeSearchIndex = computed(() => searchIndex2.value.filter((item) => item.pathLocale === routeLocale.value));
  return computed(() => {
    const searchStr = query.value.trim().toLowerCase();
    if (!searchStr)
      return [];
    const suggestions = [];
    const matchPageHeader = (searchIndexItem, header) => {
      if (isQueryMatched(searchStr, [header.title])) {
        suggestions.push({
          link: `${searchIndexItem.path}#${header.slug}`,
          title: searchIndexItem.title,
          header: header.title
        });
      }
      for (const child of header.children) {
        if (suggestions.length >= maxSuggestions2.value) {
          return;
        }
        matchPageHeader(searchIndexItem, child);
      }
    };
    for (const searchIndexItem of localeSearchIndex.value) {
      if (suggestions.length >= maxSuggestions2.value) {
        break;
      }
      if (isQueryMatched(searchStr, [searchIndexItem.title, ...searchIndexItem.extraFields])) {
        suggestions.push({
          link: searchIndexItem.path,
          title: searchIndexItem.title
        });
        continue;
      }
      for (const header of searchIndexItem.headers) {
        if (suggestions.length >= maxSuggestions2.value) {
          break;
        }
        matchPageHeader(searchIndexItem, header);
      }
    }
    return suggestions;
  });
};
const useSuggestionsFocus = (suggestions) => {
  const focusIndex = ref(0);
  const focusNext = () => {
    if (focusIndex.value < suggestions.value.length - 1) {
      focusIndex.value += 1;
    } else {
      focusIndex.value = 0;
    }
  };
  const focusPrev = () => {
    if (focusIndex.value > 0) {
      focusIndex.value -= 1;
    } else {
      focusIndex.value = suggestions.value.length - 1;
    }
  };
  return {
    focusIndex,
    focusNext,
    focusPrev
  };
};
const SearchBox = defineComponent({
  name: "SearchBox",
  props: {
    locales: {
      type: Object,
      required: false,
      default: () => ({})
    },
    hotKeys: {
      type: Array,
      required: false,
      default: () => []
    },
    maxSuggestions: {
      type: Number,
      required: false,
      default: 5
    }
  },
  setup(props) {
    const {
      locales: locales2,
      hotKeys: hotKeys2,
      maxSuggestions: maxSuggestions2
    } = toRefs(props);
    const router = useRouter();
    const routeLocale = useRouteLocale();
    const searchIndex2 = useSearchIndex();
    const input = ref(null);
    const isActive = ref(false);
    const query = ref("");
    const locale = computed(() => locales2.value[routeLocale.value] ?? {});
    const suggestions = useSearchSuggestions({
      searchIndex: searchIndex2,
      routeLocale,
      query,
      maxSuggestions: maxSuggestions2
    });
    const {
      focusIndex,
      focusNext,
      focusPrev
    } = useSuggestionsFocus(suggestions);
    useHotKeys({
      input,
      hotKeys: hotKeys2
    });
    const showSuggestions = computed(() => isActive.value && !!suggestions.value.length);
    const onArrowUp = () => {
      if (!showSuggestions.value) {
        return;
      }
      focusPrev();
    };
    const onArrowDown = () => {
      if (!showSuggestions.value) {
        return;
      }
      focusNext();
    };
    const goTo = (index2) => {
      if (!showSuggestions.value) {
        return;
      }
      const suggestion = suggestions.value[index2];
      if (!suggestion) {
        return;
      }
      router.push(suggestion.link).then(() => {
        query.value = "";
        focusIndex.value = 0;
      });
    };
    return () => h$5("form", {
      class: "search-box",
      role: "search"
    }, [h$5("input", {
      ref: input,
      type: "search",
      placeholder: locale.value.placeholder,
      autocomplete: "off",
      spellcheck: false,
      value: query.value,
      onFocus: () => isActive.value = true,
      onBlur: () => isActive.value = false,
      onInput: (event) => query.value = event.target.value,
      onKeydown: (event) => {
        switch (event.key) {
          case "ArrowUp": {
            onArrowUp();
            break;
          }
          case "ArrowDown": {
            onArrowDown();
            break;
          }
          case "Enter": {
            event.preventDefault();
            goTo(focusIndex.value);
            break;
          }
        }
      }
    }), showSuggestions.value && h$5("ul", {
      class: "suggestions",
      onMouseleave: () => focusIndex.value = -1
    }, suggestions.value.map(({
      link,
      title,
      header
    }, index2) => h$5("li", {
      class: ["suggestion", {
        focus: focusIndex.value === index2
      }],
      onMouseenter: () => focusIndex.value = index2,
      onMousedown: () => goTo(index2)
    }, h$5("a", {
      href: link,
      onClick: (event) => event.preventDefault()
    }, [h$5("span", {
      class: "page-title"
    }, title), header && h$5("span", {
      class: "page-header"
    }, `> ${header}`)]))))]);
  }
});
const vars$3 = "";
const search = "";
const locales$1 = {};
const hotKeys = [{ "key": "s", "ctrl": true }];
const maxSuggestions = 5;
const clientConfig3 = defineClientConfig({
  enhance({
    app
  }) {
    app.component("SearchBox", (props) => h$5(SearchBox, {
      locales: locales$1,
      hotKeys,
      maxSuggestions,
      ...props
    }));
  }
});
/**
 * NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT
 */
const nprogress$1 = {
  settings: {
    minimum: 0.08,
    easing: "ease",
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    barSelector: '[role="bar"]',
    parent: "body",
    template: '<div class="bar" role="bar"></div>'
  },
  status: null,
  set: (n2) => {
    const started = nprogress$1.isStarted();
    n2 = clamp$1(n2, nprogress$1.settings.minimum, 1);
    nprogress$1.status = n2 === 1 ? null : n2;
    const progress = nprogress$1.render(!started);
    const bar = progress.querySelector(nprogress$1.settings.barSelector);
    const speed = nprogress$1.settings.speed;
    const ease = nprogress$1.settings.easing;
    progress.offsetWidth;
    queue((next) => {
      css(bar, {
        transform: "translate3d(" + toBarPerc(n2) + "%,0,0)",
        transition: "all " + speed + "ms " + ease
      });
      if (n2 === 1) {
        css(progress, {
          transition: "none",
          opacity: "1"
        });
        progress.offsetWidth;
        setTimeout(function() {
          css(progress, {
            transition: "all " + speed + "ms linear",
            opacity: "0"
          });
          setTimeout(function() {
            nprogress$1.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(() => next(), speed);
      }
    });
    return nprogress$1;
  },
  isStarted: () => typeof nprogress$1.status === "number",
  start: () => {
    if (!nprogress$1.status)
      nprogress$1.set(0);
    const work = () => {
      setTimeout(() => {
        if (!nprogress$1.status)
          return;
        nprogress$1.trickle();
        work();
      }, nprogress$1.settings.trickleSpeed);
    };
    if (nprogress$1.settings.trickle)
      work();
    return nprogress$1;
  },
  done: (force) => {
    if (!force && !nprogress$1.status)
      return nprogress$1;
    return nprogress$1.inc(0.3 + 0.5 * Math.random()).set(1);
  },
  inc: (amount) => {
    let n2 = nprogress$1.status;
    if (!n2) {
      return nprogress$1.start();
    }
    if (typeof amount !== "number") {
      amount = (1 - n2) * clamp$1(Math.random() * n2, 0.1, 0.95);
    }
    n2 = clamp$1(n2 + amount, 0, 0.994);
    return nprogress$1.set(n2);
  },
  trickle: () => nprogress$1.inc(Math.random() * nprogress$1.settings.trickleRate),
  render: (fromStart) => {
    if (nprogress$1.isRendered()) {
      return document.getElementById("nprogress");
    }
    addClass(document.documentElement, "nprogress-busy");
    const progress = document.createElement("div");
    progress.id = "nprogress";
    progress.innerHTML = nprogress$1.settings.template;
    const bar = progress.querySelector(nprogress$1.settings.barSelector);
    const perc = fromStart ? "-100" : toBarPerc(nprogress$1.status || 0);
    const parent = document.querySelector(nprogress$1.settings.parent);
    css(bar, {
      transition: "all 0 linear",
      transform: "translate3d(" + perc + "%,0,0)"
    });
    if (parent !== document.body) {
      addClass(parent, "nprogress-custom-parent");
    }
    parent == null ? void 0 : parent.appendChild(progress);
    return progress;
  },
  remove: () => {
    removeClass(document.documentElement, "nprogress-busy");
    removeClass(document.querySelector(nprogress$1.settings.parent), "nprogress-custom-parent");
    const progress = document.getElementById("nprogress");
    progress && removeElement(progress);
  },
  isRendered: () => !!document.getElementById("nprogress")
};
const clamp$1 = (n2, min2, max2) => {
  if (n2 < min2)
    return min2;
  if (n2 > max2)
    return max2;
  return n2;
};
const toBarPerc = (n2) => (-1 + n2) * 100;
const queue = function() {
  const pending = [];
  function next() {
    const fn = pending.shift();
    if (fn) {
      fn(next);
    }
  }
  return function(fn) {
    pending.push(fn);
    if (pending.length === 1)
      next();
  };
}();
const css = function() {
  const cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  const cssProps = {};
  function camelCase(string) {
    return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
      return letter.toUpperCase();
    });
  }
  function getVendorProp(name2) {
    const style2 = document.body.style;
    if (name2 in style2)
      return name2;
    let i3 = cssPrefixes.length;
    const capName = name2.charAt(0).toUpperCase() + name2.slice(1);
    let vendorName;
    while (i3--) {
      vendorName = cssPrefixes[i3] + capName;
      if (vendorName in style2)
        return vendorName;
    }
    return name2;
  }
  function getStyleProp(name2) {
    name2 = camelCase(name2);
    return cssProps[name2] ?? (cssProps[name2] = getVendorProp(name2));
  }
  function applyCss(element, prop, value) {
    prop = getStyleProp(prop);
    element.style[prop] = value;
  }
  return function(element, properties) {
    for (const prop in properties) {
      const value = properties[prop];
      if (value !== void 0 && Object.prototype.hasOwnProperty.call(properties, prop))
        applyCss(element, prop, value);
    }
  };
}();
const hasClass = (element, name2) => {
  const list = typeof element === "string" ? element : classList(element);
  return list.indexOf(" " + name2 + " ") >= 0;
};
const addClass = (element, name2) => {
  const oldList = classList(element);
  const newList = oldList + name2;
  if (hasClass(oldList, name2))
    return;
  element.className = newList.substring(1);
};
const removeClass = (element, name2) => {
  const oldList = classList(element);
  if (!hasClass(element, name2))
    return;
  const newList = oldList.replace(" " + name2 + " ", " ");
  element.className = newList.substring(1, newList.length - 1);
};
const classList = (element) => {
  return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
};
const removeElement = (element) => {
  element && element.parentNode && element.parentNode.removeChild(element);
};
const vars$2 = "";
const nprogress = "";
const useNprogress = () => {
  onMounted(() => {
    const router = useRouter();
    const loadedPages = /* @__PURE__ */ new Set();
    loadedPages.add(router.currentRoute.value.path);
    router.beforeEach((to) => {
      if (!loadedPages.has(to.path)) {
        nprogress$1.start();
      }
    });
    router.afterEach((to) => {
      loadedPages.add(to.path);
      nprogress$1.done();
    });
  });
};
const clientConfig4 = defineClientConfig({
  setup() {
    useNprogress();
  }
});
function r$6(r2, e2, n2) {
  var i3, t2, o2;
  void 0 === e2 && (e2 = 50), void 0 === n2 && (n2 = {});
  var a2 = null != (i3 = n2.isImmediate) && i3, u3 = null != (t2 = n2.callback) && t2, c2 = n2.maxWait, v3 = Date.now(), l2 = [];
  function f2() {
    if (void 0 !== c2) {
      var r3 = Date.now() - v3;
      if (r3 + e2 >= c2)
        return c2 - r3;
    }
    return e2;
  }
  var d2 = function() {
    var e3 = [].slice.call(arguments), n3 = this;
    return new Promise(function(i4, t3) {
      var c3 = a2 && void 0 === o2;
      if (void 0 !== o2 && clearTimeout(o2), o2 = setTimeout(function() {
        if (o2 = void 0, v3 = Date.now(), !a2) {
          var i5 = r2.apply(n3, e3);
          u3 && u3(i5), l2.forEach(function(r3) {
            return (0, r3.resolve)(i5);
          }), l2 = [];
        }
      }, f2()), c3) {
        var d3 = r2.apply(n3, e3);
        return u3 && u3(d3), i4(d3);
      }
      l2.push({
        resolve: i4,
        reject: t3
      });
    });
  };
  return d2.cancel = function(r3) {
    void 0 !== o2 && clearTimeout(o2), l2.forEach(function(e3) {
      return (0, e3.reject)(r3);
    }), l2 = [];
  }, d2;
}
const useActiveHeaderLinks = ({
  headerLinkSelector: headerLinkSelector2,
  headerAnchorSelector: headerAnchorSelector2,
  delay: delay2,
  offset: offset2 = 5
}) => {
  const router = useRouter();
  const setActiveRouteHash = () => {
    var _a3, _b2;
    const scrollTop = Math.max(window.scrollY, document.documentElement.scrollTop, document.body.scrollTop);
    const isAtPageTop = Math.abs(scrollTop - 0) < offset2;
    if (isAtPageTop) {
      updateHash(router, "");
      return;
    }
    const scrollBottom = window.innerHeight + scrollTop;
    const scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
    const isAtPageBottom = Math.abs(scrollHeight - scrollBottom) < offset2;
    const headerLinks = Array.from(document.querySelectorAll(headerLinkSelector2));
    const headerAnchors = Array.from(document.querySelectorAll(headerAnchorSelector2));
    const existedHeaderAnchors = headerAnchors.filter((anchor) => headerLinks.some((link) => link.hash === anchor.hash));
    for (let i3 = 0; i3 < existedHeaderAnchors.length; i3++) {
      const anchor = existedHeaderAnchors[i3];
      const nextAnchor = existedHeaderAnchors[i3 + 1];
      const hasPassedCurrentAnchor = scrollTop >= (((_a3 = anchor.parentElement) == null ? void 0 : _a3.offsetTop) ?? 0) - offset2;
      const hasNotPassedNextAnchor = !nextAnchor || scrollTop < (((_b2 = nextAnchor.parentElement) == null ? void 0 : _b2.offsetTop) ?? 0) - offset2;
      const isActive = hasPassedCurrentAnchor && hasNotPassedNextAnchor;
      if (!isActive)
        continue;
      const routeHash = decodeURIComponent(router.currentRoute.value.hash);
      const anchorHash = decodeURIComponent(anchor.hash);
      if (routeHash === anchorHash)
        return;
      if (isAtPageBottom) {
        for (let j2 = i3 + 1; j2 < existedHeaderAnchors.length; j2++) {
          if (routeHash === decodeURIComponent(existedHeaderAnchors[j2].hash)) {
            return;
          }
        }
      }
      updateHash(router, anchorHash);
      return;
    }
  };
  const onScroll = r$6(setActiveRouteHash, delay2);
  onMounted(() => {
    window.addEventListener("scroll", onScroll);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("scroll", onScroll);
  });
};
const updateHash = async (router, hash2) => {
  const {
    scrollBehavior
  } = router.options;
  router.options.scrollBehavior = void 0;
  await router.replace({
    query: router.currentRoute.value.query,
    hash: hash2
  }).finally(() => router.options.scrollBehavior = scrollBehavior);
};
const headerLinkSelector = "a.page-catalog-item";
const headerAnchorSelector = ".header-anchor";
const delay = 200;
const offset$1 = 5;
const clientConfig5 = defineClientConfig({
  setup() {
    useActiveHeaderLinks({
      headerLinkSelector,
      headerAnchorSelector,
      delay,
      offset: offset$1
    });
  }
});
const vars$1 = "";
const externalLinkIcon = "";
const svg = h$5("svg", {
  "class": "external-link-icon",
  "xmlns": "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  "focusable": "false",
  "x": "0px",
  "y": "0px",
  "viewBox": "0 0 100 100",
  "width": "15",
  "height": "15"
}, [h$5("path", {
  fill: "currentColor",
  d: "M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
}), h$5("polygon", {
  fill: "currentColor",
  points: "45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
})]);
const ExternalLinkIcon = defineComponent({
  name: "ExternalLinkIcon",
  props: {
    locales: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  setup(props) {
    const routeLocale = useRouteLocale();
    const locale = computed(() => props.locales[routeLocale.value] ?? {
      openInNewWindow: "open in new window"
    });
    return () => h$5("span", [svg, h$5("span", {
      class: "external-link-icon-sr-only"
    }, locale.value.openInNewWindow)]);
  }
});
const locales = {};
const clientConfig6 = defineClientConfig({
  enhance({
    app
  }) {
    app.component("ExternalLinkIcon", h$5(ExternalLinkIcon, {
      locales
    }));
  }
});
const clientConfig7 = {
  enhance: ({
    app
  }) => {
  }
};
const clientConfig8 = {
  enhance: ({
    app
  }) => {
  }
};
const getScrollTop = () => window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
const scrollToTop = () => window.scrollTo({
  top: 0,
  behavior: "smooth"
});
const vars = "";
const backToTop = "";
const BackToTop = defineComponent({
  name: "BackToTop",
  setup() {
    const scrollTop = ref(0);
    const show = computed(() => scrollTop.value > 300);
    const onScroll = r$6(() => {
      scrollTop.value = getScrollTop();
    }, 100);
    onMounted(() => {
      scrollTop.value = getScrollTop();
      window.addEventListener("scroll", () => onScroll());
    });
    const backToTopEl = h$5("div", {
      class: "back-to-top",
      onClick: scrollToTop
    });
    return () => h$5(Transition, {
      name: "back-to-top"
    }, () => show.value ? backToTopEl : null);
  }
});
const clientConfig9 = defineClientConfig({
  rootComponents: [BackToTop]
});
function useInitCopyBtn() {
  const codeNodes = ref([]);
  const addCopyBtnToCodeNode = () => {
    codeNodes.value.forEach((node2) => {
      node2.style.position = "relative";
      const btn = document.createElement("span");
      btn.className = "code-copy-btn";
      btn.style.position = "absolute";
      btn.style.zIndex = "20";
      btn.style.top = "4px";
      btn.style.right = "10px";
      btn.style.display = "none";
      btn.style.padding = "0 10px 0 10px";
      btn.style.borderRadius = "4px";
      btn.style.cursor = "pointer";
      btn.innerHTML = '<span class="copied">copied</span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="8" width="12" height="12" rx="2"></rect><path d="M16 8V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2"></path></g></svg>';
      const icon = btn.querySelector("svg");
      icon.style.width = "20px";
      icon.style.verticalAlign = "middle";
      const copied = btn.querySelector(".copied");
      copied.style.verticalAlign = "middle";
      copied.style.fontSize = "12px";
      copied.style.display = "none";
      copied.style.marginRight = "4px";
      handleElement(btn);
      node2.appendChild(btn);
      node2.addEventListener("mouseenter", () => {
        btn.style.display = "block";
      });
      node2.addEventListener("mouseleave", () => {
        btn.style.display = "none";
      });
    });
  };
  const initCopyBtn = () => {
    const nodes = document.querySelectorAll('div[class*="language-"]');
    codeNodes.value = nodes;
    addCopyBtnToCodeNode();
  };
  return {
    codeNodes,
    initCopyBtn
  };
}
async function copyToClipboard(text2) {
  try {
    return navigator.clipboard.writeText(text2);
  } catch (_a3) {
    const element = document.createElement("textarea");
    const previouslyFocusedElement = document.activeElement;
    element.value = text2;
    element.setAttribute("readonly", "");
    element.style.contain = "strict";
    element.style.position = "absolute";
    element.style.left = "-9999px";
    element.style.fontSize = "12pt";
    const selection = document.getSelection();
    const originalRange = selection ? selection.rangeCount > 0 && selection.getRangeAt(0) : null;
    document.body.appendChild(element);
    element.select();
    element.selectionStart = 0;
    element.selectionEnd = text2.length;
    document.execCommand("copy");
    document.body.removeChild(element);
    if (originalRange) {
      selection.removeAllRanges();
      selection.addRange(originalRange);
    }
    if (previouslyFocusedElement) {
      previouslyFocusedElement.focus();
    }
  }
}
function handleElement(el) {
  el.addEventListener("click", () => {
    const parent = el.parentElement;
    if (!parent) {
      return;
    }
    const isShell = parent.classList.contains("language-sh") || parent.classList.contains("language-bash");
    let {
      innerText: text2 = ""
    } = parent;
    if (isShell) {
      text2 = text2.replace(/^ *\$ /gm, "");
    }
    copyToClipboard(text2).then(() => {
      const copied = el.querySelector(".copied");
      copied.style.display = "inline-block";
      setTimeout(() => {
        copied.style.display = "none";
      }, 3e3);
    });
  });
}
async function applyClientSetup$2() {
  const {
    initCopyBtn
  } = useInitCopyBtn();
  onMounted(() => {
    setTimeout(() => {
      initCopyBtn();
    }, 500);
  });
}
const clientConfig10 = defineClientConfig({
  setup() {
    applyClientSetup$2();
  }
});
const resolveRepoType = (repo) => {
  if (!isLinkHttp$1(repo) || /github\.com/.test(repo))
    return "GitHub";
  if (/bitbucket\.org/.test(repo))
    return "Bitbucket";
  if (/gitlab\.com/.test(repo))
    return "GitLab";
  if (/gitee\.com/.test(repo))
    return "Gitee";
  return null;
};
const editLinkPatterns = {
  GitHub: ":repo/edit/:branch/:path",
  GitLab: ":repo/-/edit/:branch/:path",
  Gitee: ":repo/edit/:branch/:path",
  Bitbucket: ":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"
};
const resolveEditLink = ({
  docsRepo,
  docsBranch,
  docsDir,
  filePathRelative,
  editLinkPattern
}) => {
  const repoType = resolveRepoType(docsRepo);
  let pattern;
  if (editLinkPattern) {
    pattern = editLinkPattern;
  } else if (repoType !== null) {
    pattern = editLinkPatterns[repoType];
  }
  if (!pattern)
    return null;
  return pattern.replace(/:repo/, isLinkHttp$1(docsRepo) ? docsRepo : `https://github.com/${docsRepo}`).replace(/:branch/, docsBranch).replace(/:path/, removeLeadingSlash(`${removeEndingSlash(docsDir)}/${filePathRelative}`));
};
function createOneColor() {
  const tagColorArr = ["#e15b64", "#f47e60", "#f8b26a", "#abbd81", "#849b87", "#e15b64", "#f47e60", "#f8b26a", "#f26d6d", "#67cc86", "#fb9b5f", "#3498db"];
  const index2 = Math.floor(Math.random() * tagColorArr.length);
  return tagColorArr[index2];
}
const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  __name: "Badge",
  props: {
    type: {
      type: String,
      required: false,
      default: "tip"
    },
    text: {
      type: String,
      required: false,
      default: ""
    },
    vertical: {
      type: String,
      required: false,
      default: "top"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "span",
        {
          class: normalizeClass(["badge", __props.type]),
          style: normalizeStyle({
            verticalAlign: __props.vertical
          })
        },
        [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(
              toDisplayString(__props.text),
              1
              /* TEXT */
            )
          ])
        ],
        6
        /* CLASS, STYLE */
      );
    };
  }
});
const Badge_vue_vue_type_style_index_0_lang = "";
const Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$1l, [["__file", "Badge.vue"]]);
const _hoisted_1$15 = {
  key: 1,
  class: "xicon-container"
};
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  __name: "Xicons",
  props: {
    icon: {
      type: String,
      default: ""
    },
    iconPosition: {
      type: String,
      default: "left"
    },
    iconSize: {
      type: [String, Number],
      default: 18
    },
    color: {
      type: String,
      default: "inherit"
    },
    text: {
      type: String,
      default: ""
    },
    textSize: {
      type: [String, Number],
      default: "14"
    },
    link: {
      type: String,
      default: "javascript:void(0)"
    },
    target: {
      type: String,
      default: "_self"
    }
  },
  emits: ["click"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const slots = useSlots();
    const { icon, iconSize, color, textSize } = toRefs(props);
    const iconStyle = computed(() => {
      const style2 = {
        width: `${iconSize.value}px`,
        height: `${iconSize.value}px`,
        fontSize: `${iconSize.value}px`,
        color: color.value
      };
      return style2;
    });
    const textStyle = computed(() => {
      return { color: color.value, fontSize: `${textSize.value}px` };
    });
    const handleClick = () => {
      if (props.link) {
        window.open(props.link, props.target);
      }
      emits("click");
    };
    return (_ctx, _cache) => {
      return __props.link !== "javascript:void(0)" || (__props.text || unref(slots).default) ? (openBlock(), createElementBlock(
        "span",
        {
          key: 0,
          class: normalizeClass(["xicon-container", __props.iconPosition]),
          onClick: handleClick
        },
        [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            (openBlock(), createBlock(resolveDynamicComponent(icons[unref(icon)]), {
              class: "xicon-icon",
              style: normalizeStyle(iconStyle.value)
            }, null, 8, ["style"]))
          ]),
          __props.text || unref(slots).default ? (openBlock(), createElementBlock(
            "span",
            {
              key: 0,
              class: "xicon-content",
              style: normalizeStyle(textStyle.value)
            },
            [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(
                  toDisplayString(__props.text),
                  1
                  /* TEXT */
                )
              ])
            ],
            4
            /* STYLE */
          )) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : (openBlock(), createElementBlock("span", _hoisted_1$15, [
        (openBlock(), createBlock(resolveDynamicComponent(icons[unref(icon)]), {
          style: normalizeStyle(iconStyle.value),
          onClick: _cache[0] || (_cache[0] = ($event) => emits("click"))
        }, null, 8, ["style"]))
      ]));
    };
  }
});
const Xicons_vue_vue_type_style_index_0_lang = "";
const Xicons = /* @__PURE__ */ _export_sfc$1(_sfc_main$1k, [["__file", "Xicons.vue"]]);
const _sfc_main$1j = defineComponent({
  name: "CodeGroup",
  setup(_2, { slots }) {
    const activeIndex = ref(-1);
    const tabRefs = ref([]);
    onBeforeUpdate(() => {
      tabRefs.value = [];
    });
    const activateNext = (i3 = activeIndex.value) => {
      if (i3 < tabRefs.value.length - 1) {
        activeIndex.value = i3 + 1;
      } else {
        activeIndex.value = 0;
      }
      tabRefs.value[activeIndex.value].focus();
    };
    const activatePrev = (i3 = activeIndex.value) => {
      if (i3 > 0) {
        activeIndex.value = i3 - 1;
      } else {
        activeIndex.value = tabRefs.value.length - 1;
      }
      tabRefs.value[activeIndex.value].focus();
    };
    const keyboardHandler = (event, i3) => {
      if (event.key === " " || event.key === "Enter") {
        event.preventDefault();
        activeIndex.value = i3;
      } else if (event.key === "ArrowRight") {
        event.preventDefault();
        activateNext(i3);
      } else if (event.key === "ArrowLeft") {
        event.preventDefault();
        activatePrev(i3);
      }
    };
    return () => {
      var _a3;
      const items = (((_a3 = slots.default) == null ? void 0 : _a3.call(slots)) || []).filter((vnode) => vnode.type.name === "CodeGroupItem").map((vnode) => {
        if (vnode.props === null) {
          vnode.props = {};
        }
        return vnode;
      });
      if (items.length === 0) {
        return null;
      }
      if (activeIndex.value < 0 || activeIndex.value > items.length - 1) {
        activeIndex.value = items.findIndex(
          (vnode) => vnode.props.active === "" || vnode.props.active === true
        );
        if (activeIndex.value === -1) {
          activeIndex.value = 0;
        }
      } else {
        items.forEach((vnode, i3) => {
          vnode.props.active = i3 === activeIndex.value;
        });
      }
      return h$5("div", { class: "code-group" }, [
        h$5(
          "div",
          { class: "code-group__nav" },
          h$5(
            "ul",
            { class: "code-group__ul" },
            items.map((vnode, i3) => {
              const isActive = i3 === activeIndex.value;
              return h$5(
                "li",
                { class: "code-group__li" },
                h$5(
                  "button",
                  {
                    ref: (element) => {
                      if (element) {
                        tabRefs.value[i3] = element;
                      }
                    },
                    class: {
                      "code-group__nav-tab": true,
                      "code-group__nav-tab-active": isActive
                    },
                    ariaPressed: isActive,
                    ariaExpanded: isActive,
                    onClick: () => activeIndex.value = i3,
                    onKeydown: (e2) => keyboardHandler(e2, i3)
                  },
                  h$5(
                    Xicons,
                    {
                      icon: "Code",
                      text: vnode.props.title
                    }
                  )
                )
              );
            })
          )
        ),
        items
      ]);
    };
  }
});
const CodeGroup_vue_vue_type_style_index_0_lang = "";
const CodeGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$1j, [["__file", "CodeGroup.vue"]]);
const _sfc_main$1i = {};
const _hoisted_1$14 = { class: "magic-card" };
const _hoisted_2$J = /* @__PURE__ */ createElementVNode(
  "span",
  { class: "magic-card__bg" },
  null,
  -1
  /* HOISTED */
);
function _sfc_render$J(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$14, [
    _hoisted_2$J,
    renderSlot(_ctx.$slots, "default")
  ]);
}
const MagicCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$1i, [["render", _sfc_render$J], ["__file", "MagicCard.vue"]]);
const _hoisted_1$13 = { class: "vue-preview-container" };
const _hoisted_2$I = {
  key: 0,
  class: "preview-container"
};
const _sfc_main$1h = /* @__PURE__ */ defineComponent({
  __name: "VuePreview",
  props: ["component"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$13, [
        __props.component !== "undefined" ? (openBlock(), createElementBlock("div", _hoisted_2$I, [
          (openBlock(), createBlock(resolveDynamicComponent(__props.component)))
        ])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
const VuePreview_vue_vue_type_style_index_0_lang = "";
const VuePreview = /* @__PURE__ */ _export_sfc$1(_sfc_main$1h, [["__file", "VuePreview.vue"]]);
const _hoisted_1$12 = ["aria-selected"];
const __default__$3 = defineComponent({
  name: "CodeGroupItem"
});
const _sfc_main$1g = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: {
    title: {
      type: String,
      required: true
    },
    active: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["code-group-item", { "code-group-item__active": __props.active }]),
        "aria-selected": __props.active
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 10, _hoisted_1$12);
    };
  }
});
const CodeGroupItem_vue_vue_type_style_index_0_lang = "";
const CodeGroupItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1g, [["__file", "CodeGroupItem.vue"]]);
const GlobalComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Badge,
  CodeGroup,
  CodeGroupItem,
  MagicCard,
  VuePreview,
  Xicons
}, Symbol.toStringTag, { value: "Module" }));
function registerGlobalComponents(app) {
  Object.keys(GlobalComponents).forEach((key) => {
    app.component(key, GlobalComponents[key]);
  });
}
function resolveSearchComponent(app) {
  app.component("NavbarSearch", () => {
    const SearchComponent = app.component("Docsearch") || app.component("SearchBox");
    return SearchComponent ? h$5(SearchComponent) : null;
  });
}
const throttle = (func, wait = 500) => {
  let timer;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      func.apply(func, args);
      timer = null;
    }, wait);
  };
};
class MouseMove {
  constructor() {
    this.cards = [];
  }
  init() {
    this.getCardNodes();
    this.initMouseMoveObserver();
  }
  initMouseMoveObserver() {
    window.removeEventListener("mousemove", () => {
    });
    window.addEventListener("mousemove", throttle((event) => {
      const x2 = event.pageX;
      const y3 = event.pageY;
      this._setMouseLocationToCard(x2, y3);
    }, 50));
  }
  getCardNodes() {
    const cards = document.querySelectorAll(".magic-card");
    this.cards = cards;
    cards.forEach((card) => {
      card.setAttribute("data-x", card.offsetLeft);
      card.setAttribute("data-y", card.offsetTop);
      card.setAttribute("data-width", card.clientWidth);
      card.setAttribute("data-height", card.clientHeight);
    });
  }
  _setMouseLocationToCard(mouseX, mouseY) {
    this.cards.forEach((card) => {
      const {
        x: cardX,
        y: cardY,
        width,
        height
      } = card.dataset;
      const x2 = Math.floor(mouseX - cardX);
      const y3 = Math.floor(mouseY - cardY);
      card.style.setProperty("--x", `${x2}px`);
      card.style.setProperty("--y", `${y3}px`);
    });
  }
}
const mouseMove = new MouseMove();
function useMagicCard() {
  const initMagicCard = () => {
    mouseMove.init();
  };
  return {
    initMagicCard
  };
}
ref(false);
const useMobileMenus = () => {
  const isOpenMobileMenus = ref(false);
  const toggleMobileMenus = (to) => {
    isOpenMobileMenus.value = typeof to === "boolean" ? to : !isOpenMobileMenus.value;
  };
  return {
    isOpenMobileMenus,
    toggleMobileMenus
  };
};
const useResolveRouteWithRedirect = (...args) => {
  const router = useRouter();
  const route = router.resolve(...args);
  const lastMatched = route.matched[route.matched.length - 1];
  if (!(lastMatched === null || lastMatched === void 0 ? void 0 : lastMatched.redirect)) {
    return route;
  }
  const {
    redirect
  } = lastMatched;
  const resolvedRedirect = isFunction$1(redirect) ? redirect(route) : redirect;
  const resolvedRedirectObj = isString$1(resolvedRedirect) ? {
    path: resolvedRedirect
  } : resolvedRedirect;
  return useResolveRouteWithRedirect({
    hash: route.hash,
    query: route.query,
    params: route.params,
    ...resolvedRedirectObj
  });
};
const useNavLink = (item) => {
  const resolved = useResolveRouteWithRedirect(item);
  return {
    text: resolved.meta.title || item,
    link: resolved.name === "404" ? item : resolved.fullPath
  };
};
const catalogSymbol = Symbol("catalog");
const usePageCatalog = () => {
  const catalog = inject(catalogSymbol);
  if (!catalog) {
    throw new Error("usePageCatalog() is called without provider.");
  }
  return catalog;
};
function resolveCatalog() {
  const page = usePageData$1();
  return headersToCatalog(page.value.headers);
}
const headerToCatalogItem = (header) => ({
  text: header.title,
  link: `#${header.slug}`,
  level: header.level,
  children: headersToCatalog(header.children)
});
const headersToCatalog = (headers) => headers.map((header) => headerToCatalogItem(header));
const direction = ref("");
function useScrollDirection() {
  let startY = 0, endY = 0;
  onMounted(() => {
    window.addEventListener("touchstart", (e2) => {
      const touch = e2.touches[0];
      startY = Number(touch.pageY);
    });
    window.addEventListener("touchmove", throttle((e2) => {
      const touch = e2.touches[0];
      endY = touch.pageY;
      if (endY - startY < 0) {
        direction.value = "top";
      } else if (endY - startY > 0) {
        direction.value = "bottom";
      } else {
        direction.value = "";
      }
      startY = endY;
    }, 300));
  });
  return {
    direction
  };
}
let promise = null;
let promiseResolve = null;
const scrollPromise = {
  wait: () => promise,
  pending: () => {
    promise = new Promise((resolve) => promiseResolve = resolve);
  },
  resolve: () => {
    promiseResolve === null || promiseResolve === void 0 ? void 0 : promiseResolve();
    promise = null;
    promiseResolve = null;
  }
};
const useScrollPromise = () => scrollPromise;
const useSeriesData = () => {
  const isOpenSeries = ref(false);
  const frontmatter = usePageFrontmatter();
  const seriesItems = useSeriesItems();
  const catalog = usePageCatalog();
  const isShowSeries = computed(() => seriesItems.value.length > 0 && isOpenSeries);
  const isShowCatalog = computed(() => catalog.value.length > 0 && frontmatter.value.home !== true);
  const toggleSeries = (to) => {
    isOpenSeries.value = typeof to === "boolean" ? to : !isOpenSeries.value;
    document.body.style.overflowY = isOpenSeries.value ? "hidden" : "auto";
  };
  return {
    isOpenSeries,
    isShowSeries,
    isShowCatalog,
    toggleSeries
  };
};
const categoryPaginationPostsSymbol = Symbol("categoryPaginationPostsSymbol");
const categorySummarySymbol = Symbol("categorySummarySymbol");
const postsSymbol = Symbol("postsSymbol");
const seriesSymbol = Symbol("seriesSymbol");
function usePageData() {
  const categorySummary = inject(categorySummarySymbol, null) || {};
  const posts = inject(postsSymbol, null) || [];
  const series = inject(seriesSymbol, null) || {};
  const categoryPaginationPosts = inject(categoryPaginationPostsSymbol, null) || {};
  if (!postsSymbol) {
    throw new Error("useSiteLocaleData() is called without provider.");
  }
  const {
    currentRoute
  } = useRouter();
  const categoryPosts = computed(() => {
    return categoryPaginationPosts[currentRoute.value.path] || {};
  });
  return {
    categoryPosts,
    categorySummary,
    posts,
    series
  };
}
const seriesItemsSymbol = Symbol("seriesItems");
const useSeriesItems = () => {
  const seriesItems = inject(seriesItemsSymbol);
  if (!seriesItems) {
    throw new Error("useSeriesItems() is called without provider.");
  }
  return seriesItems;
};
const resolveSeriesItems = (frontmatter, themeLocal, series) => {
  var _a3;
  const {
    series: autoSeries
  } = usePageData();
  let seriesConfig = (_a3 = themeLocal.series) !== null && _a3 !== void 0 ? _a3 : {};
  seriesConfig = {
    ...autoSeries,
    ...seriesConfig
  };
  if (frontmatter.home) {
    return [];
  }
  if (isPlainObject$1(seriesConfig)) {
    return resolveMultiSeriesItems(seriesConfig);
  }
  return [];
};
const resolveArraySeriesItems = (seriesConfig) => {
  const handleChildItem = (item) => {
    let childItem;
    if (isString$1(item)) {
      childItem = useNavLink(item);
    } else {
      childItem = item;
    }
    return childItem;
  };
  return seriesConfig.map((item) => {
    if (isString$1(item)) {
      return useNavLink(item);
    }
    return {
      ...item,
      children: item.children.map(handleChildItem)
    };
  });
};
const resolveMultiSeriesItems = (seriesConfig) => {
  var _a3;
  const route = useRoute();
  const seriesPath = resolveLocalePath(seriesConfig, decodeURIComponent(route.path));
  const matchedSeriesConfig = (_a3 = seriesConfig[seriesPath]) !== null && _a3 !== void 0 ? _a3 : [];
  return resolveArraySeriesItems(matchedSeriesConfig);
};
const isLetterOrNumberReg = (str) => {
  return /^[0-9a-zA-Z]+$/.test(str);
};
const isAllChineseStr = (str) => {
  return /^[\u4E00-\u9FA5]+$/.test(str);
};
const splitStringByNumber = (str, sortByNumericalSize = false) => {
  let strArr = [];
  const REG_STRING_NUMBER_PARTS = /\d+|\D+/g;
  const arr = str.match(REG_STRING_NUMBER_PARTS);
  for (let i3 = 0; i3 < arr.length; i3++) {
    const splitStr = arr[i3];
    if (isNaN(splitStr)) {
      strArr = strArr.concat(splitStr.split(""));
    } else {
      if (!sortByNumericalSize) {
        strArr = strArr.concat(splitStr.split(""));
      } else {
        strArr.push(splitStr);
      }
    }
  }
  return strArr;
};
const compare = (a2, b2, sortByNumericalSize = true) => {
  if (isLetterOrNumberReg(a2) && isLetterOrNumberReg(b2)) {
    return a2.localeCompare(b2, "zh-Hans-CN", {
      numeric: true
    });
  }
  if (isAllChineseStr(a2) && isAllChineseStr(b2)) {
    return a2.localeCompare(b2, "zh-Hans-CN", {
      numeric: true
    });
  }
  const arrA = splitStringByNumber(a2, sortByNumericalSize);
  const arrB = splitStringByNumber(b2, sortByNumericalSize);
  let result = 0;
  const length = Math.min(arrA.length, arrB.length);
  for (let i3 = 0; i3 < length; i3++) {
    const charA = arrA[i3];
    const charB = arrB[i3];
    if (!isAllChineseStr(charA) && isAllChineseStr(charB)) {
      return -1;
    }
    if (isAllChineseStr(charA) && !isAllChineseStr(charB)) {
      return 1;
    }
    if (isAllChineseStr(charA) && isAllChineseStr(charB)) {
      result = charA.localeCompare(charB, "zh-Hans-CN");
    } else {
      result = charA.localeCompare(charB, "zh-Hans-CN", {
        numeric: true
      });
    }
    if (result !== 0) {
      return result;
    }
  }
  if (arrA.length > arrB.length)
    return 1;
  if (arrA.length < arrB.length)
    return -1;
  return 0;
};
function sortSeries(arr) {
  const a2 = arr.sort((a3, b2) => {
    if (a3.children)
      sortSeries(a3.children);
    if (b2.children)
      sortSeries(b2.children);
    return compare(a3.text, b2.text, true);
  });
  return a2;
}
function useSortSeries() {
  return {
    sortSeries
  };
}
const useThemeLocaleData = () => useThemeLocaleData$1();
function applyClientSetup$1() {
  const themeLocal = useThemeLocaleData();
  usePageData();
  const frontmatter = usePageFrontmatter();
  const seriesItems = computed(() => resolveSeriesItems(frontmatter.value, themeLocal.value));
  provide(seriesItemsSymbol, seriesItems);
  const catalog = computed(() => resolveCatalog());
  provide(catalogSymbol, catalog);
}
const index$1 = "";
const index = "";
function applyClientEnhance({
  app
}) {
  registerGlobalComponents(app);
  resolveSearchComponent(app);
}
/*!
 * md5-es
 * https://github.com/logotype/es-crypto.git
 *
 * Copyright 2017 Victor Norgren
 * Released under the MIT license
 */
class MD5 {
  hash(string) {
    return MD5.hex(MD5.md51(string));
  }
  static md5cycle(x2, k2) {
    let a2 = x2[0], b2 = x2[1], c2 = x2[2], d2 = x2[3];
    a2 = MD5.ff(a2, b2, c2, d2, k2[0], 7, -680876936);
    d2 = MD5.ff(d2, a2, b2, c2, k2[1], 12, -389564586);
    c2 = MD5.ff(c2, d2, a2, b2, k2[2], 17, 606105819);
    b2 = MD5.ff(b2, c2, d2, a2, k2[3], 22, -1044525330);
    a2 = MD5.ff(a2, b2, c2, d2, k2[4], 7, -176418897);
    d2 = MD5.ff(d2, a2, b2, c2, k2[5], 12, 1200080426);
    c2 = MD5.ff(c2, d2, a2, b2, k2[6], 17, -1473231341);
    b2 = MD5.ff(b2, c2, d2, a2, k2[7], 22, -45705983);
    a2 = MD5.ff(a2, b2, c2, d2, k2[8], 7, 1770035416);
    d2 = MD5.ff(d2, a2, b2, c2, k2[9], 12, -1958414417);
    c2 = MD5.ff(c2, d2, a2, b2, k2[10], 17, -42063);
    b2 = MD5.ff(b2, c2, d2, a2, k2[11], 22, -1990404162);
    a2 = MD5.ff(a2, b2, c2, d2, k2[12], 7, 1804603682);
    d2 = MD5.ff(d2, a2, b2, c2, k2[13], 12, -40341101);
    c2 = MD5.ff(c2, d2, a2, b2, k2[14], 17, -1502002290);
    b2 = MD5.ff(b2, c2, d2, a2, k2[15], 22, 1236535329);
    a2 = MD5.gg(a2, b2, c2, d2, k2[1], 5, -165796510);
    d2 = MD5.gg(d2, a2, b2, c2, k2[6], 9, -1069501632);
    c2 = MD5.gg(c2, d2, a2, b2, k2[11], 14, 643717713);
    b2 = MD5.gg(b2, c2, d2, a2, k2[0], 20, -373897302);
    a2 = MD5.gg(a2, b2, c2, d2, k2[5], 5, -701558691);
    d2 = MD5.gg(d2, a2, b2, c2, k2[10], 9, 38016083);
    c2 = MD5.gg(c2, d2, a2, b2, k2[15], 14, -660478335);
    b2 = MD5.gg(b2, c2, d2, a2, k2[4], 20, -405537848);
    a2 = MD5.gg(a2, b2, c2, d2, k2[9], 5, 568446438);
    d2 = MD5.gg(d2, a2, b2, c2, k2[14], 9, -1019803690);
    c2 = MD5.gg(c2, d2, a2, b2, k2[3], 14, -187363961);
    b2 = MD5.gg(b2, c2, d2, a2, k2[8], 20, 1163531501);
    a2 = MD5.gg(a2, b2, c2, d2, k2[13], 5, -1444681467);
    d2 = MD5.gg(d2, a2, b2, c2, k2[2], 9, -51403784);
    c2 = MD5.gg(c2, d2, a2, b2, k2[7], 14, 1735328473);
    b2 = MD5.gg(b2, c2, d2, a2, k2[12], 20, -1926607734);
    a2 = MD5.hh(a2, b2, c2, d2, k2[5], 4, -378558);
    d2 = MD5.hh(d2, a2, b2, c2, k2[8], 11, -2022574463);
    c2 = MD5.hh(c2, d2, a2, b2, k2[11], 16, 1839030562);
    b2 = MD5.hh(b2, c2, d2, a2, k2[14], 23, -35309556);
    a2 = MD5.hh(a2, b2, c2, d2, k2[1], 4, -1530992060);
    d2 = MD5.hh(d2, a2, b2, c2, k2[4], 11, 1272893353);
    c2 = MD5.hh(c2, d2, a2, b2, k2[7], 16, -155497632);
    b2 = MD5.hh(b2, c2, d2, a2, k2[10], 23, -1094730640);
    a2 = MD5.hh(a2, b2, c2, d2, k2[13], 4, 681279174);
    d2 = MD5.hh(d2, a2, b2, c2, k2[0], 11, -358537222);
    c2 = MD5.hh(c2, d2, a2, b2, k2[3], 16, -722521979);
    b2 = MD5.hh(b2, c2, d2, a2, k2[6], 23, 76029189);
    a2 = MD5.hh(a2, b2, c2, d2, k2[9], 4, -640364487);
    d2 = MD5.hh(d2, a2, b2, c2, k2[12], 11, -421815835);
    c2 = MD5.hh(c2, d2, a2, b2, k2[15], 16, 530742520);
    b2 = MD5.hh(b2, c2, d2, a2, k2[2], 23, -995338651);
    a2 = MD5.ii(a2, b2, c2, d2, k2[0], 6, -198630844);
    d2 = MD5.ii(d2, a2, b2, c2, k2[7], 10, 1126891415);
    c2 = MD5.ii(c2, d2, a2, b2, k2[14], 15, -1416354905);
    b2 = MD5.ii(b2, c2, d2, a2, k2[5], 21, -57434055);
    a2 = MD5.ii(a2, b2, c2, d2, k2[12], 6, 1700485571);
    d2 = MD5.ii(d2, a2, b2, c2, k2[3], 10, -1894986606);
    c2 = MD5.ii(c2, d2, a2, b2, k2[10], 15, -1051523);
    b2 = MD5.ii(b2, c2, d2, a2, k2[1], 21, -2054922799);
    a2 = MD5.ii(a2, b2, c2, d2, k2[8], 6, 1873313359);
    d2 = MD5.ii(d2, a2, b2, c2, k2[15], 10, -30611744);
    c2 = MD5.ii(c2, d2, a2, b2, k2[6], 15, -1560198380);
    b2 = MD5.ii(b2, c2, d2, a2, k2[13], 21, 1309151649);
    a2 = MD5.ii(a2, b2, c2, d2, k2[4], 6, -145523070);
    d2 = MD5.ii(d2, a2, b2, c2, k2[11], 10, -1120210379);
    c2 = MD5.ii(c2, d2, a2, b2, k2[2], 15, 718787259);
    b2 = MD5.ii(b2, c2, d2, a2, k2[9], 21, -343485551);
    x2[0] = a2 + x2[0] & 4294967295;
    x2[1] = b2 + x2[1] & 4294967295;
    x2[2] = c2 + x2[2] & 4294967295;
    x2[3] = d2 + x2[3] & 4294967295;
  }
  static cmn(q2, a2, b2, x2, s2, t2) {
    a2 = (a2 + q2 & 4294967295) + (x2 + t2 & 4294967295) & 4294967295;
    return (a2 << s2 | a2 >>> 32 - s2) + b2 & 4294967295;
  }
  static ff(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
  }
  static gg(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
  }
  static hh(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
  }
  static ii(a2, b2, c2, d2, x2, s2, t2) {
    return MD5.cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
  }
  static md51(s2) {
    const n2 = s2.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let o2 = 0, i3 = 64;
    for (i3; i3 <= n2; i3 += 64) {
      MD5.md5cycle(state, MD5.md5blk(s2.substring(i3 - 64, i3)));
    }
    s2 = s2.substring(i3 - 64);
    i3 = 0;
    o2 = s2.length;
    for (i3; i3 < o2; i3++) {
      tail[i3 >> 2] |= s2.charCodeAt(i3) << (i3 % 4 << 3);
    }
    tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
    if (i3 > 55) {
      MD5.md5cycle(state, tail);
      for (i3 = 0; i3 < 16; i3++) {
        tail[i3] = 0;
      }
    }
    tail[14] = n2 * 8;
    MD5.md5cycle(state, tail);
    return state;
  }
  static md5blk(s2) {
    const md5blks = [];
    let i3 = 0;
    for (i3; i3 < 64; i3 += 4) {
      md5blks[i3 >> 2] = s2.charCodeAt(i3) + (s2.charCodeAt(i3 + 1) << 8) + (s2.charCodeAt(i3 + 2) << 16) + (s2.charCodeAt(i3 + 3) << 24);
    }
    return md5blks;
  }
  static rhex(n2) {
    let s2 = "";
    s2 += MD5.hexArray[n2 >> 4 & 15] + MD5.hexArray[n2 >> 0 & 15];
    s2 += MD5.hexArray[n2 >> 12 & 15] + MD5.hexArray[n2 >> 8 & 15];
    s2 += MD5.hexArray[n2 >> 20 & 15] + MD5.hexArray[n2 >> 16 & 15];
    s2 += MD5.hexArray[n2 >> 28 & 15] + MD5.hexArray[n2 >> 24 & 15];
    return s2;
  }
  static hex(x2) {
    const length = x2.length;
    let i3 = 0;
    for (i3; i3 < length; i3++) {
      x2[i3] = MD5.rhex(x2[i3]);
    }
    return x2.join("");
  }
}
MD5.hexArray = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
const md5 = new MD5().hash;
const convertToPinyin = (sourceStr = "") => {
  let targetStr = "";
  const cnReg = /[\u4e00-\u9fa5]/;
  targetStr = sourceStr.split("").reduce((total, next, index2) => {
    if (cnReg.test(next)) {
      const searchResult = searchPinYin(next, PinYin);
      return total += searchResult ? searchResult : "";
    }
    return total += next;
  }, "");
  return targetStr;
};
const searchPinYin = (str, data) => {
  for (const key in data) {
    if (data.hasOwnProperty(key) && data[key].indexOf(str) !== -1) {
      return key;
    }
  }
  return "";
};
const PinYin = {
  a: "啊阿锕",
  ai: "埃挨哎唉哀皑癌蔼矮艾碍爱隘诶捱嗳嗌嫒瑷暧砹锿霭",
  an: "鞍氨安俺按暗岸胺案谙埯揞犴庵桉铵鹌顸黯",
  ang: "肮昂盎",
  ao: "凹敖熬翱袄傲奥懊澳坳拗嗷噢岙廒遨媪骜聱螯鏊鳌鏖",
  ba: "芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸茇菝萆捭岜灞杷钯粑鲅魃",
  bai: "白柏百摆佰败拜稗薜掰鞴",
  ban: "斑班搬扳般颁板版扮拌伴瓣半办绊阪坂豳钣瘢癍舨",
  bang: "邦帮梆榜膀绑棒磅蚌镑傍谤蒡螃",
  bao: "苞胞包褒雹保堡饱宝抱报暴豹鲍爆勹葆宀孢煲鸨褓趵龅",
  bo: "剥薄玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳亳蕃啵饽檗擘礴钹鹁簸跛",
  bei: "杯碑悲卑北辈背贝钡倍狈备惫焙被孛陂邶埤蓓呗怫悖碚鹎褙鐾",
  ben: "奔苯本笨畚坌锛",
  beng: "崩绷甭泵蹦迸唪嘣甏",
  bi: "逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛匕仳俾芘荜荸吡哔狴庳愎滗濞弼妣婢嬖璧贲畀铋秕裨筚箅篦舭襞跸髀",
  bian: "鞭边编贬扁便变卞辨辩辫遍匾弁苄忭汴缏煸砭碥稹窆蝙笾鳊",
  biao: "标彪膘表婊骠飑飙飚灬镖镳瘭裱鳔",
  bie: "鳖憋别瘪蹩鳘",
  bin: "彬斌濒滨宾摈傧浜缤玢殡膑镔髌鬓",
  bing: "兵冰柄丙秉饼炳病并禀邴摒绠枋槟燹",
  bu: "捕卜哺补埠不布步簿部怖拊卟逋瓿晡钚醭",
  ca: "擦嚓礤",
  cai: "猜裁材才财睬踩采彩菜蔡",
  can: "餐参蚕残惭惨灿骖璨粲黪",
  cang: "苍舱仓沧藏伧",
  cao: "操糙槽曹草艹嘈漕螬艚",
  ce: "厕策侧册测刂帻恻",
  ceng: "层蹭噌",
  cha: "插叉茬茶查碴搽察岔差诧猹馇汊姹杈楂槎檫钗锸镲衩",
  chai: "拆柴豺侪茈瘥虿龇",
  chan: "搀掺蝉馋谗缠铲产阐颤冁谄谶蒇廛忏潺澶孱羼婵嬗骣觇禅镡裣蟾躔",
  chang: "昌猖场尝常长偿肠厂敞畅唱倡伥鬯苌菖徜怅惝阊娼嫦昶氅鲳",
  chao: "超抄钞朝嘲潮巢吵炒怊绉晁耖",
  che: "车扯撤掣彻澈坼屮砗",
  chen: "郴臣辰尘晨忱沉陈趁衬称谌抻嗔宸琛榇肜胂碜龀",
  cheng: "撑城橙成呈乘程惩澄诚承逞骋秤埕嵊徵浈枨柽樘晟塍瞠铖裎蛏酲",
  chi: "吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽傺墀芪茌搋叱哧啻嗤彳饬沲媸敕胝眙眵鸱瘛褫蚩螭笞篪豉踅踟魑",
  chong: "充冲虫崇宠茺忡憧铳艟",
  chou: "抽酬畴踌稠愁筹仇绸瞅丑俦圳帱惆溴妯瘳雠鲋",
  chu: "臭初出橱厨躇锄雏滁除楚础储矗搐触处亍刍憷绌杵楮樗蜍蹰黜",
  chuan: "揣川穿椽传船喘串掾舛惴遄巛氚钏镩舡",
  chuang: "疮窗幢床闯创怆",
  chui: "吹炊捶锤垂陲棰槌",
  chun: "春椿醇唇淳纯蠢促莼沌肫朐鹑蝽",
  chuo: "戳绰蔟辶辍镞踔龊",
  ci: "疵茨磁雌辞慈瓷词此刺赐次荠呲嵯鹚螅糍趑",
  cong: "聪葱囱匆从丛偬苁淙骢琮璁枞",
  cu: "凑粗醋簇猝殂蹙",
  cuan: "蹿篡窜汆撺昕爨",
  cui: "摧崔催脆瘁粹淬翠萃悴璀榱隹",
  cun: "村存寸磋忖皴",
  cuo: "撮搓措挫错厝脞锉矬痤鹾蹉躜",
  da: "搭达答瘩打大耷哒嗒怛妲疸褡笪靼鞑",
  dai: "呆歹傣戴带殆代贷袋待逮怠埭甙呔岱迨逯骀绐玳黛",
  dan: "耽担丹单郸掸胆旦氮但惮淡诞弹蛋亻儋卩萏啖澹檐殚赕眈瘅聃箪",
  dang: "当挡党荡档谠凼菪宕砀铛裆",
  dao: "刀捣蹈倒岛祷导到稻悼道盗叨啁忉洮氘焘忑纛",
  de: "德得的锝",
  deng: "蹬灯登等瞪凳邓噔嶝戥磴镫簦",
  di: "堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔氐籴诋谛邸坻莜荻嘀娣柢棣觌砥碲睇镝羝骶",
  dian: "颠掂滇碘点典靛垫电佃甸店惦奠淀殿丶阽坫埝巅玷癜癫簟踮",
  diao: "碉叼雕凋刁掉吊钓调轺铞蜩粜貂",
  die: "跌爹碟蝶迭谍叠佚垤堞揲喋渫轶牒瓞褶耋蹀鲽鳎",
  ding: "丁盯叮钉顶鼎锭定订丢仃啶玎腚碇町铤疔耵酊",
  dong: "东冬董懂动栋侗恫冻洞垌咚岽峒夂氡胨胴硐鸫",
  dou: "兜抖斗陡豆逗痘蔸钭窦窬蚪篼酡",
  du: "都督毒犊独读堵睹赌杜镀肚度渡妒芏嘟渎椟橐牍蠹笃髑黩",
  duan: "端短锻段断缎彖椴煅簖",
  dui: "堆兑队对怼憝碓",
  dun: "墩吨蹲敦顿囤钝盾遁炖砘礅盹镦趸",
  duo: "掇哆多夺垛躲朵跺舵剁惰堕咄哚缍柁铎裰踱",
  e: "蛾峨鹅俄额讹娥恶厄扼遏鄂饿噩谔垩垭苊莪萼呃愕屙婀轭曷腭硪锇锷鹗颚鳄",
  en: "恩蒽摁唔嗯",
  er: "而儿耳尔饵洱二贰迩珥铒鸸鲕",
  fa: "发罚筏伐乏阀法珐垡砝",
  fan: "藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛蘩幡犭梵攵燔畈蹯",
  fang: "坊芳方肪房防妨仿访纺放匚邡彷钫舫鲂",
  fei: "菲非啡飞肥匪诽吠肺废沸费芾狒悱淝妃绋绯榧腓斐扉祓砩镄痱蜚篚翡霏鲱",
  fen: "芬酚吩氛分纷坟焚汾粉奋份忿愤粪偾瀵棼愍鲼鼢",
  feng: "丰封枫蜂峰锋风疯烽逢冯缝讽奉凤俸酆葑沣砜",
  fu: "佛否夫敷肤孵扶拂辐幅氟符伏俘服浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐匐凫郛芙苻茯莩菔呋幞滏艴孚驸绂桴赙黻黼罘稃馥虍蚨蜉蝠蝮麸趺跗鳆",
  ga: "噶嘎蛤尬呷尕尜旮钆",
  gai: "该改概钙盖溉丐陔垓戤赅胲",
  gan: "干甘杆柑竿肝赶感秆敢赣坩苷尴擀泔淦澉绀橄旰矸疳酐",
  gang: "冈刚钢缸肛纲岗港戆罡颃筻",
  gong: "杠工攻功恭龚供躬公宫弓巩汞拱贡共蕻廾咣珙肱蚣蛩觥",
  gao: "篙皋高膏羔糕搞镐稿告睾诰郜蒿藁缟槔槁杲锆",
  ge: "哥歌搁戈鸽胳疙割革葛格阁隔铬个各鬲仡哿塥嗝纥搿膈硌铪镉袼颌虼舸骼髂",
  gei: "给",
  gen: "根跟亘茛哏艮",
  geng: "耕更庚羹埂耿梗哽赓鲠",
  gou: "钩勾沟苟狗垢构购够佝诟岣遘媾缑觏彀鸲笱篝鞲",
  gu: "辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇嘏诂菰哌崮汩梏轱牯牿胍臌毂瞽罟钴锢瓠鸪鹄痼蛄酤觚鲴骰鹘",
  gua: "刮瓜剐寡挂褂卦诖呱栝鸹",
  guai: "乖拐怪哙",
  guan: "棺关官冠观管馆罐惯灌贯倌莞掼涫盥鹳鳏",
  guang: "光广逛犷桄胱疒",
  gui: "瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽匦刿庋宄妫桧炅晷皈簋鲑鳜",
  gun: "辊滚棍丨衮绲磙鲧",
  guo: "锅郭国果裹过馘蠃埚掴呙囗帼崞猓椁虢锞聒蜮蜾蝈",
  ha: "哈",
  hai: "骸孩海氦亥害骇咴嗨颏醢",
  han: "酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉邗菡撖阚瀚晗焓颔蚶鼾",
  hen: "夯痕很狠恨",
  hang: "杭航沆绗珩桁",
  hao: "壕嚎豪毫郝好耗号浩薅嗥嚆濠灏昊皓颢蚝",
  he: "呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺诃劾壑藿嗑嗬阖盍蚵翮",
  hei: "嘿黑",
  heng: "哼亨横衡恒訇蘅",
  hong: "轰哄烘虹鸿洪宏弘红黉讧荭薨闳泓",
  hou: "喉侯猴吼厚候后堠後逅瘊篌糇鲎骺",
  hu: "呼乎忽瑚壶葫胡蝴狐糊湖弧虎唬护互沪户冱唿囫岵猢怙惚浒滹琥槲轷觳烀煳戽扈祜鹕鹱笏醐斛",
  hua: "花哗华猾滑画划化话劐浍骅桦铧稞",
  huai: "槐徊怀淮坏还踝",
  huan: "欢环桓缓换患唤痪豢焕涣宦幻郇奂垸擐圜洹浣漶寰逭缳锾鲩鬟",
  huang: "荒慌黄磺蝗簧皇凰惶煌晃幌恍谎隍徨湟潢遑璜肓癀蟥篁鳇",
  hui: "灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘诙茴荟蕙哕喙隳洄彗缋珲晖恚虺蟪麾",
  hun: "荤昏婚魂浑混诨馄阍溷缗",
  huo: "豁活伙火获或惑霍货祸攉嚯夥钬锪镬耠蠖",
  ji: "击圾基机畸稽积箕肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪居丌乩剞佶佴脔墼芨芰萁蒺蕺掎叽咭哜唧岌嵴洎彐屐骥畿玑楫殛戟戢赍觊犄齑矶羁嵇稷瘠瘵虮笈笄暨跻跽霁鲚鲫髻麂",
  jia: "嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁伽郏拮岬浃迦珈戛胛恝铗镓痂蛱笳袈跏",
  jian: "歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件健舰剑饯渐溅涧建僭谏谫菅蒹搛囝湔蹇謇缣枧柙楗戋戬牮犍毽腱睑锏鹣裥笕箴翦趼踺鲣鞯",
  jiang: "僵姜将浆江疆蒋桨奖讲匠酱降茳洚绛缰犟礓耩糨豇",
  jiao: "蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫佼僬茭挢噍峤徼姣纟敫皎鹪蛟醮跤鲛",
  jie: "窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届偈讦诘喈嗟獬婕孑桀獒碣锴疖袷颉蚧羯鲒骱髫",
  jin: "巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸尽卺荩堇噤馑廑妗缙瑾槿赆觐钅锓衿矜",
  jing: "劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净刭儆阱菁獍憬泾迳弪婧肼胫腈旌",
  jiong: "炯窘冂迥扃",
  jiu: "揪究纠玖韭久灸九酒厩救旧臼舅咎就疚僦啾阄柩桕鹫赳鬏",
  ju: "鞠拘狙疽驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧倨讵苣苴莒掬遽屦琚枸椐榘榉橘犋飓钜锔窭裾趄醵踽龃雎鞫",
  juan: "捐鹃娟倦眷卷绢鄄狷涓桊蠲锩镌隽",
  jue: "撅攫抉掘倔爵觉决诀绝厥劂谲矍蕨噘崛獗孓珏桷橛爝镢蹶觖",
  jun: "均菌钧军君峻俊竣浚郡骏捃狻皲筠麇",
  ka: "喀咖卡佧咔胩",
  ke: "咯坷苛柯棵磕颗科壳咳可渴克刻客课岢恪溘骒缂珂轲氪瞌钶疴窠蝌髁",
  kai: "开揩楷凯慨剀垲蒈忾恺铠锎",
  kan: "刊堪勘坎砍看侃凵莰莶戡龛瞰",
  kang: "康慷糠扛抗亢炕坑伉闶钪",
  kao: "考拷烤靠尻栲犒铐",
  ken: "肯啃垦恳垠裉颀",
  keng: "吭忐铿",
  kong: "空恐孔控倥崆箜",
  kou: "抠口扣寇芤蔻叩眍筘",
  ku: "枯哭窟苦酷库裤刳堀喾绔骷",
  kua: "夸垮挎跨胯侉",
  kuai: "块筷侩快蒯郐蒉狯脍",
  kuan: "宽款髋",
  kuang: "匡筐狂框矿眶旷况诓诳邝圹夼哐纩贶",
  kui: "亏盔岿窥葵奎魁傀馈愧溃馗匮夔隗揆喹喟悝愦阕逵暌睽聩蝰篑臾跬",
  kun: "坤昆捆困悃阃琨锟醌鲲髡",
  kuo: "括扩廓阔蛞",
  la: "垃拉喇蜡腊辣啦剌摺邋旯砬瘌",
  lai: "莱来赖崃徕涞濑赉睐铼癞籁",
  lan: "蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥啉岚懔漤榄斓罱镧褴",
  lang: "琅榔狼廊郎朗浪莨蒗啷阆锒稂螂",
  lao: "捞劳牢老佬姥酪烙涝唠崂栳铑铹痨醪",
  le: "勒乐肋仂叻嘞泐鳓",
  lei: "雷镭蕾磊累儡垒擂类泪羸诔荽咧漯嫘缧檑耒酹",
  ling: "棱冷拎玲菱零龄铃伶羚凌灵陵岭领另令酃塄苓呤囹泠绫柃棂瓴聆蛉翎鲮",
  leng: "楞愣",
  li: "厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐痢立粒沥隶力璃哩俪俚郦坜苈莅蓠藜捩呖唳喱猁溧澧逦娌嫠骊缡珞枥栎轹戾砺詈罹锂鹂疠疬蛎蜊蠡笠篥粝醴跞雳鲡鳢黧",
  lian: "俩联莲连镰廉怜涟帘敛脸链恋炼练挛蔹奁潋濂娈琏楝殓臁膦裢蠊鲢",
  liang: "粮凉梁粱良两辆量晾亮谅墚椋踉靓魉",
  liao: "撩聊僚疗燎寥辽潦了撂镣廖料蓼尥嘹獠寮缭钌鹩耢",
  lie: "列裂烈劣猎冽埒洌趔躐鬣",
  lin: "琳林磷霖临邻鳞淋凛赁吝蔺嶙廪遴檩辚瞵粼躏麟",
  liu: "溜琉榴硫馏留刘瘤流柳六抡偻蒌泖浏遛骝绺旒熘锍镏鹨鎏",
  long: "龙聋咙笼窿隆垄拢陇弄垅茏泷珑栊胧砻癃",
  lou: "楼娄搂篓漏陋喽嵝镂瘘耧蝼髅",
  lu: "芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮垆摅撸噜泸渌漉璐栌橹轳辂辘氇胪镥鸬鹭簏舻鲈",
  lv: "驴吕铝侣旅履屡缕虑氯律率滤绿捋闾榈膂稆褛",
  luan: "峦孪滦卵乱栾鸾銮",
  lue: "掠略锊",
  lun: "轮伦仑沦纶论囵",
  luo: "萝螺罗逻锣箩骡裸落洛骆络倮荦摞猡泺椤脶镙瘰雒",
  ma: "妈麻玛码蚂马骂嘛吗唛犸嬷杩麽",
  mai: "埋买麦卖迈脉劢荬咪霾",
  man: "瞒馒蛮满蔓曼慢漫谩墁幔缦熳镘颟螨鳗鞔",
  mang: "芒茫盲忙莽邙漭朦硭蟒",
  meng: "氓萌蒙檬盟锰猛梦孟勐甍瞢懵礞虻蜢蠓艋艨黾",
  miao: "猫苗描瞄藐秒渺庙妙喵邈缈缪杪淼眇鹋蜱",
  mao: "茅锚毛矛铆卯茂冒帽貌贸侔袤勖茆峁瑁昴牦耄旄懋瞀蛑蝥蟊髦",
  me: "么",
  mei: "玫枚梅酶霉煤没眉媒镁每美昧寐妹媚坶莓嵋猸浼湄楣镅鹛袂魅",
  men: "门闷们扪玟焖懑钔",
  mi: "眯醚靡糜迷谜弥米秘觅泌蜜密幂芈冖谧蘼嘧猕獯汨宓弭脒敉糸縻麋",
  mian: "棉眠绵冕免勉娩缅面沔湎腼眄",
  mie: "蔑灭咩蠛篾",
  min: "民抿皿敏悯闽苠岷闵泯珉",
  ming: "明螟鸣铭名命冥茗溟暝瞑酩",
  miu: "谬",
  mo: "摸摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谟茉蓦馍嫫镆秣瘼耱蟆貊貘",
  mou: "谋牟某厶哞婺眸鍪",
  mu: "拇牡亩姆母墓暮幕募慕木目睦牧穆仫苜呒沐毪钼",
  na: "拿哪呐钠那娜纳内捺肭镎衲箬",
  nai: "氖乃奶耐奈鼐艿萘柰",
  nan: "南男难囊喃囡楠腩蝻赧",
  nao: "挠脑恼闹孬垴猱瑙硇铙蛲",
  ne: "淖呢讷",
  nei: "馁",
  nen: "嫩能枘恁",
  ni: "妮霓倪泥尼拟你匿腻逆溺伲坭猊怩滠昵旎祢慝睨铌鲵",
  nian: "蔫拈年碾撵捻念廿辇黏鲇鲶",
  niang: "娘酿",
  niao: "鸟尿茑嬲脲袅",
  nie: "捏聂孽啮镊镍涅乜陧蘖嗫肀颞臬蹑",
  nin: "您柠",
  ning: "狞凝宁拧泞佞蓥咛甯聍",
  niu: "牛扭钮纽狃忸妞蚴",
  nong: "脓浓农侬",
  nu: "奴努怒呶帑弩胬孥驽",
  nv: "女恧钕衄",
  nuan: "暖",
  nuenue: "虐",
  nue: "疟谑",
  nuo: "挪懦糯诺傩搦喏锘",
  ou: "哦欧鸥殴藕呕偶沤怄瓯耦",
  pa: "啪趴爬帕怕琶葩筢",
  pai: "拍排牌徘湃派俳蒎",
  pan: "攀潘盘磐盼畔判叛爿泮袢襻蟠蹒",
  pang: "乓庞旁耪胖滂逄",
  pao: "抛咆刨炮袍跑泡匏狍庖脬疱",
  pei: "呸胚培裴赔陪配佩沛掊辔帔淠旆锫醅霈",
  pen: "喷盆湓",
  peng: "砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯堋嘭怦蟛",
  pi: "砒霹批披劈琵毗啤脾疲皮匹痞僻屁譬丕陴邳郫圮鼙擗噼庀媲纰枇甓睥罴铍痦癖疋蚍貔",
  pian: "篇偏片骗谝骈犏胼褊翩蹁",
  piao: "飘漂瓢票剽嘌嫖缥殍瞟螵",
  pie: "撇瞥丿苤氕",
  pin: "拼频贫品聘拚姘嫔榀牝颦",
  ping: "乒坪苹萍平凭瓶评屏俜娉枰鲆",
  po: "坡泼颇婆破魄迫粕叵鄱溥珀钋钷皤笸",
  pou: "剖裒踣",
  pu: "扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑匍噗濮璞氆镤镨蹼",
  qi: "期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫亟亓圻芑萋葺嘁屺岐汔淇骐绮琪琦杞桤槭欹祺憩碛蛴蜞綦綮趿蹊鳍麒",
  qia: "掐恰洽葜",
  qian: "牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉佥阡芊芡荨掮岍悭慊骞搴褰缱椠肷愆钤虔箝",
  qiang: "枪呛腔羌墙蔷强抢嫱樯戗炝锖锵镪襁蜣羟跫跄",
  qiao: "橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍劁诮谯荞愀憔缲樵毳硗跷鞒",
  qie: "切茄且怯窃郄唼惬妾挈锲箧",
  qin: "钦侵亲秦琴勤芹擒禽寝沁芩蓁蕲揿吣嗪噙溱檎螓衾",
  qing: "青轻氢倾卿清擎晴氰情顷请庆倩苘圊檠磬蜻罄箐謦鲭黥",
  qiong: "琼穷邛茕穹筇銎",
  qiu: "秋丘邱球求囚酋泅俅氽巯艽犰湫逑遒楸赇鸠虬蚯蝤裘糗鳅鼽",
  qu: "趋区蛆曲躯屈驱渠取娶龋趣去诎劬蕖蘧岖衢阒璩觑氍祛磲癯蛐蠼麴瞿黢",
  quan: "圈颧权醛泉全痊拳犬券劝诠荃獾悛绻辁畎铨蜷筌鬈",
  que: "缺炔瘸却鹊榷确雀阙悫",
  qun: "裙群逡",
  ran: "然燃冉染苒髯",
  rang: "瓤壤攘嚷让禳穰",
  rao: "饶扰绕荛娆桡",
  ruo: "惹若弱",
  re: "热偌",
  ren: "壬仁人忍韧任认刃妊纫仞荏葚饪轫稔衽",
  reng: "扔仍",
  ri: "日",
  rong: "戎茸蓉荣融熔溶容绒冗嵘狨缛榕蝾",
  rou: "揉柔肉糅蹂鞣",
  ru: "茹蠕儒孺如辱乳汝入褥蓐薷嚅洳溽濡铷襦颥",
  ruan: "软阮朊",
  rui: "蕊瑞锐芮蕤睿蚋",
  run: "闰润",
  sa: "撒洒萨卅仨挲飒",
  sai: "腮鳃塞赛噻",
  san: "三叁伞散彡馓氵毵糁霰",
  sang: "桑嗓丧搡磉颡",
  sao: "搔骚扫嫂埽臊瘙鳋",
  se: "瑟色涩啬铩铯穑",
  sen: "森",
  seng: "僧",
  sha: "莎砂杀刹沙纱傻啥煞脎歃痧裟霎鲨",
  shai: "筛晒酾",
  shan: "珊苫杉山删煽衫闪陕擅赡膳善汕扇缮剡讪鄯埏芟潸姗骟膻钐疝蟮舢跚鳝",
  shang: "墒伤商赏晌上尚裳垧绱殇熵觞",
  shao: "梢捎稍烧芍勺韶少哨邵绍劭苕潲蛸笤筲艄",
  she: "奢赊蛇舌舍赦摄射慑涉社设厍佘猞畲麝",
  shen: "砷申呻伸身深娠绅神沈审婶甚肾慎渗诜谂吲哂渖椹矧蜃",
  sheng: "声生甥牲升绳省盛剩胜圣丞渑媵眚笙",
  shi: "师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试谥埘莳蓍弑唑饣轼耆贳炻礻铈铊螫舐筮豕鲥鲺",
  shou: "收手首守寿授售受瘦兽扌狩绶艏",
  shu: "蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱恕倏塾菽忄沭涑澍姝纾毹腧殳镯秫鹬",
  shua: "刷耍唰涮",
  shuai: "摔衰甩帅蟀",
  shuan: "栓拴闩",
  shuang: "霜双爽孀",
  shui: "谁水睡税",
  shun: "吮瞬顺舜恂",
  shuo: "说硕朔烁蒴搠嗍濯妁槊铄",
  si: "斯撕嘶思私司丝死肆寺嗣四伺似饲巳厮俟兕菥咝汜泗澌姒驷缌祀祠锶鸶耜蛳笥",
  song: "松耸怂颂送宋讼诵凇菘崧嵩忪悚淞竦",
  sou: "搜艘擞嗽叟嗖嗾馊溲飕瞍锼螋",
  su: "苏酥俗素速粟僳塑溯宿诉肃夙谡蔌嗉愫簌觫稣",
  suan: "酸蒜算",
  sui: "虽隋随绥髓碎岁穗遂隧祟蓑冫谇濉邃燧眭睢",
  sun: "孙损笋荪狲飧榫跣隼",
  suo: "梭唆缩琐索锁所唢嗦娑桫睃羧",
  ta: "塌他它她塔獭挞蹋踏闼溻遢榻沓",
  tai: "胎苔抬台泰酞太态汰邰薹肽炱钛跆鲐",
  tan: "坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭郯蕈昙钽锬覃",
  tang: "汤塘搪堂棠膛唐糖傥饧溏瑭铴镗耥螗螳羰醣",
  thang: "倘躺淌",
  theng: "趟烫",
  tao: "掏涛滔绦萄桃逃淘陶讨套挑鼗啕韬饕",
  te: "特",
  teng: "藤腾疼誊滕",
  ti: "梯剔踢锑提题蹄啼体替嚏惕涕剃屉荑悌逖绨缇鹈裼醍",
  tian: "天添填田甜恬舔腆掭忝阗殄畋钿蚺",
  tiao: "条迢眺跳佻祧铫窕龆鲦",
  tie: "贴铁帖萜餮",
  ting: "厅听烃汀廷停亭庭挺艇莛葶婷梃蜓霆",
  tong: "通桐酮瞳同铜彤童桶捅筒统痛佟僮仝茼嗵恸潼砼",
  tou: "偷投头透亠",
  tu: "凸秃突图徒途涂屠土吐兔堍荼菟钍酴",
  tuan: "湍团疃",
  tui: "推颓腿蜕褪退忒煺",
  tun: "吞屯臀饨暾豚窀",
  tuo: "拖托脱鸵陀驮驼椭妥拓唾乇佗坨庹沱柝砣箨舄跎鼍",
  wa: "挖哇蛙洼娃瓦袜佤娲腽",
  wai: "歪外",
  wan: "豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕剜芄苋菀纨绾琬脘畹蜿箢",
  wang: "汪王亡枉网往旺望忘妄罔尢惘辋魍",
  wei: "威巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫倭偎诿隈葳薇帏帷崴嵬猥猬闱沩洧涠逶娓玮韪軎炜煨熨痿艉鲔",
  wen: "瘟温蚊文闻纹吻稳紊问刎愠阌汶璺韫殁雯",
  weng: "嗡翁瓮蓊蕹",
  wo: "挝蜗涡窝我斡卧握沃莴幄渥杌肟龌",
  wu: "巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误兀仵阢邬圬芴庑怃忤浯寤迕妩骛牾焐鹉鹜蜈鋈鼯",
  xi: "昔熙析西硒矽晰嘻吸锡牺稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细僖兮隰郗茜葸蓰奚唏徙饩阋浠淅屣嬉玺樨曦觋欷熹禊禧钸皙穸蜥蟋舾羲粞翕醯鼷",
  xia: "瞎虾匣霞辖暇峡侠狭下厦夏吓掀葭嗄狎遐瑕硖瘕罅黠",
  xian: "锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线冼藓岘猃暹娴氙祆鹇痫蚬筅籼酰跹",
  xiang: "相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象芗葙饷庠骧缃蟓鲞飨",
  xiao: "萧硝霄削哮嚣销消宵淆晓小孝校肖啸笑效哓咻崤潇逍骁绡枭枵筱箫魈",
  xie: "楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑偕亵勰燮薤撷廨瀣邂绁缬榭榍歙躞",
  xin: "薪芯锌欣辛新忻心信衅囟馨莘歆铽鑫",
  xing: "星腥猩惺兴刑型形邢行醒幸杏性姓陉荇荥擤悻硎",
  xiong: "兄凶胸匈汹雄熊芎",
  xiu: "休修羞朽嗅锈秀袖绣莠岫馐庥鸺貅髹",
  xu: "墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续讴诩圩蓿怵洫溆顼栩煦砉盱胥糈醑",
  xuan: "轩喧宣悬旋玄选癣眩绚儇谖萱揎馔泫洵渲漩璇楦暄炫煊碹铉镟痃",
  xue: "靴薛学穴雪血噱泶鳕",
  xun: "勋熏循旬询寻驯巡殉汛训讯逊迅巽埙荀薰峋徇浔曛窨醺鲟",
  ya: "压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶伢揠吖岈迓娅琊桠氩砑睚痖",
  yan: "焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验厣靥赝俨偃兖讠谳郾鄢芫菸崦恹闫阏洇湮滟妍嫣琰晏胭腌焱罨筵酽魇餍鼹",
  yang: "殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾徉怏泱炀烊恙蛘鞅",
  yao: "邀腰妖瑶摇尧遥窑谣姚咬舀药要耀夭爻吆崾徭瀹幺珧杳曜肴鹞窈繇鳐",
  ye: "椰噎耶爷野冶也页掖业叶曳腋夜液谒邺揶馀晔烨铘",
  yi: "一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎刈劓佾诒圪圯埸懿苡薏弈奕挹弋呓咦咿噫峄嶷猗饴怿怡悒漪迤驿缢殪贻旖熠钇镒镱痍瘗癔翊衤蜴舣羿翳酏黟",
  yin: "茵荫因殷音阴姻吟银淫寅饮尹引隐印胤鄞堙茚喑狺夤氤铟瘾蚓霪龈",
  ying: "英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映嬴郢茔莺萦撄嘤膺滢潆瀛瑛璎楹鹦瘿颍罂",
  yo: "哟唷",
  yong: "拥佣臃痈庸雍踊蛹咏泳涌永恿勇用俑壅墉慵邕镛甬鳙饔",
  you: "幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼卣攸侑莸呦囿宥柚猷牖铕疣蝣鱿黝鼬",
  yu: "迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉浴寓裕预豫驭禺毓伛俣谀谕萸蓣揄喁圄圉嵛狳饫庾阈妪妤纡瑜昱觎腴欤於煜燠聿钰鹆瘐瘀窳蝓竽舁雩龉",
  yuan: "鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院塬沅媛瑗橼爰眢鸢螈鼋",
  yue: "曰约越跃钥岳粤月悦阅龠樾刖钺",
  yun: "耘云郧匀陨允运蕴酝晕韵孕郓芸狁恽纭殒昀氲",
  za: "匝砸杂拶咂",
  zai: "栽哉灾宰载再在咱崽甾",
  zan: "攒暂赞瓒昝簪糌趱錾",
  zang: "赃脏葬奘戕臧",
  zao: "遭糟凿藻枣早澡蚤躁噪造皂灶燥唣缫",
  ze: "责择则泽仄赜啧迮昃笮箦舴",
  zei: "贼",
  zen: "怎谮",
  zeng: "增憎曾赠缯甑罾锃",
  zha: "扎喳渣札轧铡闸眨栅榨咋乍炸诈揸吒咤哳怍砟痄蚱齄",
  zhai: "摘斋宅窄债寨砦",
  zhan: "瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽谵搌旃",
  zhang: "樟章彰漳张掌涨杖丈帐账仗胀瘴障仉鄣幛嶂獐嫜璋蟑",
  zhao: "招昭找沼赵照罩兆肇召爪诏棹钊笊",
  zhe: "遮折哲蛰辙者锗蔗这浙谪陬柘辄磔鹧褚蜇赭",
  zhen: "珍斟真甄砧臻贞针侦枕疹诊震振镇阵缜桢榛轸赈胗朕祯畛鸩",
  zheng: "蒸挣睁征狰争怔整拯正政帧症郑证诤峥钲铮筝",
  zhi: "芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒卮陟郅埴芷摭帙忮彘咫骘栉枳栀桎轵轾攴贽膣祉祗黹雉鸷痣蛭絷酯跖踬踯豸觯",
  zhong: "中盅忠钟衷终种肿重仲众冢锺螽舂舯踵",
  zhou: "舟周州洲诌粥轴肘帚咒皱宙昼骤啄着倜诹荮鬻纣胄碡籀舳酎鲷",
  zhu: "珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑住注祝驻伫侏邾苎茱洙渚潴驺杼槠橥炷铢疰瘃蚰竺箸翥躅麈",
  zhua: "抓",
  zhuai: "拽",
  zhuan: "专砖转撰赚篆抟啭颛",
  zhuang: "桩庄装妆撞壮状丬",
  zhui: "椎锥追赘坠缀萑骓缒",
  zhun: "谆准",
  zhuo: "捉拙卓桌琢茁酌灼浊倬诼廴蕞擢啜浞涿杓焯禚斫",
  zi: "兹咨资姿滋淄孜紫仔籽滓子自渍字谘嵫姊孳缁梓辎赀恣眦锱秭耔笫粢觜訾鲻髭",
  zong: "鬃棕踪宗综总纵腙粽",
  zou: "邹走奏揍鄹鲰",
  zu: "租足卒族祖诅阻组俎菹啐徂驵蹴",
  zuan: "钻纂攥缵",
  zui: "嘴醉最罪",
  zun: "尊遵撙樽鳟",
  zuo: "昨左佐柞做作坐座阝阼胙祚酢",
  cou: "薮楱辏腠",
  nang: "攮哝囔馕曩",
  o: "喔",
  dia: "嗲",
  chuai: "嘬膪踹",
  cen: "岑涔",
  diu: "铥",
  nou: "耨",
  fou: "缶",
  bia: "髟"
};
function formatISODate(ISODate = "") {
  const dateStr = ISODate.replace("T", " ").replace("Z", "").split(".")[0];
  const formatDateStr = dateStr.replace(/(\s00:00:00)$/, "");
  return formatDateStr;
}
const _sfc_main$1f = defineComponent({
  name: "PageInfo",
  props: {
    pageData: {
      type: Object,
      default: () => ({})
    },
    currentCategory: {
      type: String,
      default: ""
    },
    currentTag: {
      type: String,
      default: ""
    },
    hideViews: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const { pageData, hideViews } = toRefs(props);
    const { solution, options } = useComment();
    const themeData2 = useThemeLocaleData$1();
    const author2 = computed(
      () => {
        var _a3, _b2;
        return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.author) || themeData2.value.author || "";
      }
    );
    const date = computed(() => {
      var _a3, _b2;
      const d2 = (_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.date;
      return d2 ? formatISODate(d2) : "";
    });
    const categories = computed(
      () => {
        var _a3, _b2;
        return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.categories) || [];
      }
    );
    const tags = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.tags) || [];
    });
    const showPageInfo = computed(
      () => !!author2.value || !!date.value || !!(categories.value && categories.value.length > 0) || !!(tags.value && tags.value.length > 0)
    );
    const showValineViews = computed(() => {
      return solution.value === "valine" && options.value.visitor != false && !hideViews.value;
    });
    const showWalineViews = computed(() => {
      return solution.value === "waline" && options.value.pageview != false && !hideViews.value;
    });
    return {
      author: author2,
      date,
      categories,
      tags,
      showPageInfo,
      solution,
      showValineViews,
      showWalineViews,
      convertToPinyin
    };
  }
});
const _hoisted_1$11 = {
  key: 0,
  class: "page-info"
};
const _hoisted_2$H = {
  class: "xicon-icon",
  style: { "width": "18px", "height": "18px", "font-size": "18px", "color": "inherit" },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 12 12"
};
const _hoisted_3$B = /* @__PURE__ */ createElementVNode(
  "g",
  { fill: "none" },
  [
    /* @__PURE__ */ createElementVNode("path", {
      d: "M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_4$q = [
  _hoisted_3$B
];
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  const _component_ValineViews = resolveComponent("ValineViews");
  const _component_WalineViews = resolveComponent("WalineViews");
  return _ctx.showPageInfo ? (openBlock(), createElementBlock("div", _hoisted_1$11, [
    !!_ctx.author ? (openBlock(), createBlock(_component_Xicons, {
      key: 0,
      icon: "User",
      text: _ctx.author
    }, null, 8, ["text"])) : createCommentVNode("v-if", true),
    !!_ctx.date ? (openBlock(), createBlock(_component_Xicons, {
      key: 1,
      icon: "Calendar",
      text: _ctx.date
    }, null, 8, ["text"])) : createCommentVNode("v-if", true),
    !!_ctx.categories && _ctx.categories.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
      key: 2,
      icon: "Folder"
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString(_ctx.categories.join(" ")),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    })) : createCommentVNode("v-if", true),
    !!_ctx.tags && _ctx.tags.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
      key: 3,
      icon: "Tag"
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString(_ctx.tags.join(" ")),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    })) : createCommentVNode("v-if", true),
    _ctx.showValineViews || _ctx.showWalineViews ? (openBlock(), createBlock(_component_Xicons, { key: 4 }, {
      icon: withCtx(() => [
        (openBlock(), createElementBlock("svg", _hoisted_2$H, _hoisted_4$q))
      ]),
      default: withCtx(() => [
        _ctx.showValineViews ? (openBlock(), createBlock(_component_ValineViews, { key: 0 })) : createCommentVNode("v-if", true),
        _ctx.showWalineViews ? (openBlock(), createBlock(_component_WalineViews, {
          key: 1,
          path: _ctx.pageData.path
        }, null, 8, ["path"])) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    })) : createCommentVNode("v-if", true)
  ])) : createCommentVNode("v-if", true);
}
const PageInfo$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1f, [["render", _sfc_render$I], ["__file", "PageInfo.vue"]]);
const _sfc_main$1e = defineComponent({
  components: { PageInfo: PageInfo$1 },
  props: {
    data: {
      type: Object,
      default: () => ({})
    }
  },
  setup() {
    const { solution } = useComment();
    return { solution };
  }
});
const _hoisted_1$10 = { class: "title" };
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RouterLink = resolveComponent("RouterLink");
  const _component_PageInfo = resolveComponent("PageInfo");
  const _component_MagicCard = resolveComponent("MagicCard");
  return openBlock(), createBlock(_component_MagicCard, { class: "post-item-container" }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$10, [
        createVNode(_component_RouterLink, {
          to: _ctx.data.path
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString(_ctx.data.title),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["to"])
      ]),
      createVNode(_component_PageInfo, {
        "page-data": _ctx.data,
        "hide-views": _ctx.solution === "valine"
      }, null, 8, ["page-data", "hide-views"])
    ]),
    _: 1
    /* STABLE */
  });
}
const PostItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1e, [["render", _sfc_render$H], ["__file", "PostItem.vue"]]);
const _sfc_main$1d = defineComponent({
  components: { PostItem },
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup() {
    return {};
  }
});
const _hoisted_1$$ = { class: "post-list-container" };
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PostItem = resolveComponent("PostItem");
  return openBlock(), createElementBlock("div", _hoisted_1$$, [
    (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.data, (item, index2) => {
        return openBlock(), createBlock(_component_PostItem, {
          key: index2,
          data: item
        }, null, 8, ["data"]);
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ]);
}
const PostList = /* @__PURE__ */ _export_sfc$1(_sfc_main$1d, [["render", _sfc_render$G], ["__file", "PostList.vue"]]);
var ModeIcon = /* @__PURE__ */ ((ModeIcon2) => {
  ModeIcon2["auto"] = "BrightnessContrast";
  ModeIcon2["dark"] = "Moon";
  ModeIcon2["light"] = "Sun";
  return ModeIcon2;
})(ModeIcon || {});
var EMode = /* @__PURE__ */ ((EMode2) => {
  EMode2[EMode2["auto"] = 0] = "auto";
  EMode2[EMode2["dark"] = 1] = "dark";
  EMode2[EMode2["light"] = 2] = "light";
  return EMode2;
})(EMode || {});
const APPEARANCE_KEY$1 = "vuepress-reco-color-scheme";
const _sfc_main$1c = /* @__PURE__ */ defineComponent({
  __name: "ToggleDarkModeButton",
  setup(__props) {
    const themeConfig = useThemeLocaleData();
    const mode = ref(themeConfig.value.colorMode || "auto");
    const icon = computed(() => {
      return ModeIcon[mode.value];
    });
    let toggleMode = () => {
      const currModeIndex = EMode[mode.value];
      const nextModeIndex = currModeIndex === 2 ? 0 : currModeIndex + 1;
      mode.value = EMode[nextModeIndex];
    };
    onMounted(() => {
      const userPreference = localStorage[APPEARANCE_KEY$1];
      if (userPreference) {
        mode.value = userPreference;
      }
      const classList2 = document.documentElement.classList;
      function setDarkClass(dark) {
        classList2.toggle("dark", dark);
      }
      function handleModeChange(m2) {
        if (m2 === "auto") {
          setDarkClass(darkMedia.matches);
          localStorage.removeItem(APPEARANCE_KEY$1);
        } else {
          setDarkClass(m2 === "dark");
          localStorage[APPEARANCE_KEY$1] = m2;
        }
      }
      const darkMedia = window.matchMedia("(prefers-color-scheme: dark)");
      darkMedia.onchange = (e2) => {
        if (mode.value === "auto") {
          setDarkClass(e2.matches);
        }
      };
      watch(mode, handleModeChange);
      handleModeChange(mode.value);
    });
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createBlock(_component_Xicons, {
        icon: icon.value,
        "icon-size": "20",
        class: "btn-toggle-dark-mode",
        onClick: _cache[0] || (_cache[0] = ($event) => unref(toggleMode)())
      }, null, 8, ["icon"]);
    };
  }
});
const ToggleDarkModeButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1c, [["__file", "ToggleDarkModeButton.vue"]]);
const _sfc_main$1b = defineComponent({
  name: "Link",
  inheritAttrs: false,
  props: {
    item: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const route = useRoute();
    const routeLocale = useRouteLocale();
    const siteLocal = useSiteLocaleData();
    const themeLocal = useThemeLocaleData();
    const { item } = toRefs(props);
    const hasHttpProtocol = computed(() => isLinkHttp$1(item.value.link));
    const hasNonHttpProtocal = computed(
      () => isLinkMailto(item.value.link) || isLinkTel(item.value.link)
    );
    const linkTarget = computed(() => {
      if (hasNonHttpProtocal.value)
        return void 0;
      if (item.value.target)
        return item.value.target;
      if (hasHttpProtocol.value)
        return "_blank";
      return void 0;
    });
    const isBlankTarget = computed(() => linkTarget.value === "_blank");
    const isRouterLink = computed(
      () => !hasHttpProtocol.value && !hasNonHttpProtocal.value && !isBlankTarget.value
    );
    const linkRel = computed(() => {
      if (hasNonHttpProtocal.value)
        return void 0;
      if (item.value.rel)
        return item.value.rel;
      if (isBlankTarget.value)
        return "noopener noreferrer";
      return void 0;
    });
    const linkAriaLabel = computed(
      () => item.value.ariaLabel || item.value.text
    );
    const shouldBeActiveInSubpath = computed(() => {
      const localeKeys2 = Object.keys(siteLocal.value.locales);
      if (localeKeys2.length) {
        return !localeKeys2.some((key) => key === item.value.link);
      }
      return item.value.link !== themeLocal.value.home || routeLocale.value;
    });
    const isActiveInSubpath = computed(() => {
      if (!isRouterLink.value || !shouldBeActiveInSubpath.value) {
        return false;
      }
      return route.path.startsWith(item.value.link);
    });
    return {
      isActiveInSubpath,
      isBlankTarget,
      isRouterLink,
      linkRel,
      linkTarget,
      linkAriaLabel
    };
  }
});
const _hoisted_1$_ = ["href", "target", "rel", "aria-label"];
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  const _component_RouterLink = resolveComponent("RouterLink");
  const _component_ExternalLinkIcon = resolveComponent("ExternalLinkIcon");
  return _ctx.isRouterLink ? (openBlock(), createBlock(_component_RouterLink, mergeProps({
    key: 0,
    class: ["link", { "router-link-active": _ctx.isActiveInSubpath }],
    to: _ctx.item.link,
    "aria-label": _ctx.linkAriaLabel
  }, _ctx.$attrs, {
    key: `${_ctx.item.link}-router`
  }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "before"),
      createVNode(_component_Xicons, {
        icon: _ctx.item.icon,
        text: _ctx.item.text
      }, null, 8, ["icon", "text"]),
      renderSlot(_ctx.$slots, "after")
    ]),
    _: 3
    /* FORWARDED */
  }, 16, ["class", "to", "aria-label"])) : (openBlock(), createElementBlock("a", mergeProps({
    key: 1,
    class: "link",
    href: _ctx.item.link,
    target: _ctx.linkTarget,
    rel: _ctx.linkRel,
    "aria-label": _ctx.linkAriaLabel
  }, _ctx.$attrs, {
    key: `${_ctx.item.link}-a`
  }), [
    renderSlot(_ctx.$slots, "before"),
    createVNode(_component_Xicons, {
      icon: _ctx.item.icon,
      text: _ctx.item.text
    }, null, 8, ["icon", "text"]),
    _ctx.isBlankTarget ? (openBlock(), createBlock(_component_ExternalLinkIcon, { key: 0 })) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "after")
  ], 16, _hoisted_1$_));
}
const Link = /* @__PURE__ */ _export_sfc$1(_sfc_main$1b, [["render", _sfc_render$F], ["__file", "Link.vue"]]);
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "DropdownTransition",
  setup(__props) {
    const setHeight = (items) => {
      items.style.height = items.scrollHeight + "px";
    };
    const unsetHeight = (items) => {
      items.style.height = "";
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: "bounce",
        mode: "out-in",
        onEnter: setHeight,
        onAfterEnter: unsetHeight,
        onBeforeLeave: setHeight
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
        /* FORWARDED */
      });
    };
  }
});
const DropdownTransition_vue_vue_type_style_index_0_lang = "";
const DropdownTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$1a, [["__file", "DropdownTransition.vue"]]);
const _hoisted_1$Z = ["aria-label"];
const _hoisted_2$G = {
  key: 0,
  class: "arrow down"
};
const _hoisted_3$A = ["aria-label"];
const _hoisted_4$p = { class: "title" };
const _hoisted_5$h = { class: "dropdown-link__subtitle" };
const _hoisted_6$d = { class: "dropdown-link__subcontainer" };
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "DropdownLink",
  props: {
    item: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const { item } = toRefs(props);
    const dropdownAriaLabel = computed(
      () => item.value.ariaLabel || item.value.text
    );
    const open = ref(false);
    const route = useRoute();
    watch(
      () => route.path,
      () => {
        open.value = false;
      }
    );
    const handleDropdown = (e2) => {
      const isTriggerByTab = e2.detail === 1;
      if (isTriggerByTab) {
        open.value = !open.value;
      } else {
        open.value = false;
      }
    };
    const isLastItemOfArray = (item2, arr) => arr[arr.length - 1] === item2;
    const inButton = ref(false);
    const handleButtonMouseEnter = () => {
      if (isMobile2.value)
        isMobile2.value = false;
      open.value = true;
      inButton.value = true;
    };
    const handleButtonMouseLeave = () => {
      inButton.value = false;
      setTimeout(() => {
        if (inButton.value || inDropdown.value) {
          open.value = true;
        } else {
          open.value = false;
        }
      }, 200);
    };
    const inDropdown = ref(false);
    const handleDropdownMouseEnter = () => {
      if (isMobile2.value)
        return;
      inDropdown.value = true;
    };
    const handleDropdownMouseLeave = () => {
      if (isMobile2.value)
        return;
      inDropdown.value = false;
      setTimeout(() => {
        if (inButton.value || inDropdown.value) {
          open.value = true;
        } else {
          open.value = false;
        }
      }, 200);
    };
    const isMobile2 = ref(true);
    const handleMobileButtonClick = () => {
      open.value = !open.value;
      if (!isMobile2.value)
        isMobile2.value = true;
    };
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(["dropdown-link", { open: open.value }])
        },
        [
          createElementVNode("button", {
            class: "dropdown-link__title",
            type: "button",
            "aria-label": dropdownAriaLabel.value,
            onClick: handleDropdown,
            onMouseenter: handleButtonMouseEnter,
            onMouseleave: handleButtonMouseLeave
          }, [
            createVNode(_component_Xicons, {
              class: "title",
              icon: unref(item).icon,
              text: unref(item).text
            }, null, 8, ["icon", "text"]),
            unref(item).text ? (openBlock(), createElementBlock("span", _hoisted_2$G)) : createCommentVNode("v-if", true)
          ], 40, _hoisted_1$Z),
          createElementVNode("button", {
            class: "dropdown-link--mobile__title",
            type: "button",
            "aria-label": dropdownAriaLabel.value,
            onClick: handleMobileButtonClick
          }, [
            createElementVNode("span", _hoisted_4$p, [
              createVNode(_component_Xicons, {
                icon: unref(item).icon,
                text: unref(item).text
              }, null, 8, ["icon", "text"])
            ]),
            unref(item).text ? (openBlock(), createElementBlock(
              "span",
              {
                key: 0,
                class: normalizeClass(["arrow", open.value ? "down" : "right"])
              },
              null,
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true)
          ], 8, _hoisted_3$A),
          createVNode(DropdownTransition, null, {
            default: withCtx(() => [
              withDirectives(createElementVNode(
                "ul",
                {
                  class: "dropdown-link__container",
                  onMouseenter: handleDropdownMouseEnter,
                  onMouseleave: handleDropdownMouseLeave
                },
                [
                  (openBlock(true), createElementBlock(
                    Fragment,
                    null,
                    renderList(unref(item).children, (child, index2) => {
                      return openBlock(), createElementBlock("li", {
                        key: child.link || index2,
                        class: "dropdown-link__item"
                      }, [
                        child.children ? (openBlock(), createElementBlock(
                          Fragment,
                          { key: 0 },
                          [
                            createElementVNode("h5", _hoisted_5$h, [
                              createVNode(_component_Xicons, {
                                icon: child.icon,
                                text: child.text
                              }, null, 8, ["icon", "text"])
                            ]),
                            createElementVNode("ul", _hoisted_6$d, [
                              (openBlock(true), createElementBlock(
                                Fragment,
                                null,
                                renderList(child.children, (grandchild) => {
                                  return openBlock(), createElementBlock("li", {
                                    key: grandchild.link,
                                    class: "dropdown-link__subitem"
                                  }, [
                                    createVNode(Link, {
                                      item: grandchild,
                                      onFocusout: ($event) => isLastItemOfArray(grandchild, child.children) && isLastItemOfArray(child, unref(item).children) && (open.value = false)
                                    }, null, 8, ["item", "onFocusout"])
                                  ]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ])
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        )) : (openBlock(), createBlock(Link, {
                          key: 1,
                          item: child,
                          onFocusout: ($event) => isLastItemOfArray(child, unref(item).children) && (open.value = false)
                        }, null, 8, ["item", "onFocusout"]))
                      ]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ],
                544
                /* HYDRATE_EVENTS, NEED_PATCH */
              ), [
                [vShow, open.value]
              ])
            ]),
            _: 1
            /* STABLE */
          })
        ],
        2
        /* CLASS */
      );
    };
  }
});
const DropdownLink = /* @__PURE__ */ _export_sfc$1(_sfc_main$19, [["__file", "DropdownLink.vue"]]);
const useNavbarSelectLanguage = () => {
  const router = useRouter();
  const routeLocale = useRouteLocale();
  const siteLocale = useSiteLocaleData();
  const themeLocal = useThemeLocaleData$1();
  return computed(() => {
    const localePaths = Object.keys(siteLocale.value.locales);
    if (localePaths.length < 2) {
      return [];
    }
    const currentPath = router.currentRoute.value.path;
    const currentFullPath = router.currentRoute.value.fullPath;
    const selectLanguageText = computed(() => {
      return themeLocal.value.selectLanguageText || "选择语言";
    });
    const languageDropdown = {
      icon: "EarthFilled",
      text: selectLanguageText.value,
      children: localePaths.map((targetLocalePath) => {
        var _a3, _b2;
        const targetSiteLocale = ((_a3 = siteLocale.value.locales) == null ? void 0 : _a3[targetLocalePath]) ?? {};
        const targetThemeLocale = ((_b2 = themeLocal.value.locales) == null ? void 0 : _b2[targetLocalePath]) ?? {};
        const targetLang = `${targetSiteLocale.lang}`;
        const text2 = targetThemeLocale.selectLanguageName ?? targetLang;
        let link;
        if (targetLang === siteLocale.value.lang) {
          link = currentFullPath;
        } else {
          const targetLocalePage = currentPath.replace(
            routeLocale.value,
            targetLocalePath
          );
          if (router.getRoutes().some((item) => item.path === targetLocalePage)) {
            link = targetLocalePage;
          } else {
            link = targetThemeLocale.home ?? targetLocalePath;
          }
        }
        return {
          text: text2,
          link
        };
      })
    };
    return [languageDropdown];
  });
};
const useNavbarRepo = () => {
  const themeLocal = useThemeLocaleData$1();
  const repo = computed(() => themeLocal.value.repo);
  const repoType = computed(
    () => repo.value ? resolveRepoType(repo.value) : null
  );
  const repoLink = computed(() => {
    if (repoType.value === "GitHub") {
      return `https://github.com/${repo.value}`;
    }
    return repo.value;
  });
  const repoLabel = computed(() => {
    if (!repoLink.value)
      return null;
    if (themeLocal.value.repoLabel)
      return themeLocal.value.repoLabel;
    if (repoType.value === null)
      return "Source";
    return repoType.value;
  });
  return computed(() => {
    if (!repoLink.value || !repoLabel.value) {
      return [];
    }
    return [
      {
        text: repoLabel.value,
        link: repoLink.value
      }
    ];
  });
};
const resolveNavbarItem = (item) => {
  if (isString$1(item)) {
    return useNavLink(item);
  }
  if (item.children) {
    return {
      ...item,
      children: item.children.map(resolveNavbarItem)
    };
  }
  return item;
};
const useNavbarConfig = () => {
  const themeLocal = useThemeLocaleData$1();
  const { categorySummary } = usePageData();
  const parseCategories = computed(() => {
    var _a3, _b2, _c, _d;
    return [
      {
        text: ((_a3 = themeLocal.value.autoAddCategoryToNavbar) == null ? void 0 : _a3.categoryText) || "Categories",
        children: Object.values(((_b2 = categorySummary == null ? void 0 : categorySummary.categories) == null ? void 0 : _b2.items) || {}).map((c2) => ({
          // @ts-ignore
          text: c2.label,
          // @ts-ignore
          link: `/categories/${convertToPinyin(c2.label)}/1/`
        }))
      },
      {
        text: ((_c = themeLocal.value.autoAddCategoryToNavbar) == null ? void 0 : _c.tagText) || "Tags",
        children: Object.values(((_d = categorySummary == null ? void 0 : categorySummary.tags) == null ? void 0 : _d.items) || {}).map((t2) => ({
          // @ts-ignore
          text: t2.label,
          // @ts-ignore
          link: `/tags/${convertToPinyin(t2.label)}/1/`
        }))
      }
    ];
  });
  return computed(() => {
    var _a3;
    let navItems = [...themeLocal.value.navbar || []];
    if (themeLocal.value.autoAddCategoryToNavbar) {
      navItems.splice(
        ((_a3 = themeLocal.value.autoAddCategoryToNavbar) == null ? void 0 : _a3.location) || 0,
        0,
        ...parseCategories.value
      );
    }
    return navItems.map(resolveNavbarItem);
  });
};
const _sfc_main$18 = defineComponent({
  name: "NavbarLinks",
  components: {
    Link,
    DropdownLink
  },
  setup() {
    const navbarConfig = useNavbarConfig();
    const navbarSelectLanguage = useNavbarSelectLanguage();
    const navbarRepo = useNavbarRepo();
    const navbarLinks = computed(() => [
      ...navbarConfig.value,
      ...navbarSelectLanguage.value,
      ...navbarRepo.value
    ]);
    return {
      navbarLinks
    };
  }
});
const _hoisted_1$Y = {
  key: 0,
  class: "navbar-links"
};
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DropdownLink = resolveComponent("DropdownLink");
  const _component_Link = resolveComponent("Link");
  return _ctx.navbarLinks.length ? (openBlock(), createElementBlock("nav", _hoisted_1$Y, [
    (openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.navbarLinks, (item) => {
        return openBlock(), createElementBlock("div", {
          key: item.link,
          class: "navbar-links__item"
        }, [
          item.children ? (openBlock(), createBlock(_component_DropdownLink, {
            key: 0,
            item
          }, null, 8, ["item"])) : (openBlock(), createBlock(_component_Link, {
            key: 1,
            item
          }, null, 8, ["item"]))
        ]);
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ])) : createCommentVNode("v-if", true);
}
const NavbarLinks = /* @__PURE__ */ _export_sfc$1(_sfc_main$18, [["render", _sfc_render$E], ["__file", "NavbarLinks.vue"]]);
const _hoisted_1$X = { class: "site-brand" };
const _hoisted_2$F = ["src", "alt"];
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  __name: "SiteBrand",
  setup(__props) {
    const siteLocale = useSiteLocaleData();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    const siteBrandLink = computed(
      () => themeLocal.value.home || routeLocale.value
    );
    const siteBrandLogo = computed(() => themeLocal.value.logo);
    const siteBrandTitle = computed(() => siteLocale.value.title);
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return openBlock(), createElementBlock("div", _hoisted_1$X, [
        siteBrandLogo.value ? (openBlock(), createElementBlock("img", {
          key: 0,
          class: "logo",
          src: unref(withBase)(siteBrandLogo.value),
          alt: siteBrandTitle.value
        }, null, 8, _hoisted_2$F)) : createCommentVNode("v-if", true),
        siteBrandTitle.value ? (openBlock(), createBlock(_component_RouterLink, {
          key: 1,
          to: siteBrandLink.value,
          class: normalizeClass(["site-name", { "can-hide": siteBrandLogo.value }])
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString(siteBrandTitle.value),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["to", "class"])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});
const SiteBrand_vue_vue_type_style_index_0_lang = "";
const SiteBrand = /* @__PURE__ */ _export_sfc$1(_sfc_main$17, [["__file", "SiteBrand.vue"]]);
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "Navbar",
  emits: ["toggle-menus"],
  setup(__props, { emit: emits }) {
    const seriesItems = useSeriesItems();
    const siteLocale = useSiteLocaleData();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    computed(
      () => themeLocal.value.home || routeLocale.value
    );
    computed(() => themeLocal.value.logo);
    computed(() => siteLocale.value.title);
    const navbar = ref(null);
    const siteBrand = ref(null);
    const linksWrapperMaxWidth = ref(0);
    const linksWrapperStyle = computed(() => {
      if (!linksWrapperMaxWidth.value) {
        return {};
      }
      return {
        maxWidth: linksWrapperMaxWidth.value + "px"
      };
    });
    const toggleMenus = (bool) => {
      emits("toggle-menus", bool);
    };
    const isMobile2 = ref(false);
    onMounted(() => {
      const MOBILE_DESKTOP_BREAKPOINT = 768;
      const handleLinksWrapWidth = () => {
        var _a3, _b2;
        if (window.innerWidth <= MOBILE_DESKTOP_BREAKPOINT) {
          isMobile2.value = true;
          linksWrapperMaxWidth.value = 0;
        } else {
          isMobile2.value = false;
          linksWrapperMaxWidth.value = ((_a3 = navbar.value) == null ? void 0 : _a3.offsetWidth) - (((_b2 = siteBrand.value) == null ? void 0 : _b2.offsetWidth) || 0) - 50;
          toggleMenus(false);
        }
      };
      handleLinksWrapWidth();
      window.addEventListener("resize", throttle(handleLinksWrapWidth), false);
      window.addEventListener("orientationchange", handleLinksWrapWidth, false);
    });
    return (_ctx, _cache) => {
      const _component_NavbarSearch = resolveComponent("NavbarSearch");
      return openBlock(), createElementBlock(
        "header",
        {
          ref_key: "navbar",
          ref: navbar,
          class: "navbar-container",
          style: normalizeStyle({ top: unref(seriesItems).length > 0 && isMobile2.value ? "-4rem" : "0" })
        },
        [
          createVNode(SiteBrand, { class: "nav-item" }),
          createElementVNode(
            "div",
            {
              class: "nav-item navbar-links-wrapper",
              style: normalizeStyle(linksWrapperStyle.value)
            },
            [
              createElementVNode("div", null, [
                createVNode(_component_NavbarSearch)
              ]),
              createVNode(NavbarLinks),
              createVNode(ToggleDarkModeButton, { class: "btn--dark-mode" }),
              createVNode(Xicons, {
                class: "btn-toggle-menus",
                icon: "OverflowMenuVertical",
                iconSize: 20,
                onClick: toggleMenus
              })
            ],
            4
            /* STYLE */
          )
        ],
        4
        /* STYLE */
      );
    };
  }
});
const Navbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$16, [["__file", "Navbar.vue"]]);
const _hoisted_1$W = ["title"];
const _hoisted_2$E = /* @__PURE__ */ createElementVNode(
  "div",
  {
    class: "icon",
    "aria-hidden": "true"
  },
  [
    /* @__PURE__ */ createElementVNode("span"),
    /* @__PURE__ */ createElementVNode("span"),
    /* @__PURE__ */ createElementVNode("span")
  ],
  -1
  /* HOISTED */
);
const _hoisted_3$z = [
  _hoisted_2$E
];
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "ToggleSeriesButton",
  emits: ["toggle"],
  setup(__props, { emit: emits }) {
    const toggle = () => {
      emits("toggle");
    };
    const themeLocal = useThemeLocaleData$1();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "toggle-series-button",
        title: unref(themeLocal).toggleSeries,
        "aria-expanded": "false",
        role: "button",
        tabindex: "0",
        onClick: toggle
      }, _hoisted_3$z, 8, _hoisted_1$W);
    };
  }
});
const ToggleSeriesButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$15, [["__file", "ToggleSeriesButton.vue"]]);
const _hoisted_1$V = {
  ref: "subnavbar",
  class: "sub-navbar-container"
};
const _hoisted_2$D = { class: "nav-item" };
const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "SubNavbar",
  emits: ["toggle-series"],
  setup(__props, { emit: emits }) {
    const toggleSeries = () => {
      emits("toggle-series");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "header",
        _hoisted_1$V,
        [
          createElementVNode("span", _hoisted_2$D, [
            createVNode(ToggleSeriesButton, { onToggle: toggleSeries }),
            createTextVNode(" Series ")
          ])
        ],
        512
        /* NEED_PATCH */
      );
    };
  }
});
const SubNavbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$14, [["__file", "SubNavbar.vue"]]);
const normalizePath = (path) => decodeURI(path).replace(/#.*$/, "").replace(/(index)?\.(md|html)$/, "");
const isActiveLink = (route, link) => {
  if (link === void 0) {
    return false;
  }
  if (route.hash === link) {
    return true;
  }
  const currentPath = normalizePath(route.path);
  const targetPath = normalizePath(link);
  return currentPath === targetPath;
};
const isActiveItem$1 = (route, item) => {
  if (isActiveLink(route, item.link)) {
    return true;
  }
  if (item.children) {
    return item.children.some((child) => isActiveItem$1(route, child));
  }
  return false;
};
const togglecollapsible = (e2, item) => {
  item.collapsible = !!!item.collapsible;
  const currentNode = e2.target.querySelector(".arrow");
  const nextNode = e2.target.nextElementSibling;
  if (item.collapsible) {
    currentNode.classList.remove("down");
    currentNode.classList.add("right");
    nextNode.style.display = "none";
  } else {
    currentNode.classList.remove("right");
    currentNode.classList.add("down");
    nextNode.style.display = "block";
  }
};
const renderItem$1 = (item, props) => {
  if (item.link) {
    return h$5(Link, {
      ...props,
      item
    });
  }
  return h$5("h5", {
    ...props,
    onClick: (e2) => togglecollapsible(e2, item)
  }, [item.text, h$5("span", {
    class: !!item.collapsible ? "arrow right" : "arrow down"
  })]);
};
const renderChildren$1 = (item) => {
  var _a3;
  if (!((_a3 = item.children) === null || _a3 === void 0 ? void 0 : _a3.length)) {
    return null;
  }
  return h$5("ul", {
    style: {
      display: !!item.collapsible ? "none" : "block"
    }
  }, item.children.map((child) => h$5("li", h$5(SeriesItem, {
    item: child
  }))));
};
const SeriesItem = ({
  item
}) => {
  const route = useRoute();
  const active = isActiveItem$1(route, item);
  if (item.children) {
    return [h$5("section", {
      class: "series-group series-item"
    }, [renderItem$1(item, {
      class: {
        "series-heading": true,
        active
      }
    }), renderChildren$1(item)])];
  }
  return [renderItem$1(item, {
    class: {
      "series-item": true,
      active
    }
  })];
};
SeriesItem.displayName = "SeriesItem";
SeriesItem.props = {
  item: {
    type: Object,
    required: true
  }
};
const _hoisted_1$U = { class: "series-container" };
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  __name: "Series",
  setup(__props) {
    const themeLocal = useThemeLocaleData$1();
    const { sortSeries: sortSeries2 } = useSortSeries();
    const seriesItems = useSeriesItems();
    const sortedSeries = computed(() => {
      if (!themeLocal.value.autoSetSeries) {
        return seriesItems.value;
      }
      const series = sortSeries2(seriesItems.value);
      return series;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("aside", _hoisted_1$U, [
        createVNode(SiteBrand),
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(sortedSeries.value, (item) => {
            return openBlock(), createBlock(unref(SeriesItem), {
              item,
              key: item.link || item.text
            }, null, 8, ["item"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]);
    };
  }
});
const Series = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["__file", "Series.vue"]]);
const isActiveItem = (route, item) => {
  if (route.hash === item.link) {
    return true;
  }
  if (item.children) {
    return item.children.some((child) => isActiveItem(route, child));
  }
  return false;
};
const renderItem = (item, props) => {
  return h$5("li", {
    ...props
  }, h$5(Link, {
    class: "page-catalog-item",
    item
  }));
};
const renderChildren = (item) => {
  var _a3;
  if (!((_a3 = item.children) === null || _a3 === void 0 ? void 0 : _a3.length)) {
    return [null];
  }
  return item.children.map((child) => h$5(CatalogItem, {
    item: child
  }));
};
const CatalogItem = ({
  item
}) => {
  const route = useRoute();
  const active = isActiveItem(route, item);
  if (item.children && item.children.length > 0) {
    return [renderItem(item, {
      class: {
        [`page-catalog-menu-depth_${item.level || 2}`]: true,
        active
      }
    }), ...renderChildren(item)];
  }
  return [renderItem(item, {
    class: {
      [`page-catalog-menu-depth_${item.level || 2}`]: true,
      active
    }
  })];
};
CatalogItem.displayName = "CatalogItem";
CatalogItem.props = {
  item: {
    type: Object,
    required: true
  }
};
const _hoisted_1$T = { class: "page-catalog-container" };
const _hoisted_2$C = { class: "tip" };
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "Catalog",
  setup(__props) {
    const catalog = usePageCatalog();
    const themeConfig = useThemeLocaleData();
    const catalogTitle = computed(() => {
      return themeConfig.value.catalogTitle || "ON THIS PAGE";
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$T, [
        createElementVNode(
          "h5",
          _hoisted_2$C,
          toDisplayString(catalogTitle.value),
          1
          /* TEXT */
        ),
        createElementVNode("ul", null, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(unref(catalog), (item) => {
              return openBlock(), createBlock(unref(CatalogItem), {
                key: item.link || item.text,
                item
              }, null, 8, ["item"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ]);
    };
  }
});
const Catalog = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__file", "Catalog.vue"]]);
function useSiteInfo() {
  const siteLocale = useSiteLocaleData();
  const themeLocal = useThemeLocaleData();
  const siteBrandLogo = computed(() => themeLocal.value.logo);
  const siteBrandTitle = computed(() => siteLocale.value.title);
  const sitePassword = computed(() => {
    const _password = themeLocal.value.password;
    if (!_password)
      return [];
    return Array.isArray(_password) ? _password : [_password];
  });
  return {
    siteBrandLogo,
    siteBrandTitle,
    sitePassword
  };
}
function useHandlePassword$1(sitePassword, emit) {
  const password = ref("");
  const passwordRef = ref(null);
  const lockIcon = ref("Locked");
  const lockText = ref("请输入密码");
  watch(password, (newVal) => {
    if (newVal.length !== 6)
      return;
    if (sitePassword.value.includes(md5(md5(newVal)))) {
      lockIcon.value = "Unlocked";
      lockText.value = "密码正确，请重稍后！";
      setTimeout(() => {
        emit("pass");
      }, 600);
    } else {
      password.value = "";
      lockText.value = "密码错误，请重新输入！";
    }
  });
  const focus = () => {
    passwordRef.value.focus();
  };
  return {
    password,
    passwordRef,
    lockIcon,
    lockText,
    focus
  };
}
const _imports_0$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAMAAAC7IEhfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURUxpcfjxsuzNbOC3gOCzcezbl/PWkvnpveKrTPXMmtmTRu/ljumwSdq1geSbP+a8ae+zSurBV/LjrO7Yb+bNlfrrrtmNP/PgdenEWurKhenFdt2rYt/EjPXnu+e9faFjNbWReNq8fdi1hZ1xTuOtVVxBUlIxSGFPX+jGXvHgmu/hn/Hfj96tYe7Yqea7XfXimPLghP334+Cwbvr32N3CiN/Bd+K5fui0Wt2fUeS2U+zOeuO1Y/bmiuPEiuG0bqyKduG5hfvOWaBuWk8sPa6DW++jROfFZfLkl86JV/nuyOzZfvjVY9qkYd20dJ9yXL+YWWxSWcmjbpyQdoyHee7ZfOGsVuTBau3WeOW7V92nUdCSRee3UcaEQuOwVufJk4deQfPOgIpsTt2fR6R/Vtyzd86keNqsab6SX8GYdPWlPPy/VZySeevMYufDeenMZtqkT9KRU/LNYP3aj8imfLCMbdQsG+m+Xem4UurDXtYgF+e2Weq+VRgWb+/KXui7WOWzUxESfO3BWQ8JatIWEduVQdcKCw8PcttQJ+GjSenIZNZfLhcHX9dKKNqXUOnBaN+fR8pEIuO4YdOEPOm0T+/GXNdBJNS6c96jUNIeEsZRJOhyNPbKaedoLeR2OelcJG9wehkaeIN9etQ1HvDOYqqkhdhzNNg6H/jCUv3VWNEIBRUeidl+OPG+UtmjW+GQP9x0OsdeLMsLCPfFXSMOXfAsEcEOEaqBUaWOZU0GRM+wax81jbOgboeFf8izeu6uWaSbfb2ve+OtV9RqMt1rNN2DQt6IN49aOOaiQ7slGmlgblBMb8ovF91YKMcfEF9ujex/M2FkfYeMjJKNfnl3d5wGHpJ7Xu2NQuKxTNBZLseoWb9oOfY7GcE7LWUZSGYEOPevRp+AXDVGinSAi4ZvW60TFUcmU7Cbe7ipdNBGJv7oapJsSV8nUa81NL9GI/R6LbORVbJQOCgueogKJ3ZjXuNCHK4HGn1oYDMfXLp7Pi8LVmsuUKM7LkFXknNiZHtdUdwjFSsuVN8AAAB1dFJOUwAE/hMaDRsI/gH+FPw6/L/+9GT+cS/+7vyP0M0kQbD5w1uI/uf5+v7sTHyU3FvVPLgXvyRJ/aPk1fyq66Vn2NEt/Nv85/7eh2FLzPfvsvX9+N7m8trP7+ntyafrm/OH+Jz59+3Pn3/Mq+qq+NHq5MF4+InD117Lt0kAAAU3SURBVDjLbdV3VJNnFAdgE8gkCQkJS9nInspQRGSIu+496qhard3tySAkIYuEbCBkAAFCwpCN7CkgKGUvBffee1S7z+kXUiL2cP9+zu97733Pe79582YXaFFIAMHFJdqFEBCyCDRv7kLAYGbmMegoN5fo6Gg3AjrG3AwGQ8wBYdaObsfj4pydDx06cuTo0bi4427rHGFzBEJ8ok66bHJ3dr5w4enThoZNm1xOEgIgcwQ6nIj3XHnB+epVobC7qqK5tdHTM/6Ew/8jQTAoOv72SgBWVw/marIkFQboHo+GghCfdmt9eOMWj3tPCzVqjk7B56uJk6qOca8t4T9BZ2eCINahG7d6eLg3ZOVyknU6saKEMzLZWeDl9XM4GgozzQkUEmS51cPTa8v5kSJiQgJRp1CoOUMDZ9MmRj08jjkBnzdBxxWbH/zm9W7kJVENQKKiSM2pH1p1ti3vgefWY6EOINMEQ7fla7WXGjS5yclEIJPDIRLPnMnNedRBo+VvC40BzZwwyHVbPpN5qSHXBHUA5GvaC2i8ie2uQZBpiVgUc8ry63wmzf13/q/JyQkJuqIiXUJCSUkRX9lJ4+VtD15uPX3vIAf0qUAjHDRAokLMF+uIABw0wvXBjiEGCHH98qtVD9uYzNubRzTJJamX023g8J4qtTo3p/kRjZff8eOGNVYQExwHzvhq8iXnTGZ1OndqqrKHSMyabG6l8do6MmL9fA3QzC0cg2nvKC3tu4e6lfkiNfVcYVlZVVVZTyz90j88bUE7Fut00GwabsRgmh+Wlva/g6+qzkxNFQoLC7u7e5A1lA9eTG2BEotysjdA88X+NpVS5Z0WWu3r6pwc8ePUx0KhWNydU3X1N1rpHSW4F+O/2NwAF3xmYyNV/t3CE/31IiuLLzZkisUazeXXteyWO2FgDNcE09Nvnb07zGRfrK+7NijMzDxXmJN1ra7+vYg9fJdUzLWJtJwFx+4C8H1dHf8yAM9Nw4si3vAYq5iLDDTC8MVfyGqy2wtamE0379cPDQ0MDOj4fMX1tzd52o727Oykz43NmAEwpSY7rLOltKnp7cX7938B6vr1589vNtHePFIa4DJj107HkNwuajZ4bJjGFolEtU03btz4o1YkYvNGJwQbSFQ4fP4ycyOUIFVdNdKCsTdaNpstevDsz2e1Ijabp80bp8dSu2YgdH5YhUQiwfRKwzpb730YzWts3Pyqr7+/fzSvOQ3VK5PBk3avh07DbysAWYkhScOUjbfb2lqvXLkykdfXlz+eRu3FyGRTETuCDRBi5bsnQqVC2pSdL6/R6+n08nIslkTB4+msyvNIJHzKzpvgY3iKsHVWgXvgKiSysAxbfBqo4mIsNvb0kyexxQCUdEV4f+NjDZteTlAr39W4iKn0dK6Mrmex5HIGQ6/foE+RISVp0l2rCT4W/71tIHO1t10E0obLpdBJjKQkBomu1wtSZCqVFLxrfkDQzA6AOQasiLSzM5BEFoVComRksBhweBJVABZIF/q7zoJWKyIFAgqFSjVACoWewSCnpFAZYABG+kf5zEALv2BbPB6flkalMoBUEolBlslS4FQqiSQA422Xr7EwweW2tnjwR0iWA2OGUxkkEhhsOwuCoNZ+y7xxZDIro7xcLieTUSgyg8VKTKQIdu/w83WwQJi2N5RgHxi4fz8OlwgguRyFYuDs7HA47+/WB/taQT5uSAQIYhGDXvvDvn17dy5dunDhkiU7F1haHraPcnWAWkA+XfgIM/O1aw8c+H6vES4AoP3BUPTH38K/OmNBlhC2jIMAAAAASUVORK5CYII=";
const name = "vuepress-theme-reco";
const version = "2.0.0-beta.68";
const description = "> TODO: description";
const homepage = "https://github.com/recoluan/vuepress-theme-reco#readme";
const bugs = {
  url: "https://github.com/recoluan/vuepress-theme-reco/issues"
};
const repository = {
  type: "git",
  url: "git+https://github.com/recoluan/vuepress-theme-reco.git"
};
const license = "MIT";
const author = "reco_luan <recoluan@qq.com>";
const main = "lib/node/index.js";
const types = "lib/node/index.d.ts";
const type = "module";
const directories = {
  lib: "lib",
  test: "__tests__"
};
const files = [
  "lib",
  "templates"
];
const publishConfig = {
  access: "public"
};
const dependencies = {
  "@vicons/carbon": "^0.12.0",
  "@vuepress-reco/shared": "2.0.0-beta.68",
  "@vuepress-reco/tailwindcss-config": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-bulletin-popover": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-comments": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-page": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-code-copy": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-markdown-task": "2.0.0-beta.68",
  "@vuepress-reco/vuepress-plugin-vue-preview": "2.0.0-beta.68",
  "@vuepress/bundler-vite": "2.0.0-beta.67",
  "@vuepress/bundler-webpack": "2.0.0-beta.67",
  "@vuepress/client": "2.0.0-beta.67",
  "@vuepress/core": "2.0.0-beta.67",
  "@vuepress/plugin-active-header-links": "2.0.0-beta.67",
  "@vuepress/plugin-back-to-top": "2.0.0-beta.67",
  "@vuepress/plugin-container": "2.0.0-beta.67",
  "@vuepress/plugin-external-link-icon": "2.0.0-beta.67",
  "@vuepress/plugin-git": "2.0.0-beta.67",
  "@vuepress/plugin-medium-zoom": "2.0.0-beta.67",
  "@vuepress/plugin-nprogress": "2.0.0-beta.67",
  "@vuepress/plugin-palette": "2.0.0-beta.67",
  "@vuepress/plugin-prismjs": "2.0.0-beta.67",
  "@vuepress/plugin-register-components": "2.0.0-beta.67",
  "@vuepress/plugin-search": "2.0.0-beta.67",
  "@vuepress/plugin-docsearch": "2.0.0-beta.67",
  "@vuepress/plugin-theme-data": "2.0.0-beta.67",
  "@vuepress/shared": "2.0.0-beta.67",
  "@vuepress/utils": "2.0.0-beta.67",
  autoprefixer: "10.4.7",
  postcss: "8.4.14",
  "postcss-each": "1.1.0",
  "postcss-import": "14.0.2",
  tailwindcss: "3.1.6",
  vue: "^3.3.4",
  "vue-router": "^4.2.2"
};
const devDependencies = {
  "eslint-config-vuepress": "3.2.1",
  "eslint-config-vuepress-typescript": "2.2.1",
  prettier: "2.2.1",
  "sort-package-json": "1.44.0"
};
const peerDependencies = {
  vuepress: "2.0.0-beta.67"
};
const scripts = {
  test: 'echo "Error: run tests from root" && exit 1',
  build: "tsc --build tsconfig.build.json",
  clean: "rimraf lib *.tsbuildinfo",
  copy: 'cpx "src/**/*.{d.ts,vue,scss,css,svg,png,jpg}" lib'
};
const packageInfo = {
  name,
  version,
  description,
  homepage,
  bugs,
  repository,
  license,
  author,
  main,
  types,
  type,
  directories,
  files,
  publishConfig,
  dependencies,
  devDependencies,
  peerDependencies,
  scripts
};
const _hoisted_1$S = { class: "footer-wrapper" };
const _hoisted_2$B = {
  class: "xicon-icon",
  style: { "width": "18px", "height": "18px", "font-size": "18px", "color": "inherit" },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
};
const _hoisted_3$y = /* @__PURE__ */ createElementVNode(
  "g",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  },
  [
    /* @__PURE__ */ createElementVNode("circle", {
      cx: "12",
      cy: "12",
      r: "9"
    }),
    /* @__PURE__ */ createElementVNode("path", { d: "M14 9.75a3.016 3.016 0 0 0-4.163.173a2.993 2.993 0 0 0 0 4.154A3.016 3.016 0 0 0 14 14.25" })
  ],
  -1
  /* HOISTED */
);
const _hoisted_4$o = [
  _hoisted_3$y
];
const _hoisted_5$g = { key: 0 };
const _hoisted_6$c = {
  class: "xicon-icon",
  style: { "width": "18px", "height": "18px", "font-size": "18px", "color": "inherit" },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 12 12"
};
const _hoisted_7$9 = /* @__PURE__ */ createElementVNode(
  "g",
  { fill: "none" },
  [
    /* @__PURE__ */ createElementVNode("path", {
      d: "M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z",
      fill: "currentColor"
    })
  ],
  -1
  /* HOISTED */
);
const _hoisted_8$7 = [
  _hoisted_7$9
];
const _hoisted_9$6 = {
  key: 1,
  class: "cyber-security"
};
const _hoisted_10$5 = /* @__PURE__ */ createElementVNode(
  "img",
  {
    src: _imports_0$1,
    alt: ""
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_11$4 = ["href"];
const _sfc_main$11 = {
  __name: "Footer",
  setup(__props) {
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData$1();
    const frontmatter = usePageFrontmatter();
    const { solution, options } = useComment();
    const { version: version2 } = packageInfo;
    const showAccessNumber = computed(() => {
      if (solution.value === "valine")
        return options.value.visitor != false;
      if (solution.value === "waline")
        return options.value.pageview != false;
      return false;
    });
    const copyRight = computed(() => {
      var _a3, _b2;
      let text2 = "";
      if (themeLocal.value.author) {
        text2 += `${themeLocal.value.author} `;
      }
      const startYear = (_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.footer) == null ? void 0 : _b2.startYear;
      const currYear = (/* @__PURE__ */ new Date()).getFullYear();
      if (startYear && startYear != currYear) {
        text2 += `${startYear} - `;
      }
      text2 += currYear;
      return text2;
    });
    const homeLink = computed(() => themeLocal.value.home || routeLocale.value);
    const isShowCommentAtHomePage = computed(() => {
      var _a3;
      return (_a3 = frontmatter.value.modules || []) == null ? void 0 : _a3.includes("Comment");
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
      const _component_Xicons = resolveComponent("Xicons");
      const _component_ValineViews = resolveComponent("ValineViews");
      const _component_WalineViews = resolveComponent("WalineViews");
      const _component_Comments = resolveComponent("Comments");
      return openBlock(), createElementBlock("div", _hoisted_1$S, [
        createElementVNode("span", null, [
          createVNode(_component_Xicons, {
            icon: "ColorPalette",
            link: "https://vuepress-theme-reco.recoluan.com",
            target: "_blank",
            text: `vuepress-theme-reco@${unref(version2)}`
          }, null, 8, ["text"])
        ]),
        withDirectives(createElementVNode(
          "span",
          null,
          [
            createVNode(_component_Xicons, {
              icon: "Security",
              link: (_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.footer) == null ? void 0 : _b2.recordLink,
              text: (_d = (_c = unref(frontmatter)) == null ? void 0 : _c.footer) == null ? void 0 : _d.record,
              target: "_blank"
            }, null, 8, ["link", "text"])
          ],
          512
          /* NEED_PATCH */
        ), [
          [vShow, (_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.footer) == null ? void 0 : _f.record]
        ]),
        createElementVNode("span", null, [
          createVNode(_component_Xicons, { text: copyRight.value }, {
            icon: withCtx(() => [
              (openBlock(), createElementBlock("svg", _hoisted_2$B, _hoisted_4$o))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["text"])
        ]),
        showAccessNumber.value ? (openBlock(), createElementBlock("span", _hoisted_5$g, [
          createVNode(_component_Xicons, null, {
            icon: withCtx(() => [
              (openBlock(), createElementBlock("svg", _hoisted_6$c, _hoisted_8$7))
            ]),
            default: withCtx(() => [
              unref(solution) === "valine" ? (openBlock(), createBlock(_component_ValineViews, {
                key: 0,
                idVal: homeLink.value
              }, null, 8, ["idVal"])) : createCommentVNode("v-if", true),
              unref(solution) === "waline" ? (openBlock(), createBlock(_component_WalineViews, {
                key: 1,
                path: homeLink.value
              }, null, 8, ["path"])) : createCommentVNode("v-if", true)
            ]),
            _: 1
            /* STABLE */
          })
        ])) : createCommentVNode("v-if", true),
        ((_h = (_g = unref(frontmatter)) == null ? void 0 : _g.footer) == null ? void 0 : _h.cyberSecurityRecord) ? (openBlock(), createElementBlock("span", _hoisted_9$6, [
          _hoisted_10$5,
          createElementVNode("a", {
            href: ((_j = (_i = unref(frontmatter)) == null ? void 0 : _i.footer) == null ? void 0 : _j.cyberSecurityLink) || "#",
            target: "_blank"
          }, toDisplayString((_l = (_k = unref(frontmatter)) == null ? void 0 : _k.footer) == null ? void 0 : _l.cyberSecurityRecord), 9, _hoisted_11$4)
        ])) : createCommentVNode("v-if", true),
        !isShowCommentAtHomePage.value ? (openBlock(), createBlock(_component_Comments, {
          key: 2,
          "hide-comments": true
        })) : createCommentVNode("v-if", true)
      ]);
    };
  }
};
const Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "Footer.vue"]]);
const _hoisted_1$R = { class: "password-wrapper" };
const _hoisted_2$A = { class: "site-info" };
const _hoisted_3$x = ["src", "alt"];
const _hoisted_4$n = {
  key: 1,
  class: "site-name"
};
const _hoisted_5$f = { key: 0 };
const _hoisted_6$b = { key: 0 };
const _hoisted_7$8 = { key: 0 };
const _hoisted_8$6 = { key: 0 };
const _hoisted_9$5 = { key: 0 };
const _hoisted_10$4 = { key: 0 };
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["pass"],
  setup(__props, { emit }) {
    const { siteBrandLogo, siteBrandTitle, sitePassword } = useSiteInfo();
    const { password, passwordRef, lockIcon, lockText, focus } = useHandlePassword$1(
      sitePassword,
      emit
    );
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock("div", _hoisted_1$R, [
        withDirectives(createElementVNode(
          "input",
          {
            maxlength: "6",
            type: "password",
            ref_key: "passwordRef",
            ref: passwordRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(password) ? password.value = $event : null)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vModelText, unref(password)]
        ]),
        createElementVNode("div", _hoisted_2$A, [
          unref(siteBrandLogo) ? (openBlock(), createElementBlock("img", {
            key: 0,
            class: "logo",
            src: unref(withBase)(unref(siteBrandLogo)),
            alt: unref(siteBrandTitle)
          }, null, 8, _hoisted_3$x)) : createCommentVNode("v-if", true),
          unref(siteBrandTitle) ? (openBlock(), createElementBlock(
            "h1",
            _hoisted_4$n,
            toDisplayString(unref(siteBrandTitle)),
            1
            /* TEXT */
          )) : createCommentVNode("v-if", true)
        ]),
        createElementVNode("div", null, [
          createVNode(_component_Xicons, {
            icon: unref(lockIcon),
            text: unref(lockText)
          }, null, 8, ["icon", "text"])
        ]),
        createElementVNode("ul", {
          class: "password-show",
          onClick: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => unref(focus) && unref(focus)(...args))
        }, [
          createElementVNode("li", null, [
            unref(password).length > 0 ? (openBlock(), createElementBlock("i", _hoisted_5$f)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 1 ? (openBlock(), createElementBlock("i", _hoisted_6$b)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 2 ? (openBlock(), createElementBlock("i", _hoisted_7$8)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 3 ? (openBlock(), createElementBlock("i", _hoisted_8$6)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 4 ? (openBlock(), createElementBlock("i", _hoisted_9$5)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 5 ? (openBlock(), createElementBlock("i", _hoisted_10$4)) : createCommentVNode("v-if", true)
          ])
        ]),
        createVNode(Footer)
      ]);
    };
  }
});
const Password$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "index.vue"]]);
const _hoisted_1$Q = { class: "mobile-menus-container" };
const _hoisted_2$z = { class: "appearance" };
const _hoisted_3$w = /* @__PURE__ */ createElementVNode(
  "span",
  null,
  "Appearance",
  -1
  /* HOISTED */
);
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "NavbarDropdownNemu",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Q, [
        createVNode(NavbarLinks, { class: "mobile" }),
        createElementVNode("div", _hoisted_2$z, [
          _hoisted_3$w,
          createVNode(ToggleDarkModeButton)
        ])
      ]);
    };
  }
});
const NavbarDropdownNemu = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "NavbarDropdownNemu.vue"]]);
function useSeries(toggleSeries, toggleMobileMenus) {
  let unregisterRouterHook;
  onMounted(() => {
    const router = useRouter();
    const {
      direction: direction2
    } = useScrollDirection();
    unregisterRouterHook = router.afterEach((to, from) => {
      if (to.path !== from.path) {
        toggleSeries(false);
        toggleMobileMenus(false);
        direction2.value = "";
      }
    });
  });
  onUnmounted(() => {
    unregisterRouterHook();
  });
}
const SITE_PASSWORD_PASS = "SITE_PASSWORD_PASS";
function usePassword$1() {
  const themeLocal = useThemeLocaleData();
  const setedSitePassword = ref(!!themeLocal.value.password);
  const siteLoaded = ref(false);
  const sitePasswordPass = ref(true);
  onMounted(() => {
    let sitePasswordPassCache = "true";
    {
      sitePasswordPassCache = sessionStorage.getItem(SITE_PASSWORD_PASS);
    }
    if (themeLocal.value.password && sitePasswordPassCache !== "true") {
      sitePasswordPass.value = false;
    }
    siteLoaded.value = true;
  });
  const handlePass = () => {
    sitePasswordPass.value = true;
    {
      sessionStorage.setItem(SITE_PASSWORD_PASS, "true");
    }
  };
  return {
    siteLoaded,
    sitePasswordPass,
    setedSitePassword,
    handlePass
  };
}
function useInitCodeCopy() {
  const route = useRoute();
  const {
    path
  } = toRefs(route);
  const {
    initCopyBtn
  } = useInitCopyBtn();
  watch(path, () => {
    setTimeout(() => {
      initCopyBtn();
    }, 1e3);
  });
}
const _hoisted_1$P = { key: 1 };
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    const {
      isOpenSeries,
      isShowSeries,
      isShowCatalog,
      toggleSeries
    } = useSeriesData();
    const { isOpenMobileMenus, toggleMobileMenus } = useMobileMenus();
    const { siteLoaded, sitePasswordPass, setedSitePassword, handlePass } = usePassword$1();
    const containerClass = computed(() => [
      {
        "series--open": isOpenSeries.value,
        "series--no": !isShowSeries.value,
        "show-series": isShowSeries.value,
        "show-catalog": isShowCatalog.value,
        "mobile-menus--active": isOpenMobileMenus.value
      },
      frontmatter.value.pageClass
    ]);
    const seriesItems = useSeriesItems();
    onMounted(() => {
      useInitCodeCopy();
    });
    useSeries(toggleSeries, toggleMobileMenus);
    return (_ctx, _cache) => {
      return !unref(setedSitePassword) ? (openBlock(), createElementBlock(
        "div",
        {
          key: 0,
          class: normalizeClass(["common-wrapper", containerClass.value])
        },
        [
          createVNode(Navbar, { onToggleMenus: unref(toggleMobileMenus) }, null, 8, ["onToggleMenus"]),
          unref(seriesItems).length > 0 ? (openBlock(), createBlock(SubNavbar, {
            key: 0,
            onToggleSeries: unref(toggleSeries)
          }, null, 8, ["onToggleSeries"])) : createCommentVNode("v-if", true),
          createVNode(NavbarDropdownNemu),
          createElementVNode("div", {
            class: "series-mask",
            onClick: _cache[0] || (_cache[0] = ($event) => unref(toggleSeries)(false))
          }),
          createVNode(Series),
          renderSlot(_ctx.$slots, "default"),
          unref(isShowCatalog) ? (openBlock(), createBlock(Catalog, { key: 1 })) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : (openBlock(), createElementBlock(
        "div",
        {
          key: 1,
          class: normalizeClass(["common-wrapper", containerClass.value])
        },
        [
          unref(siteLoaded) && !unref(sitePasswordPass) ? (openBlock(), createBlock(Password$1, {
            class: "out",
            key: "out",
            onPass: unref(handlePass)
          }, null, 8, ["onPass"])) : createCommentVNode("v-if", true),
          unref(siteLoaded) && unref(sitePasswordPass) ? (openBlock(), createElementBlock("div", _hoisted_1$P, [
            createVNode(Navbar, { onToggleMenus: unref(toggleMobileMenus) }, null, 8, ["onToggleMenus"]),
            unref(seriesItems).length > 0 ? (openBlock(), createBlock(SubNavbar, {
              key: 0,
              onToggleSeries: unref(toggleSeries)
            }, null, 8, ["onToggleSeries"])) : createCommentVNode("v-if", true),
            createVNode(NavbarDropdownNemu),
            createElementVNode("div", {
              class: "series-mask",
              onClick: _cache[1] || (_cache[1] = ($event) => unref(toggleSeries)(false))
            }),
            createVNode(Series),
            renderSlot(_ctx.$slots, "default"),
            unref(isShowCatalog) ? (openBlock(), createBlock(Catalog, { key: 1 })) : createCommentVNode("v-if", true)
          ])) : createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      ));
    };
  }
});
const Common = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "index.vue"]]);
const _hoisted_1$O = {
  key: 0,
  class: "pagation-container"
};
const _hoisted_2$y = {
  class: "ellipsis",
  key: "ellipsis-front"
};
const _hoisted_3$v = ["onClick"];
const _hoisted_4$m = {
  class: "ellipsis",
  key: "ellipsis-back"
};
const _hoisted_5$e = {
  class: "jumpinput",
  key: "input"
};
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "Pagation",
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    pageSize: {
      type: Number,
      default: 10
    },
    total: {
      type: Number,
      default: 0
    },
    totalPage: {
      type: Number,
      default: 0
    }
  },
  emits: ["change"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const targetPage = ref(null);
    const tp = computed(() => {
      return Math.ceil(props.total / props.pageSize);
    });
    const showStartFakePageNum = computed(() => {
      return efont.value && !indexes.value.includes(1);
    });
    const showLastFakePageNum = computed(() => {
      return efont.value && !indexes.value.includes(tp.value);
    });
    const efont = computed(() => {
      return tp.value > 7;
    });
    const indexes = computed(() => {
      const ar = [];
      let left = 1;
      let right = tp.value;
      if (tp.value >= 7) {
        if (props.currentPage > 5 && props.currentPage < tp.value - 4) {
          left = Number(props.currentPage) - 3;
          right = Number(props.currentPage) + 3;
        } else {
          if (props.currentPage <= 5) {
            left = 1;
            right = 7;
          } else {
            right = tp.value;
            left = tp.value - 6;
          }
        }
      }
      while (left <= right) {
        ar.push(left);
        left++;
      }
      return ar;
    });
    const jumpPage = (page) => {
      const p2 = parseInt(page);
      if (p2 <= tp.value && p2 > 0) {
        emits("change", p2);
        return;
      }
      alert(`请输入大于0，并且小于等于${tp.value}的页码！`);
    };
    const goPrev = () => {
      let currentPage = props.currentPage;
      if (currentPage > 1) {
        emits("change", --currentPage);
      }
    };
    const goNext = () => {
      let currentPage = props.currentPage;
      if (currentPage < tp.value) {
        emits("change", ++currentPage);
      }
    };
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return tp.value > 1 ? (openBlock(), createElementBlock("div", _hoisted_1$O, [
        __props.currentPage > 1 ? (openBlock(), createBlock(_component_Xicons, {
          class: "jump",
          icon: "ChevronLeft",
          iconSize: 16,
          unselectable: "on",
          key: "left",
          onClick: goPrev
        })) : createCommentVNode("v-if", true),
        showStartFakePageNum.value ? (openBlock(), createElementBlock("span", {
          class: "jump",
          key: "page-one",
          onClick: _cache[0] || (_cache[0] = ($event) => jumpPage(1))
        }, "1")) : createCommentVNode("v-if", true),
        showStartFakePageNum.value && indexes.value[0] > 2 ? (openBlock(), createElementBlock("span", _hoisted_2$y, "...")) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(indexes.value, (num) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(["jump", { active: __props.currentPage == num }]),
              key: `page-${num}`,
              onClick: ($event) => jumpPage(num)
            }, toDisplayString(num), 11, _hoisted_3$v);
          }),
          128
          /* KEYED_FRAGMENT */
        )),
        showLastFakePageNum.value && tp.value - indexes.value.at(-1) > 1 ? (openBlock(), createElementBlock("span", _hoisted_4$m, "...")) : createCommentVNode("v-if", true),
        showLastFakePageNum.value ? (openBlock(), createElementBlock(
          "span",
          {
            class: "jump",
            key: "page-lastest",
            onClick: _cache[1] || (_cache[1] = ($event) => jumpPage(tp.value))
          },
          toDisplayString(tp.value),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        __props.currentPage < tp.value ? (openBlock(), createBlock(_component_Xicons, {
          class: "jump",
          key: "right",
          icon: "ChevronRight",
          iconSize: 16,
          onClick: goNext
        })) : createCommentVNode("v-if", true),
        createElementVNode("span", _hoisted_5$e, [
          withDirectives(createElementVNode(
            "input",
            {
              type: "text",
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => targetPage.value = $event)
            },
            null,
            512
            /* NEED_PATCH */
          ), [
            [vModelText, targetPage.value]
          ])
        ]),
        createElementVNode("span", {
          class: "jump go",
          key: "go",
          onClick: _cache[3] || (_cache[3] = ($event) => jumpPage(targetPage.value))
        }, "Go")
      ])) : createCommentVNode("v-if", true);
    };
  }
});
const Pagation = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "Pagation.vue"]]);
const _sfc_main$Y = defineComponent({
  components: { Common, PostList, Pagation },
  setup() {
    const {
      categoryPosts,
      categorySummary
    } = usePageData();
    const router = useRouter();
    const categoryList = computed(() => {
      let list = [];
      const currentCategoryKey = categoryPosts.value.currentCategoryKey;
      if (currentCategoryKey) {
        const { items = [] } = categorySummary[currentCategoryKey];
        list = Object.values(items);
      }
      return list;
    });
    const handlePagation = (page) => {
      const {
        currentCategoryKey,
        currentCategoryValue
      } = categoryPosts.value;
      router.push(`/${currentCategoryKey}/${currentCategoryValue}/${page}/`);
    };
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return {
      categoryList,
      categoryPosts,
      handlePagation,
      convertToPinyin
    };
  }
});
const _hoisted_1$N = { class: "categories-container" };
const _hoisted_2$x = { class: "category-list" };
const _hoisted_3$u = { class: "text" };
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RouterLink = resolveComponent("RouterLink");
  const _component_PostList = resolveComponent("PostList");
  const _component_Pagation = resolveComponent("Pagation");
  const _component_Common = resolveComponent("Common");
  return openBlock(), createBlock(_component_Common, null, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$N, [
        createElementVNode("ul", _hoisted_2$x, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.categoryList, ({ label, length }, index2) => {
              return openBlock(), createElementBlock(
                "li",
                {
                  key: index2,
                  class: normalizeClass([
                    "category-item",
                    {
                      active: _ctx.categoryPosts.currentCategoryValue === _ctx.convertToPinyin(label)
                    }
                  ])
                },
                [
                  createVNode(_component_RouterLink, {
                    class: "category-link",
                    to: `/${_ctx.categoryPosts.currentCategoryKey}/${_ctx.convertToPinyin(label)}/1/`
                  }, {
                    default: withCtx(() => [
                      createElementVNode(
                        "span",
                        _hoisted_3$u,
                        toDisplayString(label),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["to"])
                ],
                2
                /* CLASS */
              );
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        createVNode(_component_PostList, {
          data: _ctx.categoryPosts.pages
        }, null, 8, ["data"]),
        _ctx.categoryPosts.totalPage > 10 ? (openBlock(), createBlock(_component_Pagation, {
          key: 0,
          currentPage: _ctx.categoryPosts.currentPage,
          total: _ctx.categoryPosts.totalPage,
          onChange: _ctx.handlePagation
        }, null, 8, ["currentPage", "total", "onChange"])) : createCommentVNode("v-if", true)
      ])
    ]),
    _: 1
    /* STABLE */
  });
}
const Categories = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["render", _sfc_render$D], ["__file", "Categories.vue"]]);
const _hoisted_1$M = { class: "banner-brand__content" };
const _hoisted_2$w = ["src"];
const _hoisted_3$t = { key: 1 };
const _hoisted_4$l = { key: 2 };
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "Banner",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    const heroImage = computed(() => {
      var _a3, _b2, _c, _d;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroImage) ? withBase((_d = (_c = frontmatter.value) == null ? void 0 : _c.banner) == null ? void 0 : _d.heroImage) : null;
    });
    const heroImageStyle = computed(
      () => frontmatter.value.banner.heroImageStyle || {}
    );
    const bgImageStyle = computed(() => {
      var _a3;
      const { bgImageStyle: bgImageStyle2, bgImage } = ((_a3 = frontmatter.value) == null ? void 0 : _a3.banner) || {};
      const initBgImageStyle = bgImage ? {
        textAlign: "center",
        overflow: "hidden",
        background: `url(${withBase(bgImage)}) center/cover no-repeat`
      } : {};
      return bgImageStyle2 ? { ...initBgImageStyle, ...bgImageStyle2 } : initBgImageStyle;
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f, _g, _h;
      return openBlock(), createElementBlock(
        "section",
        {
          class: "banner-wrapper",
          style: normalizeStyle({ ...bgImageStyle.value })
        },
        [
          createElementVNode("div", _hoisted_1$M, [
            heroImage.value ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: heroImage.value,
              style: normalizeStyle({
                heroImageStyle: heroImageStyle.value
              }),
              alt: "heroImage"
            }, null, 12, _hoisted_2$w)) : createCommentVNode("v-if", true),
            ((_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroText) ? (openBlock(), createElementBlock(
              "h1",
              _hoisted_3$t,
              toDisplayString((_d = (_c = unref(frontmatter)) == null ? void 0 : _c.banner) == null ? void 0 : _d.heroText),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            ((_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.banner) == null ? void 0 : _f.tagline) ? (openBlock(), createElementBlock(
              "p",
              _hoisted_4$l,
              toDisplayString((_h = (_g = unref(frontmatter)) == null ? void 0 : _g.banner) == null ? void 0 : _h.tagline),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true)
          ])
        ],
        4
        /* STYLE */
      );
    };
  }
});
const Banner = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__file", "Banner.vue"]]);
const _hoisted_1$L = { class: "banner-brand__content" };
const _hoisted_2$v = {
  key: 0,
  class: "title"
};
const _hoisted_3$s = {
  key: 1,
  class: "description"
};
const _hoisted_4$k = {
  key: 2,
  class: "tagline"
};
const _hoisted_5$d = {
  key: 3,
  class: "btn-group"
};
const _hoisted_6$a = {
  key: 4,
  class: "social-links"
};
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "BannerBrand",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    computed(() => {
      var _a3, _b2, _c, _d;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.heroImage) ? withBase((_d = (_c = frontmatter.value) == null ? void 0 : _c.bannerBrand) == null ? void 0 : _d.heroImage) : null;
    });
    const buttons = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.buttons) || [];
    });
    const socialLinks = computed(() => {
      var _a3, _b2;
      return (((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.socialLinks) || []).map((item) => {
        if (!item.color)
          item.color = createOneColor();
        return item;
      });
    });
    computed(
      () => frontmatter.value.bannerBrand.heroImageStyle || {}
    );
    const bgImageStyle = computed(() => {
      var _a3;
      const { bgImageStyle: bgImageStyle2, bgImage } = ((_a3 = frontmatter.value) == null ? void 0 : _a3.bannerBrand) || {};
      const initBgImageStyle = bgImage ? {
        overflow: "hidden",
        background: `url(${withBase(bgImage)}) center/cover no-repeat`
      } : {};
      return bgImageStyle2 ? { ...initBgImageStyle, ...bgImageStyle2 } : initBgImageStyle;
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock(
        "section",
        {
          class: "banner-brand__wrapper",
          style: normalizeStyle({ ...bgImageStyle.value })
        },
        [
          createElementVNode("div", _hoisted_1$L, [
            ((_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.bannerBrand) == null ? void 0 : _b2.title) ? (openBlock(), createElementBlock(
              "h1",
              _hoisted_2$v,
              toDisplayString((_d = (_c = unref(frontmatter)) == null ? void 0 : _c.bannerBrand) == null ? void 0 : _d.title),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            ((_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.bannerBrand) == null ? void 0 : _f.description) ? (openBlock(), createElementBlock(
              "p",
              _hoisted_3$s,
              toDisplayString((_h = (_g = unref(frontmatter)) == null ? void 0 : _g.bannerBrand) == null ? void 0 : _h.description),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            ((_j = (_i = unref(frontmatter)) == null ? void 0 : _i.bannerBrand) == null ? void 0 : _j.tagline) ? (openBlock(), createElementBlock(
              "p",
              _hoisted_4$k,
              toDisplayString((_l = (_k = unref(frontmatter)) == null ? void 0 : _k.bannerBrand) == null ? void 0 : _l.tagline),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true),
            buttons.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(buttons.value, (btn, index2) => {
                  return openBlock(), createBlock(_component_Xicons, {
                    class: normalizeClass(btn.type),
                    key: index2,
                    icon: btn.icon,
                    text: btn.text,
                    link: btn.link,
                    "icon-size": "18",
                    "text-size": "14"
                  }, null, 8, ["class", "icon", "text", "link"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])) : createCommentVNode("v-if", true),
            socialLinks.value.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_6$a, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(socialLinks.value, (item, index2) => {
                  return openBlock(), createElementBlock("li", {
                    class: "social-item",
                    key: index2
                  }, [
                    createVNode(_component_Xicons, {
                      icon: item.icon,
                      link: item.link,
                      style: normalizeStyle({ color: item.color }),
                      target: "_blank"
                    }, null, 8, ["icon", "link", "style"])
                  ]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])) : createCommentVNode("v-if", true)
          ])
        ],
        4
        /* STYLE */
      );
    };
  }
});
const BannerBrand = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "BannerBrand.vue"]]);
const _sfc_main$V = defineComponent({
  setup(props, ctx) {
    const themeLocal = useThemeLocaleData$1();
    const frontmatter = usePageFrontmatter();
    const socialLinks = computed(() => {
      var _a3, _b2;
      return (((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.blog) == null ? void 0 : _b2.socialLinks) || []).map((item) => {
        if (!item.color)
          item.color = createOneColor();
        return item;
      });
    });
    return { themeLocal, socialLinks };
  }
});
const _hoisted_1$K = { class: "personal-info-wrapper" };
const _hoisted_2$u = ["src"];
const _hoisted_3$r = {
  key: 1,
  class: "name"
};
const _hoisted_4$j = { class: "social-links" };
const _hoisted_5$c = /* @__PURE__ */ createElementVNode(
  "hr",
  null,
  null,
  -1
  /* HOISTED */
);
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  return openBlock(), createElementBlock("div", _hoisted_1$K, [
    _ctx.themeLocal.authorAvatar ? (openBlock(), createElementBlock("img", {
      key: 0,
      class: "personal-img",
      src: _ctx.$withBase(_ctx.themeLocal.authorAvatar),
      alt: "author-avatar"
    }, null, 8, _hoisted_2$u)) : createCommentVNode("v-if", true),
    _ctx.themeLocal.author ? (openBlock(), createElementBlock(
      "p",
      _hoisted_3$r,
      toDisplayString(_ctx.themeLocal.author),
      1
      /* TEXT */
    )) : createCommentVNode("v-if", true),
    createCommentVNode(" 支持 hover 展示文案、图片 "),
    createElementVNode("ul", _hoisted_4$j, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.socialLinks, (item, index2) => {
          return openBlock(), createElementBlock("li", {
            class: "social-item",
            key: index2
          }, [
            createVNode(_component_Xicons, {
              icon: item.icon,
              link: item.link,
              style: normalizeStyle({ color: item.color }),
              target: "_blank"
            }, null, 8, ["icon", "link", "style"])
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]),
    _hoisted_5$c
  ]);
}
const PersonalInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["render", _sfc_render$C], ["__file", "PersonalInfo.vue"]]);
const _hoisted_1$J = { class: "home-blog-content" };
const _hoisted_2$t = { class: "blog-list" };
const _hoisted_3$q = { class: "module-title" };
const _hoisted_4$i = { class: "category-wrapper" };
const _hoisted_5$b = { class: "text" };
const _hoisted_6$9 = { class: "num" };
const _hoisted_7$7 = { class: "module-title" };
const _hoisted_8$5 = { class: "tag-wrapper" };
const perPage$1 = 10;
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "Blog",
  setup(__props) {
    const { posts, categorySummary } = usePageData();
    const currentPage = ref(1);
    const categories = computed(() => {
      var _a3;
      return ((_a3 = categorySummary == null ? void 0 : categorySummary.categories) == null ? void 0 : _a3.items) || [];
    });
    const tags = computed(() => {
      var _a3;
      return ((_a3 = categorySummary == null ? void 0 : categorySummary.tags) == null ? void 0 : _a3.items) || [];
    });
    const postsOfCurrentPage = computed(() => {
      const start = (currentPage.value - 1) * perPage$1;
      const end = currentPage.value * perPage$1;
      return (posts || []).slice(start, end);
    });
    let handlePagation = (page) => {
    };
    const route = useRoute();
    const router = useRouter();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    const queryPage = computed(() => route.query.page);
    {
      handlePagation = (page) => {
        currentPage.value = page;
        const homeHref = themeLocal.value.home || routeLocale.value;
        router.push(page > 1 ? `${homeHref}?page=${page}` : homeHref);
        window.scrollTo({ left: 0, top: 0, behavior: "smooth" });
      };
      onMounted(() => {
        watch(queryPage, (newVal) => {
          if (newVal) {
            currentPage.value = Number(newVal);
          }
        });
      });
      window.addEventListener(
        "scroll",
        throttle(() => {
          const card = document.querySelector(".info-wrapper");
          if (card) {
            card.setAttribute("data-x", card.offsetLeft);
            card.setAttribute("data-y", card.offsetTop);
            card.setAttribute("data-width", card.clientWidth);
            card.setAttribute("data-height", card.clientHeight);
          }
        }, 50)
      );
    }
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      const _component_router_link = resolveComponent("router-link");
      const _component_MagicCard = resolveComponent("MagicCard");
      return openBlock(), createElementBlock("section", _hoisted_1$J, [
        createElementVNode("section", _hoisted_2$t, [
          createVNode(PostList, { data: postsOfCurrentPage.value }, null, 8, ["data"]),
          createVNode(Pagation, {
            currentPage: currentPage.value,
            total: unref(posts).length,
            onChange: unref(handlePagation)
          }, null, 8, ["currentPage", "total", "onChange"])
        ]),
        createVNode(_component_MagicCard, { class: "info-wrapper" }, {
          default: withCtx(() => [
            createVNode(PersonalInfo),
            createElementVNode("h4", _hoisted_3$q, [
              createVNode(_component_Xicons, {
                icon: "Folder",
                text: "Categories"
              })
            ]),
            createElementVNode("ul", _hoisted_4$i, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(categories.value, (value, key, index2) => {
                  return openBlock(), createElementBlock("li", {
                    class: "category-item",
                    key: index2
                  }, [
                    createVNode(_component_router_link, {
                      class: "category-link",
                      to: `/categories/${key}/1/`
                    }, {
                      default: withCtx(() => [
                        createElementVNode(
                          "span",
                          _hoisted_5$b,
                          toDisplayString(value.label),
                          1
                          /* TEXT */
                        ),
                        createElementVNode(
                          "span",
                          _hoisted_6$9,
                          toDisplayString(value.length),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1032, ["to"])
                  ]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            createElementVNode("h4", _hoisted_7$7, [
              createVNode(_component_Xicons, {
                icon: "Tag",
                text: "Tags"
              })
            ]),
            createElementVNode("ul", _hoisted_8$5, [
              (openBlock(true), createElementBlock(
                Fragment,
                null,
                renderList(tags.value, (value, key, index2) => {
                  return openBlock(), createElementBlock(
                    "li",
                    {
                      class: "tag-item",
                      key: index2,
                      style: normalizeStyle({ borderColor: unref(createOneColor)() })
                    },
                    [
                      createVNode(_component_router_link, {
                        class: "tag-link",
                        to: `/tags/${key}/1/`
                      }, {
                        default: withCtx(() => [
                          createTextVNode(
                            toDisplayString(value.label),
                            1
                            /* TEXT */
                          )
                        ]),
                        _: 2
                        /* DYNAMIC */
                      }, 1032, ["to"])
                    ],
                    4
                    /* STYLE */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ]),
          _: 1
          /* STABLE */
        })
      ]);
    };
  }
});
const Blog = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["__file", "Blog.vue"]]);
const _sfc_main$T = {};
const _hoisted_1$I = { class: "theme-reco-default-content" };
function _sfc_render$B(_ctx, _cache) {
  const _component_Content = resolveComponent("Content");
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createCommentVNode(" content "),
      createElementVNode("section", _hoisted_1$I, [
        createVNode(_component_Content)
      ])
    ],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const MdContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["render", _sfc_render$B], ["__file", "MdContent.vue"]]);
const _sfc_main$S = {};
function _sfc_render$A(_ctx, _cache) {
  const _component_Comments = resolveComponent("Comments");
  return openBlock(), createBlock(_component_Comments, { "hide-comments": false });
}
const Comment = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["render", _sfc_render$A], ["__file", "Comment.vue"]]);
const _hoisted_1$H = { class: "home-wrapper" };
const __default__$2 = defineComponent({
  name: "HomeWrapper",
  components: {
    Banner,
    BannerBrand,
    Blog,
    MdContent,
    Comment,
    Footer
  }
});
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$H, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(unref(frontmatter).modules || ["Banner", "Blog", "Footer"], (key) => {
            return openBlock(), createBlock(resolveDynamicComponent(key), { key });
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]);
    };
  }
});
const Home = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "index.vue"]]);
const resolveFromFrontmatterConfig = (conf) => {
  if (conf === false) {
    return null;
  }
  if (isString$1(conf)) {
    return useNavLink(conf);
  }
  if (isPlainObject$1(conf)) {
    return conf;
  }
  return false;
};
const resolveFromSeriesItems = (seriesItems, currentPath, offset2) => {
  const index2 = seriesItems.findIndex((item) => item.link === currentPath);
  if (index2 !== -1) {
    const targetItem = seriesItems[index2 + offset2];
    if (!(targetItem == null ? void 0 : targetItem.link)) {
      return null;
    }
    return targetItem;
  }
  for (const item of seriesItems) {
    if (item.children) {
      const childResult = resolveFromSeriesItems(
        item.children,
        currentPath,
        offset2
      );
      if (childResult) {
        return childResult;
      }
    }
  }
  return null;
};
const _sfc_main$Q = defineComponent({
  name: "PageNav",
  components: { Link },
  setup() {
    const frontmatter = usePageFrontmatter();
    const seriesItems = useSeriesItems();
    const route = useRoute();
    const router = useRouter();
    const prevNavLink = computed(() => {
      const prevConfig = resolveFromFrontmatterConfig(frontmatter.value.prev);
      if (prevConfig !== false) {
        return prevConfig;
      }
      return resolveFromSeriesItems(seriesItems.value, route.path, -1);
    });
    const nextNavLink = computed(() => {
      const nextConfig = resolveFromFrontmatterConfig(frontmatter.value.next);
      if (nextConfig !== false) {
        return nextConfig;
      }
      return resolveFromSeriesItems(seriesItems.value, route.path, 1);
    });
    const go = (link) => {
      router.push(link);
    };
    return {
      prevNavLink,
      nextNavLink,
      go
    };
  }
});
const _hoisted_1$G = {
  key: 0,
  class: "page-nav"
};
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.prevNavLink || _ctx.nextNavLink ? (openBlock(), createElementBlock("nav", _hoisted_1$G, [
    createElementVNode(
      "p",
      {
        class: normalizeClass(["inner", { hasPrev: !!_ctx.prevNavLink, hasNext: !!_ctx.nextNavLink }])
      },
      [
        _ctx.prevNavLink ? (openBlock(), createElementBlock(
          "span",
          {
            key: 0,
            class: "page-nav-item prev",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.go(_ctx.prevNavLink.link))
          },
          " ← " + toDisplayString(_ctx.prevNavLink.text),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        _ctx.nextNavLink ? (openBlock(), createElementBlock(
          "span",
          {
            key: 1,
            class: "page-nav-item next",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.go(_ctx.nextNavLink.link))
          },
          toDisplayString(_ctx.nextNavLink.text) + " → ",
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ],
      2
      /* CLASS */
    )
  ])) : createCommentVNode("v-if", true);
}
const PageNav = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["render", _sfc_render$z], ["__file", "PageNav.vue"]]);
const useEditNavLink$1 = () => {
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    const showEditLink = frontmatter.value.editLink ?? themeLocal.value.editLink ?? true;
    if (!showEditLink) {
      return null;
    }
    const {
      repo,
      docsRepo = repo,
      docsBranch = "main",
      docsDir = "",
      editLinkText
    } = themeLocal.value;
    if (!docsRepo)
      return null;
    const editLink = resolveEditLink({
      docsRepo,
      docsBranch,
      docsDir,
      filePathRelative: page.value.filePathRelative,
      editLinkPattern: themeLocal.value.editLinkPattern
    });
    if (!editLink)
      return null;
    return {
      text: editLinkText ?? "Edit this page",
      link: editLink,
      icon: "Edit",
      hideExternalLinkIcon: true
    };
  });
};
const useLastUpdated$1 = () => {
  useSiteLocaleData();
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    var _a3, _b2;
    const showLastUpdated = frontmatter.value.lastUpdated ?? themeLocal.value.lastUpdated ?? true;
    if (!showLastUpdated)
      return null;
    if (!((_a3 = page.value.git) == null ? void 0 : _a3.updatedTime))
      return null;
    const updatedDate = new Date((_b2 = page.value.git) == null ? void 0 : _b2.updatedTime);
    return updatedDate.toLocaleString();
  });
};
const _sfc_main$P = defineComponent({
  name: "PageMeta",
  components: { Link },
  setup() {
    const themeLocal = useThemeLocaleData$1();
    const editNavLink = useEditNavLink$1();
    const lastUpdated = useLastUpdated$1();
    return {
      themeLocal,
      editNavLink,
      lastUpdated
    };
  }
});
const _hoisted_1$F = { class: "page-meta" };
const _hoisted_2$s = {
  key: 0,
  class: "meta-item edit-link"
};
const _hoisted_3$p = {
  key: 1,
  class: "meta-item last-updated"
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  return openBlock(), createElementBlock("footer", _hoisted_1$F, [
    _ctx.editNavLink ? (openBlock(), createElementBlock("div", _hoisted_2$s, [
      createVNode(_component_Xicons, {
        class: "meta-item-label",
        icon: _ctx.editNavLink.icon,
        text: _ctx.editNavLink.text,
        link: _ctx.editNavLink.link,
        target: "_blank",
        "icon-size": "20",
        "text-size": "14"
      }, null, 8, ["icon", "text", "link"])
    ])) : createCommentVNode("v-if", true),
    _ctx.lastUpdated ? (openBlock(), createElementBlock("div", _hoisted_3$p, [
      createVNode(_component_Xicons, {
        class: "meta-item-label",
        icon: "Calendar",
        text: `${_ctx.themeLocal.lastUpdatedText || "Last Updated"} ${_ctx.lastUpdated}`,
        "icon-size": "20",
        "text-size": "14"
      }, null, 8, ["text"])
    ])) : createCommentVNode("v-if", true)
  ]);
}
const PageMeta$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["render", _sfc_render$y], ["__file", "PageMeta.vue"]]);
function usePageInfo() {
  const frontmatter = usePageFrontmatter();
  const pagePassword = computed(() => {
    const _password = frontmatter.value.password;
    if (!_password)
      return [];
    return Array.isArray(_password) ? _password : [_password];
  });
  return {
    pagePassword
  };
}
function useHandlePassword(pagePassword, emit) {
  const password = ref("");
  const passwordRef = ref(null);
  const lockIcon = ref("Locked");
  const lockText = ref("请输入密码");
  watch(password, (newVal) => {
    if (newVal.length !== 6)
      return;
    if (pagePassword.value.includes(md5(md5(newVal)))) {
      lockIcon.value = "Unlocked";
      lockText.value = "密码正确，请重稍后！";
      setTimeout(() => {
        emit("pass");
      }, 600);
    } else {
      password.value = "";
      lockText.value = "密码错误，请重新输入！";
    }
  });
  const focus = () => {
    passwordRef.value.focus();
  };
  return {
    password,
    passwordRef,
    lockIcon,
    lockText,
    focus
  };
}
const _hoisted_1$E = { class: "page-password-wrapper" };
const _hoisted_2$r = { key: 0 };
const _hoisted_3$o = { key: 0 };
const _hoisted_4$h = { key: 0 };
const _hoisted_5$a = { key: 0 };
const _hoisted_6$8 = { key: 0 };
const _hoisted_7$6 = { key: 0 };
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["pass"],
  setup(__props, { emit }) {
    const { pagePassword } = usePageInfo();
    const { password, passwordRef, lockIcon, lockText, focus } = useHandlePassword(
      pagePassword,
      emit
    );
    return (_ctx, _cache) => {
      const _component_Xicons = resolveComponent("Xicons");
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        withDirectives(createElementVNode(
          "input",
          {
            maxlength: "6",
            type: "password",
            ref_key: "passwordRef",
            ref: passwordRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(password) ? password.value = $event : null)
          },
          null,
          512
          /* NEED_PATCH */
        ), [
          [vModelText, unref(password)]
        ]),
        createElementVNode("div", null, [
          createVNode(_component_Xicons, {
            icon: unref(lockIcon),
            text: unref(lockText)
          }, null, 8, ["icon", "text"])
        ]),
        createElementVNode("ul", {
          class: "password-show",
          onClick: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => unref(focus) && unref(focus)(...args))
        }, [
          createElementVNode("li", null, [
            unref(password).length > 0 ? (openBlock(), createElementBlock("i", _hoisted_2$r)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 1 ? (openBlock(), createElementBlock("i", _hoisted_3$o)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 2 ? (openBlock(), createElementBlock("i", _hoisted_4$h)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 3 ? (openBlock(), createElementBlock("i", _hoisted_5$a)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 4 ? (openBlock(), createElementBlock("i", _hoisted_6$8)) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("li", null, [
            unref(password).length > 5 ? (openBlock(), createElementBlock("i", _hoisted_7$6)) : createCommentVNode("v-if", true)
          ])
        ])
      ]);
    };
  }
});
const Password = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "index.vue"]]);
let PAGE_PASSWORD_PASS = "PAGE_PASSWORD_PASS";
function usePassword() {
  const route = useRoute();
  PAGE_PASSWORD_PASS = `${PAGE_PASSWORD_PASS}:${route.path}`;
  const frontmatter = usePageFrontmatter();
  console.log(frontmatter.value.password, !!frontmatter.value.password);
  const pageLoaded = ref(false);
  const pagePasswordPass = ref(true);
  const setedPagePassword = ref(!!frontmatter.value.password);
  onMounted(() => {
    let pagePasswordPassCache = "true";
    {
      pagePasswordPassCache = sessionStorage.getItem(PAGE_PASSWORD_PASS);
    }
    if (frontmatter.value.password && pagePasswordPassCache !== "true") {
      pagePasswordPass.value = false;
    }
    pageLoaded.value = true;
  });
  const handlePass = () => {
    pagePasswordPass.value = true;
    {
      sessionStorage.setItem(PAGE_PASSWORD_PASS, "true");
    }
  };
  return {
    pageLoaded,
    pagePasswordPass,
    setedPagePassword,
    handlePass
  };
}
const _hoisted_1$D = { class: "page-container" };
const _hoisted_2$q = {
  key: 0,
  class: "page-title"
};
const _hoisted_3$n = {
  key: 1,
  class: "theme-reco-default-content"
};
const _hoisted_4$g = {
  key: 2,
  class: "theme-reco-default-content"
};
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    const pageData = usePageData$1();
    const { options } = useComment();
    const { pageLoaded, pagePasswordPass, setedPagePassword, handlePass } = usePassword();
    const title = computed(
      () => {
        var _a3, _b2, _c;
        return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.title) || ((_c = pageData == null ? void 0 : pageData.value) == null ? void 0 : _c.title) || "";
      }
    );
    const shouldHideComments = computed(() => {
      var _a3;
      const { hideComments: hideCommentsInSinglePage } = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter;
      const { hideComments: hideCommentsInAllPage } = options.value;
      return hideCommentsInSinglePage === true || hideCommentsInSinglePage !== false && hideCommentsInAllPage === true;
    });
    return (_ctx, _cache) => {
      const _component_Content = resolveComponent("Content");
      const _component_Comments = resolveComponent("Comments");
      return openBlock(), createElementBlock("main", _hoisted_1$D, [
        !!title.value ? (openBlock(), createElementBlock(
          "h1",
          _hoisted_2$q,
          toDisplayString(title.value),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        createVNode(PageInfo$1, { "page-data": unref(pageData) }, null, 8, ["page-data"]),
        !unref(setedPagePassword) ? (openBlock(), createElementBlock("div", _hoisted_3$n, [
          createVNode(_component_Content)
        ])) : (openBlock(), createElementBlock("div", _hoisted_4$g, [
          unref(pageLoaded) && !unref(pagePasswordPass) ? (openBlock(), createBlock(Password, {
            key: 0,
            onPass: unref(handlePass)
          }, null, 8, ["onPass"])) : createCommentVNode("v-if", true),
          unref(pageLoaded) && unref(pagePasswordPass) ? (openBlock(), createBlock(_component_Content, { key: 1 })) : createCommentVNode("v-if", true)
        ])),
        createVNode(PageMeta$1),
        createVNode(PageNav),
        createVNode(_component_Comments, { "hide-comments": shouldHideComments.value }, null, 8, ["hide-comments"])
      ]);
    };
  }
});
const Page$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "index.vue"]]);
const _hoisted_1$C = { class: "theme-container" };
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const page = usePageData$1();
    const frontmatter = usePageFrontmatter();
    const scrollPromise2 = useScrollPromise();
    const onBeforeEnter = scrollPromise2.resolve;
    const onBeforeLeave = scrollPromise2.pending;
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$C, [
        createVNode(Common, null, {
          default: withCtx(() => [
            unref(frontmatter).home === true ? (openBlock(), createBlock(Home, { key: 0 })) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: "fade-slide-y",
              mode: "out-in",
              onBeforeEnter: unref(onBeforeEnter),
              onBeforeLeave: unref(onBeforeLeave)
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(Page$1, {
                  key: unref(page).path
                }))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["onBeforeEnter", "onBeforeLeave"]))
          ]),
          _: 1
          /* STABLE */
        })
      ]);
    };
  }
});
const Layout$2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "Layout.vue"]]);
const _imports_0 = "/assets/taken-42974550.svg";
const _hoisted_1$B = /* @__PURE__ */ createElementVNode(
  "h1",
  null,
  "404",
  -1
  /* HOISTED */
);
const _hoisted_2$p = /* @__PURE__ */ createElementVNode(
  "p",
  null,
  "Oops! Page does not exist.",
  -1
  /* HOISTED */
);
const _hoisted_3$m = /* @__PURE__ */ createElementVNode(
  "img",
  { src: _imports_0 },
  null,
  -1
  /* HOISTED */
);
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "NotFound",
  setup(__props) {
    const router = useRouter();
    const routeLocale = useRouteLocale();
    const themeLocal = useThemeLocaleData();
    const goHome = () => {
      router.push(withBase(themeLocal.value.home || routeLocale.value));
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [
          createElementVNode("section", { class: "page-404-wrapper" }, [
            createElementVNode("div", { class: "content" }, [
              _hoisted_1$B,
              _hoisted_2$p,
              createElementVNode("div", {
                class: "xicon-container",
                onClick: goHome
              }, "Go Home")
            ]),
            _hoisted_3$m
          ])
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const NotFound = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "NotFound.vue"]]);
const _hoisted_1$A = { class: "posts-container" };
const perPage = 10;
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "Posts",
  setup(__props) {
    const { posts } = usePageData();
    const currentPage = ref(1);
    const blogContentTop = ref(0);
    const postsOfCurrentPage = computed(() => {
      const start = (currentPage.value - 1) * perPage;
      const end = currentPage.value * perPage;
      return (posts || []).slice(start, end);
    });
    let handlePagation = (page) => {
    };
    const route = useRoute();
    const router = useRouter();
    useRouteLocale();
    useThemeLocaleData();
    const queryPage = computed(() => route.query.page);
    {
      handlePagation = (page) => {
        currentPage.value = page;
        const homeHref = withBase("/posts/");
        router.push(page > 1 ? `${homeHref}?page=${page}` : homeHref);
        setTimeout(() => {
          if (blogContentTop.value === 0) {
            const blogContent = document.querySelector(".home-blog-content");
            if (blogContent)
              blogContentTop.value = blogContent.getBoundingClientRect().top;
          }
          window.scrollTo({ left: 0, top: 0, behavior: "smooth" });
        }, 100);
      };
      onMounted(() => {
        watch(queryPage, (newVal) => {
          if (newVal) {
            currentPage.value = Number(newVal);
          }
        });
      });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", _hoisted_1$A, [
        createVNode(PostList, { data: postsOfCurrentPage.value }, null, 8, ["data"]),
        createVNode(Pagation, {
          currentPage: currentPage.value,
          total: unref(posts).length,
          onChange: unref(handlePagation)
        }, null, 8, ["currentPage", "total", "onChange"])
      ]);
    };
  }
});
const Posts$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "Posts.vue"]]);
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "Posts",
  setup(__props) {
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [
          createVNode(Posts$1)
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const Posts = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "Posts.vue"]]);
const _hoisted_1$z = { class: "timeline-content" };
const _hoisted_2$o = { class: "year" };
const _hoisted_3$l = { class: "year-wrapper" };
const _hoisted_4$f = { class: "date" };
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "Timeline",
  setup(__props) {
    const { posts } = usePageData();
    const dataMap = {};
    posts.forEach((post) => {
      if (!post.frontmatter.date)
        return;
      let connector = post.frontmatter.date.includes("/") ? "/" : "-";
      const [year, mounth, day] = formatISODate(post.frontmatter.date).split(" ")[0].split(connector) || [];
      if (!year || !mounth || !day)
        return;
      if (!dataMap[year]) {
        dataMap[year] = [{
          ...post,
          date: `${mounth}${connector}${day}`
        }];
        return;
      }
      dataMap[year].push({
        ...post,
        date: `${mounth}-${day}`
      });
    });
    const timelineData = Object.keys(dataMap).reduce(
      (all2, next) => {
        all2.push({
          year: next,
          data: dataMap[next]
        });
        return all2;
      },
      []
    );
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return openBlock(), createBlock(Common, { class: "timeline-wrapper" }, {
        default: withCtx(() => [
          createElementVNode("ul", _hoisted_1$z, [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(unref(timelineData), (item, index2) => {
                return openBlock(), createElementBlock("li", { key: index2 }, [
                  createElementVNode(
                    "h2",
                    _hoisted_2$o,
                    toDisplayString(item.year),
                    1
                    /* TEXT */
                  ),
                  createElementVNode("ul", _hoisted_3$l, [
                    (openBlock(true), createElementBlock(
                      Fragment,
                      null,
                      renderList(item.data, (subItem, subIndex) => {
                        return openBlock(), createElementBlock("li", {
                          key: subIndex,
                          class: "item"
                        }, [
                          createElementVNode(
                            "span",
                            _hoisted_4$f,
                            toDisplayString(subItem.date),
                            1
                            /* TEXT */
                          ),
                          createVNode(_component_RouterLink, {
                            class: "title",
                            to: subItem.path
                          }, {
                            default: withCtx(() => [
                              createTextVNode(
                                toDisplayString(subItem.title),
                                1
                                /* TEXT */
                              )
                            ]),
                            _: 2
                            /* DYNAMIC */
                          }, 1032, ["to"])
                        ]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const Timeline$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "Timeline.vue"]]);
const _hoisted_1$y = { class: "friendship-link-container" };
const _hoisted_2$n = { class: "logo" };
const _hoisted_3$k = ["src"];
const _hoisted_4$e = { class: "title" };
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "FriendshipLink",
  setup(__props) {
    const themeLocal = useThemeLocaleData$1();
    const friendshipLinks = computed(() => {
      return themeLocal.value.friendshipLinks || [];
    });
    const handlClick = (link) => {
      window.open(link, "_blank");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(friendshipLinks.value, (item, index2) => {
            return openBlock(), createBlock(unref(MagicCard), {
              class: "friendship-link-item",
              key: index2,
              onClick: () => handlClick(item.link)
            }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_2$n, [
                  createElementVNode("img", {
                    src: item.logo
                  }, null, 8, _hoisted_3$k)
                ]),
                createElementVNode(
                  "span",
                  _hoisted_4$e,
                  toDisplayString(item.title),
                  1
                  /* TEXT */
                )
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["onClick"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]);
    };
  }
});
const FriendshipLink$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "FriendshipLink.vue"]]);
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "FriendshipLink",
  setup(__props) {
    const { initMagicCard } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [
          createVNode(FriendshipLink$1)
        ]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const FriendshipLink = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "FriendshipLink.vue"]]);
const layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Categories,
  FriendshipLink,
  Layout: Layout$2,
  NotFound,
  Posts,
  Timeline: Timeline$1
}, Symbol.toStringTag, { value: "Module" }));
const clientConfig11 = defineClientConfig({
  enhance(...args) {
    applyClientEnhance(...args);
  },
  setup() {
    applyClientSetup$1();
  },
  layouts
});
async function applyClientSetup() {
  const posts = [{ "title": "音乐播放器测试", "frontmatter": { "id": "blog_1", "title": "音乐播放器测试", "date": "2023-09-08T00:00:00.000Z" }, "path": "/blogs/blogtest.html" }, { "title": "9月8日", "frontmatter": { "id": "blog-2023-09-08_1", "title": "9月8日", "date": "2023-09-08T00:00:00.000Z" }, "path": "/blogs/shuoshuotest.html" }];
  const series = {};
  const categorySummary = { "categories": { "pageSize": 10, "items": {}, "layout": "Categories" }, "tags": { "pageSize": 10, "items": {}, "layout": "Categories" } };
  const categoryPosts = {};
  provide(postsSymbol, posts);
  provide(seriesSymbol, series);
  provide(categorySummarySymbol, categorySummary);
  provide(categoryPaginationPostsSymbol, categoryPosts);
}
const clientConfig12 = defineClientConfig({
  setup() {
    applyClientSetup();
  }
});
const hopeInject = "";
const clientConfig13 = {};
let i$6 = {};
const t$4 = Symbol(""), n$6 = () => inject(t$4), s$4 = (o2) => {
  o2.provide(t$4, i$6);
};
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b2[i3] = start += 1 << eb[i3 - 1];
  }
  var r2 = new i32(b2[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j2 = b2[i3]; j2 < b2[i3 + 1]; ++j2) {
      r2[j2] = j2 - b2[i3] << 5 | i3;
    }
  }
  return {
    b: b2,
    r: r2
  };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b;
var rev = new u16(32768);
for (var i$5 = 0; i$5 < 32768; ++i$5) {
  var x$5 = (i$5 & 43690) >> 1 | (i$5 & 21845) << 1;
  x$5 = (x$5 & 52428) >> 2 | (x$5 & 13107) << 2;
  x$5 = (x$5 & 61680) >> 4 | (x$5 & 3855) << 4;
  rev[i$5] = ((x$5 & 65280) >> 8 | (x$5 & 255) << 8) >> 1;
}
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i3 = 0;
  var l2 = new u16(mb);
  for (; i3 < s2; ++i3) {
    if (cd[i3])
      ++l2[cd[i3] - 1];
  }
  var le2 = new u16(mb);
  for (i3 = 1; i3 < mb; ++i3) {
    le2[i3] = le2[i3 - 1] + l2[i3 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v3 = le2[cd[i3] - 1]++ << r_1;
        for (var m2 = v3 | (1 << r_1) - 1; v3 <= m2; ++v3) {
          co[rev[v3] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le2[cd[i3] - 1]++] >> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (var i$5 = 0; i$5 < 144; ++i$5)
  flt[i$5] = 8;
for (var i$5 = 144; i$5 < 256; ++i$5)
  flt[i$5] = 9;
for (var i$5 = 256; i$5 < 280; ++i$5)
  flt[i$5] = 7;
for (var i$5 = 280; i$5 < 288; ++i$5)
  flt[i$5] = 8;
var fdt = new u8(32);
for (var i$5 = 0; i$5 < 32; ++i$5)
  fdt[i$5] = 5;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max$1 = function(a2) {
  var m2 = a2[0];
  for (var i3 = 1; i3 < a2.length; ++i3) {
    if (a2[i3] > m2)
      m2 = a2[i3];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v3, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v3.length)
    e2 = v3.length;
  var n2 = new u8(e2 - s2);
  n2.set(v3.subarray(s2, e2));
  return n2;
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt2) {
  var e2 = new Error(msg || ec[ind]);
  e2.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e2, err);
  if (!nt2)
    throw e2;
  return e2;
};
var inflt = function(dat, st2, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st2.f && !st2.l)
    return buf || new u8(0);
  var noBuf = !buf || st2.i != 2;
  var noSt = st2.i;
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type2 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type2) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t2), bt2);
        st2.b = bt2 += l2, st2.p = pos = t2 * 8, st2.f = final;
        continue;
      } else if (type2 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type2 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$1(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >> 4;
          if (s2 < 16) {
            ldt[i3++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i3 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i3++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max$1(lt2);
        dbt = max$1(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c2)
        err(2);
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b2 = fleb[i3];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i3];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt2 + 131072);
        var end = bt2 + add;
        if (bt2 < dt2) {
          var shift2 = dl - dt2, dend = Math.min(dt2, end);
          if (shift2 + bt2 < 0)
            err(3);
          for (; bt2 < dend; ++bt2)
            buf[bt2] = dict[shift2 + bt2];
        }
        for (; bt2 < end; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end;
      }
    }
    st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var et$2 = /* @__PURE__ */ new u8(0);
var zls = function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
};
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {
    i: 2
  }, opts && opts.out, opts && opts.dictionary);
}
var te = typeof TextEncoder != "undefined" && /* @__PURE__ */ new TextEncoder();
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et$2, {
    stream: true
  });
  tds = 1;
} catch (e2) {
}
var dutf8 = function(d2) {
  for (var r2 = "", i3 = 0; ; ) {
    var c2 = d2[i3++];
    var eb = (c2 > 127) + (c2 > 223) + (c2 > 239);
    if (i3 + eb > d2.length)
      return {
        s: r2,
        r: slc(d2, i3 - 1)
      };
    if (!eb)
      r2 += String.fromCharCode(c2);
    else if (eb == 3) {
      c2 = ((c2 & 15) << 18 | (d2[i3++] & 63) << 12 | (d2[i3++] & 63) << 6 | d2[i3++] & 63) - 65536, r2 += String.fromCharCode(55296 | c2 >> 10, 56320 | c2 & 1023);
    } else if (eb & 1)
      r2 += String.fromCharCode((c2 & 31) << 6 | d2[i3++] & 63);
    else
      r2 += String.fromCharCode((c2 & 15) << 12 | (d2[i3++] & 63) << 6 | d2[i3++] & 63);
  }
};
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i3 = 0; i3 < str.length; ++i3)
      ar_1[i3] = str.charCodeAt(i3);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l2 = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai2 = 0;
  var w2 = function(v3) {
    ar[ai2++] = v3;
  };
  for (var i3 = 0; i3 < l2; ++i3) {
    if (ai2 + 5 > ar.length) {
      var n2 = new u8(ai2 + 8 + (l2 - i3 << 1));
      n2.set(ar);
      ar = n2;
    }
    var c2 = str.charCodeAt(i3);
    if (c2 < 128 || latin1)
      w2(c2);
    else if (c2 < 2048)
      w2(192 | c2 >> 6), w2(128 | c2 & 63);
    else if (c2 > 55295 && c2 < 57344)
      c2 = 65536 + (c2 & 1023 << 10) | str.charCodeAt(++i3) & 1023, w2(240 | c2 >> 18), w2(128 | c2 >> 12 & 63), w2(128 | c2 >> 6 & 63), w2(128 | c2 & 63);
    else
      w2(224 | c2 >> 12), w2(128 | c2 >> 6 & 63), w2(128 | c2 & 63);
  }
  return slc(ar, 0, ai2);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r2 = "";
    for (var i3 = 0; i3 < dat.length; i3 += 16384)
      r2 += String.fromCharCode.apply(null, dat.subarray(i3, i3 + 16384));
    return r2;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a3 = dutf8(dat), s2 = _a3.s, r2 = _a3.r;
    if (r2.length)
      err(8);
    return s2;
  }
}
const C$5 = ({
  size: e2 = 48,
  stroke: t2 = 4,
  wrapper: n2 = true,
  height: o2 = 2 * e2
}) => {
  const i3 = h$5("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: e2,
    height: e2,
    preserveAspectRatio: "xMidYMid",
    viewBox: "25 25 50 50"
  }, [h$5("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    dur: "2s",
    keyTimes: "0;1",
    repeatCount: "indefinite",
    values: "0;360"
  }), h$5("circle", {
    cx: "50",
    cy: "50",
    r: "20",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": t2,
    "stroke-linecap": "round"
  }, [h$5("animate", {
    attributeName: "stroke-dasharray",
    dur: "1.5s",
    keyTimes: "0;0.5;1",
    repeatCount: "indefinite",
    values: "1,200;90,200;1,200"
  }), h$5("animate", {
    attributeName: "stroke-dashoffset",
    dur: "1.5s",
    keyTimes: "0;0.5;1",
    repeatCount: "indefinite",
    values: "0;-35px;-125px"
  })])]);
  return n2 ? h$5("div", {
    class: "loading-icon-wrapper",
    style: `display:flex;align-items:center;justify-content:center;height:${o2}px`
  }, i3) : i3;
};
C$5.displayName = "LoadingIcon";
const p$4 = Array.isArray, fe$1 = (e2) => typeof e2 == "function", ve$1 = (e2) => typeof e2 == "string";
var d$6 = (e2) => Object.prototype.toString.call(e2) === "[object Object]";
const Re = (e2) => typeof e2 == "function", M$4 = Object.entries, v$5 = (e2, ...t2) => {
  if (t2.length === 0)
    return e2;
  const n2 = t2.shift() || null;
  return n2 && M$4(n2).forEach(([o2, i3]) => {
    o2 === "__proto__" || o2 === "constructor" || (d$6(e2[o2]) && d$6(i3) ? v$5(e2[o2], i3) : p$4(i3) ? e2[o2] = [...i3] : d$6(i3) ? e2[o2] = {
      ...i3
    } : e2[o2] = n2[o2]);
  }), v$5(e2, ...t2);
}, R$3 = (e2) => (e2.endsWith(".md") && (e2 = `${e2.slice(0, -3)}.html`), !e2.endsWith("/") && !e2.endsWith(".html") && (e2 = `${e2}.html`), e2 = e2.replace(/(^|\/)(?:README|index).html$/i, "$1"), e2), A$4 = (e2) => {
  const [t2, n2 = ""] = e2.split("#");
  return t2 ? `${R$3(t2)}${n2 ? `#${n2}` : ""}` : e2;
};
const Fe = (e2) => {
  const t2 = atob(e2);
  return strFromU8(unzlibSync(strToU8(t2, true)));
}, w$5 = (e2, ...t2) => {
  const n2 = e2.resolve(...t2), o2 = n2.matched[n2.matched.length - 1];
  if (!(o2 != null && o2.redirect))
    return n2;
  const {
    redirect: i3
  } = o2, r2 = fe$1(i3) ? i3(n2) : i3, a2 = ve$1(r2) ? {
    path: r2
  } : r2;
  return w$5(e2, {
    hash: n2.hash,
    query: n2.query,
    params: n2.params,
    ...a2
  });
}, y$5 = (e2) => {
  if (!(e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey) && !e2.defaultPrevented && !(e2.button !== void 0 && e2.button !== 0)) {
    if (e2.currentTarget) {
      const t2 = e2.currentTarget.getAttribute("target");
      if (t2 != null && t2.match(/\b_blank\b/i))
        return;
    }
    return e2.preventDefault(), true;
  }
}, T$3 = (e2) => {
  const t2 = useRouter(), n2 = useRoute(), o2 = computed(() => w$5(t2, unref(e2))), i3 = computed(() => o2.value.fullPath === n2.fullPath), r2 = (a2 = {}) => y$5(a2) ? t2.push(unref(e2)).catch() : Promise.resolve();
  return {
    route: o2,
    href: computed(() => o2.value.href),
    isActive: i3,
    navigate: r2
  };
};
defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: String,
      required: true
    }
  },
  slots: Object,
  setup(e2, {
    slots: t2
  }) {
    const n2 = toRef(e2, "to"), o2 = T$3(n2);
    return () => {
      var i3;
      return h$5("a", {
        class: ["vp-link", {
          "vp-active": o2.isActive.value
        }],
        href: o2.href.value,
        onClick: o2.navigate
      }, (i3 = t2.default) == null ? void 0 : i3.call(t2, o2));
    };
  }
});
const j$1 = ({
  to: e2 = "",
  class: t2 = "",
  ...n2
}, {
  slots: o2
}) => {
  var i3;
  const r2 = useRouter(), a2 = (m2 = {}) => y$5(m2) ? r2.push(e2).catch() : Promise.resolve();
  return h$5("a", {
    ...n2,
    class: ["vp-link", t2],
    href: withBase(A$4(e2)),
    onClick: a2
  }, (i3 = o2.default) == null ? void 0 : i3.call(o2));
};
j$1.displayName = "VPLink";
const Qe$1 = (e2, t2) => {
  const n2 = t2 ? t2._instance : getCurrentInstance();
  return d$6(n2 == null ? void 0 : n2.appContext.components) && (e2 in n2.appContext.components || camelize(e2) in n2.appContext.components || capitalize(camelize(e2)) in n2.appContext.components);
}, Ze$1 = (e2) => {
  const t2 = useRouteLocale();
  return computed(() => e2[t2.value]);
};
const photoswipe = "";
const photoSwipe = "";
const P$3 = ".page-container :not(a) > img:not([no-view])", x$4 = { "/": { "closeTitle": "关闭", "downloadTitle": "下载图片", "fullscreenTitle": "切换全屏", "zoomTitle": "缩放", "arrowPrevTitle": "上一个 (左箭头)", "arrowNextTitle": "下一个 (右箭头)" } }, A$3 = 800, b$5 = '<div class="photo-swipe-loading"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div>', H$3 = (e2) => isString$1(e2) ? Array.from(document.querySelectorAll(e2)) : e2.map((l2) => Array.from(document.querySelectorAll(l2))).flat(), h$4 = (e2) => new Promise((l2, m2) => {
  e2.complete ? l2({
    type: "image",
    element: e2,
    src: e2.src,
    width: e2.naturalWidth,
    height: e2.naturalHeight,
    alt: e2.alt,
    msrc: e2.src
  }) : (e2.onload = () => l2(h$4(e2)), e2.onerror = (d2) => m2(d2));
}), N$1 = () => {
  const {
    isSupported: e2,
    toggle: l2
  } = useFullscreen(), m2 = n$6(), d2 = Ze$1(x$4), v3 = usePageData$1();
  let n2;
  const g2 = (a2) => {
    a2.on("uiRegister", () => {
      e2 && a2.ui.registerElement({
        name: "fullscreen",
        order: 7,
        isButton: true,
        html: '<svg class="pswp__icn" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M249.5 270.833H437v-75H212a37.5 37.5 0 0 0-37.5 37.5v225h75v-187.5zm-37.5 600h225v-75H249.5v-187.5h-75v225a37.5 37.5 0 0 0 37.5 37.5zm637.5-37.5v-225h-75v187.5H587v75h225a37.5 37.5 0 0 0 37.5-37.5zM587 270.833h187.5v187.5h75v-225a37.5 37.5 0 0 0-37.5-37.5H587v75z"/></svg>',
        onClick: () => {
          l2();
        }
      }), a2.ui.registerElement({
        name: "download",
        order: 8,
        isButton: true,
        tagName: "a",
        html: {
          isCustomSVG: true,
          inner: '<path d="M20.5 14.3 17.1 18V10h-2.2v7.9l-3.4-3.6L10 16l6 6.1 6-6.1-1.5-1.6ZM23 23H9v2h14" id="pswp__icn-download"/>',
          outlineID: "pswp__icn-download"
        },
        onInit: (r2, o2) => {
          r2.setAttribute("download", ""), r2.setAttribute("target", "_blank"), r2.setAttribute("rel", "noopener"), o2.on("change", () => {
            r2.setAttribute("href", o2.currSlide.data.src);
          });
        }
      }), a2.ui.registerElement({
        name: "bulletsIndicator",
        className: "photo-swipe-bullets-indicator",
        appendTo: "wrapper",
        onInit: (r2, o2) => {
          const t2 = [];
          let i3 = -1;
          for (let s2 = 0; s2 < o2.getNumItems(); s2++) {
            const c2 = document.createElement("div");
            c2.className = "photo-swipe-bullet", c2.onclick = (w2) => {
              o2.goTo(t2.indexOf(w2.target));
            }, t2.push(c2), r2.appendChild(c2);
          }
          o2.on("change", () => {
            i3 >= 0 && t2[i3].classList.remove("active"), t2[o2.currIndex].classList.add("active"), i3 = o2.currIndex;
          });
        }
      });
    });
  }, p2 = () => Promise.all([__vitePreload(() => import("./photoswipe.esm-514cb96e.js"), true ? [] : void 0), nextTick().then(() => new Promise((a2) => setTimeout(a2, A$3)).then(() => H$3(P$3)))]).then(([{
    default: a2
  }, r2]) => {
    const o2 = r2.map((t2) => ({
      html: b$5,
      element: t2,
      msrc: t2.src
    }));
    r2.forEach((t2, i3) => {
      const s2 = () => {
        n2 = new a2({
          preloaderDelay: 0,
          showHideAnimationType: "zoom",
          ...d2.value,
          ...m2,
          dataSource: o2,
          index: i3,
          ...{
            closeOnVerticalDrag: true,
            wheelToZoom: false
          }
        }), g2(n2), n2.addFilter("thumbEl", () => t2), n2.addFilter("placeholderSrc", () => t2.src), n2.init();
      };
      t2.style.cursor = "zoom-in", t2.addEventListener("click", () => {
        s2();
      }), t2.addEventListener("keypress", ({
        key: c2
      }) => {
        c2 === "Enter" && s2();
      });
    }), r2.forEach((t2, i3) => {
      h$4(t2).then((s2) => {
        o2.splice(i3, 1, s2), n2 == null || n2.refreshSlideContent(i3);
      });
    });
  });
  onMounted(() => {
    useEventListener("wheel", () => {
      n2 == null || n2.close();
    }), p2(), watch(() => v3.value.path, () => p2());
  });
};
var M$3 = defineClientConfig({
  enhance: ({
    app: e2
  }) => {
    s$4(e2);
  },
  setup: () => {
    N$1();
  }
});
const vpCard = "";
const t$3 = ({
  title: c2,
  desc: e2 = "",
  logo: l2 = "",
  color: s2 = "",
  link: o2 = ""
}) => {
  const i3 = [h$5("img", {
    class: "vp-card-logo",
    src: withBase(l2)
  }), h$5("div", {
    class: "vp-card-content"
  }, [h$5("div", {
    class: "vp-card-title",
    innerHTML: c2
  }), h$5("hr"), h$5("div", {
    class: "vp-card-desc",
    innerHTML: e2
  })])], a2 = {
    class: "vp-card"
  };
  return s2 && (a2.style = {
    background: s2
  }), isLinkExternal(o2) ? h$5("a", {
    href: o2,
    target: "_blank",
    ...a2
  }, i3) : h$5(j$1, {
    to: o2,
    ...a2
  }, () => i3);
};
t$3.displayName = "VPCard";
const figure = "";
const footnote = "";
const imageMark = "";
const mermaid = "";
let i$4 = {};
const o$4 = Symbol(""), r$5 = () => inject(o$4), t$2 = (e2) => {
  e2.provide(o$4, i$4);
};
const o$3 = {
  useMaxWidth: false
}, L$5 = (e2) => ({
  dark: e2,
  background: e2 ? "#1e1e1e" : "#fff",
  primaryColor: e2 ? "#389d70" : "#4abf8a",
  primaryBorderColor: e2 ? "#389d70" : "#4abf8a",
  primaryTextColor: "#fff",
  secondaryColor: "#ffb500",
  secondaryBorderColor: e2 ? "#fff" : "#000",
  secondaryTextColor: e2 ? "#ddd" : "#333",
  tertiaryColor: e2 ? "#282828" : "#efeef4",
  tertiaryBorderColor: e2 ? "#bbb" : "#242424",
  tertiaryTextColor: e2 ? "#ddd" : "#333",
  noteBkgColor: e2 ? "#f6d365" : "#fff5ad",
  noteTextColor: "#242424",
  noteBorderColor: e2 ? "#f6d365" : "#333",
  lineColor: e2 ? "#d3d3d3" : "#333",
  textColor: e2 ? "#fff" : "#242424",
  mainBkg: e2 ? "#389d70" : "#4abf8a",
  errorBkgColor: "#eb4d5d",
  errorTextColor: "#fff",
  nodeBorder: e2 ? "#389d70" : "#4abf8a",
  nodeTextColor: e2 ? "#fff" : "#242424",
  signalTextColor: e2 ? "#9e9e9e" : "#242424",
  classText: "#fff",
  labelColor: "#fff",
  fillType0: e2 ? "#cf1322" : "#f1636e",
  fillType1: "#f39c12",
  fillType2: "#2ecc71",
  fillType3: "#fa541c",
  fillType4: "#25a55b",
  fillType5: "#13c2c2",
  fillType6: "#096dd9",
  fillType7: "#aa6fe9"
});
var k$3 = defineComponent({
  name: "Mermaid",
  props: {
    id: {
      type: String,
      required: true
    },
    code: {
      type: String,
      required: true
    }
  },
  setup(e2) {
    const {
      themeVariables: d2,
      ...s2
    } = r$5(), f2 = shallowRef(), m2 = computed(() => Fe(e2.code)), l2 = ref(""), i3 = ref(false), c2 = async () => {
      const [{
        default: t2
      }] = await Promise.all([__vitePreload(() => import("mermaid"), true ? [] : void 0), new Promise((r2) => setTimeout(r2, 800))]);
      t2.initialize({
        theme: "base",
        themeVariables: {
          ...L$5(i3.value),
          ...Re(d2) ? d2(i3.value) : d2
        },
        flowchart: o$3,
        sequence: o$3,
        journey: o$3,
        gantt: o$3,
        er: o$3,
        pie: o$3,
        ...s2,
        startOnLoad: false
      }), l2.value = (await t2.render(e2.id, m2.value)).svg;
    }, p2 = () => {
      const {
        body: t2
      } = document, r2 = document.createElement("div");
      r2.classList.add("mermaid-preview"), r2.innerHTML = l2.value, t2.appendChild(r2), r2.addEventListener("click", () => {
        t2.removeChild(r2);
      });
    }, u3 = () => {
      const t2 = `data:image/svg+xml;charset=utf8,${l2.value.replace(/<br>/g, "<br />").replace(/%/g, "%25").replace(/"/g, "%22").replace(/'/g, "%27").replace(/&/g, "%26").replace(/#/g, "%23").replace(/{/g, "%7B").replace(/}/g, "%7D").replace(/</g, "%3C").replace(/>/g, "%3E")}`, r2 = document.createElement("a");
      r2.setAttribute("href", t2), r2.setAttribute("download", `${e2.id}.svg`), r2.click();
    };
    return onMounted(() => {
      const t2 = document.documentElement, r2 = () => t2.classList.contains("dark") || t2.getAttribute("data-theme") === "dark";
      i3.value = r2(), c2(), useMutationObserver(t2, () => {
        i3.value = r2();
      }, {
        attributeFilter: ["class", "data-theme"],
        attributes: true
      }), watch(i3, () => c2());
    }), () => [h$5("div", {
      class: "mermaid-actions"
    }, [h$5("button", {
      class: "preview-button",
      onClick: () => p2(),
      title: "preview",
      innerHTML: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1316 1024" fill="currentColor"><path d="M658.286 0C415.89 0 0 297.106 0 512c0 214.82 415.89 512 658.286 512 242.322 0 658.285-294.839 658.285-512S900.608 0 658.286 0zm0 877.714c-161.573 0-512-221.769-512-365.714 0-144.018 350.427-365.714 512-365.714 161.572 0 512 217.16 512 365.714s-350.428 365.714-512 365.714z"/><path d="M658.286 292.571a219.429 219.429 0 1 0 0 438.858 219.429 219.429 0 0 0 0-438.858zm0 292.572a73.143 73.143 0 1 1 0-146.286 73.143 73.143 0 0 1 0 146.286z"/></svg>'
    }), h$5("button", {
      class: "download-button",
      onClick: () => u3(),
      title: "download",
      innerHTML: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor"><path d="M828.976 894.125H190.189c-70.55 0-127.754-57.185-127.754-127.753V606.674c0-17.634 14.31-31.933 31.933-31.933h63.889c17.634 0 31.932 14.299 31.932 31.933v95.822c0 35.282 28.596 63.877 63.877 63.877h511.033c35.281 0 63.877-28.595 63.877-63.877v-95.822c0-17.634 14.298-31.933 31.943-31.933h63.878c17.635 0 31.933 14.299 31.933 31.933v159.7c0 70.566-57.191 127.751-127.754 127.751zM249.939 267.51c12.921-12.92 33.885-12.92 46.807 0l148.97 148.972V94.893c0-17.634 14.302-31.947 31.934-31.947h63.876c17.638 0 31.946 14.313 31.946 31.947v321.589l148.97-148.972c12.922-12.92 33.876-12.92 46.797 0l46.814 46.818c12.922 12.922 12.922 33.874 0 46.807L552.261 624.93c-1.14 1.138-21.664 13.684-42.315 13.693-20.877.01-41.88-12.542-43.021-13.693L203.122 361.135c-12.923-12.934-12.923-33.885 0-46.807l46.817-46.818z"/></svg>'
    })]), h$5("div", {
      ref: f2,
      class: "mermaid-wrapper"
    }, l2.value ? h$5("div", {
      class: "mermaid-content",
      innerHTML: l2.value
    }) : h$5(C$5, {
      class: "mermaid-loading",
      height: 96
    }))];
  }
});
const s$3 = {
  showCompileOutput: false,
  clearConsole: false,
  ssr: false
};
let e$4 = s$3;
const n$5 = Symbol(""), r$4 = () => inject(n$5), t$1 = (o2) => {
  o2.provide(n$5, e$4);
};
const katex_min = "";
const katex = "";
const clientConfig15 = defineClientConfig({
  enhance: ({
    app
  }) => {
    app.component("VPCard", t$3);
    t$2(app);
    app.component("Mermaid", k$3);
    t$1(app);
    app.component("VuePlayground", defineAsyncComponent(() => __vitePreload(() => import("./VuePlayground-96fb86a8.js"), true ? [] : void 0)));
  },
  setup: () => {
  }
});
const biliBili = "";
const e$3 = "accelerometer; autoplay; clipboard-write; encrypted-media; fullscreen; gyroscope; picture-in-picture";
const h$3 = (e2) => isString$1(e2) ? e2 : `${e2}px`, z$3 = (e2, u3 = 0) => {
  const o2 = shallowRef(), p2 = computed(() => h$3(unref(e2.width) || "100%")), m2 = ref("auto"), l2 = (t2) => {
    if (isString$1(t2)) {
      const [i3, s2] = t2.split(":"), a2 = Number(i3) / Number(s2);
      if (!Number.isNaN(a2))
        return a2;
    }
    return typeof t2 == "number" ? t2 : 16 / 9;
  }, N2 = (t2) => {
    const i3 = unref(e2.height), s2 = l2(unref(e2.ratio));
    return i3 ? h$3(i3) : `${Number(t2) / s2 + unref(u3)}px`;
  }, r2 = () => {
    o2.value && (m2.value = N2(o2.value.clientWidth));
  };
  return onMounted(() => {
    r2(), isRef(u3) && watch(u3, () => r2()), useEventListener("orientationchange", () => r2()), useEventListener("resize", () => r2());
  }), {
    el: o2,
    width: p2,
    height: m2
  };
};
const d$5 = "https://player.bilibili.com/player.html";
var S$3 = defineComponent({
  name: "BiliBili",
  props: {
    bvid: {
      type: String,
      default: ""
    },
    aid: {
      type: String,
      default: ""
    },
    cid: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: "A BiliBili video"
    },
    page: {
      type: [String, Number],
      default: 1
    },
    width: {
      type: [String, Number],
      default: "100%"
    },
    height: {
      type: [String, Number],
      default: void 0
    },
    ratio: {
      type: [String, Number],
      default: 16 / 9
    },
    time: {
      type: [String, Number],
      default: 0
    },
    autoplay: Boolean
  },
  setup(i3) {
    const {
      el: m2,
      width: n2,
      height: f2
    } = z$3(i3), e2 = ref(false), l2 = computed(() => {
      const {
        aid: a2,
        bvid: r2,
        cid: o2,
        autoplay: u3,
        time: p2,
        page: s2
      } = i3;
      return a2 && o2 ? `${d$5}?aid=${a2}&cid=${o2}&t=${p2}&autoplay=${u3 ? 1 : 0}&page=${s2}` : r2 ? `${d$5}?bvid=${r2}&t=${p2}&autoplay=${u3 ? 1 : 0}` : null;
    });
    return () => l2.value ? [h$5("div", {
      class: "bilibili-desc"
    }, h$5("a", {
      class: "sr-only",
      href: l2.value
    }, i3.title)), h$5("iframe", {
      ref: m2,
      src: l2.value,
      title: i3.title,
      class: "bilibili-iframe",
      allow: e$3,
      style: {
        width: n2.value,
        height: e2.value ? f2.value : 0
      },
      onLoad: () => {
        e2.value = true;
      }
    }), e2.value ? null : h$5(C$5)] : [];
  }
});
const srOnly = "";
const clientConfig16 = defineClientConfig({
  enhance: ({
    app
  }) => {
    if (!Qe$1("BiliBili"))
      app.component("BiliBili", S$3);
  },
  setup: () => {
  },
  rootComponents: []
});
const _Fontaine_ost13___HOYOMiX = "/assets/「Fontaine」ost-13 - HOYO-MiX-17c7ef45.mp3";
const __vite_glob_0_0$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost13___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost2___HOYOMiX = "/assets/「Fontaine」ost-2 - HOYO-MiX-e9a0a09d.mp3";
const __vite_glob_0_1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost2___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost20___HOYOMiX = "/assets/「Fontaine」ost-20 - HOYO-MiX-fafc51b0.mp3";
const __vite_glob_0_2$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost20___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost22___HOYOMiX = "/assets/「Fontaine」ost-22 - HOYO-MiX-35bbf440.mp3";
const __vite_glob_0_3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost22___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost23___HOYOMiX = "/assets/「Fontaine」ost-23 - HOYO-MiX-53dbbf8d.mp3";
const __vite_glob_0_4$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost23___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost31___HOYOMiX = "/assets/「Fontaine」ost-31 - HOYO-MiX-0eb6268e.mp3";
const __vite_glob_0_5$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost31___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost55___HOYOMiX = "/assets/「Fontaine」ost-55 - HOYO-MiX-8c9e0d5d.mp3";
const __vite_glob_0_6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost55___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _Fontaine_ost64___HOYOMiX = "/assets/「Fontaine」ost-64 - HOYO-MiX-1f66b1af.mp3";
const __vite_glob_0_7$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _Fontaine_ost64___HOYOMiX
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$F = {
  name: "Meting",
  props: {
    music: {
      required: false,
      type: Object,
      validator: (obj) => {
        if (obj.auto) {
          return true;
        } else if (obj.server === "local") {
          return !!obj.path;
        } else if (["netease", "tencent", "kuwo", "kugou", "baidu"].includes(obj.server)) {
          return !!obj.type && !!obj.mid;
        }
        return false;
      },
      default: null
    },
    additionalAudios: {
      required: false,
      type: Array,
      default: () => []
    },
    mini: {
      required: false,
      type: Boolean,
      default: null
    },
    float: {
      required: false,
      type: Boolean,
      default: false
    },
    theme: {
      required: false,
      type: String,
      default: "#b7daff"
    },
    shuffle: {
      required: false,
      type: Boolean,
      default: false
    },
    repeat: {
      required: false,
      type: String,
      default: "repeat-all"
    },
    customAudioType: {
      required: false,
      type: Object,
      default: void 0
    },
    mutex: {
      required: false,
      type: Boolean,
      default: true
    },
    lrcType: {
      required: false,
      type: Number,
      default: 0
    },
    showLrc: {
      required: false,
      type: Boolean,
      default: false
    },
    listFolded: {
      required: false,
      type: Boolean,
      default: true
    },
    listMaxHeight: {
      required: false,
      type: Number,
      default: 250
    },
    storageName: {
      required: false,
      type: String,
      default: "vuepress-plugin-meting"
    },
    autoplay: {
      required: false,
      type: Boolean,
      default: false
    },
    preload: {
      required: false,
      type: String,
      default: "auto"
    },
    volume: {
      required: false,
      type: Number,
      default: 0.7
    },
    controls: {
      required: false,
      type: Boolean,
      default: false
    },
    muted: {
      required: false,
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      metingApi: "https://api.i-meto.com/meting/api",
      audio: reactive([{
        title: "加载音乐列表中..",
        artist: " ",
        pic: "",
        src: "null"
      }]),
      rules: [["music.163.com.*song.*id=(\\d+)", "netease", "song"], ["music.163.com.*album.*id=(\\d+)", "netease", "album"], ["music.163.com.*artist.*id=(\\d+)", "netease", "artist"], ["music.163.com.*playlist.*id=(\\d+)", "netease", "playlist"], ["music.163.com.*discover/toplist.*id=(\\d+)", "netease", "playlist"], ["y.qq.com.*song/(\\w+).html", "tencent", "song"], ["y.qq.com.*album/(\\w+).html", "tencent", "album"], ["y.qq.com.*singer/(\\w+).html", "tencent", "artist"], ["y.qq.com.*playsquare/(\\w+).html", "tencent", "playlist"], ["y.qq.com.*playlist/(\\w+).html", "tencent", "playlist"], ["xiami.com.*song/(\\w+)", "xiami", "song"], ["xiami.com.*album/(\\w+)", "xiami", "album"], ["xiami.com.*artist/(\\w+)", "xiami", "artist"], ["xiami.com.*collect/(\\w+)", "xiami", "playlist"]],
      localRules: [["/(.+/)?(.+)\\.(.+)", "local", "song", 2], ["/(.+)?/|/", "local", "playlist"]]
    };
  },
  created() {
    const mapFunc2 = (obj) => ({
      title: obj.name || obj.title || "Audio name",
      artist: obj.artist || obj.author || "Audio artist",
      src: obj.url || obj.src,
      pic: obj.pic,
      lrc: obj.lrc || obj.lyric || "",
      theme: obj.pic,
      type: obj.type || "auto"
    });
    if (this.music === null) {
      if (this.additionalAudios.length) {
        this.audio = this.additionalAudios.map(mapFunc2);
        console.log(this.audio);
      }
      return;
    }
    const {
      auto,
      type: type2,
      server,
      mid,
      path
    } = this.music;
    let params;
    if (auto) {
      const parsed_params = this.parse_link(auto);
      params = {
        ...parsed_params,
        r: Math.random()
      };
    } else if (server === "local") {
      params = this.parse_link(path, this.localRules);
      if (params.type === "playlist") {
        const musics = /* @__PURE__ */ Object.assign({
          "../../../public/music/「Fontaine」ost-13 - HOYO-MiX.mp3": __vite_glob_0_0$2,
          "../../../public/music/「Fontaine」ost-2 - HOYO-MiX.mp3": __vite_glob_0_1$2,
          "../../../public/music/「Fontaine」ost-20 - HOYO-MiX.mp3": __vite_glob_0_2$2,
          "../../../public/music/「Fontaine」ost-22 - HOYO-MiX.mp3": __vite_glob_0_3$2,
          "../../../public/music/「Fontaine」ost-23 - HOYO-MiX.mp3": __vite_glob_0_4$2,
          "../../../public/music/「Fontaine」ost-31 - HOYO-MiX.mp3": __vite_glob_0_5$2,
          "../../../public/music/「Fontaine」ost-55 - HOYO-MiX.mp3": __vite_glob_0_6$2,
          "../../../public/music/「Fontaine」ost-64 - HOYO-MiX.mp3": __vite_glob_0_7$2
        });
        this.audio = Object.keys(musics).map((m2) => {
          const reg = new RegExp(`.*public(${path}(.+?)( - (.+))?\\.mp3)`);
          const match = m2.match(reg);
          return {
            title: match[2],
            artist: match[4],
            src: match[1],
            pic: "/images/avatar.png"
          };
        });
      } else {
        const [dir, title, _2, artist, suf] = path.match(/.+\/(.+?)( - (.+))?\.(\w+)/);
        this.audio = [{
          title,
          artist,
          src: path,
          pic: "/images/avatar.png"
        }];
      }
      this.audio.concat(this.additionalAudios.map(mapFunc2));
      return;
    } else {
      params = {
        server,
        type: type2,
        id: mid,
        r: Math.random()
      };
    }
    let url = this.metingApi;
    let paramsArray = [];
    Object.keys(params).forEach((key) => paramsArray.push(key + "=" + params[key]));
    url += "?" + paramsArray.join("&");
    fetch(url, {
      headers: {
        referer: null
      }
    }).then((res) => res.json()).then((result) => {
      console.log(url, result);
      const res = result.map(mapFunc2);
      if (res.length) {
        this.audio = this.additionalAudios.map(mapFunc2).concat(res);
        this.setAudio();
      }
    });
  },
  mounted() {
    this.setAudio();
  },
  methods: {
    parse_link(link, rules = this.rules.concat(this.localRules)) {
      for (let rule of rules) {
        let patt = new RegExp(rule[0]);
        let res = patt.exec(link);
        if (res !== null) {
          return {
            server: rule[1],
            type: rule[2],
            id: res[rule[3] ?? 1]
          };
        }
      }
      console.error(`无法解析的链接: ${link}，请检查链接是否书写正确`);
      return {
        server: "",
        type: "",
        id: ""
      };
    },
    setAudio() {
      const {
        aplayer
      } = this.$refs;
      aplayer.setAudioList(this.audio);
    }
  }
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_APlayer = resolveComponent("APlayer");
  return openBlock(), createBlock(_component_APlayer, {
    ref: "aplayer",
    music: $data.audio[0],
    mini: $props.mini,
    theme: $props.theme,
    float: $props.float,
    shuffle: $props.shuffle,
    repeat: $props.repeat,
    "custom-audio-type": $props.customAudioType,
    mutex: $props.mutex,
    "lrc-type": $props.lrcType,
    "show-lrc": $props.showLrc,
    "list-folded": $props.listFolded,
    "list-max-height": $props.listMaxHeight.toString(),
    "storage-name": $props.storageName,
    preload: $props.preload,
    volume: $props.volume,
    autoplay: $props.autoplay,
    controls: $props.controls,
    muted: $props.muted
  }, null, 8, ["music", "mini", "theme", "float", "shuffle", "repeat", "custom-audio-type", "mutex", "lrc-type", "show-lrc", "list-folded", "list-max-height", "storage-name", "preload", "volume", "autoplay", "controls", "muted"]);
}
const Meting = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["render", _sfc_render$x], ["__file", "Meting.vue"]]);
const MetingGlobal_vue_vue_type_style_index_0_lang = "";
const _sfc_main$E = {
  name: "MetingGlobal",
  data() {
    return {
      ...{
        "auto": "",
        "server": "",
        "type": "",
        "mid": "",
        "path": ""
      },
      ...{
        "additionalAudios": [],
        "mini": false,
        "float": false,
        "theme": "#b7daff",
        "shuffle": false,
        "repeat": "repeat-all",
        "mutex": true,
        "lrcType": 0,
        "showLrc": false,
        "listFolded": false,
        "listMaxHeight": 250,
        "storageName": "vuepress-plugin-meting",
        "autoplay": false,
        "preload": "auto",
        "volume": 0.7,
        "controls": false,
        "muted": false
      }
    };
  },
  mounted() {
    if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
      this.aplayer_fixed_mobile_switch();
    }
  },
  methods: {
    aplayer_fixed_mobile_switch() {
      const aplayer = document.getElementById("aplayer-fixed");
      if (aplayer === null)
        return;
      aplayer.querySelector(".aplayer-body");
      const btn = aplayer.querySelector(".aplayer-miniswitcher");
      aplayer.querySelector(".aplayer-lrc");
      btn.onclick = () => {
      };
    }
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Meting = resolveComponent("Meting");
  return openBlock(), createBlock(_component_Meting, {
    ref: "meting",
    id: "aplayer-fixed",
    music: {
      auto: _ctx.auto,
      server: _ctx.server,
      type: _ctx.type,
      mid: _ctx.mid,
      path: _ctx.path
    },
    auto: _ctx.auto,
    server: _ctx.server,
    type: _ctx.type,
    mid: _ctx.mid,
    "additional-audios": _ctx.additionalAudios,
    mini: _ctx.mini,
    theme: _ctx.theme,
    float: true,
    shuffle: _ctx.shuffle,
    repeat: _ctx.repeat,
    mutex: _ctx.mutex,
    "lrc-type": _ctx.lrcType,
    "show-lrc": _ctx.showLrc,
    "list-folded": _ctx.listFolded,
    "list-max-height": _ctx.listMaxHeight,
    "storage-name": _ctx.storageName,
    autoplay: _ctx.autoplay,
    preload: _ctx.preload,
    volume: _ctx.volume,
    controls: _ctx.controls,
    muted: _ctx.muted,
    class: normalizeClass(_ctx.mini ? "fixed" : "")
  }, null, 8, ["music", "auto", "server", "type", "mid", "additional-audios", "mini", "theme", "shuffle", "repeat", "mutex", "lrc-type", "show-lrc", "list-folded", "list-max-height", "storage-name", "autoplay", "preload", "volume", "controls", "muted", "class"]);
}
const MetingGlobal = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["render", _sfc_render$w], ["__file", "MetingGlobal.vue"]]);
const __vite_glob_0_0$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M4 16c0-6.6 5.4-12 12-12s12 5.4 12 12c0 1.2-0.8 2-2 2s-2-0.8-2-2c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8c1.2 0 2 0.8 2 2s-0.8 2-2 2c-6.6 0-12-5.4-12-12z"></path>\r\n</svg>';
const __vite_glob_0_1$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M26.667 5.333h-21.333c-0 0-0.001 0-0.001 0-1.472 0-2.666 1.194-2.666 2.666 0 0 0 0.001 0 0.001v-0 16c0 0 0 0.001 0 0.001 0 1.472 1.194 2.666 2.666 2.666 0 0 0.001 0 0.001 0h21.333c0 0 0.001 0 0.001 0 1.472 0 2.666-1.194 2.666-2.666 0-0 0-0.001 0-0.001v0-16c0-0 0-0.001 0-0.001 0-1.472-1.194-2.666-2.666-2.666-0 0-0.001 0-0.001 0h0zM5.333 16h5.333v2.667h-5.333v-2.667zM18.667 24h-13.333v-2.667h13.333v2.667zM26.667 24h-5.333v-2.667h5.333v2.667zM26.667 18.667h-13.333v-2.667h13.333v2.667z"></path>\r\n</svg>';
const __vite_glob_0_2$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-5 0 32 32">\r\n    <path d="M20.8 14.4q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2zM1.6 11.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2zM20.8 20.8q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2z"></path>\r\n</svg>';
const __vite_glob_0_3$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4h-11.64v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v0.973h-2.667v-3.64l-4-4zM22.667 17.333h2.667v5.573l-2.667-2.667v-2.907zM22.667 6.667v-4l5.333 5.333-5.333 5.333v-4h-10.907l-2.667-2.667h13.573z"></path>\r\n</svg>';
const __vite_glob_0_4$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-8 0 32 32">\r\n    <path d="M14.080 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112v-18.24q0-2.048 2.88-2.048zM2.88 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112v-18.24q0-2.048 2.88-2.048z"></path>\r\n</svg>';
const __vite_glob_0_5$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-8 0 32 32">\r\n    <path d="M15.552 15.168q0.448 0.32 0.448 0.832 0 0.448-0.448 0.768l-13.696 8.512q-0.768 0.512-1.312 0.192t-0.544-1.28v-16.448q0-0.96 0.544-1.28t1.312 0.192z"></path>\r\n</svg>';
const __vite_glob_0_6$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-1 0 32 32">\r\n  <path d="M25.6 9.92q1.344 0 2.272 0.928t0.928 2.272v9.28q0 1.28-0.928 2.24t-2.272 0.96h-22.4q-1.28 0-2.24-0.96t-0.96-2.24v-9.28q0-1.344 0.96-2.272t2.24-0.928h8v-3.52l6.4 5.76-6.4 5.76v-3.52h-6.72v6.72h19.84v-6.72h-4.8v-4.48h6.080z"></path>\r\n</svg>';
const __vite_glob_0_7$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n<path d="M9.333 9.333h13.333v4l5.333-5.333-5.333-5.333v4h-16v8h2.667v-5.333zM22.667 22.667h-13.333v-4l-5.333 5.333 5.333 5.333v-4h16v-8h-2.667v5.333z"></path>\r\n</svg>';
const __vite_glob_0_8$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 38 32">\r\n  <path d="M2.072 21.577c0.71-0.197 1.125-0.932 0.928-1.641-0.221-0.796-0.333-1.622-0.333-2.457 0-5.049 4.108-9.158 9.158-9.158h5.428c0.056-0.922 0.221-1.816 0.482-2.667h-5.911c-3.158 0-6.128 1.23-8.361 3.463s-3.463 5.203-3.463 8.361c0 1.076 0.145 2.143 0.431 3.171 0.164 0.59 0.7 0.976 1.284 0.976 0.117 0 0.238-0.016 0.357-0.049zM21.394 25.613h-12.409v-2.362c0-0.758-0.528-1.052-1.172-0.652l-5.685 3.522c-0.644 0.4-0.651 1.063-0.014 1.474l5.712 3.69c0.637 0.411 1.158 0.127 1.158-0.63v-2.374h12.409c3.158 0 6.128-1.23 8.361-3.463 1.424-1.424 2.44-3.148 2.99-5.029-0.985 0.368-2.033 0.606-3.125 0.691-1.492 3.038-4.619 5.135-8.226 5.135zM28.718 0c-4.985 0-9.026 4.041-9.026 9.026s4.041 9.026 9.026 9.026 9.026-4.041 9.026-9.026-4.041-9.026-9.026-9.026zM30.392 13.827h-1.728v-6.822c-0.635 0.576-1.433 1.004-2.407 1.285v-1.713c0.473-0.118 0.975-0.325 1.506-0.62 0.532-0.325 0.975-0.665 1.329-1.034h1.3v8.904z"></path>\r\n</svg>';
const __vite_glob_0_9$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M9.333 9.333h13.333v4l5.333-5.333-5.333-5.333v4h-16v8h2.667v-5.333zM22.667 22.667h-13.333v-4l-5.333 5.333 5.333 5.333v-4h16v-8h-2.667v5.333zM17.333 20v-8h-1.333l-2.667 1.333v1.333h2v5.333h2z"></path>\r\n</svg>';
const __vite_glob_0_10$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M22.667 4l7 6-7 6 7 6-7 6v-4h-3.653l-3.76-3.76 2.827-2.827 2.587 2.587h2v-8h-2l-12 12h-6v-4h4.347l12-12h3.653v-4zM2.667 8h6l3.76 3.76-2.827 2.827-2.587-2.587h-4.347v-4z"></path>\r\n</svg>';
const __vite_glob_0_11$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M25.468 6.947c-0.326-0.172-0.724-0.151-1.030 0.057l-6.438 4.38v-3.553c0-0.371-0.205-0.71-0.532-0.884-0.326-0.172-0.724-0.151-1.030 0.057l-12 8.164c-0.274 0.186-0.438 0.496-0.438 0.827s0.164 0.641 0.438 0.827l12 8.168c0.169 0.115 0.365 0.174 0.562 0.174 0.16 0 0.321-0.038 0.468-0.116 0.327-0.173 0.532-0.514 0.532-0.884v-3.556l6.438 4.382c0.169 0.115 0.365 0.174 0.562 0.174 0.16 0 0.321-0.038 0.468-0.116 0.327-0.173 0.532-0.514 0.532-0.884v-16.333c0-0.371-0.205-0.71-0.532-0.884z"></path>\r\n</svg>';
const __vite_glob_0_12$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8zM20.576 16q0 1.344-0.768 2.528t-2.016 1.664q-0.16 0.096-0.448 0.096-0.448 0-0.8-0.32t-0.32-0.832q0-0.384 0.192-0.64t0.544-0.448 0.608-0.384 0.512-0.64 0.192-1.024-0.192-1.024-0.512-0.64-0.608-0.384-0.544-0.448-0.192-0.64q0-0.48 0.32-0.832t0.8-0.32q0.288 0 0.448 0.096 1.248 0.48 2.016 1.664t0.768 2.528z"></path>\r\n</svg>';
const __vite_glob_0_13$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8z"></path>\r\n</svg>';
const __vite_glob_0_14$1 = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32">\r\n    <path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8zM20.576 16q0 1.344-0.768 2.528t-2.016 1.664q-0.16 0.096-0.448 0.096-0.448 0-0.8-0.32t-0.32-0.832q0-0.384 0.192-0.64t0.544-0.448 0.608-0.384 0.512-0.64 0.192-1.024-0.192-1.024-0.512-0.64-0.608-0.384-0.544-0.448-0.192-0.64q0-0.48 0.32-0.832t0.8-0.32q0.288 0 0.448 0.096 1.248 0.48 2.016 1.664t0.768 2.528zM25.152 16q0 2.72-1.536 5.056t-4 3.36q-0.256 0.096-0.448 0.096-0.48 0-0.832-0.352t-0.32-0.8q0-0.704 0.672-1.056 1.024-0.512 1.376-0.8 1.312-0.96 2.048-2.4t0.736-3.104-0.736-3.104-2.048-2.4q-0.352-0.288-1.376-0.8-0.672-0.352-0.672-1.056 0-0.448 0.32-0.8t0.8-0.352q0.224 0 0.48 0.096 2.496 1.056 4 3.36t1.536 5.056zM29.728 16q0 4.096-2.272 7.552t-6.048 5.056q-0.224 0.096-0.448 0.096-0.48 0-0.832-0.352t-0.32-0.8q0-0.64 0.704-1.056 0.128-0.064 0.384-0.192t0.416-0.192q0.8-0.448 1.44-0.896 2.208-1.632 3.456-4.064t1.216-5.152-1.216-5.152-3.456-4.064q-0.64-0.448-1.44-0.896-0.128-0.096-0.416-0.192t-0.384-0.192q-0.704-0.416-0.704-1.056 0-0.448 0.32-0.8t0.832-0.352q0.224 0 0.448 0.096 3.776 1.632 6.048 5.056t2.272 7.552z"></path>\r\n</svg>';
const aplayerIcon_vue_vue_type_style_index_0_lang = "";
const assets = /* @__PURE__ */ Object.assign({
  "../assets/loading.svg": __vite_glob_0_0$1,
  "../assets/lrc.svg": __vite_glob_0_1$1,
  "../assets/menu.svg": __vite_glob_0_2$1,
  "../assets/no-repeat.svg": __vite_glob_0_3$1,
  "../assets/pause.svg": __vite_glob_0_4$1,
  "../assets/play.svg": __vite_glob_0_5$1,
  "../assets/repeat-all-legacy.svg": __vite_glob_0_6$1,
  "../assets/repeat-all.svg": __vite_glob_0_7$1,
  "../assets/repeat-one-legacy.svg": __vite_glob_0_8$1,
  "../assets/repeat-one.svg": __vite_glob_0_9$1,
  "../assets/shuffle.svg": __vite_glob_0_10$1,
  "../assets/skip.svg": __vite_glob_0_11$1,
  "../assets/volume-down.svg": __vite_glob_0_12$1,
  "../assets/volume-off.svg": __vite_glob_0_13$1,
  "../assets/volume-up.svg": __vite_glob_0_14$1
});
const SVGs = {};
for (const [path, inlineSvg] of Object.entries(assets)) {
  const viewBox = inlineSvg.match(/^<svg.+?viewBox="(.+?)".*>/)[1];
  const d2 = inlineSvg.match(/<path.+?d="(.+?)".*>/)[1];
  const name2 = path.match(/^.*\/(.+?)\.svg$/)[1];
  SVGs[name2] = {
    viewBox,
    d: d2
  };
}
const _sfc_main$D = {
  props: ["type"],
  computed: {
    svg() {
      this.type;
      if (this.type === "prev" || this.type === "next")
        ;
      return SVGs[this.type] || {};
    },
    style() {
      if (this.type === "next") {
        return {
          transform: "rotate(180deg)"
        };
      }
      return {};
    }
  }
};
const _hoisted_1$x = ["viewBox"];
const _hoisted_2$m = /* @__PURE__ */ createElementVNode(
  "use",
  {
    "xlink:href": "#aplayer-${type}"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$j = ["d"];
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    height: "100%",
    version: "1.1",
    viewBox: $options.svg.viewBox,
    width: "100%",
    style: normalizeStyle($options.style)
  }, [_hoisted_2$m, createElementVNode("path", {
    class: "aplayer-fill",
    d: $options.svg.d
  }, null, 8, _hoisted_3$j)], 12, _hoisted_1$x);
}
const Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["render", _sfc_render$v], ["__file", "aplayer-icon.vue"]]);
const aplayerIconbutton_vue_vue_type_style_index_0_lang = "";
const _sfc_main$C = {
  components: {
    Icon
  },
  props: ["icon"]
};
const _hoisted_1$w = {
  type: "button",
  class: "aplayer-icon"
};
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon = resolveComponent("icon");
  return openBlock(), createElementBlock("button", _hoisted_1$w, [createVNode(_component_icon, {
    type: $props.icon
  }, null, 8, ["type"])]);
}
const IconButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["render", _sfc_render$u], ["__file", "aplayer-iconbutton.vue"]]);
const aplayerThumbnail_vue_vue_type_style_index_0_lang = "";
const _sfc_main$B = {
  components: {
    IconButton
  },
  props: {
    pic: String,
    theme: String,
    playing: {
      type: Boolean,
      default: false
    },
    enableDrag: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      hasMovedSinceMouseDown: false,
      dragStartX: 0,
      dragStartY: 0
    };
  },
  computed: {
    currentPicStyleObj() {
      if (!this.pic)
        return {};
      return {
        backgroundImage: `url(${this.pic})`,
        backgroundColor: this.theme
      };
    }
  },
  methods: {
    onDragBegin(e2) {
      if (this.enableDrag) {
        this.hasMovedSinceMouseDown = false;
        this.$emit("dragbegin");
        this.dragStartX = e2.clientX;
        this.dragStartY = e2.clientY;
        document.addEventListener("mousemove", this.onDocumentMouseMove);
        document.addEventListener("mouseup", this.onDocumentMouseUp);
      }
    },
    onDocumentMouseMove(e2) {
      this.hasMovedSinceMouseDown = true;
      this.$emit("dragging", {
        offsetLeft: e2.clientX - this.dragStartX,
        offsetTop: e2.clientY - this.dragStartY
      });
    },
    onDocumentMouseUp(e2) {
      document.removeEventListener("mouseup", this.onDocumentMouseUp);
      document.removeEventListener("mousemove", this.onDocumentMouseMove);
      this.$emit("dragend");
    },
    onClick() {
      if (!this.hasMovedSinceMouseDown) {
        this.$emit("toggleplay");
      }
    }
  }
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_button = resolveComponent("icon-button");
  return openBlock(), createElementBlock(
    "div",
    {
      class: "aplayer-pic",
      style: normalizeStyle($options.currentPicStyleObj),
      onMousedown: _cache[0] || (_cache[0] = (...args) => $options.onDragBegin && $options.onDragBegin(...args)),
      onClick: _cache[1] || (_cache[1] = (...args) => $options.onClick && $options.onClick(...args))
    },
    [createElementVNode(
      "div",
      {
        class: normalizeClass(["aplayer-button", $props.playing ? "aplayer-pause" : "aplayer-play"])
      },
      [createVNode(_component_icon_button, {
        icon: $props.playing ? "pause" : "play",
        class: normalizeClass($props.playing ? "aplayer-icon-pause" : "aplayer-icon-play")
      }, null, 8, ["icon", "class"])],
      2
      /* CLASS */
    )],
    36
    /* STYLE, HYDRATE_EVENTS */
  );
}
const Thumbnail = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$t], ["__file", "aplayer-thumbnail.vue"]]);
const aplayerList_vue_vue_type_style_index_0_lang = "";
const _sfc_main$A = {
  props: {
    show: {
      type: Boolean,
      default: true
    },
    currentMusic: Object,
    musicList: {
      type: Array,
      default() {
        return [];
      }
    },
    playIndex: {
      type: Number,
      default: 0
    },
    theme: String,
    listmaxheight: String
  },
  computed: {
    listHeightStyle() {
      return {
        height: `${33 * this.musicList.length - 1}px`,
        maxHeight: this.listmaxheight || ""
      };
    }
  }
};
const _hoisted_1$v = ["onClick"];
const _hoisted_2$l = {
  class: "aplayer-list-index"
};
const _hoisted_3$i = {
  class: "aplayer-list-title"
};
const _hoisted_4$d = {
  class: "aplayer-list-author"
};
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "slide-v",
    persisted: ""
  }, {
    default: withCtx(() => [withDirectives(createElementVNode(
      "div",
      {
        class: "aplayer-list",
        style: normalizeStyle($options.listHeightStyle),
        ref: "list"
      },
      [createElementVNode(
        "ol",
        {
          ref: "ol",
          style: normalizeStyle($options.listHeightStyle)
        },
        [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList($props.musicList, (aMusic, index2) => {
            return openBlock(), createElementBlock("li", {
              key: index2,
              class: normalizeClass({
                "aplayer-list-light": aMusic === $props.currentMusic
              }),
              onClick: ($event) => _ctx.$emit("selectsong", aMusic)
            }, [createElementVNode(
              "span",
              {
                class: "aplayer-list-cur",
                style: normalizeStyle({
                  background: $props.theme
                })
              },
              null,
              4
              /* STYLE */
            ), createElementVNode(
              "span",
              _hoisted_2$l,
              toDisplayString(index2 + 1),
              1
              /* TEXT */
            ), createElementVNode(
              "span",
              _hoisted_3$i,
              toDisplayString(aMusic.title || "Untitled"),
              1
              /* TEXT */
            ), createElementVNode(
              "span",
              _hoisted_4$d,
              toDisplayString(aMusic.artist || "Unknown"),
              1
              /* TEXT */
            )], 10, _hoisted_1$v);
          }),
          128
          /* KEYED_FRAGMENT */
        ))],
        4
        /* STYLE */
      )],
      4
      /* STYLE */
    ), [[vShow, $props.show]])]),
    _: 1
    /* STABLE */
  });
}
const MusicList = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$s], ["__file", "aplayer-list.vue"]]);
function parseLrc(lrc_s) {
  if (lrc_s) {
    lrc_s = lrc_s.replace(/([^\]^\n])\[/g, (match, p1) => p1 + "\n[");
    const lyric = lrc_s.split("\n");
    const lrc = [];
    const lyricLen = lyric.length;
    for (let i3 = 0; i3 < lyricLen; i3++) {
      const lrcTimes = lyric[i3].match(/\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g);
      const lrcText = lyric[i3].replace(/.*\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g, "").replace(/<(\d{2}):(\d{2})(\.(\d{2,3}))?>/g, "").replace(/^\s+|\s+$/g, "");
      if (lrcTimes) {
        const timeLen = lrcTimes.length;
        for (let j2 = 0; j2 < timeLen; j2++) {
          const oneTime = /\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/.exec(lrcTimes[j2]);
          const min2sec = oneTime[1] * 60;
          const sec2sec = parseInt(oneTime[2]);
          const msec2sec = oneTime[4] ? parseInt(oneTime[4]) / ((oneTime[4] + "").length === 2 ? 100 : 1e3) : 0;
          const lrcTime = min2sec + sec2sec + msec2sec;
          lrc.push([lrcTime, lrcText]);
        }
      }
    }
    lrc.sort((a2, b2) => a2[0] - b2[0]);
    return lrc;
  } else {
    return [];
  }
}
function warn(message) {
  return console.warn(`[Vue-APlayer] ${message}`);
}
function getElementViewLeft(element) {
  let actualLeft = element.offsetLeft;
  let current = element.offsetParent;
  let elementScrollLeft;
  while (current !== null) {
    actualLeft += current.offsetLeft;
    current = current.offsetParent;
  }
  elementScrollLeft = document.body.scrollLeft + document.documentElement.scrollLeft;
  return actualLeft - elementScrollLeft;
}
function getElementViewTop(element) {
  let actualTop = element.offsetTop;
  let current = element.offsetParent;
  let elementScrollTop;
  while (current !== null) {
    actualTop += current.offsetTop;
    current = current.offsetParent;
  }
  elementScrollTop = document.body.scrollTop + document.documentElement.scrollTop;
  return actualTop - elementScrollTop;
}
const aplayerControllerProgress_vue_vue_type_style_index_0_lang = "";
const _sfc_main$z = {
  components: {
    Icon
  },
  props: ["loadProgress", "playProgress", "theme"],
  data() {
    return {
      thumbHovered: false
    };
  },
  methods: {
    onThumbMouseDown(e2) {
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragbegin", percentage);
      document.addEventListener("mousemove", this.onDocumentMouseMove);
      document.addEventListener("mouseup", this.onDocumentMouseUp);
    },
    onDocumentMouseMove(e2) {
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragging", percentage);
    },
    onDocumentMouseUp(e2) {
      document.removeEventListener("mouseup", this.onDocumentMouseUp);
      document.removeEventListener("mousemove", this.onDocumentMouseMove);
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragend", percentage);
    },
    onThumbTouchStart(e2) {
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (e2.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragbegin", percentage);
      document.addEventListener("touchmove", this.onDocumentTouchMove);
      document.addEventListener("touchend", this.onDocumentTouchEnd);
    },
    onDocumentTouchMove(e2) {
      const touch = e2.changedTouches[0];
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (touch.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragging", percentage);
    },
    onDocumentTouchEnd(e2) {
      document.removeEventListener("touchend", this.onDocumentTouchEnd);
      document.removeEventListener("touchmove", this.onDocumentTouchMove);
      const touch = e2.changedTouches[0];
      const barWidth = this.$refs.barWrap.clientWidth;
      let percentage = (touch.clientX - getElementViewLeft(this.$refs.barWrap)) / barWidth;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("dragend", percentage);
    }
  }
};
const _hoisted_1$u = {
  class: "aplayer-bar"
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon = resolveComponent("icon");
  return openBlock(), createElementBlock(
    "div",
    {
      class: "aplayer-bar-wrap",
      onMousedown: _cache[2] || (_cache[2] = (...args) => $options.onThumbMouseDown && $options.onThumbMouseDown(...args)),
      onTouchstart: _cache[3] || (_cache[3] = (...args) => $options.onThumbTouchStart && $options.onThumbTouchStart(...args)),
      ref: "barWrap"
    },
    [createElementVNode("div", _hoisted_1$u, [createElementVNode(
      "div",
      {
        class: "aplayer-loaded",
        style: normalizeStyle({
          width: `${$props.loadProgress * 100}%`
        })
      },
      null,
      4
      /* STYLE */
    ), createElementVNode(
      "div",
      {
        class: "aplayer-played",
        style: normalizeStyle({
          width: `${$props.playProgress * 100}%`,
          background: $props.theme
        })
      },
      [createElementVNode(
        "span",
        {
          ref: "thumb",
          onMouseover: _cache[0] || (_cache[0] = ($event) => $data.thumbHovered = true),
          onMouseout: _cache[1] || (_cache[1] = ($event) => $data.thumbHovered = false),
          class: "aplayer-thumb",
          style: normalizeStyle({
            borderColor: $props.theme,
            backgroundColor: $data.thumbHovered ? $props.theme : "#fff"
          })
        },
        [createElementVNode(
          "span",
          {
            class: "aplayer-loading-icon",
            style: normalizeStyle({
              backgroundColor: $props.theme
            })
          },
          [createVNode(_component_icon, {
            type: "loading"
          })],
          4
          /* STYLE */
        )],
        36
        /* STYLE, HYDRATE_EVENTS */
      )],
      4
      /* STYLE */
    )])],
    544
    /* HYDRATE_EVENTS, NEED_PATCH */
  );
}
const VProgress = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$r], ["__file", "aplayer-controller-progress.vue"]]);
const aplayerControllerVolume_vue_vue_type_style_index_0_lang = "";
const barHeight = 40;
const _sfc_main$y = {
  components: {
    IconButton
  },
  props: ["volume", "muted", "theme"],
  computed: {
    volumeIcon() {
      if (this.muted || this.volume <= 0)
        return "volume-off";
      if (this.volume >= 1)
        return "volume-up";
      return "volume-down";
    }
  },
  methods: {
    adjustVolume(e2) {
      let percentage = (barHeight - e2.clientY + getElementViewTop(this.$refs.bar)) / barHeight;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("setvolume", percentage);
    },
    onBarMouseDown() {
      document.addEventListener("mousemove", this.onDocumentMouseMove);
      document.addEventListener("mouseup", this.onDocumentMouseUp);
    },
    onDocumentMouseMove(e2) {
      let percentage = (barHeight - e2.clientY + getElementViewTop(this.$refs.bar)) / barHeight;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("setvolume", percentage);
    },
    onDocumentMouseUp(e2) {
      document.removeEventListener("mouseup", this.onDocumentMouseUp);
      document.removeEventListener("mousemove", this.onDocumentMouseMove);
      let percentage = (barHeight - e2.clientY + getElementViewTop(this.$refs.bar)) / barHeight;
      percentage = percentage > 0 ? percentage : 0;
      percentage = percentage < 1 ? percentage : 1;
      this.$emit("setvolume", percentage);
    }
  }
};
const _hoisted_1$t = {
  class: "aplayer-volume-wrap"
};
const _hoisted_2$k = {
  class: "aplayer-volume-bar",
  ref: "bar"
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_button = resolveComponent("icon-button");
  return openBlock(), createElementBlock("div", _hoisted_1$t, [createVNode(_component_icon_button, {
    class: normalizeClass(`aplayer-icon-${$options.volumeIcon}`),
    icon: $options.volumeIcon,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("togglemute"))
  }, null, 8, ["class", "icon"]), createElementVNode(
    "div",
    {
      class: "aplayer-volume-bar-wrap",
      onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onBarMouseDown && $options.onBarMouseDown(...args))
    },
    [createElementVNode(
      "div",
      _hoisted_2$k,
      [createElementVNode(
        "div",
        {
          class: "aplayer-volume",
          style: normalizeStyle({
            height: $props.muted ? 0 : `${Math.trunc($props.volume * 100)}%`,
            background: $props.theme
          })
        },
        null,
        4
        /* STYLE */
      )],
      512
      /* NEED_PATCH */
    )],
    32
    /* HYDRATE_EVENTS */
  )]);
}
const Volume = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$q], ["__file", "aplayer-controller-volume.vue"]]);
const aplayerController_vue_vue_type_style_index_0_lang = "";
const _sfc_main$x = {
  components: {
    IconButton,
    VProgress,
    Volume
  },
  props: ["shuffle", "repeat", "stat", "theme", "volume", "muted"],
  computed: {
    loadProgress() {
      if (this.stat.duration === 0)
        return 0;
      return this.stat.loadedTime / this.stat.duration;
    },
    playProgress() {
      if (this.stat.duration === 0)
        return 0;
      return this.stat.playedTime / this.stat.duration;
    }
  },
  methods: {
    secondToTime(second) {
      if (isNaN(second)) {
        return "00:00";
      }
      const pad0 = (num) => {
        return num < 10 ? "0" + num : "" + num;
      };
      const min2 = Math.trunc(second / 60);
      const sec = Math.trunc(second - min2 * 60);
      const hours = Math.trunc(min2 / 60);
      const minAdjust = Math.trunc(second / 60 - 60 * Math.trunc(second / 60 / 60));
      return second >= 3600 ? pad0(hours) + ":" + pad0(minAdjust) + ":" + pad0(sec) : pad0(min2) + ":" + pad0(sec);
    }
  }
};
const _hoisted_1$s = {
  class: "aplayer-controller"
};
const _hoisted_2$j = {
  class: "aplayer-time"
};
const _hoisted_3$h = {
  class: "aplayer-time-inner"
};
const _hoisted_4$c = {
  class: "aplayer-ptime"
};
const _hoisted_5$9 = {
  class: "aplayer-dtime"
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_v_progress = resolveComponent("v-progress");
  const _component_volume = resolveComponent("volume");
  const _component_icon_button = resolveComponent("icon-button");
  return openBlock(), createElementBlock("div", _hoisted_1$s, [createVNode(_component_v_progress, {
    loadProgress: $options.loadProgress,
    playProgress: $options.playProgress,
    theme: $props.theme,
    onDragbegin: _cache[0] || (_cache[0] = (val) => _ctx.$emit("dragbegin", val)),
    onDragend: _cache[1] || (_cache[1] = (val) => _ctx.$emit("dragend", val)),
    onDragging: _cache[2] || (_cache[2] = (val) => _ctx.$emit("dragging", val))
  }, null, 8, ["loadProgress", "playProgress", "theme"]), createElementVNode("div", _hoisted_2$j, [createElementVNode("div", _hoisted_3$h, [createTextVNode(" - "), createElementVNode(
    "span",
    _hoisted_4$c,
    toDisplayString($options.secondToTime($props.stat.playedTime)),
    1
    /* TEXT */
  ), createTextVNode(" / "), createElementVNode(
    "span",
    _hoisted_5$9,
    toDisplayString($options.secondToTime($props.stat.duration)),
    1
    /* TEXT */
  )]), !_ctx.$parent.isMobile ? (openBlock(), createBlock(_component_volume, {
    key: 0,
    volume: $props.volume,
    theme: $props.theme,
    muted: $props.muted,
    onTogglemute: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("togglemute")),
    onSetvolume: _cache[4] || (_cache[4] = (v3) => _ctx.$emit("setvolume", v3))
  }, null, 8, ["volume", "theme", "muted"])) : createCommentVNode("v-if", true), createVNode(_component_icon_button, {
    class: normalizeClass(["aplayer-icon-mode", {
      "inactive": !$props.shuffle
    }]),
    icon: "shuffle",
    onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("toggleshuffle"))
  }, null, 8, ["class"]), createVNode(_component_icon_button, {
    class: normalizeClass(["aplayer-icon-mode", {
      "inactive": $props.repeat === "no-repeat"
    }]),
    icon: $props.repeat === "repeat-one" ? "repeat-one" : "repeat-all",
    onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("nextmode"))
  }, null, 8, ["icon", "class"]), createVNode(_component_icon_button, {
    class: normalizeClass(["aplayer-icon-menu", {
      "inactive": !_ctx.$parent.showList
    }]),
    icon: "menu",
    onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("togglelist"))
  }, null, 8, ["class"])])]);
}
const Controls = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$p], ["__file", "aplayer-controller.vue"]]);
const aplayerLrc_vue_vue_type_style_index_0_lang = "";
const _sfc_main$w = {
  props: {
    currentMusic: {
      type: Object,
      required: true
    },
    playStat: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      displayLrc: "",
      currentLineIndex: 0
    };
  },
  computed: {
    lrcLines() {
      return parseLrc(this.displayLrc);
    },
    currentLine() {
      if (this.currentLineIndex > this.lrcLines.length - 1) {
        return null;
      }
      return this.lrcLines[this.currentLineIndex];
    },
    transformStyle() {
      return {
        transform: `translateY(${-this.currentLineIndex * 16}px)`,
        webkitTransform: `translateY(${-this.currentLineIndex * 16}px)`
      };
    }
  },
  methods: {
    applyLrc(lrc) {
      if (/^https?:\/\//.test(lrc)) {
        this.fetchLrc(lrc);
      } else {
        this.displayLrc = lrc;
      }
    },
    fetchLrc(src) {
      fetch(src).then((response) => response.text()).then((lrc) => {
        this.displayLrc = lrc;
      });
    },
    hideLrc() {
      this.displayLrc = "";
    }
  },
  watch: {
    currentMusic: {
      immediate: true,
      handler(music) {
        this.currentLineIndex = 0;
        if (music.lrc) {
          this.applyLrc(music.lrc);
        } else {
          this.hideLrc();
        }
      }
    },
    "playStat.playedTime"(playedTime) {
      for (let i3 = 0; i3 < this.lrcLines.length; i3++) {
        const line = this.lrcLines[i3];
        const nextLine = this.lrcLines[i3 + 1];
        if (playedTime >= line[0] && (!nextLine || playedTime < nextLine[0])) {
          this.currentLineIndex = i3;
        }
      }
    }
  }
};
const _hoisted_1$r = {
  class: "aplayer-lrc"
};
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$r, [createElementVNode(
    "div",
    {
      class: "aplayer-lrc-contents",
      style: normalizeStyle($options.transformStyle)
    },
    [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList($options.lrcLines, (line, index2) => {
        return openBlock(), createElementBlock(
          "p",
          {
            key: index2,
            class: normalizeClass({
              "aplayer-lrc-current": index2 === $data.currentLineIndex
            })
          },
          toDisplayString(line[1]),
          3
          /* TEXT, CLASS */
        );
      }),
      128
      /* KEYED_FRAGMENT */
    ))],
    4
    /* STYLE */
  )]);
}
const Lyrics = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$o], ["__file", "aplayer-lrc.vue"]]);
const vueAplayer_vue_vue_type_style_index_0_lang = "";
const picThemeCache = {};
let activeMutex = null;
const REPEAT = {
  NONE: "none",
  MUSIC: "music",
  LIST: "list",
  NO_REPEAT: "no-repeat",
  REPEAT_ONE: "repeat-one",
  REPEAT_ALL: "repeat-all"
};
const VueAPlayer = {
  name: "APlayer",
  disableVersionBadge: false,
  components: {
    Thumbnail,
    Controls,
    MusicList,
    Lyrics
  },
  props: {
    music: {
      type: Object,
      required: true,
      validator(song) {
        return !!song.src;
      }
    },
    mini: {
      type: Boolean,
      default: false
    },
    showLrc: {
      type: Boolean,
      default: false
    },
    mutex: {
      type: Boolean,
      default: true
    },
    theme: {
      type: String,
      default: "#41b883"
    },
    listMaxHeight: String,
    /**
     * @since 1.4.1
     * Fold playlist initially
     */
    listFolded: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.2.0 Float mode
     */
    float: {
      type: Boolean,
      default: false
    },
    // Audio attributes as props
    // since 1.4.0
    // autoplay controls muted preload volume
    // autoplay is not observable
    /**
     * @since 1.4.0
     * not observable
     */
    autoplay: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.4.0
     * whether to show native audio controls below Vue-APlayer
     * only work in development environment and not mini mode
     *
     * observable
     */
    controls: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.4.0
     * observable, sync
     */
    muted: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.4.0
     * observable
     */
    preload: String,
    /**
     * @since 1.4.0
     * observable, sync
     */
    volume: {
      type: Number,
      default: 0.8,
      validator(value) {
        return value >= 0 && value <= 1;
      }
    },
    // play order control
    // since 1.5.0
    /**
     * @since 1.5.0
     * @see https://support.apple.com/en-us/HT207230
     * twoWay
     */
    shuffle: {
      type: Boolean,
      default: false
    },
    /**
     * @since 1.5.0
     * @see https://support.apple.com/en-us/HT207230
     * twoWay
     */
    repeat: {
      type: String,
      default: REPEAT.NO_REPEAT
    }
  },
  data() {
    return {
      internalMusic: this.music,
      isPlaying: false,
      isSeeking: false,
      wasPlayingBeforeSeeking: false,
      isMobile: /mobile/i.test(window.navigator.userAgent),
      playStat: {
        duration: 0,
        loadedTime: 0,
        playedTime: 0
      },
      showList: !this.listFolded,
      list: [],
      // handle Promise returned from audio.play()
      // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play
      audioPlayPromise: Promise.resolve(),
      // @since 1.2.0 float mode
      floatOriginX: 0,
      floatOriginY: 0,
      floatOffsetLeft: 0,
      floatOffsetTop: 0,
      // @since 1.3.0 self adapting theme
      selfAdaptingTheme: null,
      // @since 1.4.0
      // sync muted, volume
      internalMuted: this.muted,
      internalVolume: this.volume,
      // @since 1.4.1
      // Loading indicator
      isLoading: false,
      // @since 1.5.1
      // sync shuffle, repeat
      internalShuffle: this.shuffle,
      internalRepeat: this.repeat,
      // for shuffling
      shuffledList: []
    };
  },
  computed: {
    // alias for $refs.audio
    audio() {
      return this.$refs.audio;
    },
    // sync music
    currentMusic: {
      get() {
        return this.internalMusic;
      },
      set(val) {
        this.$emit("update:music", val);
        this.internalMusic = val;
      }
    },
    // props wrappers
    currentTheme() {
      return this.selfAdaptingTheme || this.currentMusic.theme || this.theme;
    },
    isFloatMode() {
      return this.float && !this.isMobile;
    },
    shouldAutoplay() {
      if (this.isMobile)
        return false;
      return this.autoplay;
    },
    musicList() {
      return this.list;
    },
    shouldShowNativeControls() {
      return this.controls && !this.mini;
    },
    // useful
    floatStyleObj() {
      return {
        transform: `translate(${this.floatOffsetLeft}px, ${this.floatOffsetTop}px)`,
        webkitTransform: `translate(${this.floatOffsetLeft}px, ${this.floatOffsetTop}px)`
      };
    },
    currentPicStyleObj() {
      if (this.currentMusic && this.currentMusic.pic) {
        return {
          backgroundImage: `url(${this.currentMusic.pic})`
        };
      }
      return {};
    },
    loadProgress() {
      if (this.playStat.duration === 0)
        return 0;
      return this.playStat.loadedTime / this.playStat.duration;
    },
    playProgress() {
      if (this.playStat.duration === 0)
        return 0;
      return this.playStat.playedTime / this.playStat.duration;
    },
    playIndex: {
      get() {
        return this.shuffledList.indexOf(this.currentMusic);
      },
      set(val) {
        this.currentMusic = this.shuffledList[val % this.shuffledList.length];
      }
    },
    shouldRepeat() {
      return this.repeatMode !== REPEAT.NO_REPEAT;
    },
    // since 1.4.0
    // sync muted, volume
    isAudioMuted: {
      get() {
        return this.internalMuted;
      },
      set(val) {
        this.$emit("update:muted", val);
        this.internalMuted = val;
      }
    },
    audioVolume: {
      get() {
        return this.internalVolume;
      },
      set(val) {
        this.$emit("update:volume", val);
        this.internalVolume = val;
      }
    },
    // since 1.5.0
    // sync shuffle, repeat
    shouldShuffle: {
      get() {
        return this.internalShuffle;
      },
      set(val) {
        this.$emit("update:shuffle", val);
        this.internalShuffle = val;
      }
    },
    repeatMode: {
      get() {
        switch (this.internalRepeat) {
          case REPEAT.NONE:
          case REPEAT.NO_REPEAT:
            return REPEAT.NO_REPEAT;
          case REPEAT.MUSIC:
          case REPEAT.REPEAT_ONE:
            return REPEAT.REPEAT_ONE;
          default:
            return REPEAT.REPEAT_ALL;
        }
      },
      set(val) {
        this.$emit("update:repeat", val);
        this.internalRepeat = val;
      }
    }
  },
  methods: {
    // Float mode
    onDragBegin() {
      this.floatOriginX = this.floatOffsetLeft;
      this.floatOriginY = this.floatOffsetTop;
    },
    onDragAround({
      offsetLeft,
      offsetTop
    }) {
      this.floatOffsetLeft = this.floatOriginX + offsetLeft;
      this.floatOffsetTop = this.floatOriginY + offsetTop;
    },
    // functions
    setNextMode() {
      if (this.repeatMode === REPEAT.REPEAT_ALL) {
        this.repeatMode = REPEAT.REPEAT_ONE;
      } else if (this.repeatMode === REPEAT.REPEAT_ONE) {
        this.repeatMode = REPEAT.NO_REPEAT;
      } else {
        this.repeatMode = REPEAT.REPEAT_ALL;
      }
    },
    thenPlay() {
      this.$nextTick(() => {
        this.play();
      });
    },
    setAudioList(list) {
      this.list = list;
      this.shuffledList = this.getShuffledList();
      console.log(this.shuffledList);
    },
    // controls
    // play/pause
    toggle() {
      if (!this.audio.paused) {
        this.pause();
      } else {
        this.play();
      }
    },
    play() {
      if (this.mutex) {
        if (activeMutex && activeMutex !== this) {
          activeMutex.pause();
        }
        activeMutex = this;
      }
      const audioPlayPromise = this.audio.play();
      if (audioPlayPromise) {
        return this.audioPlayPromise = new Promise((resolve, reject) => {
          this.rejectPlayPromise = reject;
          audioPlayPromise.then((res) => {
            this.rejectPlayPromise = null;
            resolve(res);
          }).catch(warn);
        });
      }
    },
    pause() {
      this.audioPlayPromise.then(() => {
        this.audio.pause();
      }).catch(() => {
        this.audio.pause();
      });
      if (this.rejectPlayPromise) {
        this.rejectPlayPromise();
        this.rejectPlayPromise = null;
      }
    },
    // progress bar
    onProgressDragBegin(val) {
      this.wasPlayingBeforeSeeking = this.isPlaying;
      this.pause();
      this.isSeeking = true;
      if (!isNaN(this.audio.duration)) {
        this.audio.currentTime = this.audio.duration * val;
      }
    },
    onProgressDragging(val) {
      if (isNaN(this.audio.duration)) {
        this.playStat.playedTime = 0;
      } else {
        this.audio.currentTime = this.audio.duration * val;
      }
    },
    onProgressDragEnd(val) {
      this.isSeeking = false;
      if (this.wasPlayingBeforeSeeking) {
        this.thenPlay();
      }
    },
    // volume
    toggleMute() {
      this.setAudioMuted(!this.audio.muted);
    },
    setAudioMuted(val) {
      this.audio.muted = val;
    },
    setAudioVolume(val) {
      this.audio.volume = val;
      if (val > 0) {
        this.setAudioMuted(false);
      }
    },
    // playlist
    getShuffledList() {
      if (!this.list.length) {
        return [this.internalMusic];
      }
      let unshuffled = [...this.list];
      if (!this.internalShuffle || unshuffled.length <= 1) {
        return unshuffled;
      }
      let indexOfCurrentMusic = unshuffled.indexOf(this.internalMusic);
      if (unshuffled.length === 2 && indexOfCurrentMusic !== -1) {
        if (indexOfCurrentMusic === 0) {
          return unshuffled;
        } else {
          return [this.internalMusic, unshuffled[0]];
        }
      }
      for (let i3 = unshuffled.length - 1; i3 > 0; i3--) {
        const j2 = Math.floor(Math.random() * (i3 + 1));
        const tmp = unshuffled[i3];
        unshuffled[i3] = unshuffled[j2];
        unshuffled[j2] = tmp;
      }
      if (indexOfCurrentMusic !== -1) {
        indexOfCurrentMusic = unshuffled.indexOf(this.internalMusic);
        if (indexOfCurrentMusic !== 0) {
          [unshuffled[0], unshuffled[indexOfCurrentMusic]] = [unshuffled[indexOfCurrentMusic], unshuffled[0]];
        }
      }
      return unshuffled;
    },
    onSelectSong(song) {
      if (this.currentMusic === song) {
        this.toggle();
      } else {
        this.currentMusic = song;
        this.thenPlay();
      }
    },
    // event handlers
    // for keeping up with audio states
    onAudioPlay() {
      this.isPlaying = true;
    },
    onAudioPause() {
      this.isPlaying = false;
    },
    onAudioWaiting() {
      this.isLoading = true;
    },
    onAudioCanplay() {
      this.isLoading = false;
    },
    onAudioDurationChange() {
      if (this.audio.duration !== 1) {
        this.playStat.duration = this.audio.duration;
      }
    },
    onAudioProgress() {
      if (this.audio.buffered.length) {
        this.playStat.loadedTime = this.audio.buffered.end(this.audio.buffered.length - 1);
      } else {
        this.playStat.loadedTime = 0;
      }
    },
    onAudioTimeUpdate() {
      this.playStat.playedTime = this.audio.currentTime;
    },
    onAudioSeeking() {
      this.playStat.playedTime = this.audio.currentTime;
    },
    onAudioSeeked() {
      this.playStat.playedTime = this.audio.currentTime;
    },
    onAudioVolumeChange() {
      this.audioVolume = this.audio.volume;
      this.isAudioMuted = this.audio.muted;
    },
    onAudioEnded() {
      if (this.repeatMode === REPEAT.REPEAT_ALL) {
        if (this.shouldShuffle && this.playIndex === this.shuffledList.length - 1) {
          this.shuffledList = this.getShuffledList();
        }
        this.playIndex++;
        this.thenPlay();
      } else if (this.repeatMode === REPEAT.REPEAT_ONE) {
        this.thenPlay();
      } else {
        this.playIndex++;
        if (this.playIndex !== 0) {
          this.thenPlay();
        } else if (this.shuffledList.length === 1) {
          this.audio.currentTime = 0;
        }
      }
    },
    initAudio() {
      this.audio.controls = this.shouldShowNativeControls;
      this.audio.muted = this.muted;
      this.audio.preload = this.preload;
      this.audio.volume = this.volume;
      const mediaEvents = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "interruptbegin", "interruptend", "loadeddata", "loadedmetadata", "loadstart", "mozaudioavailable", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
      mediaEvents.forEach((event) => {
        this.audio.addEventListener(event, (e2) => this.$emit(event, e2));
      });
      this.audio.addEventListener("play", this.onAudioPlay);
      this.audio.addEventListener("pause", this.onAudioPause);
      this.audio.addEventListener("abort", this.onAudioPause);
      this.audio.addEventListener("waiting", this.onAudioWaiting);
      this.audio.addEventListener("canplay", this.onAudioCanplay);
      this.audio.addEventListener("progress", this.onAudioProgress);
      this.audio.addEventListener("durationchange", this.onAudioDurationChange);
      this.audio.addEventListener("seeking", this.onAudioSeeking);
      this.audio.addEventListener("seeked", this.onAudioSeeked);
      this.audio.addEventListener("timeupdate", this.onAudioTimeUpdate);
      this.audio.addEventListener("volumechange", this.onAudioVolumeChange);
      this.audio.addEventListener("ended", this.onAudioEnded);
      if (this.currentMusic) {
        this.audio.src = this.currentMusic.src;
      }
    },
    setSelfAdaptingTheme() {
      if ((this.currentMusic.theme || this.theme) === "pic") {
        const pic = this.currentMusic.pic;
        if (picThemeCache[pic]) {
          this.selfAdaptingTheme = picThemeCache[pic];
        } else {
          try {
            new ColorThief().getColorAsync(pic, ([r2, g2, b2]) => {
              picThemeCache[pic] = `rgb(${r2}, ${g2}, ${b2})`;
              this.selfAdaptingTheme = `rgb(${r2}, ${g2}, ${b2})`;
            });
          } catch (e2) {
            warn("color-thief is required to support self-adapting theme");
          }
        }
      } else {
        this.selfAdaptingTheme = null;
      }
    }
  },
  watch: {
    music(music) {
      this.internalMusic = music;
    },
    currentMusic: {
      handler(music) {
        this.setSelfAdaptingTheme();
        const src = music.src;
        if (/\.m3u8(?=(#|\?|$))/.test(src)) {
          if (this.audio.canPlayType("application/x-mpegURL") || this.audio.canPlayType("application/vnd.apple.mpegURL")) {
            this.audio.src = src;
          } else {
            try {
              const Hls = require("hls.js");
              if (Hls.isSupported()) {
                if (!this.hls) {
                  this.hls = new Hls();
                }
                this.hls.loadSource(src);
                this.hls.attachMedia(this.audio);
              } else {
                warn("HLS is not supported on your browser");
                this.audio.src = src;
              }
            } catch (e2) {
              warn("hls.js is required to support m3u8");
              this.audio.src = src;
            }
          }
        } else {
          this.audio.src = src;
        }
      }
    },
    // since 1.4.0
    // observe controls, muted, preload, volume
    shouldShowNativeControls(val) {
      this.audio.controls = val;
    },
    isAudioMuted(val) {
      this.audio.muted = val;
    },
    preload(val) {
      this.audio.preload = val;
    },
    audioVolume(val) {
      this.audio.volume = val;
    },
    // sync muted, volume
    muted(val) {
      this.internalMuted = val;
    },
    volume(val) {
      this.internalVolume = val;
    },
    // sync shuffle, repeat
    shuffle(val) {
      this.internalShuffle = val;
    },
    repeat(val) {
      this.internalRepeat = val;
    }
  },
  created() {
    this.shuffledList = this.getShuffledList();
  },
  mounted() {
    this.initAudio();
    this.setSelfAdaptingTheme();
    if (this.autoplay)
      this.play();
  },
  beforeUnmount() {
    if (activeMutex === this) {
      activeMutex = null;
    }
    if (this.hls) {
      this.hls.destroy();
    }
  }
};
const _sfc_main$v = VueAPlayer;
const _hoisted_1$q = {
  class: "aplayer-body"
};
const _hoisted_2$i = {
  class: "aplayer-info"
};
const _hoisted_3$g = {
  class: "aplayer-music"
};
const _hoisted_4$b = {
  class: "aplayer-title"
};
const _hoisted_5$8 = {
  class: "aplayer-author"
};
const _hoisted_6$7 = {
  ref: "audio"
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_thumbnail = resolveComponent("thumbnail");
  const _component_lyrics = resolveComponent("lyrics");
  const _component_controls = resolveComponent("controls");
  const _component_music_list = resolveComponent("music-list");
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["aplayer", {
        "aplayer-mini": _ctx.mini,
        "aplayer-withlist": !_ctx.mini && _ctx.musicList.length > 0,
        "aplayer-withlrc": !_ctx.mini && (!!_ctx.$slots.display || _ctx.showLrc),
        "aplayer-float": _ctx.isFloatMode,
        "aplayer-loading": _ctx.isPlaying && _ctx.isLoading
      }]),
      style: normalizeStyle(_ctx.floatStyleObj)
    },
    [createElementVNode("div", _hoisted_1$q, [createVNode(_component_thumbnail, {
      pic: _ctx.currentMusic.pic,
      playing: _ctx.isPlaying,
      "enable-drag": _ctx.isFloatMode,
      theme: _ctx.currentTheme,
      onToggleplay: _ctx.toggle,
      onDragbegin: _ctx.onDragBegin,
      onDragging: _ctx.onDragAround
    }, null, 8, ["pic", "playing", "enable-drag", "theme", "onToggleplay", "onDragbegin", "onDragging"]), withDirectives(createElementVNode(
      "div",
      _hoisted_2$i,
      [createElementVNode("div", _hoisted_3$g, [createElementVNode(
        "span",
        _hoisted_4$b,
        toDisplayString(_ctx.currentMusic.title || "Untitled"),
        1
        /* TEXT */
      ), createElementVNode(
        "span",
        _hoisted_5$8,
        toDisplayString(_ctx.currentMusic.artist || "Unknown"),
        1
        /* TEXT */
      )]), renderSlot(_ctx.$slots, "display", {
        currentMusic: _ctx.currentMusic,
        playStat: _ctx.playStat
      }, () => [_ctx.showLrc ? (openBlock(), createBlock(_component_lyrics, {
        key: 0,
        "current-music": _ctx.currentMusic,
        "play-stat": _ctx.playStat
      }, null, 8, ["current-music", "play-stat"])) : createCommentVNode("v-if", true)]), createVNode(_component_controls, {
        shuffle: _ctx.shouldShuffle,
        repeat: _ctx.repeatMode,
        stat: _ctx.playStat,
        volume: _ctx.audioVolume,
        muted: _ctx.isAudioMuted,
        theme: _ctx.currentTheme,
        onToggleshuffle: _cache[0] || (_cache[0] = ($event) => _ctx.shouldShuffle = !_ctx.shouldShuffle),
        onTogglelist: _cache[1] || (_cache[1] = ($event) => _ctx.showList = !_ctx.showList),
        onTogglemute: _ctx.toggleMute,
        onSetvolume: _ctx.setAudioVolume,
        onDragbegin: _ctx.onProgressDragBegin,
        onDragend: _ctx.onProgressDragEnd,
        onDragging: _ctx.onProgressDragging,
        onNextmode: _ctx.setNextMode
      }, null, 8, ["shuffle", "repeat", "stat", "volume", "muted", "theme", "onTogglemute", "onSetvolume", "onDragbegin", "onDragend", "onDragging", "onNextmode"])],
      512
      /* NEED_PATCH */
    ), [[vShow, !_ctx.mini]])]), createElementVNode(
      "audio",
      _hoisted_6$7,
      null,
      512
      /* NEED_PATCH */
    ), createVNode(_component_music_list, {
      show: _ctx.showList && !_ctx.mini,
      "current-music": _ctx.currentMusic,
      "music-list": _ctx.musicList,
      "play-index": _ctx.playIndex,
      listmaxheight: _ctx.listMaxHeight,
      theme: _ctx.currentTheme,
      onSelectsong: _ctx.onSelectSong
    }, null, 8, ["show", "current-music", "music-list", "play-index", "listmaxheight", "theme", "onSelectsong"])],
    6
    /* CLASS, STYLE */
  );
}
const APlayer = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$n], ["__file", "vue-aplayer.vue"]]);
const clientConfig17 = defineClientConfig({
  enhance: async ({
    app
  }) => {
    if (typeof window !== "undefined") {
      localStorage.setItem("aplayer-setting", "[]");
      app.component("APlayer", APlayer);
    }
    app.component("Meting", Meting);
    app.component("MetingGlobal", MetingGlobal);
  },
  rootComponents: void 0
});
const volume = {
  data() {
    return {
      volumeKey: "reco-bgm-volume"
    };
  },
  methods: {
    setVolume(val) {
      sessionStorage.setItem(this.volumeKey, val);
    },
    getVolume() {
      return sessionStorage.getItem(this.volumeKey);
    },
    removeVolume() {
      sessionStorage.removeItem(this.volumeKey);
    }
  }
};
const _sfc_main$u = {
  name: "ModuleTransition",
  props: {
    delay: {
      type: String,
      default: "0"
    },
    duration: {
      type: String,
      default: ".25"
    },
    position: {
      type: String,
      default: "left"
    }
  },
  methods: {
    setStyle(items) {
      items.style.transition = `${this.duration}s ease-in-out ${this.delay}s`;
      items.style.transitionProperty = "all";
      items.style.transform = this.position === "right" ? "translateX(20px)" : "translateX(-20px)";
      items.style.opacity = 0;
    },
    unsetStyle(items) {
      items.style.transform = null, items.style.transitionProperty = "opacity";
      items.style.opacity = 1;
    }
  }
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "ModuleTransition",
    onEnter: $options.setStyle,
    onAfterEnter: $options.unsetStyle,
    onBeforeLeave: $options.setStyle,
    onAfterLeave: _ctx.unsetTransform
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
    /* FORWARDED */
  }, 8, ["onEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]);
}
const ModuleTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$m], ["__file", "ModuleTransition.vue"]]);
const BgMusic_vue_vue_type_style_index_0_scoped_355e2f24_lang = "";
const mapFunc = (obj) => ({
  name: obj.name || obj.title || "未知歌曲",
  artist: obj.artist || obj.author || "未知歌手",
  url: obj.url || obj.src,
  cover: obj.pic,
  lrc: obj.lrc || obj.lyric || ""
});
function resolveAudios(requiredAudio) {
  let files2 = null;
  let covers = null;
  const syn = [], asyn = [];
  for (const e2 of requiredAudio) {
    if (!("type" in e2)) {
      syn.push(e2);
      continue;
    }
    switch (e2.type) {
      case "dir": {
        if (!files2)
          files2 = /* @__PURE__ */ Object.assign({
            "../../../public/music/「Fontaine」ost-13 - HOYO-MiX.mp3": __vite_glob_0_0$2,
            "../../../public/music/「Fontaine」ost-2 - HOYO-MiX.mp3": __vite_glob_0_1$2,
            "../../../public/music/「Fontaine」ost-20 - HOYO-MiX.mp3": __vite_glob_0_2$2,
            "../../../public/music/「Fontaine」ost-22 - HOYO-MiX.mp3": __vite_glob_0_3$2,
            "../../../public/music/「Fontaine」ost-23 - HOYO-MiX.mp3": __vite_glob_0_4$2,
            "../../../public/music/「Fontaine」ost-31 - HOYO-MiX.mp3": __vite_glob_0_5$2,
            "../../../public/music/「Fontaine」ost-55 - HOYO-MiX.mp3": __vite_glob_0_6$2,
            "../../../public/music/「Fontaine」ost-64 - HOYO-MiX.mp3": __vite_glob_0_7$2
          });
        if (!covers)
          covers = /* @__PURE__ */ Object.assign({});
        syn.push(...Object.keys(files2).map((m2) => {
          const reg = new RegExp(`.*public(${e2.url}(.+?)( - (.+))?\\.mp3)`);
          const match = m2.match(reg);
          const coverUrl = m2.replace(".mp3", ".png");
          return {
            name: match[2] ?? "未知歌曲",
            artist: match[4] ?? "未知歌手",
            url: match[1],
            cover: coverUrl in covers ? coverUrl : "/images/avatar.png"
          };
        }));
        break;
      }
      case "remote": {
        const params = {
          server: e2.from,
          type: "playlist",
          id: e2.mid,
          r: Math.random()
        };
        let url = e2.api, paramsArr = [];
        Object.keys(params).forEach((key) => paramsArr.push(key + "=" + params[key]));
        url += "?" + paramsArr.join("&");
        const headers = {
          referer: null
        };
        const prom = fetch(url, {
          headers
        }).then((res) => res.json()).then((result) => {
          console.log(url, result);
          const mapped = result.map(mapFunc);
          return mapped;
        });
        asyn.push(prom);
        break;
      }
    }
  }
  return {
    audios: syn,
    asyncAudios: asyn
  };
}
const _sfc_main$t = {
  mixins: [volume],
  components: {
    ModuleTransition
  },
  data() {
    return {
      /** @type {string} */
      defaultCover: "/images/avatar.png",
      /** @type {import("../index").PositionOptions} */
      panelPosition: {
        "right": "10px",
        "bottom": "10px",
        "z-index": "40"
      },
      curIndex: 0,
      curPlayStatus: "paused",
      /** @type {Audio[]} */
      audiolist: [{
        name: "音乐加载中..",
        artist: "",
        url: "",
        cover: ""
      }],
      /** @type {boolean} */
      autoplay: false,
      /** @type {boolean} */
      draggable: true,
      isFloat: false,
      isMini: false,
      firstLoad: true,
      isMute: false,
      isFault: false,
      /** @type {"left" | "right"} */
      floatPosition: "right",
      /** @type {import("vue").StyleValue} */
      floatStyle: {
        "bottom": "200px",
        "z-index": "40"
      },
      /** @type {boolean} */
      autoShrink: false,
      /** @type {"mini" | "float"} */
      shrinkMode: "float",
      initPos: true,
      dragging: false,
      align: {
        x: "left",
        y: "bottom"
      },
      // 记录播放器的对齐状态
      oMouse: null,
      orgX: 0,
      orgY: 0,
      posX: 0,
      posY: 0
    };
  },
  created() {
    const {
      audios,
      asyncAudios
    } = resolveAudios([{
      "type": "remote",
      "api": "https://api.i-meto.com/meting/api",
      "from": "netease",
      "mid": "8785212327"
    }]);
    let inited = false;
    if (audios && audios.length) {
      this.audiolist = audios;
      inited = true;
    }
    Promise.all(asyncAudios).then((res) => {
      if (!inited) {
        this.audiolist = [];
        inited = true;
      }
      this.audiolist.push(...res.flat());
    });
    const {
      right,
      top
    } = this.panelPosition;
    right && (this.align.x = "right");
    top && (this.align.y = "top");
  },
  computed: {
    rotate() {
      return this.curPlayStatus === "playing" ? "rotate" : "";
    },
    panelPos() {
      const {
        x: alignX,
        y: alignY
      } = this.align;
      return this.initPos ? this.panelPosition : {
        left: alignX === "left" ? `${this.posX}px` : null,
        right: alignX === "right" ? `${this.posX}px` : null,
        top: alignY === "top" ? `${this.posY}px` : null,
        bottom: alignY === "bottom" ? `${this.posY}px` : null,
        "z-index": this.panelPosition["z-index"]
      };
    }
  },
  mounted() {
    if (this.floatPosition === "left") {
      this.floatStyle = {
        ...this.floatStyle,
        "left": "0",
        "border-top-right-radius": "20px",
        "border-bottom-right-radius": "20px"
      };
    } else {
      this.floatStyle = {
        ...this.floatStyle,
        "right": "0",
        "border-top-left-radius": "20px",
        "border-bottom-left-radius": "20px"
      };
    }
    this.isMini = this.isMobile();
    if (this.autoShrink)
      this.toggleMode(true);
    let {
      left,
      right,
      top,
      bottom
    } = this.$refs.bgmBox.style;
    [left, right, top, bottom] = [left, right, top, bottom].map((e2) => e2 ? parseInt(e2.match(/\d+/)[0]) : 0);
    this.posX = this.align.x === "left" ? left : right;
    this.posY = this.align.y === "top" ? top : bottom;
    this.initPos = false;
  },
  methods: {
    /** @param { MouseEvent } oe */
    onDragBegin(oe2) {
      if (!this.draggable)
        return;
      [this.orgX, this.orgY] = [this.posX, this.posY];
      this.oMouse = oe2;
      document.addEventListener("mousemove", this.onDragAround);
      document.addEventListener("mouseup", this.onDragEnd);
    },
    /** @param { MouseEvent } e */
    onDragAround(e2) {
      const {
        innerWidth: winW,
        innerHeight: winH
      } = window;
      const {
        offsetWidth: objW,
        offsetHeight: objH
      } = this.$refs.bgmBox;
      const {
        min: min2,
        max: max2
      } = Math;
      this.dragging = true;
      let dx = e2.clientX - this.oMouse.clientX;
      let dy = e2.clientY - this.oMouse.clientY;
      this.align.x === "right" && (dx = -dx);
      this.align.y === "bottom" && (dy = -dy);
      this.posX = max2(0, min2(this.orgX + dx, winW - objW));
      this.posY = max2(0, min2(this.orgY + dy, winH - objH));
    },
    onDragEnd() {
      this.dragging = false;
      document.removeEventListener("mousemove", this.onDragAround);
      document.removeEventListener("mouseup", this.onDragEnd);
    },
    isMobile() {
      return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    },
    // 显示或隐藏歌曲信息
    toggleMode(bool) {
      const isMobile2 = this.isMobile();
      if (isMobile2 || this.shrinkMode === "float") {
        this.isFloat = bool;
      } else if (!isMobile2 && this.shrinkMode === "mini") {
        this.isMini = bool;
      }
    },
    // audio canplay回调事件
    playReady() {
      if (this.firstLoad) {
        if (this.getVolume()) {
          const percent = this.getVolume();
          this.$refs.vbar.style.width = percent * 100 + "%";
          this.$refs.bgm.volume = percent;
        } else {
          const vbar_width = this.$refs.bgm.volume * 100 + "%";
          this.$refs.vbar.style.width = vbar_width;
        }
        this.firstLoad = false;
        if (this.autoplay) {
          this.tryAutoPlay();
        }
      }
      if (this.curPlayStatus === "playing") {
        this.playBgm();
      }
    },
    tryAutoPlay() {
      let tryCount = 0;
      const playPromise = this.$refs.bgm.play();
      if (!playPromise)
        return;
      const tryPlay = async () => {
        try {
          await playPromise;
          console.log("bgm-player: 自动播放成功");
          this.curPlayStatus = "playing";
        } catch (e2) {
          console.log("bgm-player: 自动播放失败，尝试第", ++tryCount, "次");
          const handleClick = () => {
            this.playBgm();
            window.removeEventListener("click", handleClick);
          };
          tryCount < 3 ? setTimeout(tryPlay, 1e3) : window.addEventListener("click", handleClick);
        }
      };
      tryPlay();
    },
    // 暂停
    pauseBgm() {
      this.$refs.bgm.pause();
      this.curPlayStatus = "paused";
    },
    // 播放
    playBgm() {
      const playPromise = this.$refs.bgm.play();
      if (playPromise !== void 0) {
        playPromise.then((res) => {
          if (this.isFault) {
            this.isFault = false;
          }
          this.curPlayStatus = "playing";
        }).catch((err2) => {
          console.log(err2);
          this.isFault = true;
          this.pauseBgm();
        });
      }
    },
    // 播放下一首
    playNext() {
      this.$refs.pbar.style.width = 0;
      this.isFault = false;
      if (this.curIndex >= this.audiolist.length - 1) {
        this.curIndex = 0;
      } else {
        this.curIndex++;
      }
    },
    // 播放上一首
    playLast() {
      this.$refs.pbar.style.width = 0;
      this.isFault = false;
      if (this.curIndex <= 0) {
        this.curIndex = this.audiolist.length - 1;
      } else {
        this.curIndex--;
      }
    },
    // bgm结束时自动下一首
    bgmEnded() {
      this.$refs.pbar.style.width = 0;
      this.playNext();
    },
    // 更新歌曲进度条
    timeUpdate() {
      const total_time = this.$refs.bgm.duration;
      const cur_time = this.$refs.bgm.currentTime;
      const bar_width = cur_time / total_time * 100 + "%";
      this.$refs.pbar.style.width = bar_width;
    },
    // 点击进度条跳播
    progressJump(e2) {
      const total_time = this.$refs.bgm.duration;
      const percent = e2.offsetX / 150;
      if (isNaN(total_time))
        return;
      this.$refs.bgm.currentTime = percent * total_time;
    },
    // 点击音量条修改音量
    volumeJump(e2) {
      const percent = e2.offsetX / 57;
      if (percent >= 0 && percent <= 1) {
        this.isMute = !(percent > 0);
        this.$refs.vbar.style.width = percent * 100 + "%";
        this.$refs.bgm.volume = percent;
        this.setVolume(this.$refs.bgm.volume);
      }
    },
    // 静音
    muteBgm() {
      this.isMute = true;
      this.setVolume(this.$refs.bgm.volume);
      this.$refs.vbar.style.width = 0;
      this.$refs.bgm.volume = 0;
    },
    // 取消静音
    unMuteBgm() {
      this.isMute = false;
      if (this.getVolume()) {
        const percent = this.getVolume();
        this.$refs.vbar.style.width = percent * 100 + "%";
        this.$refs.bgm.volume = percent;
      } else {
        this.$refs.vbar.style.width = "100%";
        this.$refs.bgm.volume = 1;
      }
    }
  }
};
const _withScopeId$4 = (n2) => (pushScopeId("data-v-355e2f24"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$p = {
  class: "reco-bgm-panel"
};
const _hoisted_2$h = ["src"];
const _hoisted_3$f = ["src"];
const _hoisted_4$a = {
  key: 0,
  class: "mini-operation"
};
const _hoisted_5$7 = {
  key: 1,
  class: "falut-message"
};
const _hoisted_6$6 = {
  class: "reco-bgm-info"
};
const _hoisted_7$5 = {
  class: "info-box"
};
const _hoisted_8$4 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "reco-bgm reco-bgm-music music"
  },
  null,
  -1
  /* HOISTED */
));
const _hoisted_9$4 = {
  class: "info-box"
};
const _hoisted_10$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "reco-bgm reco-bgm-artist"
  },
  null,
  -1
  /* HOISTED */
));
const _hoisted_11$3 = {
  class: "reco-bgm-progress"
};
const _hoisted_12$1 = {
  class: "bar",
  ref: "pbar"
};
const _hoisted_13$1 = {
  class: "reco-bgm-operation"
};
const _hoisted_14$1 = {
  class: "bar",
  ref: "vbar"
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_module_transition = resolveComponent("module-transition");
  return openBlock(), createElementBlock("div", _hoisted_1$p, [createCommentVNode(" 播放器 "), createElementVNode("audio", {
    id: "bgm",
    src: $data.audiolist[$data.curIndex].url,
    ref: "bgm",
    onEnded: _cache[0] || (_cache[0] = (...args) => $options.bgmEnded && $options.bgmEnded(...args)),
    onCanplay: _cache[1] || (_cache[1] = (...args) => $options.playReady && $options.playReady(...args)),
    onTimeupdate: _cache[2] || (_cache[2] = (...args) => $options.timeUpdate && $options.timeUpdate(...args))
  }, null, 40, _hoisted_2$h), createVNode(_component_module_transition, {
    position: $data.floatPosition
  }, {
    default: withCtx(() => [withDirectives(createElementVNode(
      "div",
      {
        onClick: _cache[3] || (_cache[3] = ($event) => $options.toggleMode(false)),
        class: "reco-float-box",
        style: normalizeStyle($data.floatStyle)
      },
      [createElementVNode("img", {
        class: normalizeClass($options.rotate),
        src: $data.audiolist[$data.curIndex].cover ?? $data.defaultCover
      }, null, 10, _hoisted_3$f)],
      4
      /* STYLE */
    ), [[vShow, $data.isFloat]])]),
    _: 1
    /* STABLE */
  }, 8, ["position"]), createVNode(_component_module_transition, {
    position: $data.align.x
  }, {
    default: withCtx(() => [withDirectives(createElementVNode(
      "div",
      {
        ref: "bgmBox",
        class: "reco-bgm-box",
        style: normalizeStyle($options.panelPos),
        onMousedown: _cache[16] || (_cache[16] = (...args) => $options.onDragBegin && $options.onDragBegin(...args))
      },
      [createCommentVNode(" 封面 "), createElementVNode(
        "div",
        {
          class: normalizeClass(["reco-bgm-cover", $options.rotate]),
          onClick: _cache[6] || (_cache[6] = ($event) => $options.toggleMode(false)),
          style: normalizeStyle(`background-image:url(${$data.audiolist[$data.curIndex].cover ?? $data.defaultCover})`)
        },
        [createCommentVNode(" mini操作栏 "), $data.isMini ? (openBlock(), createElementBlock("div", _hoisted_4$a, [$data.curPlayStatus === "playing" ? (openBlock(), createElementBlock("i", {
          key: 0,
          onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $options.pauseBgm && $options.pauseBgm(...args), ["stop"])),
          class: "reco-bgm reco-bgm-pause clickable"
        })) : $data.curPlayStatus === "paused" ? (openBlock(), createElementBlock("i", {
          key: 1,
          onClick: _cache[5] || (_cache[5] = withModifiers((...args) => $options.playBgm && $options.playBgm(...args), ["stop"])),
          class: "reco-bgm reco-bgm-play clickable"
        })) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true), createCommentVNode(" 错误信息显示 "), $data.isFault ? (openBlock(), createElementBlock("div", _hoisted_5$7, " 播放失败 ")) : createCommentVNode("v-if", true)],
        6
        /* CLASS, STYLE */
      ), createCommentVNode(' <module-transition duration=".15"> '), createCommentVNode(" 歌曲信息栏 "), withDirectives(createElementVNode(
        "div",
        _hoisted_6$6,
        [createCommentVNode(" 歌曲名 "), createElementVNode("div", _hoisted_7$5, [_hoisted_8$4, createTextVNode(
          " " + toDisplayString($data.audiolist[$data.curIndex].name),
          1
          /* TEXT */
        )]), createCommentVNode(" 艺术家名 "), createElementVNode("div", _hoisted_9$4, [_hoisted_10$3, createTextVNode(
          " " + toDisplayString($data.audiolist[$data.curIndex].artist),
          1
          /* TEXT */
        )]), createCommentVNode(" 歌曲进度条 "), createElementVNode("div", _hoisted_11$3, [createElementVNode("div", {
          class: "progress-bar clickable bar",
          onClick: _cache[7] || (_cache[7] = (...args) => $options.progressJump && $options.progressJump(...args))
        }, [createElementVNode(
          "div",
          _hoisted_12$1,
          null,
          512
          /* NEED_PATCH */
        )])]), createCommentVNode(" 歌曲操作栏 "), createElementVNode("div", _hoisted_13$1, [createElementVNode("i", {
          class: "reco-bgm reco-bgm-last last clickable",
          onClick: _cache[8] || (_cache[8] = (...args) => $options.playLast && $options.playLast(...args))
        }), $data.curPlayStatus === "playing" ? (openBlock(), createElementBlock("i", {
          key: 0,
          onClick: _cache[9] || (_cache[9] = (...args) => $options.pauseBgm && $options.pauseBgm(...args)),
          class: "reco-bgm reco-bgm-pause pause clickable"
        })) : $data.curPlayStatus === "paused" ? (openBlock(), createElementBlock(
          "i",
          {
            key: 1,
            ref: "play",
            onClick: _cache[10] || (_cache[10] = (...args) => $options.playBgm && $options.playBgm(...args)),
            class: "reco-bgm reco-bgm-play play clickable"
          },
          null,
          512
          /* NEED_PATCH */
        )) : createCommentVNode("v-if", true), createElementVNode("i", {
          class: "reco-bgm reco-bgm-next next clickable",
          onClick: _cache[11] || (_cache[11] = (...args) => $options.playNext && $options.playNext(...args))
        }), $data.isMute ? (openBlock(), createElementBlock("i", {
          key: 2,
          onClick: _cache[12] || (_cache[12] = (...args) => $options.unMuteBgm && $options.unMuteBgm(...args)),
          class: "reco-bgm reco-bgm-mute mute clickable"
        })) : (openBlock(), createElementBlock("i", {
          key: 3,
          onClick: _cache[13] || (_cache[13] = (...args) => $options.muteBgm && $options.muteBgm(...args)),
          class: "reco-bgm reco-bgm-volume1 volume clickable"
        })), createElementVNode("div", {
          class: "volume-bar clickable bar",
          onClick: _cache[14] || (_cache[14] = (...args) => $options.volumeJump && $options.volumeJump(...args))
        }, [createElementVNode(
          "div",
          _hoisted_14$1,
          null,
          512
          /* NEED_PATCH */
        )])])],
        512
        /* NEED_PATCH */
      ), [[vShow, !$data.isMini]]), createCommentVNode(" </module-transition> "), createCommentVNode(" 收起按钮 "), createCommentVNode(' <module-transition duration=".15"> '), !$data.isMini ? (openBlock(), createElementBlock("div", {
        key: 0,
        onClick: _cache[15] || (_cache[15] = ($event) => $options.toggleMode(true)),
        class: "reco-bgm-left-box"
      }, [createElementVNode(
        "i",
        {
          class: normalizeClass(["reco-bgm", `reco-bgm-${$data.align.x}`])
        },
        null,
        2
        /* CLASS */
      )])) : createCommentVNode("v-if", true), createCommentVNode(" </module-transition> ")],
      36
      /* STYLE, HYDRATE_EVENTS */
    ), [[vShow, !$data.isFloat]])]),
    _: 1
    /* STABLE */
  }, 8, ["position"])]);
}
const BgMusic = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$l], ["__scopeId", "data-v-355e2f24"], ["__file", "BgMusic.vue"]]);
const clientConfig18 = defineClientConfig({
  enhance: async ({
    app
  }) => {
    app.component("BgMusic", BgMusic);
  },
  rootComponents: [BgMusic]
});
const _hoisted_1$o = {
  key: 0,
  class: "xicon-container"
};
const _hoisted_2$g = ["src"];
const _hoisted_3$e = {
  class: "info"
};
const _hoisted_4$9 = {
  key: 0,
  class: "location",
  n: ""
};
const _hoisted_5$6 = /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "fas fa-map-marker-alt"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_6$5 = {
  key: 1,
  class: "date"
};
const _hoisted_7$4 = /* @__PURE__ */ createElementVNode(
  "i",
  {
    class: "fas fa-clock"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_8$3 = {
  class: "description"
};
const _hoisted_9$3 = {
  key: 0,
  class: "album-info"
};
const _hoisted_10$2 = {
  class: "title"
};
const _hoisted_11$2 = {
  class: "descrption"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "Container",
  props: {
    id: {
      required: true,
      type: String
    },
    src: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: "photo",
      validate: (val) => ["album", "photo"].includes(val)
    },
    title: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    date: {
      type: Date,
      default: null
    },
    location: {
      type: String,
      default: ""
    }
  },
  emits: ["click"],
  setup(__props, {
    emit
  }) {
    const mask = ref(false);
    const loading = ref(true);
    const error = ref(false);
    return (_ctx, _cache) => {
      const _component_xicons = resolveComponent("xicons");
      const _component_MagicCard = resolveComponent("MagicCard");
      return openBlock(), createBlock(_component_MagicCard, {
        class: normalizeClass(["photo-container", {
          photo: __props.type === "photo",
          album: __props.type === "album"
        }]),
        onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click", __props.id))
      }, {
        default: withCtx(() => [createElementVNode(
          "div",
          {
            class: normalizeClass(["photo-img", {
              empty: !__props.src || error.value,
              loading: loading.value
            }]),
            onMouseenter: _cache[3] || (_cache[3] = ($event) => mask.value = true)
          },
          [!__props.src || error.value ? (openBlock(), createElementBlock("div", _hoisted_1$o, [createVNode(_component_xicons, {
            icon: "NoImage"
          })])) : (openBlock(), createElementBlock("img", {
            key: 1,
            src: __props.src,
            onLoad: _cache[0] || (_cache[0] = ($event) => loading.value = false),
            onError: _cache[1] || (_cache[1] = ($event) => error.value = true)
          }, null, 40, _hoisted_2$g)), __props.type === "photo" && true ? (openBlock(), createElementBlock(
            "div",
            {
              key: 2,
              class: "photo-mask",
              onMouseleave: _cache[2] || (_cache[2] = ($event) => mask.value = false)
            },
            [createElementVNode("div", _hoisted_3$e, [createElementVNode(
              "h3",
              null,
              toDisplayString(__props.title),
              1
              /* TEXT */
            ), createElementVNode("div", null, [createElementVNode("p", null, [__props.location ? (openBlock(), createElementBlock("span", _hoisted_4$9, [_hoisted_5$6, createTextVNode(
              " " + toDisplayString(__props.location),
              1
              /* TEXT */
            )])) : createCommentVNode("v-if", true), __props.date ? (openBlock(), createElementBlock("span", _hoisted_6$5, [_hoisted_7$4, createTextVNode(
              toDisplayString(__props.date),
              1
              /* TEXT */
            )])) : createCommentVNode("v-if", true)]), createElementVNode(
              "p",
              _hoisted_8$3,
              toDisplayString(__props.description),
              1
              /* TEXT */
            )])])],
            32
            /* HYDRATE_EVENTS */
          )) : createCommentVNode("v-if", true)],
          34
          /* CLASS, HYDRATE_EVENTS */
        ), __props.type === "album" ? (openBlock(), createElementBlock("div", _hoisted_9$3, [createElementVNode(
          "div",
          _hoisted_10$2,
          toDisplayString(__props.title),
          1
          /* TEXT */
        ), createElementVNode(
          "div",
          _hoisted_11$2,
          toDisplayString(__props.description),
          1
          /* TEXT */
        )])) : createCommentVNode("v-if", true)]),
        _: 1
        /* STABLE */
      }, 8, ["class"]);
    };
  }
});
const Container_vue_vue_type_style_index_0_lang = "";
const Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "Container.vue"]]);
const __vite_glob_0_0 = "/assets/2019-3-0484df66.png";
const __vite_glob_0_1 = "/assets/2020-1-4f259201.png";
const __vite_glob_0_2 = "/assets/Bkg2-3510cccd.gif";
const __vite_glob_0_3 = "/assets/MY48-3-af6b9a12.png";
const __vite_glob_0_4 = "/assets/MY52-2-f114818d.png";
const __vite_glob_0_5 = "/assets/MY52-5-2a42a6ce.png";
const __vite_glob_0_6 = "/assets/MY57-a320017b.png";
const __vite_glob_0_7 = "/assets/psb (1)-311f9601.png";
const __vite_glob_0_8 = "/assets/psb (2)-f056bd30.png";
const __vite_glob_0_9 = "/assets/psb-f51096b0.png";
const __vite_glob_0_10 = "/assets/MY55-4-4d03b147.png";
const __vite_glob_0_11 = "/assets/MY55-40be5c3f.png";
const __vite_glob_0_12 = "/assets/MY56-3-e5ead1a6.png";
const __vite_glob_0_13 = "/assets/MY56-4-3ee9222d.png";
const __vite_glob_0_14 = "/assets/MY56-5-11809f65.png";
const __vite_glob_0_15 = "/assets/MY59-6-55e96185.png";
const _sfc_main$r = {
  name: "PhotoPage",
  props: {
    id: {
      type: String
    },
    albumId: {
      type: String,
      required: true
    },
    photoMap: {
      type: Object,
      required: true
    }
  },
  emits: {
    back: () => true
  },
  computed: {
    curId() {
      const {
        fileName
      } = this.$route.params;
      return fileName && [this.albumId, fileName].join(":") || this.id;
    },
    fileName() {
      return this.curId.split(":")[1];
    },
    src() {
      return this.photoMap[this.curId];
    }
  },
  created() {
  },
  setup() {
    const pageMap2 = usePageMap();
    return {
      pageMap: pageMap2
    };
  }
};
const _hoisted_1$n = {
  class: "photo-page-wrapper"
};
const _hoisted_2$f = ["src"];
const _hoisted_3$d = {
  key: 1
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  var _a3;
  const _component_Content = resolveComponent("Content");
  return openBlock(), createElementBlock("div", _hoisted_1$n, [createElementVNode("img", {
    width: "400",
    height: "300",
    src: $options.src
  }, null, 8, _hoisted_2$f), createCommentVNode(" 相片所对应的md文件的内容 "), ((_a3 = $setup.pageMap[$options.curId]) == null ? void 0 : _a3.key) ? (openBlock(), createBlock(_component_Content, {
    key: 0,
    "page-key": $setup.pageMap[$options.curId].key
  }, null, 8, ["page-key"])) : (openBlock(), createElementBlock("div", _hoisted_3$d, "该相片暂无正文"))]);
}
const PhotoPage = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$k], ["__file", "PhotoPage.vue"]]);
const localPhotos = /* @__PURE__ */ Object.assign({
  "../../public/images/albums/test_album_1/2019-3.png": __vite_glob_0_0,
  "../../public/images/albums/test_album_1/2020-1.png": __vite_glob_0_1,
  "../../public/images/albums/test_album_1/Bkg2.gif": __vite_glob_0_2,
  "../../public/images/albums/test_album_1/MY48-3.png": __vite_glob_0_3,
  "../../public/images/albums/test_album_1/MY52-2.png": __vite_glob_0_4,
  "../../public/images/albums/test_album_1/MY52-5.png": __vite_glob_0_5,
  "../../public/images/albums/test_album_1/MY57.png": __vite_glob_0_6,
  "../../public/images/albums/test_album_1/psb (1).png": __vite_glob_0_7,
  "../../public/images/albums/test_album_1/psb (2).png": __vite_glob_0_8,
  "../../public/images/albums/test_album_1/psb.png": __vite_glob_0_9,
  "../../public/images/albums/test_album_2/MY55-4.png": __vite_glob_0_10,
  "../../public/images/albums/test_album_2/MY55.png": __vite_glob_0_11,
  "../../public/images/albums/test_album_2/MY56-3.png": __vite_glob_0_12,
  "../../public/images/albums/test_album_2/MY56-4.png": __vite_glob_0_13,
  "../../public/images/albums/test_album_2/MY56-5.png": __vite_glob_0_14,
  "../../public/images/albums/test_album_2/MY59-6.png": __vite_glob_0_15
});
Object.values(localPhotos);
const localPhotoMap = {};
for (const relPath in localPhotos) {
  const match = ((_a2 = relPath.match(/^.*images(.*)/)) == null ? void 0 : _a2[1]) ?? null;
  if (!match)
    continue;
  localPhotoMap[match] = localPhotos[relPath];
}
const usePhotoMap = () => localPhotoMap;
const useAlbumPhotosMap = (id) => {
  var _a3;
  const map = {};
  for (const relPath in localPhotos) {
    const match = ((_a3 = relPath.match(new RegExp(`^.*images/albums/${id}/(.*)`))) == null ? void 0 : _a3[1]) ?? null;
    if (!match)
      continue;
    const photoId = [id, match].join(":");
    map[photoId] = localPhotos[relPath];
  }
  return map;
};
const siteData = useSiteData();
const albums = computed(() => {
  const pageMap2 = siteData.value.pageIdMap;
  const entries2 = Object.entries(pageMap2).filter(([id, pageData]) => id !== "albums" && !id.includes(":") && pageData.path.startsWith("/albums/"));
  return Object.fromEntries(entries2);
});
const useAlbums = () => albums;
const addPhotoRoutes = (router) => {
  const routes = router.getRoutes();
  const prohibited = [];
  for (const id in albums.value) {
    const pageData = albums.value[id];
    if (pageData.path == "/albums/")
      continue;
    const route = routes.find((e2) => e2.name === albums.value[id].key);
    if (!route || !route.name)
      continue;
    if (pageData.path === `/albums/${id}/`) {
      const photoPage = () => h$5(PhotoPage, {
        albumId: id,
        photoMap: useAlbumPhotosMap(id)
      });
      photoPage.displayName = "PhotoPage";
      router.removeRoute(route.name);
      route.children.push({
        path: ":fileName",
        component: photoPage
      });
      router.addRoute(route);
      router.replace(router.currentRoute.value.fullPath);
      const childRoutes = routes.filter((r2) => r2.path !== route.path && r2.path.startsWith(route.path));
      for (const childRoute of childRoutes) {
        const {
          path
        } = childRoute;
        const allowed = ["README.md", "index.html"];
        if (allowed.some((e2) => path.endsWith(e2)))
          continue;
        prohibited.push(path);
      }
    }
  }
  router.beforeEach((to, from, next) => {
    if (prohibited.includes(to.fullPath)) {
      next({
        path: "/404"
      });
    } else
      next();
  });
};
const _sfc_main$q = {
  components: {
    Container
  },
  setup() {
    const pageMap2 = usePageMap();
    const albums2 = useAlbums();
    const photoMap = usePhotoMap();
    return {
      pageMap: pageMap2,
      albums: albums2,
      photoMap
    };
  },
  methods: {
    getAbsUrl(album) {
      var _a3;
      const cover = (_a3 = album.frontmatter) == null ? void 0 : _a3.cover;
      if (!cover)
        return "";
      const relPath = `/albums/${album.id}/${cover}`;
      return this.photoMap[relPath] ?? "";
    },
    onClick(id) {
      this.$router.push(this.pageMap[id].path);
    }
  }
};
const AlbumList_vue_vue_type_style_index_0_scoped_8efd530d_lang = "";
const _hoisted_1$m = {
  class: "album-list"
};
const _hoisted_2$e = {
  class: "album-box"
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Container = resolveComponent("Container");
  return openBlock(), createElementBlock("section", _hoisted_1$m, [(openBlock(true), createElementBlock(
    Fragment,
    null,
    renderList(Object.entries($setup.albums), ([id, album]) => {
      return openBlock(), createElementBlock("div", _hoisted_2$e, [createVNode(_component_Container, mergeProps(
        {
          id,
          src: $options.getAbsUrl(album),
          type: "album"
        },
        /** @ts-ignore */
        album.frontmatter,
        {
          onClick: $options.onClick
        }
      ), null, 16, ["id", "src", "onClick"])]);
    }),
    256
    /* UNKEYED_FRAGMENT */
  ))]);
}
const AlbumList = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$j], ["__scopeId", "data-v-8efd530d"], ["__file", "AlbumList.vue"]]);
const _sfc_main$p = {
  components: {
    Container,
    PhotoPage
  },
  props: {
    albumId: {
      type: String,
      required: true
    }
  },
  data() {
    const photoMap = useAlbumPhotosMap(this.albumId);
    const entries2 = Object.entries(photoMap);
    const photos = entries2.length ? new Array(20).fill(null).map((n2, i3) => {
      const rIdx = randInt({
        min: 0,
        max: entries2.length
      });
      return {
        id: entries2[rIdx][0],
        src: entries2[rIdx][1],
        title: "测试图画标题#" + i3,
        description: "描述：" + entries2[rIdx][0],
        date: /* @__PURE__ */ new Date()
      };
    }) : [];
    return {
      curPhotoId: "",
      photoMap,
      photos,
      pageMap: usePageMap()
    };
  },
  computed: {
    pageKey() {
      return this.pageMap[this.albumId].key;
    },
    pagePath() {
      return this.pageMap[this.albumId].path;
    }
  },
  methods: {
    showPhotoPage(photoId) {
      console.log(photoId);
      this.curPhotoId = photoId;
    }
  }
};
const PhotoList_vue_vue_type_style_index_0_scoped_a15becb0_lang = "";
const _withScopeId$3 = (n2) => (pushScopeId("data-v-a15becb0"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$l = {
  class: "photo-list-wrapper"
};
const _hoisted_2$d = {
  key: 0,
  class: "photo-page"
};
const _hoisted_3$c = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode(
  "button",
  null,
  "返回相册",
  -1
  /* HOISTED */
));
const _hoisted_4$8 = [_hoisted_3$c];
const _hoisted_5$5 = {
  key: 1,
  class: "photo-list"
};
const _hoisted_6$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode(
  "button",
  null,
  "返回首页",
  -1
  /* HOISTED */
));
const _hoisted_7$3 = [_hoisted_6$4];
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PhotoPage = resolveComponent("PhotoPage");
  const _component_Container = resolveComponent("Container");
  return openBlock(), createElementBlock("div", _hoisted_1$l, [$data.curPhotoId ? (openBlock(), createElementBlock("section", _hoisted_2$d, [createElementVNode("div", {
    class: "back-link transparent-btn",
    onClick: _cache[0] || (_cache[0] = ($event) => $data.curPhotoId = "")
  }, _hoisted_4$8), createVNode(_component_PhotoPage, {
    id: $data.curPhotoId,
    "album-id": $props.albumId,
    "photo-map": $data.photoMap,
    onBack: _cache[1] || (_cache[1] = ($event) => $data.curPhotoId = "")
  }, null, 8, ["id", "album-id", "photo-map"])])) : (openBlock(), createElementBlock("section", _hoisted_5$5, [createElementVNode("div", {
    class: "back-link transparent-btn",
    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$router.push("/albums"))
  }, _hoisted_7$3), (openBlock(true), createElementBlock(
    Fragment,
    null,
    renderList($data.photos, (p2, i3) => {
      return openBlock(), createBlock(_component_Container, mergeProps({
        key: i3,
        type: "photo"
      }, p2, {
        onClick: $options.showPhotoPage
      }), null, 16, ["onClick"]);
    }),
    128
    /* KEYED_FRAGMENT */
  ))]))]);
}
const PhotoList = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$i], ["__scopeId", "data-v-a15becb0"], ["__file", "PhotoList.vue"]]);
const _hoisted_1$k = /* @__PURE__ */ createElementVNode(
  "div",
  {
    style: {
      "text-align": "center"
    }
  },
  "---【页面开发中】这里是相册---",
  -1
  /* HOISTED */
);
const _hoisted_2$c = /* @__PURE__ */ createElementVNode(
  "hr",
  null,
  null,
  -1
  /* HOISTED */
);
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const pageData = usePageData$1();
    const albumId = computed(() => pageData.value.frontmatter.id);
    const scrollPromise2 = useScrollPromise();
    const onBeforeEnter = scrollPromise2.resolve;
    const onBeforeLeave = scrollPromise2.pending;
    const {
      initMagicCard
    } = useMagicCard();
    onMounted(() => {
      initMagicCard();
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
    });
    return (_ctx, _cache) => {
      const _component_Content = resolveComponent("Content");
      return openBlock(), createBlock(Common, null, {
        default: withCtx(() => [createVNode(Transition, {
          name: "fade-slide-y",
          mode: "out-in",
          onBeforeEnter: unref(onBeforeEnter),
          onBeforeLeave: unref(onBeforeLeave)
        }, {
          default: withCtx(() => [(openBlock(), createElementBlock("main", {
            key: unref(pageData).path,
            class: "album-main"
          }, [_hoisted_1$k, createCommentVNode(" 相册的md正文 "), createCommentVNode(" 每一个相册在/docs/album目录下都必须建一个id同名的目录，并在其中添加README.md作为正文 "), createCommentVNode(" 可以在同目录内添加某一张该相片 "), createVNode(_component_Content), _hoisted_2$c, unref(pageData).path === "/albums/" ? (openBlock(), createBlock(AlbumList, {
            key: 0
          })) : albumId.value ? (openBlock(), createBlock(PhotoList, {
            key: 1,
            "album-id": albumId.value
          }, null, 8, ["album-id"])) : createCommentVNode("v-if", true)]))]),
          _: 1
          /* STABLE */
        }, 8, ["onBeforeEnter", "onBeforeLeave"])]),
        _: 1
        /* STABLE */
      });
    };
  }
});
const Layout_vue_vue_type_style_index_0_lang = "";
const Layout$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__file", "Layout.vue"]]);
const _sfc_main$n = defineComponent({
  name: "WalineViews",
  props: {
    articleId: {
      type: String,
      default: null
    },
    path: String
  },
  setup() {
    const route = useRoute();
    const articleInfo = inject(ARTICLE_INFO_KEY);
    const userInfo2 = useUserInfo();
    const isAdmin = computed(() => userInfo2.value.type === "administrator");
    const pageView = computed(() => (articleInfo == null ? void 0 : articleInfo.value.pageView.toString()) ?? "0");
    return {
      route,
      pageView,
      isAdmin
    };
  },
  watch: {
    pageView() {
      this.viewFn();
    }
  },
  methods: {
    viewFn(update = false) {
      this.pageviewCount(`[data-path="${this.path}"]`, update);
    },
    pageviewCount(selector, update) {
      const id = (this.articleId || this.path) ?? "";
      const controller = new AbortController();
      const elements = Array.from(
        // pageview selectors
        document.querySelectorAll(selector)
      );
      console.log("PageView", this.pageView);
      elements.forEach((el) => el.innerText = this.pageView);
      if (update) {
        this.$api.addPageView(id).then(() => {
          elements.forEach((el) => el.innerText = ((Number(el.innerText) || 0) + 1).toString());
        });
      }
      return controller.abort.bind(controller);
    }
  },
  mounted() {
    this.viewFn(!this.isAdmin && this.route.path === this.path);
  },
  updated() {
    this.viewFn();
  }
});
const _hoisted_1$j = ["data-path"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: "waline-pageview-count",
    "data-path": _ctx.path
  }, null, 8, _hoisted_1$j);
}
const WalineViews = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["render", _sfc_render$h], ["__file", "WalineViews.vue"]]);
const i$3 = () => {
  const e2 = usePageData$1();
  return computed(() => e2.value.readingTime ?? null);
}, n$4 = typeof { "/": { "word": "约 $word 字", "less1Minute": "小于 1 分钟", "time": "大约 $time 分钟" } } > "u" ? null : { "/": { "word": "约 $word 字", "less1Minute": "小于 1 分钟", "time": "大约 $time 分钟" } }, a$3 = (e2, o2) => {
  const {
    minutes: r2,
    words: l2
  } = e2, {
    less1Minute: m2,
    word: c2,
    time: d2
  } = o2;
  return {
    time: r2 < 1 ? m2 : d2.replace("$time", Math.round(r2).toString()),
    words: c2.replace("$word", l2.toString())
  };
}, u$5 = {
  words: "",
  time: ""
}, s$2 = () => n$4 ? Ze$1(n$4) : computed(() => null), L$4 = () => {
  if (typeof n$4 > "u")
    return computed(() => u$5);
  const e2 = i$3(), o2 = s$2();
  return computed(() => e2.value && o2.value ? a$3(e2.value, o2.value) : u$5);
};
const _sfc_main$m = defineComponent({
  name: "PageInfo",
  components: {
    WalineViews
  },
  props: {
    pageData: {
      type: Object,
      default: () => ({})
    },
    currentCategory: {
      type: String,
      default: ""
    },
    currentTag: {
      type: String,
      default: ""
    },
    hideViews: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      readingTimeData: i$3(),
      readingTimeLocale: L$4()
    };
  },
  setup(props) {
    const {
      pageData,
      hideViews
    } = toRefs(props);
    const themeData2 = useThemeLocaleData$1();
    const author2 = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.author) || themeData2.value.author || "";
    });
    const date = computed(() => {
      var _a3, _b2;
      const d2 = (_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.date;
      return d2 ? formatISODate(d2) : "";
    });
    const categories = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.categories) || [];
    });
    const articleId = computed(() => {
      var _a3, _b2, _c;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.id) || ((_c = pageData == null ? void 0 : pageData.value) == null ? void 0 : _c.path);
    });
    const tags = computed(() => {
      var _a3, _b2;
      return ((_b2 = (_a3 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a3.frontmatter) == null ? void 0 : _b2.tags) || [];
    });
    const showPageInfo = computed(() => !!author2.value || !!date.value || !!(categories.value && categories.value.length > 0) || !!(tags.value && tags.value.length > 0));
    const showWalineViews = computed(() => !hideViews.value);
    return {
      author: author2,
      date,
      categories,
      tags,
      showPageInfo,
      showWalineViews,
      convertToPinyin,
      articleId
    };
  }
});
const _hoisted_1$i = {
  key: 0,
  class: "page-info"
};
const _hoisted_2$b = {
  class: "xicon-icon",
  style: {
    "width": "18px",
    "height": "18px",
    "font-size": "18px",
    "color": "inherit"
  },
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 12 12"
};
const _hoisted_3$b = /* @__PURE__ */ createElementVNode(
  "g",
  {
    fill: "none"
  },
  [/* @__PURE__ */ createElementVNode("path", {
    d: "M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z",
    fill: "currentColor"
  })],
  -1
  /* HOISTED */
);
const _hoisted_4$7 = [_hoisted_3$b];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  const _component_WalineViews = resolveComponent("WalineViews");
  return _ctx.showPageInfo ? (openBlock(), createElementBlock("div", _hoisted_1$i, [!!_ctx.author ? (openBlock(), createBlock(_component_Xicons, {
    key: 0,
    icon: "User",
    text: _ctx.author
  }, null, 8, ["text"])) : createCommentVNode("v-if", true), !!_ctx.date ? (openBlock(), createBlock(_component_Xicons, {
    key: 1,
    icon: "Calendar",
    text: _ctx.date
  }, null, 8, ["text"])) : createCommentVNode("v-if", true), !!_ctx.categories && _ctx.categories.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
    key: 2,
    icon: "Folder"
  }, {
    default: withCtx(() => [createTextVNode(
      toDisplayString(_ctx.categories.join(" ")),
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), !!_ctx.tags && _ctx.tags.length > 0 ? (openBlock(), createBlock(_component_Xicons, {
    key: 3,
    icon: "Tag"
  }, {
    default: withCtx(() => [createTextVNode(
      toDisplayString(_ctx.tags.join(" ")),
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), _ctx.showWalineViews ? (openBlock(), createBlock(_component_Xicons, {
    key: 4
  }, {
    icon: withCtx(() => [(openBlock(), createElementBlock("svg", _hoisted_2$b, _hoisted_4$7))]),
    default: withCtx(() => [_ctx.showWalineViews ? (openBlock(), createBlock(_component_WalineViews, {
      key: 0,
      path: _ctx.pageData.path,
      "article-id": _ctx.articleId
    }, null, 8, ["path", "article-id"])) : createCommentVNode("v-if", true)]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), createElementVNode("div", null, [!!_ctx.readingTimeData ? (openBlock(), createBlock(_component_Xicons, {
    key: 0,
    icon: "Data2"
  }, {
    default: withCtx(() => [createTextVNode(
      toDisplayString(_ctx.readingTimeData.words) + " 字 ",
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true), !!_ctx.readingTimeData ? (openBlock(), createBlock(_component_Xicons, {
    key: 1,
    icon: "Time"
  }, {
    default: withCtx(() => [createTextVNode(
      " 预计阅读 " + toDisplayString(Math.round(_ctx.readingTimeData.minutes * 10) / 10) + " 分钟 ",
      1
      /* TEXT */
    )]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true)])])) : createCommentVNode("v-if", true);
}
const PageInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$g], ["__file", "PageInfo.vue"]]);
const useEditNavLink = () => {
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    const showEditLink = frontmatter.value.editLink ?? themeLocal.value.editLink ?? true;
    if (!showEditLink) {
      return null;
    }
    const {
      repo,
      docsRepo = repo,
      docsBranch = "main",
      docsDir = "",
      editLinkText
    } = themeLocal.value;
    if (!docsRepo)
      return null;
    const editLink = resolveEditLink({
      docsRepo,
      docsBranch,
      docsDir,
      filePathRelative: page.value.filePathRelative,
      editLinkPattern: themeLocal.value.editLinkPattern
    });
    if (!editLink)
      return null;
    return {
      text: editLinkText ?? "Edit this page",
      link: editLink,
      icon: "Edit",
      hideExternalLinkIcon: true
    };
  });
};
const useLastUpdated = () => {
  useSiteLocaleData();
  const themeLocal = useThemeLocaleData$1();
  const page = usePageData$1();
  const frontmatter = usePageFrontmatter();
  return computed(() => {
    var _a3, _b2;
    const showLastUpdated = frontmatter.value.lastUpdated ?? themeLocal.value.lastUpdated ?? true;
    if (!showLastUpdated)
      return null;
    if (!((_a3 = page.value.git) == null ? void 0 : _a3.updatedTime))
      return null;
    const updatedDate = new Date((_b2 = page.value.git) == null ? void 0 : _b2.updatedTime);
    return updatedDate.toLocaleString();
  });
};
const _sfc_main$l = defineComponent({
  name: "PageMeta",
  components: {
    Link
  },
  setup() {
    const themeLocal = useThemeLocaleData$1();
    const editNavLink = useEditNavLink();
    const lastUpdated = useLastUpdated();
    return {
      themeLocal,
      editNavLink,
      lastUpdated
    };
  }
});
const _hoisted_1$h = {
  class: "page-meta"
};
const _hoisted_2$a = {
  key: 0,
  class: "meta-item edit-link"
};
const _hoisted_3$a = {
  key: 1,
  class: "meta-item last-updated"
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xicons = resolveComponent("Xicons");
  return openBlock(), createElementBlock("footer", _hoisted_1$h, [_ctx.editNavLink ? (openBlock(), createElementBlock("div", _hoisted_2$a, [createVNode(_component_Xicons, {
    class: "meta-item-label",
    icon: _ctx.editNavLink.icon,
    text: _ctx.editNavLink.text,
    link: _ctx.editNavLink.link,
    target: "_blank",
    "icon-size": "20",
    "text-size": "14"
  }, null, 8, ["icon", "text", "link"])])) : createCommentVNode("v-if", true), _ctx.lastUpdated ? (openBlock(), createElementBlock("div", _hoisted_3$a, [createVNode(_component_Xicons, {
    class: "meta-item-label",
    icon: "Calendar",
    text: `最后于 ${_ctx.lastUpdated} 更新`,
    "icon-size": "20",
    "text-size": "14"
  }, null, 8, ["text"])])) : createCommentVNode("v-if", true)]);
}
const PageMeta = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$f], ["__file", "PageMeta.vue"]]);
const _hoisted_1$g = {
  class: "page-container"
};
const _hoisted_2$9 = {
  key: 0,
  class: "page-title"
};
const _hoisted_3$9 = {
  key: 1,
  class: "theme-reco-default-content"
};
const _hoisted_4$6 = {
  key: 2,
  class: "theme-reco-default-content"
};
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    var _a4, _b2;
    const lang = usePageLang();
    const pageData = usePageData$1();
    const {
      pageLoaded,
      pagePasswordPass,
      setedPagePassword,
      handlePass
    } = usePassword();
    const title = computed(() => {
      var _a5, _b3, _c;
      return ((_b3 = (_a5 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a5.frontmatter) == null ? void 0 : _b3.title) || ((_c = pageData == null ? void 0 : pageData.value) == null ? void 0 : _c.title) || "";
    });
    let _a3;
    const options = ref({
      id: (_b2 = (_a4 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a4.frontmatter) == null ? void 0 : _b2.id,
      path: withBase((_a3 = pageData.value) === null || _a3 === void 0 ? void 0 : _a3.path),
      login: "force"
    });
    const walineOption = computed(() => {
      return {
        lang: lang.value || "zh-CN",
        dark: 'html[class="dark"]',
        ...options.value,
        pageview: false
      };
    });
    const shouldHideComments = computed(() => {
      var _a5;
      const {
        hideComments: hideCommentsInSinglePage
      } = (_a5 = pageData == null ? void 0 : pageData.value) == null ? void 0 : _a5.frontmatter;
      const {
        hideComments: hideCommentsInAllPage
      } = options.value;
      return hideCommentsInSinglePage === true || hideCommentsInSinglePage !== false && hideCommentsInAllPage === true;
    });
    const RecoWalineWrapper = () => {
      if (shouldHideComments.value)
        return null;
      return h$5("div", {
        class: "reco-waline-wrapper"
      }, h$5(Waline$1, walineOption.value));
    };
    return (_ctx, _cache) => {
      const _component_Content = resolveComponent("Content");
      return openBlock(), createElementBlock("main", _hoisted_1$g, [!!title.value ? (openBlock(), createElementBlock(
        "h1",
        _hoisted_2$9,
        toDisplayString(title.value),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true), createVNode(PageInfo, {
        "page-data": unref(pageData)
      }, null, 8, ["page-data"]), !unref(setedPagePassword) ? (openBlock(), createElementBlock("div", _hoisted_3$9, [createVNode(_component_Content)])) : (openBlock(), createElementBlock("div", _hoisted_4$6, [unref(pageLoaded) && !unref(pagePasswordPass) ? (openBlock(), createBlock(Password, {
        key: 0,
        onPass: unref(handlePass)
      }, null, 8, ["onPass"])) : createCommentVNode("v-if", true), unref(pageLoaded) && unref(pagePasswordPass) ? (openBlock(), createBlock(_component_Content, {
        key: 1
      })) : createCommentVNode("v-if", true)])), createVNode(PageMeta), createVNode(PageNav), createVNode(RecoWalineWrapper)]);
    };
  }
});
const Page = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "index.vue"]]);
const _sfc_main$j = {
  props: {
    modelValue: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    tag: {
      type: Number,
      default: 0
    }
  },
  emits: {
    "update:modelValue": (val) => true
  },
  watch: {
    modelValue(val) {
      if (val)
        setTimeout(() => this.load = true, 200);
      else
        setTimeout(() => this.load = false, 500);
    }
  },
  setup(props) {
    const load = ref(props.modelValue);
    const posX = ref(void 0);
    const posXS = computed(() => posX.value === void 0 ? void 0 : `${posX.value}px`);
    const posY = ref(void 0);
    const posYS = computed(() => posY.value === void 0 ? void 0 : `${posY.value}px`);
    return {
      load,
      posX,
      posY,
      posXS,
      posYS
    };
  },
  mounted() {
    window.addEventListener("resize", this.onResize);
  },
  unmounted() {
    window.removeEventListener("resize", this.onResize);
  },
  methods: {
    onResize() {
      const container = this.$refs.containerRef;
      const {
        offsetLeft: left = 0,
        offsetTop: top = 0,
        offsetWidth: width = 0,
        offsetHeight: height = 0
      } = container ?? {};
      this.posX = window.innerWidth - width - left;
      this.posY = top;
    }
  }
};
const Popup_vue_vue_type_style_index_0_lang = "";
const Popup_vue_vue_type_style_index_1_scoped_f8dc53bb_lang = "";
const _hoisted_1$f = {
  class: "popup-head"
};
const _hoisted_2$8 = ["textContent"];
const _hoisted_3$8 = {
  class: "popup-content"
};
const _hoisted_4$5 = {
  key: 0,
  class: "popup-tag"
};
const _hoisted_5$4 = {
  class: "popup-icon"
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  return $setup.load ? (openBlock(), createElementBlock(
    "div",
    {
      key: 0,
      ref: "containerRef",
      class: normalizeClass(["popup popup-container", {
        popin: $props.modelValue,
        popout: !$props.modelValue
      }]),
      style: normalizeStyle({
        "--x": $setup.posXS,
        "--y": $setup.posYS
      })
    },
    [createElementVNode("div", _hoisted_1$f, [createElementVNode("span", {
      class: "popup-title",
      textContent: toDisplayString($props.title)
    }, null, 8, _hoisted_2$8), createElementVNode("span", {
      class: "popup-close",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", false))
    }, [createVNode(_component_xicons, {
      icon: "Close",
      iconSize: "25"
    })])]), createElementVNode("div", _hoisted_3$8, [renderSlot(_ctx.$slots, "default", {}, void 0, true)])],
    6
    /* CLASS, STYLE */
  )) : (openBlock(), createElementBlock(
    "div",
    {
      key: 1,
      ref: "popupButtonRef",
      class: normalizeClass(["popup popup-button", {
        popin: !$props.modelValue,
        popout: $props.modelValue
      }]),
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", true))
    },
    [$props.tag > 0 ? (openBlock(), createElementBlock(
      "div",
      _hoisted_4$5,
      toDisplayString($props.tag < 10 ? `${$props.tag}` : "9+"),
      1
      /* TEXT */
    )) : createCommentVNode("v-if", true), createElementVNode("div", _hoisted_5$4, [createVNode(_component_xicons, {
      icon: "ChevronLeft",
      iconSize: "30"
    })])],
    2
    /* CLASS */
  ));
}
const Popup = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$e], ["__scopeId", "data-v-f8dc53bb"], ["__file", "Popup.vue"]]);
const _sfc_main$i = {
  components: {
    Popup
  },
  setup() {
    var _a3;
    const open = ref(false);
    const userInfo2 = useUserInfo();
    const data = ref({
      id: ((_a3 = userInfo2.value) == null ? void 0 : _a3.id) ?? "",
      replies: [],
      likes: []
    });
    const emoji2 = useEmoji();
    const now2 = useNow();
    const locale = {
      seconds: "秒前",
      minutes: "分钟前",
      hours: "小时前",
      days: "天前",
      now: "刚刚"
    };
    const getTimeDesc = (date) => getTimeAgo(new Date(date), now2.value, locale);
    const likesUserDesc = computed(() => {
      const {
        likes
      } = data.value;
      const userSet = new Map(likes.map((l2) => [l2.userId, l2.userName]));
      const names = `<strong>${[...userSet.values()].slice(0, 3).join("、")}</strong>`;
      const count = userSet.size;
      return count < 3 ? names : `${names}等<strong>${count}</strong>人`;
    });
    const dataCount = computed(() => {
      var _a4;
      return data.value.replies.filter((e2) => !e2.read).length + (((_a4 = data.value.likes) == null ? void 0 : _a4.length) || 0);
    });
    const pageMap2 = usePageMap();
    return {
      open,
      data,
      emoji: emoji2,
      now: now2,
      userInfo: userInfo2,
      getTimeDesc,
      parseEmoji,
      likesUserDesc,
      dataCount,
      pageMap: pageMap2
    };
  },
  mounted() {
    if (this.userInfo.id) {
      this.refreshData();
    }
  },
  methods: {
    refreshData() {
      const update = (res, admin) => {
        var _a3;
        const viewReplies = Object.entries(res.data.replies || []).map(([aid, replies]) => replies.map((r2) => ({
          parentId: aid,
          commentId: r2.id,
          admin,
          ...r2
        }))).flat();
        this.data.replies.push(...viewReplies);
        this.data.likes.push(...((_a3 = res.data) == null ? void 0 : _a3.likes) || []);
      };
      this.$api.getRecentComments(this.userInfo.id).then((res) => update(res, false));
      if (this.userInfo.type === "administrator") {
        this.$api.getRecentComments("admin").then((res) => update(res, true));
      }
    },
    parse(content) {
      let uriDecoded = decodeURIComponent(content);
      const len = uriDecoded.length;
      const overflow = len >= 100;
      overflow && (uriDecoded = uriDecoded.slice(0, 100));
      let text2 = parseHTMLText(uriDecoded);
      overflow && (text2 += `<span class="overflow-desc">...剩余${len - 100}字</span>`);
      return parseEmoji(text2, this.emoji.map);
    },
    readAllLikes() {
      const {
        likes
      } = this.data;
      if (!likes.length)
        return;
      const userId = this.userInfo.id;
      this.$api.removeRecentComments(userId, [], likes.map((e2) => e2.userId)).then(() => this.data.likes.splice(0, likes.length));
    },
    readComment(item) {
      if (item.read)
        return;
      const userId = item.admin ? "admin" : this.userInfo.id;
      this.$api.removeRecentComments(userId, [item.commentId]).then(() => {
        item.read = true;
      });
    }
  }
};
const RecentComments_vue_vue_type_style_index_0_lang = "";
const RecentComments_vue_vue_type_style_index_1_scoped_2e8beafb_lang = "";
const _withScopeId$2 = (n2) => (pushScopeId("data-v-2e8beafb"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$e = {
  class: "content-wrapper"
};
const _hoisted_2$7 = {
  key: 0
};
const _hoisted_3$7 = {
  key: 0,
  class: "recent-like"
};
const _hoisted_4$4 = {
  class: "desc"
};
const _hoisted_5$3 = ["innerHTML"];
const _hoisted_6$3 = {
  class: "button"
};
const _hoisted_7$2 = {
  class: "header"
};
const _hoisted_8$2 = ["innerHTML"];
const _hoisted_9$2 = {
  class: "footer"
};
const _hoisted_10$1 = {
  class: "buttons"
};
const _hoisted_11$1 = ["onClick"];
const _hoisted_12 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode(
  "span",
  {
    class: "text"
  },
  "查看",
  -1
  /* HOISTED */
));
const _hoisted_13 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode(
  "span",
  null,
  ">",
  -1
  /* HOISTED */
));
const _hoisted_14 = {
  key: 1,
  class: "recent-empty"
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  const _component_Popup = resolveComponent("Popup");
  return $setup.userInfo.id ? (openBlock(), createBlock(_component_Popup, {
    key: 0,
    title: "最近消息",
    modelValue: $setup.open,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.open = $event),
    tag: $setup.dataCount
  }, {
    default: withCtx(() => {
      var _a3, _b2;
      return [createElementVNode("div", _hoisted_1$e, [((_a3 = $setup.data.likes) == null ? void 0 : _a3.length) || ((_b2 = $setup.data.replies) == null ? void 0 : _b2.length) ? (openBlock(), createElementBlock("div", _hoisted_2$7, [createVNode(Transition, {
        name: "recent-likes"
      }, {
        default: withCtx(() => {
          var _a4, _b3;
          return [((_a4 = $setup.data.likes) == null ? void 0 : _a4.length) ? (openBlock(), createElementBlock("div", _hoisted_3$7, [createElementVNode("div", _hoisted_4$4, [createElementVNode("span", {
            innerHTML: $setup.likesUserDesc
          }, null, 8, _hoisted_5$3), createTextVNode(
            "点赞了你的评论共" + toDisplayString((_b3 = $setup.data.likes) == null ? void 0 : _b3.length) + "次 ",
            1
            /* TEXT */
          )]), createElementVNode("div", _hoisted_6$3, [createElementVNode("button", {
            class: "text",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.readAllLikes && $options.readAllLikes(...args))
          }, " 已读 ")])])) : createCommentVNode("v-if", true)];
        }),
        _: 1
        /* STABLE */
      }), createVNode(TransitionGroup, {
        class: "recent-replies",
        name: "recent-replies",
        tag: "div"
      }, {
        default: withCtx(() => [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList($setup.data.replies.filter((e2) => !e2.read), (item) => {
            var _a4, _b3, _c;
            return openBlock(), createElementBlock("div", {
              class: "recent-reply-item",
              key: item.id
            }, [createElementVNode("div", _hoisted_7$2, [createElementVNode(
              "strong",
              null,
              toDisplayString(item.user.nickname),
              1
              /* TEXT */
            ), createTextVNode(" 于 "), createElementVNode(
              "span",
              null,
              toDisplayString($setup.getTimeDesc(item.time)),
              1
              /* TEXT */
            ), createTextVNode(" 回复了你： ")]), createElementVNode("div", {
              class: "content",
              innerHTML: $options.parse(item.content)
            }, null, 8, _hoisted_8$2), createElementVNode("div", _hoisted_9$2, [createElementVNode(
              "span",
              null,
              toDisplayString(((_b3 = (_a4 = $setup.pageMap) == null ? void 0 : _a4[item.parentId]) == null ? void 0 : _b3.title) ?? "(已删除)"),
              1
              /* TEXT */
            ), createElementVNode("div", _hoisted_10$1, [createElementVNode("button", {
              class: normalizeClass(["text", {
                visited: item.read
              }]),
              onClick: ($event) => $options.readComment(item)
            }, " 已读 ", 10, _hoisted_11$1), ((_c = $setup.pageMap) == null ? void 0 : _c[item.parentId]) ? (openBlock(), createBlock(_component_router_link, {
              key: 0,
              to: $setup.pageMap[item.parentId].path,
              type: "text"
            }, {
              default: withCtx(() => [_hoisted_12, _hoisted_13]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["to"])) : createCommentVNode("v-if", true)])])]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))]),
        _: 1
        /* STABLE */
      })])) : (openBlock(), createElementBlock("div", _hoisted_14, " 暂时没有消息哦~ 小孤独(: )～ "))])];
    }),
    _: 1
    /* STABLE */
  }, 8, ["modelValue", "tag"])) : createCommentVNode("v-if", true);
}
const RecentComments = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$d], ["__scopeId", "data-v-2e8beafb"], ["__file", "RecentComments.vue"]]);
const _hoisted_1$d = {
  class: "theme-container"
};
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const page = usePageData$1();
    const frontmatter = usePageFrontmatter();
    const scrollPromise2 = useScrollPromise();
    const onBeforeEnter = scrollPromise2.resolve;
    const onBeforeLeave = scrollPromise2.pending;
    const {
      proxy: proxy2
    } = getCurrentInstance();
    const {
      initMagicCard
    } = useMagicCard();
    console.log("PAGE", page);
    const api = proxy2.$api;
    const articleId = computed(() => {
      return frontmatter.value.id ?? page.value.path;
    });
    provide(ARTICLE_ID_KEY, articleId);
    const articleInfo = ref({
      id: articleId.value,
      time: NaN,
      pageView: 0,
      trends: {}
    });
    const getArticleInfo = () => {
      api.getArticleInfo(articleId.value).then((resp) => {
        articleInfo.value = resp.data;
      });
    };
    provide(ARTICLE_INFO_KEY, articleInfo);
    onBeforeMount(() => {
      getArticleInfo();
    });
    const testMsg = (e2) => e2.altKey && e2.key === "c" && (proxy2 == null ? void 0 : proxy2.$msg({
      type: "success",
      text: '我在测试一段很长的消息Σ(⊙▽⊙"a',
      delay: 12e3
    }));
    onMounted(() => {
      initMagicCard();
      window.addEventListener("keydown", testMsg);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", testMsg);
    });
    const route = useRoute();
    watch(route, () => {
      initMagicCard();
      getArticleInfo();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [createVNode(Common, null, {
        default: withCtx(() => [unref(frontmatter).home === true ? (openBlock(), createBlock(Home, {
          key: 0
        })) : (openBlock(), createBlock(Transition, {
          key: 1,
          name: "fade-slide-y",
          mode: "out-in",
          onBeforeEnter: unref(onBeforeEnter),
          onBeforeLeave: unref(onBeforeLeave)
        }, {
          default: withCtx(() => [(openBlock(), createBlock(Page, {
            key: unref(page).path
          }))]),
          _: 1
          /* STABLE */
        }, 8, ["onBeforeEnter", "onBeforeLeave"])), createVNode(RecentComments)]),
        _: 1
        /* STABLE */
      })]);
    };
  }
});
const Layout = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "Layout.vue"]]);
const _sfc_main$g = {
  components: {
    Common,
    LoadingIcon,
    Pad: () => h$5("span", {
      style: {
        padding: "5px"
      }
    })
  },
  setup() {
    const frontend = ref(true);
    const page = ref(1);
    const status = ref("load");
    const data = ref([]);
    const dataMap = computed(() => {
      const map = {};
      for (const item of data.value) {
        let date = "未知年份";
        if (item.date) {
          date = item.date.toLocaleDateString();
        }
        if (!map[date]) {
          map[date] = [item];
        } else {
          map[date].push(item);
        }
      }
      return map;
    });
    const timelineData = computed(() => {
      return Object.entries(dataMap.value).map(([date, data2]) => ({
        date,
        data: data2
      }));
    });
    return {
      frontend,
      page,
      status,
      data,
      timelineData
    };
  },
  mounted() {
    {
      this.init(this.frontend);
    }
  },
  watch: {
    frontend(val) {
      this.init(val);
    }
  },
  methods: {
    init(frontend) {
      this.page = 1;
      this.data.splice(0, this.data.length);
      this.getCommitsInfo(frontend);
    },
    async getCommitsInfo(frontend, page = 1) {
      const pageSize = 25;
      const repo = frontend ? "LancreeVuepressBlog" : "LancreeBlogServer";
      try {
        this.status = "load";
        const {
          data
        } = await this.$api.getCommitsInfo(repo, page, pageSize);
        this.data.push(...data.map((e2) => ({
          ...e2,
          date: e2.date ? new Date(e2.date) : null
        })));
        this.status = "part";
        if (!data.length || data.length < pageSize) {
          this.status = "all";
        }
      } catch {
        this.status = "error";
      }
    }
  }
};
const Timeline_vue_vue_type_style_index_0_scoped_598306f5_lang = "";
const _hoisted_1$c = {
  class: "timeline-title"
};
const _hoisted_2$6 = {
  class: "github-note"
};
const _hoisted_3$6 = {
  class: "timeline-content"
};
const _hoisted_4$3 = {
  class: "year"
};
const _hoisted_5$2 = {
  class: "year-wrapper"
};
const _hoisted_6$2 = {
  class: "sha"
};
const _hoisted_7$1 = {
  key: 0,
  class: "date"
};
const _hoisted_8$1 = {
  class: "message"
};
const _hoisted_9$1 = {
  class: "load-more"
};
const _hoisted_10 = {
  key: 0,
  class: "wl-loading"
};
const _hoisted_11 = {
  key: 3,
  class: "no-more"
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  const _component_Pad = resolveComponent("Pad");
  const _component_LoadingIcon = resolveComponent("LoadingIcon");
  const _component_Common = resolveComponent("Common");
  return openBlock(), createBlock(_component_Common, {
    class: "timeline-wrapper"
  }, {
    default: withCtx(() => [createElementVNode("h2", _hoisted_1$c, [createElementVNode("div", {
      class: "transparent-btn",
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.frontend = !$setup.frontend)
    }, [createVNode(_component_xicons, null, {
      icon: withCtx(() => [createVNode(_component_xicons, {
        icon: "Renew",
        class: normalizeClass({
          rotate: $setup.status === "load",
          reverse: $setup.status === "load"
        }),
        style: {
          "margin-right": ".25rem"
        }
      }, null, 8, ["class"])]),
      default: withCtx(() => [createTextVNode(
        " " + toDisplayString($setup.frontend ? "Vuepress 前端" : "Go Hertz 后端"),
        1
        /* TEXT */
      )]),
      _: 1
      /* STABLE */
    })]), createTextVNode(" 提交历史 "), createElementVNode("div", _hoisted_2$6, [createVNode(_component_xicons, {
      icon: "LogoGithub"
    }, {
      default: withCtx(() => [createTextVNode("每小时刷新")]),
      _: 1
      /* STABLE */
    })])]), createElementVNode("ul", _hoisted_3$6, [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList($setup.timelineData, (item, index2) => {
        return openBlock(), createElementBlock("li", {
          key: index2
        }, [createElementVNode(
          "h3",
          _hoisted_4$3,
          toDisplayString(item.date),
          1
          /* TEXT */
        ), createElementVNode("ul", _hoisted_5$2, [(openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(item.data, (subItem, subIndex) => {
            return openBlock(), createElementBlock("li", {
              key: subIndex,
              class: "item"
            }, [createVNode(_component_xicons, {
              icon: "Commit"
            }), createVNode(_component_Pad), createElementVNode(
              "span",
              _hoisted_6$2,
              toDisplayString(subItem.sha.slice(0, 8)),
              1
              /* TEXT */
            ), createVNode(_component_xicons, {
              icon: "Time"
            }), createVNode(_component_Pad), subItem.date ? (openBlock(), createElementBlock(
              "span",
              _hoisted_7$1,
              toDisplayString(subItem.date.toLocaleTimeString()),
              1
              /* TEXT */
            )) : createCommentVNode("v-if", true), createElementVNode(
              "span",
              _hoisted_8$1,
              toDisplayString(subItem.message),
              1
              /* TEXT */
            ), subItem.committer ? (openBlock(), createBlock(
              _component_xicons,
              {
                key: 1,
                class: "committer",
                icon: "UserCertification"
              },
              {
                default: withCtx(() => [createTextVNode(
                  toDisplayString(subItem.committer),
                  1
                  /* TEXT */
                ), createVNode(_component_Pad)]),
                _: 2
                /* DYNAMIC */
              },
              1024
              /* DYNAMIC_SLOTS */
            )) : createCommentVNode("v-if", true)]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))])]);
      }),
      128
      /* KEYED_FRAGMENT */
    )), createElementVNode("li", _hoisted_9$1, [$setup.status === "load" ? (openBlock(), createElementBlock("div", _hoisted_10, [createVNode(_component_LoadingIcon, {
      size: 30
    })])) : $setup.status === "part" ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "transparent-btn",
      onClick: _cache[1] || (_cache[1] = ($event) => $options.getCommitsInfo($setup.frontend, ++$setup.page))
    }, [createVNode(_component_xicons, {
      icon: "ResultOld"
    }, {
      default: withCtx(() => [createTextVNode("加载更多")]),
      _: 1
      /* STABLE */
    })])) : $setup.status === "error" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "transparent-btn",
      onClick: _cache[2] || (_cache[2] = ($event) => $options.getCommitsInfo($setup.frontend, $setup.page))
    }, [createVNode(_component_xicons, {
      icon: "Renew"
    }, {
      default: withCtx(() => [createTextVNode("重试")]),
      _: 1
      /* STABLE */
    })])) : (openBlock(), createElementBlock("div", _hoisted_11, " 没有更多了哟~ "))])])]),
    _: 1
    /* STABLE */
  });
}
const Timeline = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["render", _sfc_render$c], ["__scopeId", "data-v-598306f5"], ["__file", "Timeline.vue"]]);
const APPEARANCE_KEY = "vuepress-reco-color-scheme";
const PREFER_SCHEME_MEDIAKEY = "(prefers-color-scheme: dark)";
const clientConfig20 = defineClientConfig({
  enhance({
    app
  }) {
    class SetItemEvent extends StorageEvent {
    }
    const myStorage = function(win) {
      if (!win) {
        return;
      }
      const storage = {
        clear: function() {
          for (const key in this) {
            if (typeof this[key] !== "function")
              this[key] = null;
          }
          return true;
        },
        key: function(index2) {
          return Object.keys(this)[index2];
        }
      };
      return new Proxy(storage, {
        set: function(target, key, value) {
          var oldValue = target[key];
          if (oldValue === value) {
            return false;
          }
          var setItemEvent = new SetItemEvent("myStorage", {
            key,
            oldValue,
            newValue: value,
            url: win.location.href
          });
          win.dispatchEvent(setItemEvent);
          target[key] = value;
          return true;
        },
        get: function(target, key) {
          return target[key] ?? null;
        },
        deleteProperty: function(target, key) {
          target[key] = null;
          return true;
        }
      });
    }(window);
    Object.defineProperty(window, "myStorage", {
      value: myStorage,
      writable: true
    });
  },
  setup: () => {
  }
});
const _sfc_main$f = {
  props: {
    text: {
      required: true,
      type: String
    },
    darkMode: {
      type: Boolean,
      default: false
    },
    ruby: {
      type: Object,
      default: null,
      validate: (e2) => {
        return !e2 || e2.light;
      }
    }
  },
  data() {
    return {
      mousePos: []
    };
  },
  created() {
    this.mousePos = new Array(this.text.length).fill({
      x: "0px",
      y: "0px"
    });
  },
  mounted() {
    window.addEventListener("mousemove", throttle$1((event) => {
      const heroText = this.$refs.heroText;
      if (!heroText)
        return;
      const {
        pageX: x2,
        pageY: y3
      } = event;
      this.mousePos = heroText.map((t2) => {
        const {
          x: ox,
          y: oy
        } = getAbsolutePos(t2);
        return {
          x: `${x2 - ox}px`,
          y: `${y3 - oy}px`
        };
      });
    }, 100));
  }
};
const _hoisted_1$b = {
  key: 0,
  class: "banner-brand__hero-text"
};
const _hoisted_2$5 = {
  key: 0
};
const _hoisted_3$5 = {
  key: 1
};
const _hoisted_4$2 = /* @__PURE__ */ createElementVNode(
  "hr",
  {
    class: "banner-brand__hr"
  },
  null,
  -1
  /* HOISTED */
);
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.text ? (openBlock(), createElementBlock("h1", _hoisted_1$b, [(openBlock(true), createElementBlock(
    Fragment,
    null,
    renderList($props.text, (c2, i3) => {
      return openBlock(), createElementBlock(
        "span",
        {
          ref_for: true,
          ref: "heroText",
          key: i3,
          style: normalizeStyle({
            "--delay": `${i3 * 100}ms`,
            "--x": $data.mousePos[i3].x,
            "--y": $data.mousePos[i3].y
          })
        },
        [createElementVNode("ruby", null, [createTextVNode(
          toDisplayString(c2) + " ",
          1
          /* TEXT */
        ), $props.darkMode && $props.ruby && $props.ruby.dark ? (openBlock(), createElementBlock(
          "rt",
          _hoisted_2$5,
          toDisplayString($props.ruby.dark[i3] ?? ""),
          1
          /* TEXT */
        )) : $props.ruby && $props.ruby.light ? (openBlock(), createElementBlock(
          "rt",
          _hoisted_3$5,
          toDisplayString($props.ruby.light[i3] ?? ""),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)])],
        4
        /* STYLE */
      );
    }),
    128
    /* KEYED_FRAGMENT */
  )), _hoisted_4$2])) : createCommentVNode("v-if", true);
}
const HeroText = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$b], ["__file", "HeroText.vue"]]);
const _sfc_main$e = {
  props: {
    scrollTo: {
      type: [Number, String, Object],
      default: 0,
      validate: (e2) => ["number", "string"].includes(typeof e2) || e2 instanceof Element
    }
  },
  methods: {
    scroll() {
      if (typeof this.scrollTo === "number") {
        window.scroll({
          left: 0,
          top: this.scrollTo,
          behavior: "smooth"
        });
      } else {
        const el = typeof this.scrollTo === "string" ? document.querySelector(this.scrollTo) : this.scrollTo;
        el == null ? void 0 : el.scrollIntoView({
          behavior: "smooth"
        });
      }
    }
  }
};
const DownIcon_vue_vue_type_style_index_0_scoped_3d9ab88b_lang = "";
const _withScopeId$1 = (n2) => (pushScopeId("data-v-3d9ab88b"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$a = {
  class: "down-icon-wrapper"
};
const _hoisted_2$4 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode(
  "svg",
  {
    class: "down-svg",
    fill: "none",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  },
  [/* @__PURE__ */ createElementVNode("path", {
    d: "M19 14l-7 7m0 0l-7-7m7 7V3"
  })],
  -1
  /* HOISTED */
));
const _hoisted_3$4 = [_hoisted_2$4];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$a, [createElementVNode("div", {
    class: "down-icon",
    onClick: _cache[0] || (_cache[0] = (...args) => $options.scroll && $options.scroll(...args))
  }, _hoisted_3$4)]);
}
const DownIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$a], ["__scopeId", "data-v-3d9ab88b"], ["__file", "DownIcon.vue"]]);
const _hoisted_1$9 = {
  class: "wind-base"
};
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "WindBase",
  setup(__props) {
    const windStrength = ref(0);
    const windAngle = ref(180);
    const windStrengthTo = ref(0);
    const windAngleTo = ref(180);
    const windStep = ref(1);
    let itv1 = null;
    let itv2 = null;
    watch([windStrengthTo, windAngleTo], (nvals) => {
      itv1 = setInterval(() => {
        windStrength.value = passTo(windStrength.value, nvals[0], windStep.value);
        windAngle.value = passTo(windAngle.value, nvals[1], windStep.value);
        if (windStrength.value === nvals[0] && windAngle.value === nvals[1]) {
          clearInterval(itv1);
        }
      }, 20);
    });
    onMounted(() => {
      if (isMobile(window) === false) {
        itv2 = setInterval(() => {
          if (Math.random() < 0.2) {
            itv1 && clearInterval(itv1);
            windStrengthTo.value = randFloat(0, 4);
            windAngleTo.value = Math.random() < 0.5 ? randInt(-10, 30) : randInt(150, 190);
            windStep.value = randFloat(0.1, 0.5);
          }
        }, 5e3);
      }
    });
    onUnmounted(() => {
      if (itv1)
        clearInterval(itv1);
      if (itv2)
        clearInterval(itv2);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [renderSlot(_ctx.$slots, "default", {
        strength: windStrength.value,
        direction: windAngle.value
      })]);
    };
  }
});
const WindBase = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "WindBase.vue"]]);
const _hoisted_1$8 = {
  id: "flower-canvas"
};
const _hoisted_2$3 = ["width", "height"];
const _hoisted_3$3 = ["width", "height"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "Flowers",
  props: {
    windStrength: {
      type: Number,
      default: 0
    },
    windAngle: {
      type: Number,
      default: 0
    }
  },
  setup(__props) {
    const props = __props;
    const frontCanvas = ref();
    const backCanvas = ref();
    const w2 = ref(1920);
    const h2 = ref(280);
    let itv = null;
    class Flower {
      constructor(scaleRange, speedXRange, speedYRange) {
        this.scaleRange = scaleRange;
        this.speedXRange = speedXRange;
        this.speedYRange = speedYRange;
        [this.x, this.y] = [0, 0];
        [this.speedX, this.speedY] = [0, 0];
        [this.width, this.height] = [0, 0];
        this.rotate = 0;
        this.speedR = 1;
        this.scale = 0;
        this.img = null;
      }
      show(ctx) {
        this.img = new Image();
        const src = Math.random() > 0.5 ? "/images/flower1.svg" : "/images/flower2.svg";
        this.img.src = src;
        this.regen(this.speedX, this.speedY, true);
        this.img.onload = () => {
          const ratio = this.img.width / this.img.height;
          [this.width, this.height] = [ratio * this.scale, this.scale];
          ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        };
      }
      regen(dx, dy, rand = false) {
        this.scale = Array.isArray(this.scaleRange) ? randElem(this.scaleRange) : randFloat(this.scaleRange);
        [this.speedX, this.speedY] = [randFloat(this.speedXRange), randFloat(this.speedYRange)];
        if (rand) {
          [this.x, this.y] = [randFloat(0, w2.value), randFloat(0, h2.value)];
        } else {
          const ratio = (w2.value + dy) / (w2.value + h2.value + dx + dy);
          const [initX, initY] = Math.random() < ratio ? [randFloat(0, w2.value), dy >= 0 ? 0 : h2.value] : [dx >= 0 ? 0 : w2.value, randFloat(0, h2.value)];
          [this.x, this.y] = [initX, initY];
        }
      }
      draw(ctx, rotate = 0) {
        if (!this.rotate) {
          return ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        }
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(rotate * Math.PI / 180);
        ctx.drawImage(this.img, 0, 0, this.width, this.height);
        ctx.restore();
      }
      // 花瓣移动，会受风的影响
      move(ctx) {
        const wStr = props.windStrength, wAgl = props.windAngle * Math.PI / 180;
        const dx = this.speedX + (wStr ? wStr * Math.cos(wAgl) : 0);
        const dy = this.speedY + (wStr ? wStr * Math.sin(wAgl) : 0);
        const {
          width: cw,
          height: ch
        } = this;
        if (!inRange(this.x + dx, -cw, w2.value + cw) || !inRange(this.y + dy, -ch, h2.value + ch)) {
          this.regen(dx, dy);
        } else
          [this.x, this.y] = [this.x + dx, this.y + dy];
        this.rotate = (this.rotate + this.speedR) % 360;
        this.draw(ctx, this.rotate);
      }
    }
    onMounted(() => {
      const scales = [[10, 12.5, 15], [17.5, 20, 22.5]];
      const speedXRange = {
        min: 0,
        max: 2
      };
      const speedYRange = {
        min: 1,
        max: 1.5
      };
      const FlowerCounts = isMobile(window) === false ? [20, 5] : [10, 3];
      w2.value = window.innerWidth;
      h2.value = window.innerHeight;
      for (const [i3, canvas] of [backCanvas.value, frontCanvas.value].entries()) {
        let movee = function() {
          if (!ctx)
            return;
          ctx.clearRect(0, 0, w2.value, h2.value);
          for (const flower of flowers) {
            flower.move(ctx);
          }
        };
        if (!canvas)
          return;
        let ctx = canvas.getContext("2d");
        if (!ctx)
          return;
        const flowers = [];
        for (let t2 = 0; t2 < FlowerCounts[i3]; t2++) {
          const fr = new Flower(scales[i3], speedXRange, speedYRange);
          flowers.push(fr);
          fr.show(ctx);
        }
        itv = setInterval(movee, 20);
        movee();
        window.addEventListener("resize", () => {
          w2.value = window.innerWidth;
          h2.value = window.innerHeight;
        });
      }
    });
    onUnmounted(() => {
      if (itv)
        clearInterval(itv);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [createElementVNode("canvas", {
        ref_key: "frontCanvas",
        ref: frontCanvas,
        width: w2.value,
        height: h2.value,
        class: "flower-canvas front"
      }, null, 8, _hoisted_2$3), createElementVNode("canvas", {
        ref_key: "backCanvas",
        ref: backCanvas,
        width: w2.value,
        height: h2.value,
        class: "flower-canvas back"
      }, " 您的浏览器不支持canvas请升级！ ", 8, _hoisted_3$3)]);
    };
  }
});
const Flowers_vue_vue_type_style_index_0_scoped_28d5ea85_lang = "";
const Flowers = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__scopeId", "data-v-28d5ea85"], ["__file", "Flowers.vue"]]);
var p$3 = (r2, t2, i3) => {
  if (!t2.has(r2))
    throw TypeError("Cannot " + i3);
};
var e$2 = (r2, t2, i3) => (p$3(r2, t2, "read from private field"), i3 ? i3.call(r2) : t2.get(r2)), w$4 = (r2, t2, i3) => {
  if (t2.has(r2))
    throw TypeError("Cannot add the same private member more than once");
  t2 instanceof WeakSet ? t2.add(r2) : t2.set(r2, i3);
}, g$5 = (r2, t2, i3, s2) => (p$3(r2, t2, "write to private field"), s2 ? s2.call(r2, i3) : t2.set(r2, i3), i3);
const C$4 = 2147483647;
var n$3, d$4;
const u$4 = class u {
  constructor(t2, i3, s2, h2 = true) {
    w$4(this, n$3, void 0);
    w$4(this, d$4, void 0);
    g$5(this, n$3, {
      width: 0,
      height: 0
    });
    const {
      el: l2,
      ctx: o2
    } = u$4.initCanvas(t2);
    this.el = l2, this.ctx = o2, g$5(this, d$4, h2), this.size = {
      width: i3 || window.innerWidth,
      height: s2 || window.innerHeight
    };
  }
  get size() {
    return {
      ...e$2(this, n$3)
    };
  }
  set size({
    width: t2,
    height: i3
  }) {
    var h2;
    if (e$2(this, n$3).width === t2 && e$2(this, n$3).height === i3)
      return;
    e$2(this, n$3).width = t2, e$2(this, n$3).height = i3;
    const s2 = (h2 = e$2(this, d$4) ? window.devicePixelRatio : 1) != null ? h2 : 1;
    this.el.width = Math.round(e$2(this, n$3).width * s2), this.el.height = Math.round(e$2(this, n$3).height * s2), this.el.style.width = e$2(this, n$3).width + "px", this.el.style.height = e$2(this, n$3).height + "px", e$2(this, d$4) && this.ctx.scale(s2, s2);
  }
  clear() {
    u$4.clearCanvas(this.ctx, {
      ...e$2(this, n$3)
    });
  }
  to(t2) {
    t2.ctx.drawImage(this.el, 0, 0, e$2(this, n$3).width, e$2(this, n$3).height);
  }
  handleResize(t2) {
    this.size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  static setCanvasStyle(t2, i3, s2) {
    const h2 = t2.style, {
      zIndex: l2 = 0,
      opacity: o2 = 1
    } = i3;
    h2.position = "fixed", h2.top = "0", h2.left = "0", h2.zIndex = l2.toString(), h2.width = (s2 ? s2.width : t2.width).toString() + "px", h2.height = (s2 ? s2.height : t2.height).toString() + "px", o2 !== 1 && (h2.opacity = o2.toString()), h2.pointerEvents = "none";
  }
  static initCanvas(t2) {
    t2 || (t2 = document.createElement("canvas"));
    const i3 = t2.getContext("2d");
    return {
      el: t2,
      ctx: i3
    };
  }
  static createOffscreenCanvas() {
    return new u$4();
  }
  static clearCanvas(t2, i3) {
    const {
      width: s2,
      height: h2
    } = i3;
    t2.clearRect(0, 0, s2, h2);
  }
};
let x$3 = u$4;
n$3 = /* @__PURE__ */ new WeakMap(), d$4 = /* @__PURE__ */ new WeakMap();
var a$2, c$3;
let y$4 = class y {
  constructor(t2, i3, s2, h2 = true, l2 = true, o2 = {
    zIndex: 0,
    opacity: 1
  }) {
    w$4(this, a$2, void 0);
    w$4(this, c$3, void 0);
    g$5(this, a$2, new x$3(t2, i3, s2, h2)), x$3.setCanvasStyle(e$2(this, a$2).el, o2, {
      width: i3,
      height: s2
    }), g$5(this, c$3, l2 ? new x$3(void 0, i3, s2, h2) : null);
  }
  get size() {
    return e$2(this, a$2).size;
  }
  draw(t2) {
    var s2;
    const i3 = (s2 = e$2(this, c$3)) != null ? s2 : e$2(this, a$2);
    i3.clear(), t2(i3.ctx, {
      ...i3.size
    });
  }
  render() {
    !e$2(this, c$3) || (e$2(this, a$2).clear(), e$2(this, c$3).to(e$2(this, a$2)));
  }
  handleResize(t2) {
    e$2(this, a$2).handleResize(t2), e$2(this, c$3) && e$2(this, c$3).handleResize(t2);
  }
  clear() {
    e$2(this, a$2).clear(), e$2(this, c$3) && e$2(this, c$3).clear();
  }
};
a$2 = /* @__PURE__ */ new WeakMap(), c$3 = /* @__PURE__ */ new WeakMap();
var f$3 = (o2, t2, e2) => {
  if (!t2.has(o2))
    throw TypeError("Cannot " + e2);
};
var r$3 = (o2, t2, e2) => (f$3(o2, t2, "read from private field"), e2 ? e2.call(o2) : t2.get(o2)), h$2 = (o2, t2, e2) => {
  if (t2.has(o2))
    throw TypeError("Cannot add the same private member more than once");
  t2 instanceof WeakSet ? t2.add(o2) : t2.set(o2, e2);
}, d$3 = (o2, t2, e2, n2) => (f$3(o2, t2, "write to private field"), n2 ? n2.call(o2, e2) : t2.set(o2, e2), e2);
const p$2 = (o2) => typeof o2 == "string";
var s$1;
let M$2 = class M {
  constructor() {
    h$2(this, s$1, void 0);
    d$3(this, s$1, /* @__PURE__ */ new Map());
  }
  add(t2, e2, n2 = window) {
    r$3(this, s$1).has(n2) || r$3(this, s$1).set(n2, /* @__PURE__ */ new Map());
    const c2 = r$3(this, s$1).get(n2);
    c2.has(t2) || c2.set(t2, /* @__PURE__ */ new Set()), c2.get(t2).add(e2);
  }
  startAll() {
    for (const [t2, e2] of r$3(this, s$1))
      for (const [n2, c2] of e2)
        for (const a2 of c2)
          t2.addEventListener(n2, a2);
  }
  stopAll() {
    for (const [t2, e2] of r$3(this, s$1))
      for (const [n2, c2] of e2)
        for (const a2 of c2)
          t2.removeEventListener(n2, a2);
  }
  clear() {
    r$3(this, s$1).clear();
  }
};
s$1 = /* @__PURE__ */ new WeakMap();
function g$4() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function w$3(o2) {
  return !!o2.touches;
}
let i$2 = class i {
  static randomFloat(t2, e2) {
    return Math.random() * (e2 - t2) + t2;
  }
  static randomInt(t2, e2) {
    return Math.floor(i.randomFloat(t2, e2));
  }
  static choice(t2) {
    const e2 = t2.length, n2 = Math.floor(e2 * Math.random());
    return t2[n2];
  }
  static color(t2 = "0123456789ABCDEF") {
    return "#" + i.choice(t2) + i.choice(t2) + i.choice(t2) + i.choice(t2) + i.choice(t2) + i.choice(t2);
  }
};
function v$4(o2, {
  leftColor: t2 = "#fff",
  rightColor: e2 = "#444",
  leftBgColor: n2 = "#35495e",
  rightBgColor: c2 = "#00ffc0"
} = {}) {
  console.log(`%c ${o2} %c v0.5.2 112fa81 %c`, `background: ${n2}; padding: 2px; color: ${t2}; font-weight: bold; text-transform: uppercase;`, `background: ${c2}; padding: 2px; color: ${e2}; font-weight: bold; text-transform: uppercase;`, "background: transparent");
}
function l$3() {
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function b$4() {
  return !!l$3().matches;
}
var Y$1 = (r2, i3, h2) => {
  if (!i3.has(r2))
    throw TypeError("Cannot " + h2);
};
var t = (r2, i3, h2) => (Y$1(r2, i3, "read from private field"), h2 ? h2.call(r2) : i3.get(r2)), e$1 = (r2, i3, h2) => {
  if (i3.has(r2))
    throw TypeError("Cannot add the same private member more than once");
  i3 instanceof WeakSet ? i3.add(r2) : i3.set(r2, h2);
}, d$2 = (r2, i3, h2, s2) => (Y$1(r2, i3, "write to private field"), s2 ? s2.call(r2, h2) : i3.set(r2, h2), h2);
var l$2 = (r2, i3, h2) => (Y$1(r2, i3, "access private method"), h2);
var o$2, g$3, f$2;
let v$3 = class v {
  constructor(i3 = 0, h2 = 0, s2 = 0) {
    e$1(this, o$2, null);
    e$1(this, g$3, null);
    e$1(this, f$2, 50);
    this.x = i3, this.y = h2, this.z = s2;
  }
  bindGlobalSpeed(i3) {
    return d$2(this, o$2, i3), this;
  }
  bindColor(i3) {
    return d$2(this, g$3, i3), this;
  }
  reset(i3, h2 = false) {
    h2 || (this.x = Math.random() * i3.width, this.y = Math.random() * i3.height), this.z = 0.2 + Math.random() * 0.8;
  }
  move(i3) {
    let h2, s2, a2;
    if (this.x += t(this, o$2).x * this.z, this.y += t(this, o$2).y * this.z, this.x += (this.x - i3.width / 2) * t(this, o$2).z * this.z, this.y += (this.y - i3.height / 2) * t(this, o$2).z * this.z, this.z += t(this, o$2).z, this.x < -t(this, f$2) || this.x > i3.width + t(this, f$2) || this.y < -t(this, f$2) || this.y > i3.height + t(this, f$2))
      switch (h2 = "z", s2 = Math.abs(t(this, o$2).tx), a2 = Math.abs(t(this, o$2).ty), s2 > 1 && a2 > 1 && (h2 = (s2 > a2 ? Math.random() < Math.abs(t(this, o$2).x) / (s2 + a2) ? "h" : "v" : Math.random() < Math.abs(t(this, o$2).y) / (s2 + a2) ? "v" : "h") == "h" ? t(this, o$2).x > 0 ? "l" : "r" : t(this, o$2).y > 0 ? "t" : "b"), this.reset(i3, true), h2) {
        case "z":
          this.z = 0.1, this.x = Math.random() * i3.width, this.y = Math.random() * i3.height;
          break;
        case "l":
          this.x = -3, this.y = Math.random() * i3.height;
          break;
        case "r":
          this.x = i3.width + 3, this.y = Math.random() * i3.height;
          break;
        case "t":
          this.x = Math.random() * i3.width, this.y = -3;
          break;
        case "b":
          this.x = Math.random() * i3.width, this.y = i3.height + 3;
      }
  }
  draw(i3, h2) {
    i3.lineCap = "round", i3.lineWidth = 3 * this.z, i3.strokeStyle = t(this, g$3), i3.beginPath(), i3.moveTo(this.x, this.y);
    let s2 = 2 * t(this, o$2).x, a2 = 2 * t(this, o$2).y;
    Math.abs(s2) < 0.1 && (s2 = 0.5), Math.abs(a2) < 0.1 && (a2 = 0.5), i3.lineTo(this.x + s2, this.y + a2), i3.stroke();
  }
};
o$2 = /* @__PURE__ */ new WeakMap(), g$3 = /* @__PURE__ */ new WeakMap(), f$2 = /* @__PURE__ */ new WeakMap();
var M$1, y$3, w$2, u$3, c$2, b$3, n$2, p$1, x$2, m$3, P$2, L$3, T$2, R$2, A$2, O$2, H$2, V, B$2, j, k$2, q$1, z$2, C$3, F$2, I$1, W$3, J$2, X$2, K$2;
let et$1 = class et {
  constructor({
    numParticles: i3 = null,
    particleColor: h2 = "rgba(102, 175, 239, .2)"
  } = {}, s2 = {}) {
    e$1(this, P$2);
    e$1(this, T$2);
    e$1(this, A$2);
    e$1(this, H$2);
    e$1(this, B$2);
    e$1(this, k$2);
    e$1(this, z$2);
    e$1(this, F$2);
    e$1(this, W$3);
    e$1(this, X$2);
    e$1(this, M$1, void 0);
    e$1(this, y$3, void 0);
    e$1(this, w$2, void 0);
    e$1(this, u$3, null);
    e$1(this, c$2, /* @__PURE__ */ new Set());
    e$1(this, b$3, null);
    e$1(this, n$2, {
      x: 0,
      y: 0,
      tx: 0,
      ty: 0,
      z: 5e-4
    });
    e$1(this, p$1, false);
    e$1(this, x$2, false);
    e$1(this, m$3, new M$2());
    d$2(this, M$1, i3), p$2(h2) && (h2 = {
      light: h2,
      dark: h2
    }), d$2(this, y$3, h2), d$2(this, w$2, s2), this.animate = this.animate.bind(this);
  }
  mount(i3) {
    d$2(this, x$2, false), d$2(this, u$3, new y$4(i3, window.innerWidth, window.innerHeight, true, true, t(this, w$2))), l$2(this, P$2, L$3).call(this), l$2(this, B$2, j).call(this), l$2(this, A$2, O$2).call(this), v$4("Theme Meteor 🌠", {
      leftBgColor: "#66afe0"
    });
  }
  unmount() {
    l$2(this, H$2, V).call(this), l$2(this, T$2, R$2).call(this), d$2(this, x$2, true), d$2(this, b$3, null);
  }
  animate(i3) {
    if (t(this, x$2)) {
      t(this, u$3).clear();
      return;
    }
    if (requestAnimationFrame(this.animate), !t(this, p$1)) {
      t(this, n$2).tx *= 0.95, t(this, n$2).ty *= 0.95, t(this, n$2).x += 0.7 * (t(this, n$2).tx - t(this, n$2).x), t(this, n$2).y += 0.7 * (t(this, n$2).ty - t(this, n$2).y);
      for (const h2 of t(this, c$2))
        h2.move(t(this, u$3).size);
      t(this, u$3).draw((h2, s2) => {
        for (const a2 of t(this, c$2))
          a2.draw(h2, i3);
      }), t(this, u$3).render();
    }
  }
};
M$1 = /* @__PURE__ */ new WeakMap(), y$3 = /* @__PURE__ */ new WeakMap(), w$2 = /* @__PURE__ */ new WeakMap(), u$3 = /* @__PURE__ */ new WeakMap(), c$2 = /* @__PURE__ */ new WeakMap(), b$3 = /* @__PURE__ */ new WeakMap(), n$2 = /* @__PURE__ */ new WeakMap(), p$1 = /* @__PURE__ */ new WeakMap(), x$2 = /* @__PURE__ */ new WeakMap(), m$3 = /* @__PURE__ */ new WeakMap(), P$2 = /* @__PURE__ */ new WeakSet(), L$3 = function() {
  var s2;
  const i3 = (s2 = t(this, M$1)) != null ? s2 : (window.innerWidth + window.innerHeight) / 8, h2 = b$4() ? t(this, y$3).dark : t(this, y$3).light;
  for (let a2 = 0; a2 < i3; a2++) {
    const D2 = new v$3(0, 0, 0).bindColor(h2).bindGlobalSpeed(t(this, n$2));
    D2.reset(t(this, u$3).size, false), t(this, c$2).add(D2);
  }
}, T$2 = /* @__PURE__ */ new WeakSet(), R$2 = function() {
  t(this, c$2).clear();
}, A$2 = /* @__PURE__ */ new WeakSet(), O$2 = function() {
  g$4() ? (t(this, m$3).add("touchmove", l$2(this, k$2, q$1).bind(this)), t(this, m$3).add("touchend", l$2(this, z$2, C$3).bind(this))) : (t(this, m$3).add("mousemove", l$2(this, k$2, q$1).bind(this)), t(this, m$3).add("mouseleave", l$2(this, z$2, C$3).bind(this))), t(this, m$3).add("visibilitychange", l$2(this, X$2, K$2).bind(this)), t(this, m$3).add("change", l$2(this, W$3, J$2).bind(this), l$3()), t(this, m$3).add("resize", r$6(l$2(this, F$2, I$1).bind(this), 500)), t(this, m$3).startAll();
}, H$2 = /* @__PURE__ */ new WeakSet(), V = function() {
  t(this, m$3).stopAll(), t(this, m$3).clear();
}, B$2 = /* @__PURE__ */ new WeakSet(), j = function() {
  requestAnimationFrame(this.animate);
}, k$2 = /* @__PURE__ */ new WeakSet(), q$1 = function(i3) {
  const h2 = {
    x: w$3(i3) ? i3.touches[0].clientX : i3.clientX,
    y: w$3(i3) ? i3.touches[0].clientY : i3.clientY
  };
  if (t(this, b$3)) {
    const s2 = {
      x: h2.x - t(this, b$3).x,
      y: h2.y - t(this, b$3).y
    };
    t(this, n$2).tx = t(this, n$2).x + s2.x / 8, t(this, n$2).ty = t(this, n$2).y + s2.y / 8;
  }
  d$2(this, b$3, h2);
}, z$2 = /* @__PURE__ */ new WeakSet(), C$3 = function(i3) {
  d$2(this, b$3, null);
}, F$2 = /* @__PURE__ */ new WeakSet(), I$1 = function(i3) {
  t(this, u$3).handleResize(i3);
  for (const h2 of t(this, c$2))
    h2.reset(t(this, u$3).size, false);
}, W$3 = /* @__PURE__ */ new WeakSet(), J$2 = function(i3) {
  const h2 = b$4() ? t(this, y$3).dark : t(this, y$3).light;
  for (const s2 of t(this, c$2))
    s2.bindColor(h2);
}, X$2 = /* @__PURE__ */ new WeakSet(), K$2 = function(i3) {
  d$2(this, p$1, document.hidden);
};
const _sfc_main$b = {
  name: "Meteor",
  props: {
    numParticles: {
      type: Number,
      default: null
    },
    zIndex: {
      type: Number,
      default: -C$4
    }
  },
  mounted() {
    const themeConfig = {
      numParticles: this.numParticles,
      particleColor: {
        light: "rgba(191, 230, 226, .2)",
        dark: "rgba(191, 230, 226, .2)"
      }
    };
    const canvasOptions = {
      opacity: 1,
      zIndex: this.zIndex
    };
    const meteor = new et$1(themeConfig, canvasOptions);
    const el = this.$refs.canvas;
    meteor.mount(el);
  }
};
const _hoisted_1$7 = {
  ref: "canvas",
  id: "theme-meteor"
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "canvas",
    _hoisted_1$7,
    null,
    512
    /* NEED_PATCH */
  );
}
const Meteor = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$9], ["__file", "Meteor.vue"]]);
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string")
    throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(r$2(x2, 2), 16)), parseInt(r$2(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h2, s2, l2, a2] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s2) !== s2)
      throw new ColorError$1(color);
    if (guard(0, 100, l2) !== l2)
      throw new ColorError$1(color);
    return [...hslToRgb(h2, s2, l2), Number.isNaN(a2) ? 1 : a2];
  }
  throw new ColorError$1(color);
}
function hash(str) {
  let hash2 = 5381;
  let i3 = str.length;
  while (i3) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i3);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt = (x2) => parseInt(x2.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16);
  let prefix = "";
  for (let i3 = 0; i3 < 6 - hex.length; i3++) {
    prefix += "0";
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color);
  return `#${result}`;
}
const r$2 = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
const reducedHexRegex = new RegExp(`^#${r$2("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex = new RegExp(`^#${r$2("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r$2(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color) => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l2 = lightness / 100;
  if (saturation === 0) {
    return [l2, l2, l2].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l2 - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l2 - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function rgba(red, green, blue, alpha) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}
function transparentize(color, amount) {
  const [r2, g2, b2, a2] = parseToRgba(color);
  return rgba(r2, g2, b2, a2 - amount);
}
function opacify(color, amount) {
  return transparentize(color, -amount);
}
var J$1 = (n2, t2, s2) => {
  if (!t2.has(n2))
    throw TypeError("Cannot " + s2);
};
var i$1 = (n2, t2, s2) => (J$1(n2, t2, "read from private field"), s2 ? s2.call(n2) : t2.get(n2)), h$1 = (n2, t2, s2) => {
  if (t2.has(n2))
    throw TypeError("Cannot add the same private member more than once");
  t2 instanceof WeakSet ? t2.add(n2) : t2.set(n2, s2);
}, e = (n2, t2, s2, p2) => (J$1(n2, t2, "write to private field"), p2 ? p2.call(n2, s2) : t2.set(n2, s2), s2);
var l$1 = (n2, t2, s2) => (J$1(n2, t2, "access private method"), s2);
function ai(n2, t2, s2) {
  return (n2 - t2) / (s2 - t2);
}
var y$2, w$1, b$2, x$1, g$2, A$1, S$2, F$1, k$1, c$1;
class ri {
  constructor(t2 = 0, s2 = {
    x: 0,
    y: 0
  }, p2 = i$2.randomInt(50, 500), f2 = i$2.randomInt(40, 100), V2 = i$2.randomFloat(0, Math.PI * 2), j2 = i$2.randomInt(1, 3), G2 = i$2.choice(["yellow", "pink", "red", "orange", "purple", "cyan"])) {
    h$1(this, y$2, void 0);
    h$1(this, w$1, void 0);
    h$1(this, b$2, void 0);
    h$1(this, x$1, void 0);
    h$1(this, g$2, void 0);
    h$1(this, A$1, void 0);
    h$1(this, S$2, void 0);
    h$1(this, F$1, void 0);
    h$1(this, k$1, 1);
    h$1(this, c$1, void 0);
    e(this, y$2, t2), e(this, w$1, s2), e(this, b$2, p2), e(this, x$1, f2), e(this, g$2, V2), e(this, A$1, j2), e(this, S$2, G2), e(this, F$1, {
      x: Math.cos(i$1(this, g$2)) * i$1(this, x$1),
      y: Math.sin(i$1(this, g$2)) * i$1(this, x$1)
    }), e(this, c$1, {
      ...i$1(this, w$1)
    });
  }
  move(t2) {
    const s2 = ai(t2, i$1(this, y$2), i$1(this, y$2) + i$1(this, b$2));
    i$1(this, c$1).x = i$1(this, w$1).x + i$1(this, F$1).x * s2, i$1(this, c$1).y = i$1(this, w$1).y + i$1(this, F$1).y * s2, e(this, k$1, 1 - s2);
  }
  draw(t2, s2) {
    t2.fillStyle = opacify(i$1(this, S$2), i$1(this, k$1)), t2.beginPath(), t2.arc(i$1(this, c$1).x, i$1(this, c$1).y, i$1(this, A$1), 0, Math.PI * 2), t2.fill();
  }
  shouldRemove(t2) {
    return t2 > i$1(this, y$2) + i$1(this, b$2);
  }
}
y$2 = /* @__PURE__ */ new WeakMap(), w$1 = /* @__PURE__ */ new WeakMap(), b$2 = /* @__PURE__ */ new WeakMap(), x$1 = /* @__PURE__ */ new WeakMap(), g$2 = /* @__PURE__ */ new WeakMap(), A$1 = /* @__PURE__ */ new WeakMap(), S$2 = /* @__PURE__ */ new WeakMap(), F$1 = /* @__PURE__ */ new WeakMap(), k$1 = /* @__PURE__ */ new WeakMap(), c$1 = /* @__PURE__ */ new WeakMap();
var li = /* @__PURE__ */ ((n2) => (n2.FOLLOW = "follow", n2.TRAIL = "trail", n2))(li || {}), D$1, X$1, o$1, P$1, R$1, z$1, Y, u$2, m$2, a$1, I, v$2, M2, r$1, E$2, $, T$1, C$2, B$1, K$1, H$1, Q$1, L$2, Z$1, O$1, _$1, W$2, N, U$1, ii;
class fi {
  constructor({
    mode: t2 = "trail",
    numParticles: s2 = 20,
    sparkleFactor: p2 = 1,
    particleDurationRange: f2 = [50, 500],
    particleDistanceRange: V2 = [40, 100],
    particleSizeRange: j2 = [1, 3]
  } = {}, G2 = {}) {
    h$1(this, E$2);
    h$1(this, T$1);
    h$1(this, B$1);
    h$1(this, H$1);
    h$1(this, L$2);
    h$1(this, O$1);
    h$1(this, W$2);
    h$1(this, U$1);
    h$1(this, D$1, void 0);
    h$1(this, X$1, void 0);
    h$1(this, o$1, void 0);
    h$1(this, P$1, void 0);
    h$1(this, R$1, void 0);
    h$1(this, z$1, void 0);
    h$1(this, Y, void 0);
    h$1(this, u$2, null);
    h$1(this, m$2, /* @__PURE__ */ new Set());
    h$1(this, a$1, null);
    h$1(this, I, void 0);
    h$1(this, v$2, false);
    h$1(this, M2, false);
    h$1(this, r$1, new M$2());
    e(this, D$1, t2), e(this, X$1, s2), e(this, o$1, p2), e(this, P$1, f2), e(this, R$1, V2), e(this, z$1, j2), e(this, I, i$1(this, o$1)), e(this, Y, G2), this.animate = this.animate.bind(this);
  }
  mount(t2) {
    e(this, M2, false), e(this, u$2, new y$4(t2, window.innerWidth, window.innerHeight, true, true, i$1(this, Y))), l$1(this, E$2, $).call(this), v$4("Theme Sparkler 🎇", {
      leftBgColor: "#989900"
    });
  }
  unmount() {
    l$1(this, T$1, C$2).call(this), e(this, M2, true), e(this, a$1, null);
  }
  animate(t2) {
    if (i$1(this, M2)) {
      i$1(this, u$2).clear();
      return;
    }
    if (requestAnimationFrame(this.animate), !i$1(this, v$2)) {
      for (const s2 of i$1(this, m$2))
        s2.move(t2);
      for (i$1(this, u$2).draw((s2, p2) => {
        for (const f2 of i$1(this, m$2))
          f2.draw(s2, t2), f2.shouldRemove(t2) && i$1(this, m$2).delete(f2);
      }), i$1(this, u$2).render(); i$1(this, m$2).size < i$1(this, X$1); )
        i$1(this, m$2).add(new ri(t2 + i$2.randomInt(0, 300 / i$1(this, o$1)), i$1(this, D$1) === "trail" ? {
          ...i$1(this, a$1)
        } : i$1(this, a$1), i$2.randomFloat(i$1(this, P$1)[0], i$1(this, P$1)[1] / i$1(this, o$1)), i$2.randomFloat(i$1(this, R$1)[0], i$1(this, R$1)[1] * (i$1(this, o$1) === 1 ? 1 : i$1(this, o$1) / 3)), i$2.randomFloat(0, Math.PI * 2), i$2.randomInt(i$1(this, z$1)[0], i$1(this, z$1)[1] * (i$1(this, o$1) === 1 ? 1 : i$1(this, o$1) / 3)), i$2.choice(["yellow", "pink", "red", "orange", "purple", "cyan"])));
    }
  }
}
D$1 = /* @__PURE__ */ new WeakMap(), X$1 = /* @__PURE__ */ new WeakMap(), o$1 = /* @__PURE__ */ new WeakMap(), P$1 = /* @__PURE__ */ new WeakMap(), R$1 = /* @__PURE__ */ new WeakMap(), z$1 = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), u$2 = /* @__PURE__ */ new WeakMap(), m$2 = /* @__PURE__ */ new WeakMap(), a$1 = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), v$2 = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), r$1 = /* @__PURE__ */ new WeakMap(), E$2 = /* @__PURE__ */ new WeakSet(), $ = function() {
  g$4() ? (i$1(this, r$1).add("touchstart", l$1(this, L$2, Z$1).bind(this)), i$1(this, r$1).add("touchmove", l$1(this, H$1, Q$1).bind(this)), i$1(this, r$1).add("touchend", l$1(this, O$1, _$1).bind(this))) : (i$1(this, r$1).add("mousedown", l$1(this, L$2, Z$1).bind(this)), i$1(this, r$1).add("mousemove", l$1(this, H$1, Q$1).bind(this)), i$1(this, r$1).add("mouseup", l$1(this, O$1, _$1).bind(this))), i$1(this, r$1).add("visibilitychange", l$1(this, U$1, ii).bind(this)), i$1(this, r$1).add("resize", r$6(l$1(this, W$2, N).bind(this), 500)), i$1(this, r$1).startAll();
}, T$1 = /* @__PURE__ */ new WeakSet(), C$2 = function() {
  i$1(this, r$1).stopAll(), i$1(this, r$1).clear();
}, B$1 = /* @__PURE__ */ new WeakSet(), K$1 = function() {
  requestAnimationFrame(this.animate);
}, H$1 = /* @__PURE__ */ new WeakSet(), Q$1 = function(t2) {
  const s2 = {
    x: w$3(t2) ? t2.touches[0].clientX : t2.clientX,
    y: w$3(t2) ? t2.touches[0].clientY : t2.clientY
  };
  if (!i$1(this, a$1)) {
    e(this, a$1, {
      x: s2.x,
      y: s2.y
    }), l$1(this, B$1, K$1).call(this);
    return;
  }
  i$1(this, a$1).x = s2.x, i$1(this, a$1).y = s2.y;
}, L$2 = /* @__PURE__ */ new WeakSet(), Z$1 = function(t2) {
  const s2 = {
    x: w$3(t2) ? t2.touches[0].clientX : t2.clientX,
    y: w$3(t2) ? t2.touches[0].clientY : t2.clientY
  };
  i$1(this, a$1) || (e(this, a$1, {
    x: s2.x,
    y: s2.y
  }), l$1(this, B$1, K$1).call(this)), i$1(this, a$1).x = s2.x, i$1(this, a$1).y = s2.y, i$1(this, o$1) === i$1(this, I) && e(this, o$1, i$1(this, o$1) * 4);
}, O$1 = /* @__PURE__ */ new WeakSet(), _$1 = function(t2) {
  e(this, o$1, i$1(this, I));
}, W$2 = /* @__PURE__ */ new WeakSet(), N = function(t2) {
  i$1(this, u$2).handleResize(t2);
}, U$1 = /* @__PURE__ */ new WeakSet(), ii = function(t2) {
  e(this, v$2, document.hidden);
};
const _sfc_main$a = {
  name: "Sparkler",
  props: {
    mode: {
      type: String,
      default: li.TRAIL
    },
    numParticles: {
      type: Number,
      default: 20
    },
    zIndex: {
      type: Number,
      default: C$4
    }
  },
  mounted() {
    const themeConfig = {
      mode: this.mode,
      numParticles: this.numParticles
    };
    const canvasOptions = {
      opacity: 0.6,
      zIndex: this.zIndex
    };
    const sparkler = new fi(themeConfig, canvasOptions);
    const el = this.$refs.canvas;
    sparkler.mount(el);
  }
};
const _hoisted_1$6 = {
  ref: "canvas",
  id: "theme-sparkler"
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "canvas",
    _hoisted_1$6,
    null,
    512
    /* NEED_PATCH */
  );
}
const Sparkler = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$8], ["__file", "Sparkler.vue"]]);
const _sfc_main$9 = {
  props: {
    transitionName: {
      type: String,
      default: "fade"
    },
    textList: {
      type: Array,
      required: true
    },
    duration: {
      type: [Number, Array],
      default: 0
    }
  },
  emits: {
    tick: () => true,
    loop: () => true,
    over: () => true
  },
  setup(props) {
    const index2 = ref(0);
    const {
      textList,
      duration
    } = toRefs(props);
    const period = ref(null);
    const resDuration = computed(() => {
      const d2 = duration.value;
      if (typeof d2 === "number" && d2 <= 0 || Array.isArray(d2) && !d2.length)
        return textList.value.map((txt) => Math.log2((txt.length || 1) + 1) * 0.8);
      return d2;
    });
    const curDuration = computed(() => {
      const d2 = resDuration.value, i3 = index2.value;
      if (typeof d2 === "number")
        return d2;
      else {
        const dlen = d2.length;
        return d2[Math.min(i3, dlen - 1)];
      }
    });
    const curDurationStr = computed(() => {
      return `${curDuration.value}s`;
    });
    return {
      index: index2,
      period,
      curDuration,
      curDurationStr
    };
  },
  mounted() {
    this.start();
  },
  methods: {
    start() {
      const len = this.textList.length;
      const tick = () => {
        this.clear(false);
        this.$emit("tick");
        if (this.index + 1 >= len) {
          this.$emit("loop");
        }
        this.index = (this.index + 1) % len;
        this.period = setTimeout(tick, this.curDuration * 1e3);
      };
      this.index = 0;
      this.period = setTimeout(tick, this.curDuration * 1e3);
    },
    clear(emit = true) {
      if (this.period) {
        clearTimeout(this.period);
      }
      if (emit) {
        this.$emit("over");
      }
    }
  }
};
const AnimatedText_vue_vue_type_style_index_0_scoped_1ac80f97_lang = "";
const _hoisted_1$5 = {
  class: "trs-text"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: $props.transitionName,
    style: normalizeStyle({
      "--dura": $setup.curDurationStr
    })
  }, {
    default: withCtx(() => [(openBlock(), createElementBlock("div", {
      class: "animated-text",
      key: $setup.index
    }, [createElementVNode(
      "div",
      _hoisted_1$5,
      toDisplayString($props.textList[$setup.index]),
      1
      /* TEXT */
    )]))]),
    _: 1
    /* STABLE */
  }, 8, ["name", "style"]);
}
const AnimatedText = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$7], ["__scopeId", "data-v-1ac80f97"], ["__file", "AnimatedText.vue"]]);
const _hoisted_1$4 = {
  key: 0,
  class: "banner-brand__mask"
};
const _hoisted_2$2 = {
  key: 3,
  class: "banner-brand__content"
};
const _hoisted_3$2 = {
  class: "banner-brand__hero-image"
};
const _hoisted_4$1 = ["src"];
const _hoisted_5$1 = {
  key: 0,
  class: "banner-brand__hero-tagline"
};
const _hoisted_6$1 = {
  class: "typing-text"
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "MyBanner",
  setup(__props) {
    const frontmatter = usePageFrontmatter();
    const isPC = ref(false);
    const animatedText = ref(["江作青罗带 山如碧玉簪", "美如画廊的峰丛\n却是饱受石穿之灾的大地", "「八树」缠根此间\n汲走流洪 化解石荒", "歌舞升平间\n危机悄然降临", "你又该如何去守护\n这即将被溶没的音符呢？"]);
    const kana = ref(["ハッ", "ケイ", "せ", "かい", "の", "うた", "ひめ"]);
    const pinyin = ref(["Bā", "Guì", "Shì", "Jiè", "De", "Gē", "Jī"]);
    const bg = ref();
    const bgHeight = ref(0);
    const bgfar = ref();
    const bgnear = ref();
    const mode = ref(null);
    const animationOver = ref(false);
    onBeforeMount(() => {
      isPC.value = isMobile(window) === false;
    });
    onMounted(() => {
      const toggleBtns = document.querySelectorAll(".btn-toggle-dark-mode");
      mode.value = localStorage.getItem(APPEARANCE_KEY);
      toggleBtns.forEach((e2) => e2.addEventListener("click", () => {
        const event = new StorageEvent("toggleMode", {
          newValue: localStorage.getItem(APPEARANCE_KEY)
        });
        window.dispatchEvent(event);
      }));
      window.addEventListener("toggleMode", (e2) => {
        mode.value = e2.newValue;
      });
      bgHeight.value = getAbsolutePos(bg.value).height;
      window.addEventListener("resize", () => {
        bgHeight.value = getAbsolutePos(bg.value).height;
      });
      const bgMove = (e2, [fwr, fhr] = [5e-3, 4e-3], [nwr, nhr] = [0.02, 0.012]) => {
        if (!bgfar.value || !bgnear.value)
          return;
        if (!inViewport(bgfar.value) && !inViewport(bgnear.value))
          return;
        const {
          pageX: x2,
          pageY: y3
        } = e2;
        const {
          x: fx,
          y: fy,
          width: fw,
          height: fh
        } = getAbsolutePos(bgfar.value);
        const {
          x: nx,
          y: ny,
          width: nw,
          height: nh
        } = getAbsolutePos(bgnear.value);
        const ftx = (x2 - fx - fw / 2) * fwr, fty = (y3 - fy - fh / 2) * fhr;
        const ntx = (x2 - nx - nw / 2) * nwr, nty = (y3 - ny - nh / 2) * nhr;
        bgfar.value.style.setProperty("--tl", `translate(${ftx}px, ${fty}px)`);
        bgnear.value.style.setProperty("--tl", `translate(${ntx}px, ${nty}px)`);
      };
      if (isPC.value) {
        window.addEventListener("mousemove", throttle$1((e2) => bgMove(e2, [5e-3, 4e-3], [0.02, 0.012]), 100));
      }
    });
    const isDarkMode = computed(() => {
      console.log(mode.value);
      if (!mode.value || mode.value === "auto") {
        return window.matchMedia(PREFER_SCHEME_MEDIAKEY).matches;
      }
      return mode.value === "dark";
    });
    const heroImage = computed(() => {
      var _a3, _b2, _c, _d;
      return ((_b2 = (_a3 = frontmatter.value) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroImage) ? withBase((_d = (_c = frontmatter.value) == null ? void 0 : _c.banner) == null ? void 0 : _d.heroImage) : void 0;
    });
    const heroImageStyle = computed(() => frontmatter.value.banner.heroImageStyle || {});
    const bgImageStyle = computed(() => {
      var _a3;
      const {
        bgImageStyle: bgImageStyle2,
        bgImage,
        bgImageDark
      } = ((_a3 = frontmatter.value) == null ? void 0 : _a3.banner) || {};
      const image = isDarkMode.value && bgImageDark ? bgImageDark : bgImage;
      const asImage = (layer) => image.replace(".", "-" + layer + ".");
      const initBgImageStyle = image ? {
        textAlign: "center",
        overflow: "hidden",
        "--background": `url(${withBase(image)})`,
        "--background-sky": `url(${withBase(asImage("sky"))})`,
        "--background-far": `url(${withBase(asImage("far"))})`,
        "--background-near": `url(${withBase(asImage("near"))})`
      } : {};
      return bgImageStyle2 ? {
        ...initBgImageStyle,
        ...bgImageStyle2
      } : initBgImageStyle;
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e2, _f;
      const _component_xicons = resolveComponent("xicons");
      return openBlock(), createElementBlock(
        "section",
        {
          ref_key: "bg",
          ref: bg,
          class: normalizeClass(["banner-wrapper", {
            pc: isPC.value
          }]),
          style: normalizeStyle(bgImageStyle.value)
        },
        [isPC.value ? (openBlock(), createElementBlock(
          "div",
          {
            key: 0,
            ref_key: "bgfar",
            ref: bgfar,
            class: "banner-bg far"
          },
          null,
          512
          /* NEED_PATCH */
        )) : createCommentVNode("v-if", true), isPC.value ? (openBlock(), createElementBlock(
          "div",
          {
            key: 1,
            ref_key: "bgnear",
            ref: bgnear,
            class: "banner-bg near"
          },
          null,
          512
          /* NEED_PATCH */
        )) : createCommentVNode("v-if", true), createVNode(Transition, {
          name: "fade-slowly"
        }, {
          default: withCtx(() => [!animationOver.value ? (openBlock(), createElementBlock("div", _hoisted_1$4, [createVNode(_component_xicons, {
            icon: "Redo",
            class: "skip-btn",
            "text-size": 15,
            onClick: _cache[0] || (_cache[0] = ($event) => animationOver.value = true)
          }, {
            default: withCtx(() => [createTextVNode(" 跳过 ")]),
            _: 1
            /* STABLE */
          })])) : createCommentVNode("v-if", true)]),
          _: 1
          /* STABLE */
        }), !animationOver.value ? (openBlock(), createBlock(AnimatedText, {
          key: 2,
          class: "banner-brand__animated-text",
          "text-list": animatedText.value,
          onLoop: _cache[1] || (_cache[1] = ($event) => animationOver.value = true)
        }, null, 8, ["text-list"])) : (openBlock(), createElementBlock("div", _hoisted_2$2, [createElementVNode("div", _hoisted_3$2, [heroImage.value ? (openBlock(), createElementBlock("img", {
          key: 0,
          src: heroImage.value,
          style: normalizeStyle(heroImageStyle.value),
          alt: "heroImage"
        }, null, 12, _hoisted_4$1)) : createCommentVNode("v-if", true)]), createElementVNode("div", null, [createVNode(HeroText, {
          text: (_b2 = (_a3 = unref(frontmatter)) == null ? void 0 : _a3.banner) == null ? void 0 : _b2.heroText,
          "dark-mode": isDarkMode.value,
          ruby: {
            light: pinyin.value,
            dark: kana.value
          }
        }, null, 8, ["text", "dark-mode", "ruby"]), ((_d = (_c = unref(frontmatter)) == null ? void 0 : _c.banner) == null ? void 0 : _d.tagline) ? (openBlock(), createElementBlock("p", _hoisted_5$1, [createElementVNode(
          "div",
          _hoisted_6$1,
          toDisplayString((_f = (_e2 = unref(frontmatter)) == null ? void 0 : _e2.banner) == null ? void 0 : _f.tagline),
          1
          /* TEXT */
        )])) : createCommentVNode("v-if", true)]), createVNode(DownIcon, {
          "scroll-to": bgHeight.value
        }, null, 8, ["scroll-to"])])), isDarkMode.value ? (openBlock(), createBlock(unref(Meteor), {
          key: 4,
          "num-particles": isPC.value ? null : 15,
          "z-index": 3
        }, null, 8, ["num-particles"])) : (openBlock(), createBlock(unref(Sparkler), {
          key: 5,
          "num-particles": isPC.value ? 10 : 5
        }, null, 8, ["num-particles"])), createVNode(unref(WindBase), null, {
          default: withCtx(({
            strength,
            direction: direction2
          }) => [!isDarkMode.value ? (openBlock(), createBlock(unref(Flowers), {
            key: 0,
            "wind-strength": strength,
            "wind-angle": direction2
          }, null, 8, ["wind-strength", "wind-angle"])) : createCommentVNode("v-if", true)]),
          _: 1
          /* STABLE */
        })],
        6
        /* CLASS, STYLE */
      );
    };
  }
});
const MyBanner_vue_vue_type_style_index_0_lang = "";
const MyBanner = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__file", "MyBanner.vue"]]);
const _sfc_main$7 = {
  props: {
    show: {
      type: Boolean,
      default: true
    }
  }
};
const MidText_vue_vue_type_style_index_0_scoped_cc3365c8_lang = "";
const _withScopeId = (n2) => (pushScopeId("data-v-cc3365c8"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3 = {
  class: "sup",
  key: "sup"
};
const _hoisted_2$1 = {
  class: "title",
  key: "title"
};
const _hoisted_3$1 = {
  class: "content",
  key: "content"
};
const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  "OC：一个以壮侗系文化为背景的二次元幻想世界 ×",
  -1
  /* HOISTED */
));
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  "一些关于壮侗文化风格的见闻和研究 ×",
  -1
  /* HOISTED */
));
const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  "一些前后端应用和游戏开发技术心得 ×",
  -1
  /* HOISTED */
));
const _hoisted_7 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  "一些板绘渣作练习 ×",
  -1
  /* HOISTED */
));
const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode(
  "li",
  null,
  "一点随心的想法与脑洞、还有牢骚 ×",
  -1
  /* HOISTED */
));
const _hoisted_9 = [_hoisted_4, _hoisted_5, _hoisted_6, _hoisted_7, _hoisted_8];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    name: "fade-right-in"
  }, {
    default: withCtx(() => [$props.show ? (openBlock(), createElementBlock("div", _hoisted_1$3, " 欢迎来到我的个人博客！ ")) : createCommentVNode("v-if", true), $props.show ? (openBlock(), createElementBlock("div", _hoisted_2$1, " 在这里，你将了解到 ")) : createCommentVNode("v-if", true), $props.show ? (openBlock(), createElementBlock("ul", _hoisted_3$1, _hoisted_9)) : createCommentVNode("v-if", true)]),
    _: 1
    /* STABLE */
  });
}
const MidText = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$6], ["__scopeId", "data-v-cc3365c8"], ["__file", "MidText.vue"]]);
const _hoisted_1$2 = ["src"];
const _hoisted_2 = ["src"];
const _hoisted_3 = {
  class: "mid-banner__content"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "MidBanner",
  setup(__props) {
    const imageCache = useImageCache();
    const wrapperRef = ref(null);
    const back0x = ref(-200);
    const back1x = ref(350);
    const back2x = ref(500);
    const back3x = ref(1e3);
    const back4x = ref(-1100);
    const groundx = ref(0);
    const towerbr = ref(100);
    const lighto = ref(0.5);
    const showContent = ref(false);
    const nana = reactive({
      index: 0,
      tx: -280,
      opacity: 1
    });
    const nanaImg = computed(() => {
      return imageCache[`/images/Ma-${nana.index}.png`].value;
    });
    const tianjiu = reactive({
      tx: -120,
      opacity: 1
    });
    const tianjiuImg = computed(() => {
      return imageCache["/images/Tianjiu_0.png"].value;
    });
    const normalize = (x2, max2, min2 = 0) => (x2 - min2) / (max2 - min2);
    let itv = null;
    let stop = false;
    function onScroll(e2) {
      if (wrapperRef.value === null || !inViewport(wrapperRef.value))
        return;
      const {
        floor: f2,
        min: min2
      } = Math;
      const {
        y: y3,
        height
      } = getAbsolutePos(wrapperRef.value);
      const scroll = this.scrollY + this.innerHeight;
      const init = y3, dest = y3 + height;
      const diff = scroll - y3;
      const rate = 1 - normalize(diff, dest - init);
      if (rate > 0 && rate < 1) {
        back0x.value = f2(-200 - 150 * rate ** 1.5);
        back1x.value = f2(350 - 300 * rate ** 1.5);
        back2x.value = f2(500 - 450 * rate ** 1.5);
        back3x.value = f2(1e3 - 600 * rate ** 1.5);
        back4x.value = f2(-1100 + 800 * rate ** 1.5);
        towerbr.value = f2(100 - rate * 95);
        lighto.value = f2(0.5 - rate * 0.5);
      }
      showContent.value = rate < 0.2;
      if (rate > 0 && !stop) {
        nana.tx = f2(-280 - 800 * rate);
        nana.opacity = 1 - rate;
        showContent.value = false;
      } else {
        stop = true;
        if (itv)
          setTimeout(() => {
            itv && clearInterval(itv);
            itv = null;
            nana.index = 0;
          }, 2e3);
      }
    }
    onMounted(() => {
      window.addEventListener("scroll", onScroll);
      itv = setInterval(() => nana.index = (nana.index + 1) % 5, 300);
    });
    onUnmounted(() => {
      window.removeEventListener("scroll", onScroll);
      if (itv)
        clearInterval(itv);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "section",
        {
          ref_key: "wrapperRef",
          ref: wrapperRef,
          class: "mid-banner-wrapper",
          style: normalizeStyle({
            "--tx": `${back0x.value}px`
          })
        },
        [createElementVNode(
          "div",
          {
            class: "mid-banner__bg back1",
            style: normalizeStyle({
              "--tx": `${back1x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg back2",
            style: normalizeStyle({
              "--tx": `${back2x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg tower",
            style: normalizeStyle({
              "--ft": `${towerbr.value}%`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg back3",
            style: normalizeStyle({
              "--tx": `${back3x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg back4",
            style: normalizeStyle({
              "--tx": `${back4x.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg light",
            style: normalizeStyle({
              "--o": `${lighto.value}%`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode(
          "div",
          {
            class: "mid-banner__bg ground",
            style: normalizeStyle({
              "--tx": `${groundx.value}px`
            })
          },
          null,
          4
          /* STYLE */
        ), createElementVNode("img", {
          class: "mid-banner__char nana",
          src: nanaImg.value,
          style: normalizeStyle({
            "--tx": `${nana.tx}px`,
            "--o": nana.opacity
          })
        }, null, 12, _hoisted_1$2), createElementVNode("img", {
          class: "mid-banner__char tianjiu",
          src: tianjiuImg.value,
          style: normalizeStyle({
            "--tx": `${tianjiu.tx}px`,
            "--o": tianjiu.opacity
          })
        }, null, 12, _hoisted_2), createElementVNode("div", _hoisted_3, [createVNode(MidText, {
          show: showContent.value
        }, null, 8, ["show"])])],
        4
        /* STYLE */
      );
    };
  }
});
const MidBanner_vue_vue_type_style_index_0_scoped_73bc421e_lang = "";
const MidBanner = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__scopeId", "data-v-73bc421e"], ["__file", "MidBanner.vue"]]);
const _sfc_main$5 = {
  components: {
    Xicons
  },
  name: "Message",
  props: {
    text: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      // warn 警告  error 错误  success 成功 info 消息
      default: "warn"
    },
    delay: {
      type: Number,
      default: 3e3
    }
  },
  setup() {
    const style2 = {
      info: {
        icon: "Information"
      },
      warn: {
        icon: "Warning",
        color: "#E6A23C",
        backgroundColor: "rgb(253, 246, 236)",
        borderColor: "rgb(250, 236, 216)"
      },
      error: {
        icon: "Error",
        color: "#F56C6C",
        backgroundColor: "rgb(254, 240, 240)",
        borderColor: "rgb(253, 226, 226)"
      },
      success: {
        icon: "CheckmarkOutline",
        color: "#67C23A",
        backgroundColor: "rgb(240, 249, 235)",
        borderColor: "rgb(225, 243, 216)"
      }
    };
    const visible = ref(false);
    return {
      style: style2,
      visible
    };
  },
  mounted() {
    this.visible = true;
    let timeout2 = setTimeout(() => {
      this.visible = false;
      clearTimeout(timeout2);
    }, this.delay - 200);
  }
};
const Message_vue_vue_type_style_index_0_scoped_d438ee3c_lang = "";
const _hoisted_1$1 = {
  class: "text"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xicons = resolveComponent("xicons");
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [createCommentVNode(" vue动画：从上滑入且淡出 "), createVNode(Transition, {
      name: "down",
      persisted: ""
    }, {
      default: withCtx(() => [withDirectives(createElementVNode(
        "div",
        {
          ref: "message",
          class: "message",
          style: normalizeStyle({
            ...$setup.style[$props.type]
          })
        },
        [createCommentVNode(" 不同提示图标会变 "), createVNode(_component_xicons, {
          class: "iconfont",
          icon: $setup.style[$props.type].icon
        }, null, 8, ["icon"]), createElementVNode(
          "span",
          _hoisted_1$1,
          toDisplayString($props.text),
          1
          /* TEXT */
        )],
        4
        /* STYLE */
      ), [[vShow, $setup.visible]])]),
      _: 1
      /* STABLE */
    })],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const Message$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-d438ee3c"], ["__file", "Message.vue"]]);
const Message = ({
  type: type2,
  text: text2,
  delay: delay2 = 3e3
}) => {
  let container = document.getElementById("message-group");
  if (!container) {
    container = document.createElement("div");
    container.setAttribute("id", "message-group");
    document.body.appendChild(container);
  }
  const div = document.createElement("div");
  div.setAttribute("class", "message-container");
  container.appendChild(div);
  let timer = null;
  const vnode = createVNode(Message$1, {
    type: type2,
    text: text2,
    delay: delay2
  });
  render(vnode, div);
  timer && clearTimeout(timer);
  timer = setTimeout(() => {
    render(null, div);
    container == null ? void 0 : container.removeChild(div);
  }, delay2);
};
const Tooltip_vue_vue_type_style_index_0_scoped_bb385077_lang = "";
const _sfc_main = {
  setup() {
    const tooltipShow = ref(false);
    const text2 = ref();
    const placements2 = ref("left");
    function showTip() {
      tooltipShow.value = true;
    }
    function hiddenTip() {
      tooltipShow.value = false;
    }
    const tooltipPostiton = ref({
      x: 0,
      y: 0
    });
    const tooltipStyle = computed(() => {
      return {
        transform: `translate3d(${tooltipPostiton.value.x}px,${tooltipPostiton.value.y}px,0)`
      };
    });
    return {
      tooltipShow,
      showTip,
      hiddenTip,
      tooltipPostiton,
      tooltipStyle,
      text: text2,
      placements: placements2
    };
  }
};
const _hoisted_1 = ["innerHTML"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [createCommentVNode(" 指示 "), createVNode(Transition, {
      name: "tooltip",
      persisted: ""
    }, {
      default: withCtx(() => [withDirectives(createElementVNode(
        "div",
        {
          class: "zc-tooltip",
          style: normalizeStyle($setup.tooltipStyle)
        },
        [createElementVNode("span", {
          class: "zc-tooltip-text",
          innerHTML: $setup.text
        }, null, 8, _hoisted_1), createElementVNode(
          "div",
          {
            class: normalizeClass(["zc-tooltip-arrow", [{
              "left": $setup.placements == "left"
            }, {
              "bottom": $setup.placements == "bottom"
            }, {
              "right": $setup.placements == "right"
            }, {
              "top": $setup.placements == "top"
            }]])
          },
          null,
          2
          /* CLASS */
        )],
        4
        /* STYLE */
      ), [[vShow, $setup.tooltipShow]])]),
      _: 1
      /* STABLE */
    })],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const Tooltip$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-bb385077"], ["__file", "Tooltip.vue"]]);
function node() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
function tokenFun() {
  return node() + node() + node();
}
function clearEvent(el) {
  if (el._tipHandler) {
    el.removeEventListener("mouseenter", el._tipHandler);
  }
  if (el._tipMouseleaveHandler) {
    el.removeEventListener("mouseleave", el._tipMouseleaveHandler);
  }
  delete el._tipHandler;
  delete el._tipMouseleaveHandler;
  delete el._tipOptions;
  delete el._tipInstance;
}
function calculationLocation(el, target, placements2) {
  if (!el || !target)
    return;
  el.tooltipPostiton.y = 0;
  el.tooltipPostiton.x = 0;
  let el_dom = el.$el.nextElementSibling.getBoundingClientRect();
  let target_dom = target.getBoundingClientRect();
  if (placements2 === "left") {
    el.tooltipPostiton.x = target_dom.x - el_dom.width - 10;
    el.tooltipPostiton.y = target_dom.y - el_dom.height / 2 + target_dom.height / 2;
  } else if (placements2 === "bottom") {
    el.tooltipPostiton.x = target_dom.x + target_dom.width / 2 - el_dom.width / 2;
    el.tooltipPostiton.y = target_dom.y + el_dom.height + 10;
  } else if (placements2 === "right") {
    el.tooltipPostiton.x = target_dom.x + target_dom.width + 10;
    el.tooltipPostiton.y = target_dom.y - el_dom.height / 2 + target_dom.height / 2;
  } else if (placements2 === "top") {
    el.tooltipPostiton.x = target_dom.x + target_dom.width / 2 - el_dom.width / 2;
    el.tooltipPostiton.y = target_dom.y - el_dom.height - 10;
  }
}
const allPlacements = ["left", "bottom", "right", "top"];
const Tooltip = {
  install(app) {
    app.directive("tooltip", {
      mounted(el, binding) {
        clearEvent(el);
        el._tipOptions = binding.value;
        el._tipHandler = () => {
          const limitPlacementQueue = allPlacements.filter((placement) => binding.modifiers[placement]);
          const placements2 = limitPlacementQueue.length ? limitPlacementQueue : allPlacements;
          if (!el._tipInstance) {
            el._synopsis = createApp(Tooltip$1);
            el._root = document.createElement("div");
            document.body.appendChild(el._root);
            el._root.id = `tooltip_${tokenFun()}`;
            el._tipInstance = el._synopsis.mount(el._root);
          }
          el._tipInstance.placements = placements2[0];
          el._tipInstance.showTip();
          el._tipInstance.text = el._tipOptions;
          nextTick(() => {
            calculationLocation(el._tipInstance, el, placements2[0]);
          });
          el._scrollHandler = () => {
            if (el._tipInstance.tooltipShow)
              calculationLocation(el._tipInstance, el, placements2[0]);
          };
          window.addEventListener("scroll", el._scrollHandler);
        };
        el._tipMouseleaveHandler = () => {
          if (el._tipInstance) {
            el._tipInstance.hiddenTip();
          }
        };
        el.addEventListener("mouseenter", el._tipHandler);
        el.addEventListener("mouseleave", el._tipMouseleaveHandler);
      },
      updated(el, binding) {
        el._tipOptions = binding.value;
      },
      unmounted(el) {
        if (el._tipInstance) {
          el._synopsis.unmount();
          document.body.removeChild(el._root);
        }
        window.removeEventListener("scroll", el._scrollHandler);
      }
    });
  }
};
const qzoneSvg = '<svg t="1697206091997" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6494" width="18" height="18"><path d="M753.755136 657.139c-98.162688-7.774-196.35712-15.548-294.519808-23.321 5.306368-2.592 10.614784-5.181 15.919104-7.772 90.203136-64.772 180.436992-129.563 270.640128-194.335-5.306368 0-10.614784 0-15.921152 0-97.455104-42.083-397.549568-32.699-485.557248 7.772 116.732928 7.774 233.504768 15.547 350.237696 23.321-2.654208 5.181-5.306368 10.365-7.959552 15.546-95.511552 62.179-191.046656 124.381-286.558208 186.562 0 2.592 0 5.18 0 7.773 174.162944 23.443 364.192768 2.403 525.357056-15.547 0 2.592 0 5.182 0 7.773-5.30432 0-10.614784 0-15.919104 0-29.503488 23.218-34.161664 10.548-39.800832 62.188 13.26592 64.771 26.534912 129.563 39.800832 194.333-2.654208 2.595-5.306368 5.182-7.959552 7.773-10.611712 0-21.228544 0-31.84128 0-63.724544-53.829-178.624512-131.244-278.597632-139.921-82.246656 46.638-164.512768 93.285-246.759424 139.921-10.610688-5.179-21.228544-10.365-31.840256-15.545 18.57024-101.045 37.148672-202.121 55.719936-303.164-74.28608-67.363-148.59264-134.744-222.87872-202.107 1.789952-5.242 3.577856-10.483 5.366784-15.724 0.287744-0.844 0.576512-1.688 0.864256-2.531 0.576512-1.688 1.152-3.377 1.728512-5.065 98.162688-12.954 196.356096-25.913 294.518784-38.868 53.061632-93.273 106.138624-186.568 159.199232-279.842 5.306368 0 10.614784 0 15.921152 0 45.101056 95.862 90.217472 191.754 135.319552 287.616 103.467008 10.362 206.968832 20.731 310.436864 31.094 2.656256 5.181 5.306368 10.366 7.959552 15.546-74.285056 72.545-148.59264 145.11-222.877696 217.656C753.755136 631.226 753.755136 644.184 753.755136 657.139z" fill="currentColor" p-id="6495"></path></svg>';
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
const IN_BROWSER = typeof window !== "undefined";
function convertToUnit(str, unit = "px") {
  if (str == null || str === "")
    return void 0;
  else if (isNaN(+str))
    return String(str);
  else if (!isFinite(+str))
    return void 0;
  else
    return `${Number(str)}${unit}`;
}
const hasScrollbar = (el) => {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style2 = window.getComputedStyle(el);
  return ["auto", "scroll"].includes(style2.overflowY) && el.scrollHeight > el.clientHeight;
};
const shouldScroll = (el, delta) => {
  if (el.scrollTop === 0 && delta < 0)
    return true;
  return el.scrollTop + el.clientHeight === el.scrollHeight && delta > 0;
};
const noScrollableParent = (event, content) => {
  const path = event.composedPath();
  const delta = event.deltaY;
  for (let index2 = 0; index2 < path.length; index2++) {
    const el = path[index2];
    if (el === document)
      return true;
    if (el === document.documentElement)
      return true;
    if (el === content)
      return true;
    if (hasScrollbar(el))
      return shouldScroll(el, delta);
  }
  return true;
};
const getScrollbarWidth = () => {
  const container = document.createElement("div");
  container.style.visibility = "hidden";
  container.style.overflow = "scroll";
  const inner = document.createElement("div");
  container.appendChild(inner);
  document.body.appendChild(container);
  const scrollbarWidth = container.offsetWidth - inner.offsetWidth;
  document.body.removeChild(container);
  return scrollbarWidth;
};
const stack = ref([]);
function useStack(isActive) {
  const vm = getCurrentInstance();
  let scope;
  watch(isActive, (val) => {
    if (val) {
      scope = effectScope();
      scope.run(() => {
        stack.value.push(vm);
        onScopeDispose(() => {
          const idx = stack.value.indexOf(vm);
          stack.value.splice(idx, 1);
        });
      });
    } else {
      scope == null ? void 0 : scope.stop();
    }
  }, { immediate: true });
  const isTop = computed(() => {
    return toRaw(stack.value[stack.value.length - 1]) === vm;
  });
  return {
    isTop
  };
}
const overlays = ref([]);
const MIN_Z_INDEX = 1e3;
function useOverlay(isActive) {
  const id = getCurrentInstance().uid;
  const zIndex = ref(0);
  watch(isActive, (value) => {
    if (value) {
      overlays.value.push(id);
      zIndex.value = MIN_Z_INDEX + (overlays.value.indexOf(id) + 1) * 2;
    } else {
      overlays.value = overlays.value.filter((x2) => x2 !== id);
    }
  }, {
    immediate: true
  });
  return { zIndex };
}
const useLazyActivation = (baseState) => {
  const activatedOnce = ref(false);
  const active = ref(false);
  if (baseState.value) {
    activatedOnce.value = true;
    nextTick(() => {
      active.value = true;
    });
  }
  watch(baseState, (value) => {
    if (!activatedOnce.value) {
      activatedOnce.value = true;
      nextTick(() => {
        active.value = value;
      });
      return;
    }
    active.value = value;
  });
  return {
    activatedOnce,
    active
  };
};
const useScroll = ({
  overlay,
  content,
  contentActiveClass,
  fullscreen,
  contentFullscreenClass
}) => {
  if (!IN_BROWSER) {
    return {
      disableScroll: () => {
      },
      enableScroll: () => {
      }
    };
  }
  let disabled = false;
  let disableType;
  const eventListener = (event) => {
    if (event.target === overlay.value || event.target === document.body || noScrollableParent(event, content.value))
      event.preventDefault();
  };
  const scrollbarWidth = getScrollbarWidth();
  const zeroScrollBar = scrollbarWidth === 0;
  const disableScroll = () => {
    if (disabled)
      return;
    if (zeroScrollBar || fullscreen) {
      disableType = "byOverflow";
      document.documentElement.classList.add("overflow-y-hidden");
    } else {
      disableType = "byEvents";
      window.addEventListener("wheel", eventListener, {
        passive: false
      });
    }
    disabled = true;
  };
  const enableScroll = () => {
    if (!disabled)
      return;
    if (disableType === "byEvents") {
      window.removeEventListener("wheel", eventListener);
    } else if (disableType === "byOverflow") {
      const activeContentElements = document.getElementsByClassName(contentActiveClass);
      const activeFullscreenContentElements = document.getElementsByClassName(contentFullscreenClass);
      if (!zeroScrollBar && fullscreen && activeFullscreenContentElements.length === 1 || activeContentElements.length === 1)
        document.documentElement.classList.remove("overflow-y-hidden");
    }
    disabled = false;
  };
  return {
    disableScroll,
    enableScroll
  };
};
function useWindowEventListener(event, listener, options) {
  onMounted(() => {
    window.addEventListener(event, listener, options);
  });
  onUnmounted(() => {
    window.removeEventListener(event, listener);
  });
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const __default__$1 = defineComponent({
  name: "GDialogOverlay",
  props: {
    active: {
      type: Boolean,
      required: true
    },
    zIndex: {
      type: Number,
      required: true
    },
    background: {
      type: [Boolean, String],
      required: true
    },
    local: {
      type: Boolean,
      required: true
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const styles = computed(() => ({
      zIndex: props.zIndex - 1
    }));
    const activeProxy = ref(props.active);
    const deactivating = ref(false);
    watch(() => props.active, (value) => {
      deactivating.value = !value;
      if (value) {
        activeProxy.value = true;
        return;
      }
      nextTick(() => {
        activeProxy.value = false;
      });
    });
    const classes = computed(() => [
      "g-dialog-overlay",
      {
        "g-dialog-overlay--active": !deactivating.value,
        "g-dialog-overlay--local": props.local
      }
    ]);
    const computedBackground = computed(() => {
      if (typeof props.background === "string")
        return props.background;
      else if (props.background)
        return "var(--overlay-bg)";
      return "transparent";
    });
    const onClick = () => {
      emit("click");
    };
    return {
      activeProxy,
      styles,
      classes,
      computedBackground,
      onClick
    };
  }
});
const __injectCSSVars__$1 = () => {
  useCssVars((_ctx) => ({
    "6eaca59a": _ctx.computedBackground
  }));
};
const __setup__$1 = __default__$1.setup;
__default__$1.setup = __setup__$1 ? (props, ctx) => {
  __injectCSSVars__$1();
  return __setup__$1(props, ctx);
} : __injectCSSVars__$1;
const _sfc_main$4 = __default__$1;
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "fade" }, {
    default: withCtx(() => [
      _ctx.activeProxy ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle(_ctx.styles),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
      }, null, 6)) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
var GDialogOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const useSizeStyle = (props) => {
  const sizeStyles = computed(() => ({
    maxWidth: props.maxWidth === "none" ? void 0 : convertToUnit(props.maxWidth),
    width: props.width === "auto" ? void 0 : convertToUnit(props.width),
    height: props.height === "auto" ? void 0 : convertToUnit(props.height)
  }));
  return {
    sizeStyles
  };
};
const __default__ = defineComponent({
  name: "GDialogContent",
  props: {
    background: {
      type: [Boolean, String],
      required: true
    },
    borderRadius: {
      type: [Boolean, Number, String],
      required: true
    },
    class: {
      type: String,
      required: true
    },
    depressed: {
      type: Boolean,
      required: true
    },
    fullscreen: Boolean,
    height: {
      type: [String, Number],
      required: true
    },
    maxWidth: {
      type: [String, Number],
      required: true
    },
    scrollable: {
      type: Boolean,
      required: true
    },
    width: {
      type: [String, Number],
      required: true
    }
  },
  setup(props) {
    const { sizeStyles: styles } = useSizeStyle(props);
    const classes = computed(() => [
      "g-dialog-content",
      props.class,
      {
        "g-dialog-content--scrollable": props.scrollable,
        "g-dialog-content--depressed": props.depressed,
        "g-dialog-content--fullscreen": props.fullscreen
      }
    ]);
    const computedBackground = computed(() => {
      if (typeof props.background === "string")
        return props.background;
      else if (props.background)
        return "var(--content-bg)";
      return "transparent";
    });
    const computedBorderRadius = computed(() => {
      if (typeof props.borderRadius === "string")
        return convertToUnit(props.borderRadius);
      else if (props.borderRadius)
        return "var(--content-border-radius)";
      return "0";
    });
    return {
      styles,
      classes,
      computedBackground,
      computedBorderRadius
    };
  }
});
const __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "889a571a": _ctx.computedBackground,
    "023a843a": _ctx.computedBorderRadius
  }));
};
const __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
const _sfc_main$3 = __default__;
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var GDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = defineComponent({
  name: "GDialogFrame",
  components: {
    GDialogContent
  },
  inheritAttrs: false,
  props: {
    isActive: {
      type: Boolean,
      required: true
    },
    zIndex: {
      type: Number,
      required: true
    },
    background: {
      type: [Boolean, String],
      required: true
    },
    borderRadius: {
      type: [Boolean, Number, String],
      required: true
    },
    contentClass: {
      type: String,
      required: true
    },
    depressed: {
      type: Boolean,
      required: true
    },
    fullscreen: {
      type: Boolean,
      required: true
    },
    height: {
      type: [String, Number],
      required: true
    },
    local: {
      type: Boolean,
      required: true
    },
    maxWidth: {
      type: [String, Number],
      required: true
    },
    scrollable: {
      type: Boolean,
      required: true
    },
    transition: {
      type: String,
      required: true
    },
    width: {
      type: [String, Number],
      required: true
    }
  },
  setup(props) {
    const frameElement = ref();
    const animateClick = () => {
      var _a3, _b2;
      (_b2 = (_a3 = frameElement.value) == null ? void 0 : _a3.animate) == null ? void 0 : _b2.call(_a3, [
        { transformOrigin: "center" },
        { transform: "scale(1.03)" },
        { transformOrigin: "center" }
      ], {
        duration: 150,
        easing: "cubic-bezier(0.4, 0, 0.2, 1)"
      });
    };
    const classes = computed(() => [
      "g-dialog-frame",
      {
        "g-dialog-frame--active": props.isActive,
        "g-dialog-frame--local": props.local
      }
    ]);
    const styles = computed(() => ({
      zIndex: props.zIndex
    }));
    return {
      frameElement,
      classes,
      styles,
      animateClick
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GDialogContent = resolveComponent("GDialogContent");
  return openBlock(), createBlock(Transition, { name: _ctx.transition }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "frameElement",
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle(_ctx.styles)
      }, [
        createVNode(_component_GDialogContent, {
          class: normalizeClass(_ctx.contentClass),
          "max-width": _ctx.maxWidth,
          width: _ctx.width,
          height: _ctx.height,
          scrollable: _ctx.scrollable,
          depressed: _ctx.depressed,
          fullscreen: _ctx.fullscreen,
          background: _ctx.background,
          "border-radius": _ctx.borderRadius
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "max-width", "width", "height", "scrollable", "depressed", "fullscreen", "background", "border-radius"])
      ], 6), [
        [vShow, _ctx.isActive]
      ])
    ]),
    _: 3
  }, 8, ["name"]);
}
var GDialogFrame = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = defineComponent({
  name: "GDialog",
  components: {
    GDialogOverlay,
    GDialogFrame
  },
  inheritAttrs: false,
  props: {
    background: {
      type: [Boolean, String],
      default: true
    },
    borderRadius: {
      type: [Boolean, Number, String],
      default: true
    },
    contentClass: {
      type: String,
      default: ""
    },
    depressed: Boolean,
    fullscreen: Boolean,
    height: {
      type: [String, Number],
      default: "auto"
    },
    local: Boolean,
    maxWidth: {
      type: [String, Number],
      default: "none"
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    noClickAnimation: Boolean,
    overlayBackground: {
      type: [Boolean, String],
      default: true
    },
    persistent: Boolean,
    scrollable: Boolean,
    teleportTo: {
      type: String,
      default: "body"
    },
    disableTeleport: Boolean,
    transition: {
      type: String,
      default: "g-dialog-transition"
    },
    width: {
      type: [String, Number],
      default: "auto"
    },
    closeOnBack: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, { emit }) {
    const overlayComponent = ref(null);
    const frameComponent = ref(null);
    const overlayElement = computed(() => {
      var _a3;
      return (_a3 = overlayComponent.value) == null ? void 0 : _a3.$el;
    });
    const frameElement = computed(() => {
      var _a3;
      return (_a3 = frameComponent.value) == null ? void 0 : _a3.$el;
    });
    const withModelValue = props.modelValue !== void 0;
    const scopedModelValue = ref(false);
    watch(() => props.modelValue, (val) => {
      scopedModelValue.value = !!val;
    });
    const { isTop } = useStack(scopedModelValue);
    if (IN_BROWSER && props.modelValue) {
      nextTick(() => {
        scopedModelValue.value = true;
      });
    }
    const onClose = () => {
      if (!withModelValue)
        scopedModelValue.value = false;
      emit("update:modelValue", false);
    };
    const onOpen = () => {
      if (!withModelValue)
        scopedModelValue.value = false;
      emit("update:modelValue", true);
    };
    const { activatedOnce, active: isActive } = useLazyActivation(scopedModelValue);
    const { zIndex } = useOverlay(isActive);
    const animateClick = () => {
      var _a3;
      if (props.noClickAnimation)
        return;
      (_a3 = frameComponent.value) == null ? void 0 : _a3.animateClick();
    };
    useWindowEventListener("keyup", (ev) => {
      if (ev.key === "Escape" && isTop.value) {
        if (!props.persistent)
          onClose();
        else
          animateClick();
      }
    }, { passive: true });
    const { enableScroll, disableScroll } = useScroll({
      overlay: overlayElement,
      content: frameElement,
      contentActiveClass: "g-dialog-frame--active",
      fullscreen: props.fullscreen,
      contentFullscreenClass: "g-dialog-frame--fullscreen"
    });
    watch(isActive, (active) => {
      if (props.local)
        return;
      if (active)
        disableScroll();
      else
        enableScroll();
    });
    onBeforeUnmount(() => {
      enableScroll();
    });
    const onClickOutside = () => {
      if (!props.persistent)
        onClose();
      else
        animateClick();
    };
    if (IN_BROWSER && props.closeOnBack) {
      const instace = getCurrentInstance();
      let currentDialogHash = `dialog-${instace.uid}`;
      if (window.location.hash)
        currentDialogHash = `${window.location.hash.slice(1)}-${currentDialogHash}`;
      const popstateListener = () => {
        if (window.location.hash.includes(currentDialogHash) || !scopedModelValue.value)
          return;
        onClose();
      };
      onMounted(() => {
        if (scopedModelValue.value)
          window.location.hash = currentDialogHash;
        window.addEventListener("popstate", popstateListener);
      });
      onUnmounted(() => {
        window.removeEventListener("popstate", popstateListener);
      });
      watch(scopedModelValue, (value) => {
        if (!value && window.location.hash.includes(currentDialogHash)) {
          window.history.back();
        } else if (value) {
          if (window.location.hash)
            currentDialogHash = `${window.location.hash.slice(1)}-${`dialog-${instace.uid}`}`;
          else
            currentDialogHash = `dialog-${instace.uid}`;
          window.location.hash = `#${currentDialogHash}`;
        }
      });
    }
    const activatorAttrs = {
      onClick() {
        onOpen();
      }
    };
    return {
      overlayComponent,
      frameComponent,
      activatedOnce,
      zIndex,
      isActive,
      activatorAttrs,
      onClickOutside,
      onClose
    };
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GDialogOverlay = resolveComponent("GDialogOverlay");
  const _component_GDialogFrame = resolveComponent("GDialogFrame");
  return openBlock(), createElementBlock(Fragment, null, [
    renderSlot(_ctx.$slots, "activator", normalizeProps(guardReactiveProps(_ctx.activatorAttrs))),
    _ctx.activatedOnce ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      (openBlock(), createBlock(Teleport, {
        to: _ctx.teleportTo,
        disabled: _ctx.local || _ctx.disableTeleport
      }, [
        !_ctx.fullscreen ? (openBlock(), createBlock(_component_GDialogOverlay, {
          key: 0,
          ref: "overlayComponent",
          active: _ctx.isActive,
          "z-index": _ctx.zIndex,
          background: _ctx.overlayBackground,
          local: _ctx.local,
          onClick: _ctx.onClickOutside
        }, null, 8, ["active", "z-index", "background", "local", "onClick"])) : createCommentVNode("", true)
      ], 8, ["to", "disabled"])),
      (openBlock(), createBlock(Teleport, {
        to: _ctx.teleportTo,
        disabled: _ctx.local || _ctx.disableTeleport
      }, [
        createVNode(_component_GDialogFrame, {
          ref: "frameComponent",
          "is-active": _ctx.isActive,
          "z-index": _ctx.zIndex,
          "max-width": _ctx.maxWidth,
          width: _ctx.width,
          height: _ctx.height,
          scrollable: _ctx.scrollable,
          transition: _ctx.transition,
          depressed: _ctx.depressed,
          fullscreen: _ctx.fullscreen,
          background: _ctx.background,
          "border-radius": _ctx.borderRadius,
          "content-class": _ctx.contentClass,
          local: _ctx.local,
          persistent: _ctx.persistent
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", { onClose: _ctx.onClose })
          ]),
          _: 3
        }, 8, ["is-active", "z-index", "max-width", "width", "height", "scrollable", "transition", "depressed", "fullscreen", "background", "border-radius", "content-class", "local", "persistent"])
      ], 8, ["to", "disabled"]))
    ], 64)) : createCommentVNode("", true)
  ], 64);
}
var GDialog = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const dialogs = shallowReactive([]);
const errorLogger = {
  pluginIsNotInitialized() {
    console.error("The gitart-vue-dialog plugin is not initialized. Read how to solve: https://gitart-vue-dialog.gitart.org/guide/usage/plugin-usage.html#installation");
  }
};
const dialogInjectionKey = Symbol("GDialog");
const dialogInjectionFallback = {
  dialogs: [],
  addDialog: () => {
    errorLogger.pluginIsNotInitialized();
    return null;
  },
  removeDialog: () => {
    errorLogger.pluginIsNotInitialized();
  }
};
const plugin = {
  install: (app, options) => {
    var _a3, _b2;
    const defaultCloseDelay = (_a3 = options == null ? void 0 : options.closeDelay) != null ? _a3 : 500;
    const defaultProps = (_b2 = options == null ? void 0 : options.props) != null ? _b2 : {};
    const $dialog = {
      dialogs,
      addDialog: ({ component, props, id }, hooks) => {
        const dialogId = id != null ? id : Date.now() + Math.random();
        dialogs.push({
          component,
          id: dialogId,
          props: reactive(__spreadValues(__spreadValues({
            modelValue: true
          }, defaultProps), props)),
          onClose: hooks == null ? void 0 : hooks.onClose
        });
        return dialogId;
      },
      removeDialog: (id, closeDelay) => {
        const dialog = dialogs.find((d2) => d2.id === id);
        if (!dialog || !dialog.props.modelValue)
          return;
        let canceled = false;
        const event = {
          id,
          cancel: () => {
            console.warn("Dialog closing canceled");
            canceled = true;
          },
          item: dialog
        };
        if (dialog.onClose) {
          dialog.onClose(event);
          if (canceled)
            return;
        }
        dialog.props.modelValue = false;
        setTimeout(() => {
          dialogs.splice(dialogs.indexOf(dialog), 1);
        }, closeDelay != null ? closeDelay : defaultCloseDelay);
      }
    };
    app.provide(dialogInjectionKey, $dialog);
    app.config.globalProperties.$dialog = $dialog;
  }
};
defineComponent({
  name: "GDialogRoot",
  setup() {
    const {
      dialogs: dialogs2,
      removeDialog
    } = inject(dialogInjectionKey, dialogInjectionFallback);
    if (dialogs2 === dialogInjectionFallback.dialogs)
      errorLogger.pluginIsNotInitialized();
    function onClose(id) {
      removeDialog(id);
    }
    return {
      dialogs: dialogs2,
      onClose
    };
  }
});
const style$1 = "";
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction2, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction2 === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d2) => {
        const alignment2 = getAlignment(d2.placement);
        return [d2.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d2.overflows.slice(0, 2).reduce((acc, v3) => acc + v3, 0)
        ) : (
          // Check only the mainAxis.
          d2.overflows[0]
        ), d2.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d2[0]) ? 2 : 3
      ).every((v3) => v3 <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y3
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x2 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y4
            } = _ref;
            return {
              x: x3,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y3
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function n$1(t2) {
  var e2;
  return (null == (e2 = t2.ownerDocument) ? void 0 : e2.defaultView) || window;
}
function o(t2) {
  return n$1(t2).getComputedStyle(t2);
}
const i2 = Math.min, r = Math.max, l = Math.round;
function c(t2) {
  const e2 = o(t2);
  let n2 = parseFloat(e2.width), i3 = parseFloat(e2.height);
  const r2 = t2.offsetWidth, c2 = t2.offsetHeight, s2 = l(n2) !== r2 || l(i3) !== c2;
  return s2 && (n2 = r2, i3 = c2), { width: n2, height: i3, fallback: s2 };
}
function s(t2) {
  return h(t2) ? (t2.nodeName || "").toLowerCase() : "";
}
let f$1;
function u$1() {
  if (f$1)
    return f$1;
  const t2 = navigator.userAgentData;
  return t2 && Array.isArray(t2.brands) ? (f$1 = t2.brands.map((t3) => t3.brand + "/" + t3.version).join(" "), f$1) : navigator.userAgent;
}
function a(t2) {
  return t2 instanceof n$1(t2).HTMLElement;
}
function d$1(t2) {
  return t2 instanceof n$1(t2).Element;
}
function h(t2) {
  return t2 instanceof n$1(t2).Node;
}
function p(t2) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t2 instanceof n$1(t2).ShadowRoot || t2 instanceof ShadowRoot;
}
function g$1(t2) {
  const { overflow: e2, overflowX: n2, overflowY: i3, display: r2 } = o(t2);
  return /auto|scroll|overlay|hidden|clip/.test(e2 + i3 + n2) && !["inline", "contents"].includes(r2);
}
function m$1(t2) {
  return ["table", "td", "th"].includes(s(t2));
}
function y$1(t2) {
  const e2 = /firefox/i.test(u$1()), n2 = o(t2), i3 = n2.backdropFilter || n2.WebkitBackdropFilter;
  return "none" !== n2.transform || "none" !== n2.perspective || !!i3 && "none" !== i3 || e2 && "filter" === n2.willChange || e2 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some((t3) => n2.willChange.includes(t3)) || ["paint", "layout", "strict", "content"].some((t3) => {
    const e3 = n2.contain;
    return null != e3 && e3.includes(t3);
  });
}
function x() {
  return !/^((?!chrome|android).)*safari/i.test(u$1());
}
function w(t2) {
  return ["html", "body", "#document"].includes(s(t2));
}
function v$1(t2) {
  return d$1(t2) ? t2 : t2.contextElement;
}
const b$1 = { x: 1, y: 1 };
function L$1(t2) {
  const e2 = v$1(t2);
  if (!a(e2))
    return b$1;
  const n2 = e2.getBoundingClientRect(), { width: o2, height: i3, fallback: r2 } = c(e2);
  let s2 = (r2 ? l(n2.width) : n2.width) / o2, f2 = (r2 ? l(n2.height) : n2.height) / i3;
  return s2 && Number.isFinite(s2) || (s2 = 1), f2 && Number.isFinite(f2) || (f2 = 1), { x: s2, y: f2 };
}
function E$1(t2, e2, o2, i3) {
  var r2, l2;
  void 0 === e2 && (e2 = false), void 0 === o2 && (o2 = false);
  const c2 = t2.getBoundingClientRect(), s2 = v$1(t2);
  let f2 = b$1;
  e2 && (i3 ? d$1(i3) && (f2 = L$1(i3)) : f2 = L$1(t2));
  const u3 = s2 ? n$1(s2) : window, a2 = !x() && o2;
  let h2 = (c2.left + (a2 && (null == (r2 = u3.visualViewport) ? void 0 : r2.offsetLeft) || 0)) / f2.x, p2 = (c2.top + (a2 && (null == (l2 = u3.visualViewport) ? void 0 : l2.offsetTop) || 0)) / f2.y, g2 = c2.width / f2.x, m2 = c2.height / f2.y;
  if (s2) {
    const t3 = n$1(s2), e3 = i3 && d$1(i3) ? n$1(i3) : i3;
    let o3 = t3.frameElement;
    for (; o3 && i3 && e3 !== t3; ) {
      const t4 = L$1(o3), e4 = o3.getBoundingClientRect(), i4 = getComputedStyle(o3);
      e4.x += (o3.clientLeft + parseFloat(i4.paddingLeft)) * t4.x, e4.y += (o3.clientTop + parseFloat(i4.paddingTop)) * t4.y, h2 *= t4.x, p2 *= t4.y, g2 *= t4.x, m2 *= t4.y, h2 += e4.x, p2 += e4.y, o3 = n$1(o3).frameElement;
    }
  }
  return { width: g2, height: m2, top: p2, right: h2 + g2, bottom: p2 + m2, left: h2, x: h2, y: p2 };
}
function R(t2) {
  return ((h(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
}
function T(t2) {
  return d$1(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
}
function C$1(t2) {
  return E$1(R(t2)).left + T(t2).scrollLeft;
}
function F(t2) {
  if ("html" === s(t2))
    return t2;
  const e2 = t2.assignedSlot || t2.parentNode || p(t2) && t2.host || R(t2);
  return p(e2) ? e2.host : e2;
}
function W$1(t2) {
  const e2 = F(t2);
  return w(e2) ? e2.ownerDocument.body : a(e2) && g$1(e2) ? e2 : W$1(e2);
}
function D(t2, e2) {
  var o2;
  void 0 === e2 && (e2 = []);
  const i3 = W$1(t2), r2 = i3 === (null == (o2 = t2.ownerDocument) ? void 0 : o2.body), l2 = n$1(i3);
  return r2 ? e2.concat(l2, l2.visualViewport || [], g$1(i3) ? i3 : []) : e2.concat(i3, D(i3));
}
function S$1(e2, i3, l2) {
  return "viewport" === i3 ? rectToClientRect(function(t2, e3) {
    const o2 = n$1(t2), i4 = R(t2), r2 = o2.visualViewport;
    let l3 = i4.clientWidth, c2 = i4.clientHeight, s2 = 0, f2 = 0;
    if (r2) {
      l3 = r2.width, c2 = r2.height;
      const t3 = x();
      (t3 || !t3 && "fixed" === e3) && (s2 = r2.offsetLeft, f2 = r2.offsetTop);
    }
    return { width: l3, height: c2, x: s2, y: f2 };
  }(e2, l2)) : d$1(i3) ? rectToClientRect(function(t2, e3) {
    const n2 = E$1(t2, true, "fixed" === e3), o2 = n2.top + t2.clientTop, i4 = n2.left + t2.clientLeft, r2 = a(t2) ? L$1(t2) : { x: 1, y: 1 };
    return { width: t2.clientWidth * r2.x, height: t2.clientHeight * r2.y, x: i4 * r2.x, y: o2 * r2.y };
  }(i3, l2)) : rectToClientRect(function(t2) {
    const e3 = R(t2), n2 = T(t2), i4 = t2.ownerDocument.body, l3 = r(e3.scrollWidth, e3.clientWidth, i4.scrollWidth, i4.clientWidth), c2 = r(e3.scrollHeight, e3.clientHeight, i4.scrollHeight, i4.clientHeight);
    let s2 = -n2.scrollLeft + C$1(t2);
    const f2 = -n2.scrollTop;
    return "rtl" === o(i4).direction && (s2 += r(e3.clientWidth, i4.clientWidth) - l3), { width: l3, height: c2, x: s2, y: f2 };
  }(R(e2)));
}
function A(t2) {
  return a(t2) && "fixed" !== o(t2).position ? t2.offsetParent : null;
}
function H(t2) {
  const e2 = n$1(t2);
  let i3 = A(t2);
  for (; i3 && m$1(i3) && "static" === o(i3).position; )
    i3 = A(i3);
  return i3 && ("html" === s(i3) || "body" === s(i3) && "static" === o(i3).position && !y$1(i3)) ? e2 : i3 || function(t3) {
    let e3 = F(t3);
    for (; a(e3) && !w(e3); ) {
      if (y$1(e3))
        return e3;
      e3 = F(e3);
    }
    return null;
  }(t2) || e2;
}
function O(t2, e2, n2) {
  const o2 = a(e2), i3 = R(e2), r2 = E$1(t2, true, "fixed" === n2, e2);
  let l2 = { scrollLeft: 0, scrollTop: 0 };
  const c2 = { x: 0, y: 0 };
  if (o2 || !o2 && "fixed" !== n2)
    if (("body" !== s(e2) || g$1(i3)) && (l2 = T(e2)), a(e2)) {
      const t3 = E$1(e2, true);
      c2.x = t3.x + e2.clientLeft, c2.y = t3.y + e2.clientTop;
    } else
      i3 && (c2.x = C$1(i3));
  return { x: r2.left + l2.scrollLeft - c2.x, y: r2.top + l2.scrollTop - c2.y, width: r2.width, height: r2.height };
}
const P = { getClippingRect: function(t2) {
  let { element: e2, boundary: n2, rootBoundary: l2, strategy: c2 } = t2;
  const f2 = "clippingAncestors" === n2 ? function(t3, e3) {
    const n3 = e3.get(t3);
    if (n3)
      return n3;
    let i3 = D(t3).filter((t4) => d$1(t4) && "body" !== s(t4)), r2 = null;
    const l3 = "fixed" === o(t3).position;
    let c3 = l3 ? F(t3) : t3;
    for (; d$1(c3) && !w(c3); ) {
      const t4 = o(c3), e4 = y$1(c3);
      (l3 ? e4 || r2 : e4 || "static" !== t4.position || !r2 || !["absolute", "fixed"].includes(r2.position)) ? r2 = t4 : i3 = i3.filter((t5) => t5 !== c3), c3 = F(c3);
    }
    return e3.set(t3, i3), i3;
  }(e2, this._c) : [].concat(n2), u3 = [...f2, l2], a2 = u3[0], h2 = u3.reduce((t3, n3) => {
    const o2 = S$1(e2, n3, c2);
    return t3.top = r(o2.top, t3.top), t3.right = i2(o2.right, t3.right), t3.bottom = i2(o2.bottom, t3.bottom), t3.left = r(o2.left, t3.left), t3;
  }, S$1(e2, a2, c2));
  return { width: h2.right - h2.left, height: h2.bottom - h2.top, x: h2.left, y: h2.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
  let { rect: e2, offsetParent: n2, strategy: o2 } = t2;
  const i3 = a(n2), r2 = R(n2);
  if (n2 === r2)
    return e2;
  let l2 = { scrollLeft: 0, scrollTop: 0 }, c2 = { x: 1, y: 1 };
  const f2 = { x: 0, y: 0 };
  if ((i3 || !i3 && "fixed" !== o2) && (("body" !== s(n2) || g$1(r2)) && (l2 = T(n2)), a(n2))) {
    const t3 = E$1(n2);
    c2 = L$1(n2), f2.x = t3.x + n2.clientLeft, f2.y = t3.y + n2.clientTop;
  }
  return { width: e2.width * c2.x, height: e2.height * c2.y, x: e2.x * c2.x - l2.scrollLeft * c2.x + f2.x, y: e2.y * c2.y - l2.scrollTop * c2.y + f2.y };
}, isElement: d$1, getDimensions: function(t2) {
  return a(t2) ? c(t2) : t2.getBoundingClientRect();
}, getOffsetParent: H, getDocumentElement: R, getScale: L$1, async getElementRects(t2) {
  let { reference: e2, floating: n2, strategy: o2 } = t2;
  const i3 = this.getOffsetParent || H, r2 = this.getDimensions;
  return { reference: O(e2, await i3(n2), o2), floating: { x: 0, y: 0, ...await r2(n2) } };
}, getClientRects: (t2) => Array.from(t2.getClientRects()), isRTL: (t2) => "rtl" === o(t2).direction };
const B = (t2, n2, o2) => {
  const i3 = /* @__PURE__ */ new Map(), r2 = { platform: P, ...o2 }, l2 = { ...r2.platform, _c: i3 };
  return computePosition(t2, n2, { ...r2, platform: l2 });
};
function fe(e2, t2) {
  for (const o2 in t2)
    Object.prototype.hasOwnProperty.call(t2, o2) && (typeof t2[o2] == "object" && e2[o2] ? fe(e2[o2], t2[o2]) : e2[o2] = t2[o2]);
}
const u2 = {
  // Disable popper components
  disabled: false,
  // Default position offset along main axis (px)
  distance: 5,
  // Default position offset along cross axis (px)
  skidding: 0,
  // Default container where the tooltip will be appended
  container: "body",
  // Element used to compute position and size boundaries
  boundary: void 0,
  // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
  instantMove: false,
  // Auto destroy tooltip DOM nodes (ms)
  disposeTimeout: 5e3,
  // Triggers on the popper itself
  popperTriggers: [],
  // Positioning strategy
  strategy: "absolute",
  // Prevent overflow
  preventOverflow: true,
  // Flip to the opposite placement if needed
  flip: true,
  // Shift on the cross axis to prevent the popper from overflowing
  shift: true,
  // Overflow padding (px)
  overflowPadding: 0,
  // Arrow padding (px)
  arrowPadding: 0,
  // Compute arrow overflow (useful to hide it)
  arrowOverflow: true,
  // Themes
  themes: {
    tooltip: {
      // Default tooltip placement relative to target element
      placement: "top",
      // Default events that trigger the tooltip
      triggers: ["hover", "focus", "touch"],
      // Close tooltip on click on tooltip target
      hideTriggers: (e2) => [...e2, "click"],
      // Delay (ms)
      delay: {
        show: 200,
        hide: 0
      },
      // Update popper on content resize
      handleResize: false,
      // Enable HTML content in directive
      html: false,
      // Displayed when tooltip content is loading
      loadingContent: "..."
    },
    dropdown: {
      // Default dropdown placement relative to target element
      placement: "bottom",
      // Default events that trigger the dropdown
      triggers: ["click"],
      // Delay (ms)
      delay: 0,
      // Update popper on content resize
      handleResize: true,
      // Hide on clock outside
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function b(e2, t2) {
  let o2 = u2.themes[e2] || {}, i3;
  do
    i3 = o2[t2], typeof i3 > "u" ? o2.$extend ? o2 = u2.themes[o2.$extend] || {} : (o2 = null, i3 = u2[t2]) : o2 = null;
  while (o2);
  return i3;
}
function Je(e2) {
  const t2 = [e2];
  let o2 = u2.themes[e2] || {};
  do
    o2.$extend && !o2.$resetCss ? (t2.push(o2.$extend), o2 = u2.themes[o2.$extend] || {}) : o2 = null;
  while (o2);
  return t2.map((i3) => `v-popper--theme-${i3}`);
}
function oe(e2) {
  const t2 = [e2];
  let o2 = u2.themes[e2] || {};
  do
    o2.$extend ? (t2.push(o2.$extend), o2 = u2.themes[o2.$extend] || {}) : o2 = null;
  while (o2);
  return t2;
}
let _ = false;
if (typeof window < "u") {
  _ = false;
  try {
    const e2 = Object.defineProperty({}, "passive", {
      get() {
        _ = true;
      }
    });
    window.addEventListener("test", null, e2);
  } catch {
  }
}
let me = false;
typeof window < "u" && typeof navigator < "u" && (me = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
const ge = ["auto", "top", "bottom", "left", "right"].reduce((e2, t2) => e2.concat([
  t2,
  `${t2}-start`,
  `${t2}-end`
]), []), ie = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart",
  pointer: "pointerdown"
}, se = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend",
  pointer: "pointerup"
};
function ne(e2, t2) {
  const o2 = e2.indexOf(t2);
  o2 !== -1 && e2.splice(o2, 1);
}
function W() {
  return new Promise((e2) => requestAnimationFrame(() => {
    requestAnimationFrame(e2);
  }));
}
const d = [];
let g = null;
const re = {};
function pe(e2) {
  let t2 = re[e2];
  return t2 || (t2 = re[e2] = []), t2;
}
let X = function() {
};
typeof window < "u" && (X = window.Element);
function n(e2) {
  return function(t2) {
    return b(t2.theme, e2);
  };
}
const G = "__floating-vue__popper", K = () => defineComponent({
  name: "VPopper",
  provide() {
    return {
      [G]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [G]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      default: null
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    // eslint-disable-next-line vue/require-prop-types
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: n("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: n("positioningDisabled")
    },
    placement: {
      type: String,
      default: n("placement"),
      validator: (e2) => ge.includes(e2)
    },
    delay: {
      type: [String, Number, Object],
      default: n("delay")
    },
    distance: {
      type: [Number, String],
      default: n("distance")
    },
    skidding: {
      type: [Number, String],
      default: n("skidding")
    },
    triggers: {
      type: Array,
      default: n("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: n("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: n("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: n("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: n("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: n("popperHideTriggers")
    },
    container: {
      type: [String, Object, X, Boolean],
      default: n("container")
    },
    boundary: {
      type: [String, X],
      default: n("boundary")
    },
    strategy: {
      type: String,
      validator: (e2) => ["absolute", "fixed"].includes(e2),
      default: n("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: n("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: n("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: n("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: n("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: n("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: n("computeTransformOrigin")
    },
    /**
     * @deprecated
     */
    autoMinSize: {
      type: Boolean,
      default: n("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: n("autoSize")
    },
    /**
     * @deprecated
     */
    autoMaxSize: {
      type: Boolean,
      default: n("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: n("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: n("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: n("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: n("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: n("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: n("flip")
    },
    shift: {
      type: Boolean,
      default: n("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: n("shiftCrossAxis")
    },
    noAutoFocus: {
      type: Boolean,
      default: n("noAutoFocus")
    },
    disposeTimeout: {
      type: Number,
      default: n("disposeTimeout")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: {
          ...this.classes,
          popperClass: this.popperClass
        },
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var e2;
      return (e2 = this[G]) == null ? void 0 : e2.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var e2, t2;
      return ((e2 = this.popperTriggers) == null ? void 0 : e2.includes("hover")) || ((t2 = this.popperShowTriggers) == null ? void 0 : t2.includes("hover"));
    }
  },
  watch: {
    shown: "$_autoShowHide",
    disabled(e2) {
      e2 ? this.dispose() : this.init();
    },
    async container() {
      this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());
    },
    ...[
      "triggers",
      "positioningDisabled"
    ].reduce((e2, t2) => (e2[t2] = "$_refreshListeners", e2), {}),
    ...[
      "placement",
      "distance",
      "skidding",
      "boundary",
      "strategy",
      "overflowPadding",
      "arrowPadding",
      "preventOverflow",
      "shift",
      "shiftCrossAxis",
      "flip"
    ].reduce((e2, t2) => (e2[t2] = "$_computePosition", e2), {})
  },
  created() {
    this.$_isDisposed = true, this.randomId = `popper_${[Math.random(), Date.now()].map((e2) => e2.toString(36).substring(2, 10)).join("_")}`, this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
  },
  mounted() {
    this.init(), this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event: e2 = null, skipDelay: t2 = false, force: o2 = false } = {}) {
      var i3, s2;
      (i3 = this.parentPopper) != null && i3.lockedChild && this.parentPopper.lockedChild !== this || (this.$_pendingHide = false, (o2 || !this.disabled) && (((s2 = this.parentPopper) == null ? void 0 : s2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e2, t2), this.$emit("show"), this.$_showFrameLocked = true, requestAnimationFrame(() => {
        this.$_showFrameLocked = false;
      })), this.$emit("update:shown", true));
    },
    hide({ event: e2 = null, skipDelay: t2 = false } = {}) {
      var o2;
      if (!this.$_hideInProgress) {
        if (this.shownChildren.size > 0) {
          this.$_pendingHide = true;
          return;
        }
        if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
          this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
            this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t2 }), this.parentPopper.lockedChild = null);
          }, 1e3));
          return;
        }
        ((o2 = this.parentPopper) == null ? void 0 : o2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_pendingHide = false, this.$_scheduleHide(e2, t2), this.$emit("hide"), this.$emit("update:shown", false);
      }
    },
    init() {
      var e2;
      this.$_isDisposed && (this.$_isDisposed = false, this.isMounted = false, this.$_events = [], this.$_preventShow = false, this.$_referenceNode = ((e2 = this.referenceNode) == null ? void 0 : e2.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((t2) => t2.nodeType === t2.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner"), this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container"), this.$_swapTargetAttrs("title", "data-original-title"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
    },
    dispose() {
      this.$_isDisposed || (this.$_isDisposed = true, this.$_removeEventListeners(), this.hide({ skipDelay: true }), this.$_detachPopperNode(), this.isMounted = false, this.isShown = false, this.$_updateParentShownChildren(false), this.$_swapTargetAttrs("data-original-title", "title"), this.$emit("dispose"));
    },
    async onResize() {
      this.isShown && (await this.$_computePosition(), this.$emit("resize"));
    },
    async $_computePosition() {
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const e2 = {
        strategy: this.strategy,
        middleware: []
      };
      (this.distance || this.skidding) && e2.middleware.push(offset({
        mainAxis: this.distance,
        crossAxis: this.skidding
      }));
      const t2 = this.placement.startsWith("auto");
      if (t2 ? e2.middleware.push(autoPlacement({
        alignment: this.placement.split("-")[1] ?? ""
      })) : e2.placement = this.placement, this.preventOverflow && (this.shift && e2.middleware.push(shift({
        padding: this.overflowPadding,
        boundary: this.boundary,
        crossAxis: this.shiftCrossAxis
      })), !t2 && this.flip && e2.middleware.push(flip({
        padding: this.overflowPadding,
        boundary: this.boundary
      }))), e2.middleware.push(arrow({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      })), this.arrowOverflow && e2.middleware.push({
        name: "arrowOverflow",
        fn: ({ placement: i3, rects: s2, middlewareData: r2 }) => {
          let p2;
          const { centerOffset: a2 } = r2.arrow;
          return i3.startsWith("top") || i3.startsWith("bottom") ? p2 = Math.abs(a2) > s2.reference.width / 2 : p2 = Math.abs(a2) > s2.reference.height / 2, {
            data: {
              overflow: p2
            }
          };
        }
      }), this.autoMinSize || this.autoSize) {
        const i3 = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        e2.middleware.push({
          name: "autoSize",
          fn: ({ rects: s2, placement: r2, middlewareData: p2 }) => {
            var h2;
            if ((h2 = p2.autoSize) != null && h2.skip)
              return {};
            let a2, l2;
            return r2.startsWith("top") || r2.startsWith("bottom") ? a2 = s2.reference.width : l2 = s2.reference.height, this.$_innerNode.style[i3 === "min" ? "minWidth" : i3 === "max" ? "maxWidth" : "width"] = a2 != null ? `${a2}px` : null, this.$_innerNode.style[i3 === "min" ? "minHeight" : i3 === "max" ? "maxHeight" : "height"] = l2 != null ? `${l2}px` : null, {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e2.middleware.push(size({
        boundary: this.boundary,
        padding: this.overflowPadding,
        apply: ({ availableWidth: i3, availableHeight: s2 }) => {
          this.$_innerNode.style.maxWidth = i3 != null ? `${i3}px` : null, this.$_innerNode.style.maxHeight = s2 != null ? `${s2}px` : null;
        }
      })));
      const o2 = await B(this.$_referenceNode, this.$_popperNode, e2);
      Object.assign(this.result, {
        x: o2.x,
        y: o2.y,
        placement: o2.placement,
        strategy: o2.strategy,
        arrow: {
          ...o2.middlewareData.arrow,
          ...o2.middlewareData.arrowOverflow
        }
      });
    },
    $_scheduleShow(e2 = null, t2 = false) {
      if (this.$_updateParentShownChildren(true), this.$_hideInProgress = false, clearTimeout(this.$_scheduleTimer), g && this.instantMove && g.instantMove && g !== this.parentPopper) {
        g.$_applyHide(true), this.$_applyShow(true);
        return;
      }
      t2 ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
    },
    $_scheduleHide(e2 = null, t2 = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false), this.$_hideInProgress = true, clearTimeout(this.$_scheduleTimer), this.isShown && (g = this), t2 ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
    },
    $_computeDelay(e2) {
      const t2 = this.delay;
      return parseInt(t2 && t2[e2] || t2 || 0);
    },
    async $_applyShow(e2 = false) {
      clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e2, !this.isShown && (this.$_ensureTeleport(), await W(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([
        ...D(this.$_referenceNode),
        ...D(this.$_popperNode)
      ], "scroll", () => {
        this.$_computePosition();
      }));
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const t2 = this.$_referenceNode.getBoundingClientRect(), o2 = this.$_popperNode.querySelector(".v-popper__wrapper"), i3 = o2.parentNode.getBoundingClientRect(), s2 = t2.x + t2.width / 2 - (i3.left + o2.offsetLeft), r2 = t2.y + t2.height / 2 - (i3.top + o2.offsetTop);
        this.result.transformOrigin = `${s2}px ${r2}px`;
      }
      this.isShown = true, this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const e2 = this.showGroup;
      if (e2) {
        let t2;
        for (let o2 = 0; o2 < d.length; o2++)
          t2 = d[o2], t2.showGroup !== e2 && (t2.hide(), t2.$emit("close-group"));
      }
      d.push(this), document.body.classList.add("v-popper--some-open");
      for (const t2 of oe(this.theme))
        pe(t2).push(this), document.body.classList.add(`v-popper--some-open--${t2}`);
      this.$emit("apply-show"), this.classes.showFrom = true, this.classes.showTo = false, this.classes.hideFrom = false, this.classes.hideTo = false, await W(), this.classes.showFrom = false, this.classes.showTo = true, this.noAutoFocus || this.$_popperNode.focus();
    },
    async $_applyHide(e2 = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true, this.$_hideInProgress = false;
        return;
      }
      if (clearTimeout(this.$_scheduleTimer), !this.isShown)
        return;
      this.skipTransition = e2, ne(d, this), d.length === 0 && document.body.classList.remove("v-popper--some-open");
      for (const o2 of oe(this.theme)) {
        const i3 = pe(o2);
        ne(i3, this), i3.length === 0 && document.body.classList.remove(`v-popper--some-open--${o2}`);
      }
      g === this && (g = null), this.isShown = false, this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      }), clearTimeout(this.$_disposeTimer);
      const t2 = this.disposeTimeout;
      t2 !== null && (this.$_disposeTimer = setTimeout(() => {
        this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = false);
      }, t2)), this.$_removeEventListeners("scroll"), this.$emit("apply-hide"), this.classes.showFrom = false, this.classes.showTo = false, this.classes.hideFrom = true, this.classes.hideTo = false, await W(), this.classes.hideFrom = false, this.classes.hideTo = true;
    },
    $_autoShowHide() {
      this.shown ? this.show() : this.hide();
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let e2 = this.container;
      if (typeof e2 == "string" ? e2 = window.document.querySelector(e2) : e2 === false && (e2 = this.$_targetNodes[0].parentNode), !e2)
        throw new Error("No container for popover: " + this.container);
      e2.appendChild(this.$_popperNode), this.isMounted = true;
    },
    $_addEventListeners() {
      const e2 = (o2) => {
        this.isShown && !this.$_hideInProgress || (o2.usedByTooltip = true, !this.$_preventShow && this.show({ event: o2 }));
      };
      this.$_registerTriggerListeners(this.$_targetNodes, ie, this.triggers, this.showTriggers, e2), this.$_registerTriggerListeners([this.$_popperNode], ie, this.popperTriggers, this.popperShowTriggers, e2);
      const t2 = (o2) => {
        o2.usedByTooltip || this.hide({ event: o2 });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, se, this.triggers, this.hideTriggers, t2), this.$_registerTriggerListeners([this.$_popperNode], se, this.popperTriggers, this.popperHideTriggers, t2);
    },
    $_registerEventListeners(e2, t2, o2) {
      this.$_events.push({ targetNodes: e2, eventType: t2, handler: o2 }), e2.forEach((i3) => i3.addEventListener(t2, o2, _ ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(e2, t2, o2, i3, s2) {
      let r2 = o2;
      i3 != null && (r2 = typeof i3 == "function" ? i3(r2) : i3), r2.forEach((p2) => {
        const a2 = t2[p2];
        a2 && this.$_registerEventListeners(e2, a2, s2);
      });
    },
    $_removeEventListeners(e2) {
      const t2 = [];
      this.$_events.forEach((o2) => {
        const { targetNodes: i3, eventType: s2, handler: r2 } = o2;
        !e2 || e2 === s2 ? i3.forEach((p2) => p2.removeEventListener(s2, r2)) : t2.push(o2);
      }), this.$_events = t2;
    },
    $_refreshListeners() {
      this.$_isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
    },
    $_handleGlobalClose(e2, t2 = false) {
      this.$_showFrameLocked || (this.hide({ event: e2 }), e2.closePopover ? this.$emit("close-directive") : this.$emit("auto-hide"), t2 && (this.$_preventShow = true, setTimeout(() => {
        this.$_preventShow = false;
      }, 300)));
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(e2, t2) {
      for (const o2 of this.$_targetNodes) {
        const i3 = o2.getAttribute(e2);
        i3 && (o2.removeAttribute(e2), o2.setAttribute(t2, i3));
      }
    },
    $_applyAttrsToTarget(e2) {
      for (const t2 of this.$_targetNodes)
        for (const o2 in e2) {
          const i3 = e2[o2];
          i3 == null ? t2.removeAttribute(o2) : t2.setAttribute(o2, i3);
        }
    },
    $_updateParentShownChildren(e2) {
      let t2 = this.parentPopper;
      for (; t2; )
        e2 ? t2.shownChildren.add(this.randomId) : (t2.shownChildren.delete(this.randomId), t2.$_pendingHide && t2.hide()), t2 = t2.parentPopper;
    },
    $_isAimingPopper() {
      const e2 = this.$_referenceNode.getBoundingClientRect();
      if (v2 >= e2.left && v2 <= e2.right && y2 >= e2.top && y2 <= e2.bottom) {
        const t2 = this.$_popperNode.getBoundingClientRect(), o2 = v2 - f, i3 = y2 - m, r2 = t2.left + t2.width / 2 - f + (t2.top + t2.height / 2) - m + t2.width + t2.height, p2 = f + o2 * r2, a2 = m + i3 * r2;
        return S(f, m, p2, a2, t2.left, t2.top, t2.left, t2.bottom) || // Left edge
        S(f, m, p2, a2, t2.left, t2.top, t2.right, t2.top) || // Top edge
        S(f, m, p2, a2, t2.right, t2.top, t2.right, t2.bottom) || // Right edge
        S(f, m, p2, a2, t2.left, t2.bottom, t2.right, t2.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
typeof document < "u" && typeof window < "u" && (me ? (document.addEventListener("touchstart", ae, _ ? {
  passive: true,
  capture: true
} : true), document.addEventListener("touchend", Ze, _ ? {
  passive: true,
  capture: true
} : true)) : (window.addEventListener("mousedown", ae, true), window.addEventListener("click", Qe, true)), window.addEventListener("resize", ot));
function ae(e2) {
  for (let t2 = 0; t2 < d.length; t2++) {
    const o2 = d[t2];
    try {
      const i3 = o2.popperNode();
      o2.$_mouseDownContains = i3.contains(e2.target);
    } catch {
    }
  }
}
function Qe(e2) {
  $e(e2);
}
function Ze(e2) {
  $e(e2, true);
}
function $e(e2, t2 = false) {
  const o2 = {};
  for (let i3 = d.length - 1; i3 >= 0; i3--) {
    const s2 = d[i3];
    try {
      const r2 = s2.$_containsGlobalTarget = et2(s2, e2);
      s2.$_pendingHide = false, requestAnimationFrame(() => {
        if (s2.$_pendingHide = false, !o2[s2.randomId] && de(s2, r2, e2)) {
          if (s2.$_handleGlobalClose(e2, t2), !e2.closeAllPopover && e2.closePopover && r2) {
            let a2 = s2.parentPopper;
            for (; a2; )
              o2[a2.randomId] = true, a2 = a2.parentPopper;
            return;
          }
          let p2 = s2.parentPopper;
          for (; p2 && de(p2, p2.$_containsGlobalTarget, e2); ) {
            p2.$_handleGlobalClose(e2, t2);
            p2 = p2.parentPopper;
          }
        }
      });
    } catch {
    }
  }
}
function et2(e2, t2) {
  const o2 = e2.popperNode();
  return e2.$_mouseDownContains || o2.contains(t2.target);
}
function de(e2, t2, o2) {
  return o2.closeAllPopover || o2.closePopover && t2 || tt(e2, o2) && !t2;
}
function tt(e2, t2) {
  if (typeof e2.autoHide == "function") {
    const o2 = e2.autoHide(t2);
    return e2.lastAutoHide = o2, o2;
  }
  return e2.autoHide;
}
function ot(e2) {
  for (let t2 = 0; t2 < d.length; t2++)
    d[t2].$_computePosition(e2);
}
let f = 0, m = 0, v2 = 0, y2 = 0;
typeof window < "u" && window.addEventListener("mousemove", (e2) => {
  f = v2, m = y2, v2 = e2.clientX, y2 = e2.clientY;
}, _ ? {
  passive: true
} : void 0);
function S(e2, t2, o2, i3, s2, r2, p2, a2) {
  const l2 = ((p2 - s2) * (t2 - r2) - (a2 - r2) * (e2 - s2)) / ((a2 - r2) * (o2 - e2) - (p2 - s2) * (i3 - t2)), h2 = ((o2 - e2) * (t2 - r2) - (i3 - t2) * (e2 - s2)) / ((a2 - r2) * (o2 - e2) - (p2 - s2) * (i3 - t2));
  return l2 >= 0 && l2 <= 1 && h2 >= 0 && h2 <= 1;
}
const it = {
  extends: K()
}, k = (e2, t2) => {
  const o2 = e2.__vccOpts || e2;
  for (const [i3, s2] of t2)
    o2[i3] = s2;
  return o2;
};
function st(e2, t2, o2, i3, s2, r2) {
  return openBlock(), createElementBlock("div", {
    ref: "reference",
    class: normalizeClass(["v-popper", {
      "v-popper--shown": e2.slotData.isShown
    }])
  }, [
    renderSlot(e2.$slots, "default", normalizeProps(guardReactiveProps(e2.slotData)))
  ], 2);
}
const nt = /* @__PURE__ */ k(it, [["render", st]]);
function rt() {
  var e2 = window.navigator.userAgent, t2 = e2.indexOf("MSIE ");
  if (t2 > 0)
    return parseInt(e2.substring(t2 + 5, e2.indexOf(".", t2)), 10);
  var o2 = e2.indexOf("Trident/");
  if (o2 > 0) {
    var i3 = e2.indexOf("rv:");
    return parseInt(e2.substring(i3 + 3, e2.indexOf(".", i3)), 10);
  }
  var s2 = e2.indexOf("Edge/");
  return s2 > 0 ? parseInt(e2.substring(s2 + 5, e2.indexOf(".", s2)), 10) : -1;
}
let z;
function U() {
  U.init || (U.init = true, z = rt() !== -1);
}
var E = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    U(), nextTick(() => {
      this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
    });
    const e2 = document.createElement("object");
    this._resizeObject = e2, e2.setAttribute("aria-hidden", "true"), e2.setAttribute("tabindex", -1), e2.onload = this.addResizeHandlers, e2.type = "text/html", z && this.$el.appendChild(e2), e2.data = "about:blank", z || this.$el.appendChild(e2);
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify();
    },
    removeResizeHandlers() {
      this._resizeObject && this._resizeObject.onload && (!z && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
    }
  }
};
const pt = /* @__PURE__ */ withScopeId("data-v-b329ee4c");
pushScopeId("data-v-b329ee4c");
const at = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const dt = /* @__PURE__ */ pt((e2, t2, o2, i3, s2, r2) => (openBlock(), createBlock("div", at)));
E.render = dt;
E.__scopeId = "data-v-b329ee4c";
E.__file = "src/components/ResizeObserver.vue";
const J = (e2 = "theme") => ({
  computed: {
    themeClass() {
      return Je(this[e2]);
    }
  }
}), ht = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: E
  },
  mixins: [
    J()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(e2) {
      return e2 != null && !isNaN(e2) ? `${e2}px` : null;
    }
  }
});
const lt = ["id", "aria-hidden", "tabindex", "data-popper-placement"], ut = {
  ref: "inner",
  class: "v-popper__inner"
}, ct = /* @__PURE__ */ createElementVNode("div", { class: "v-popper__arrow-outer" }, null, -1), ft = /* @__PURE__ */ createElementVNode("div", { class: "v-popper__arrow-inner" }, null, -1), mt = [
  ct,
  ft
];
function gt(e2, t2, o2, i3, s2, r2) {
  const p2 = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: e2.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      e2.themeClass,
      e2.classes.popperClass,
      {
        "v-popper__popper--shown": e2.shown,
        "v-popper__popper--hidden": !e2.shown,
        "v-popper__popper--show-from": e2.classes.showFrom,
        "v-popper__popper--show-to": e2.classes.showTo,
        "v-popper__popper--hide-from": e2.classes.hideFrom,
        "v-popper__popper--hide-to": e2.classes.hideTo,
        "v-popper__popper--skip-transition": e2.skipTransition,
        "v-popper__popper--arrow-overflow": e2.result && e2.result.arrow.overflow,
        "v-popper__popper--no-positioning": !e2.result
      }
    ]]),
    style: normalizeStyle(e2.result ? {
      position: e2.result.strategy,
      transform: `translate3d(${Math.round(e2.result.x)}px,${Math.round(e2.result.y)}px,0)`
    } : void 0),
    "aria-hidden": e2.shown ? "false" : "true",
    tabindex: e2.autoHide ? 0 : void 0,
    "data-popper-placement": e2.result ? e2.result.placement : void 0,
    onKeyup: t2[2] || (t2[2] = withKeys((a2) => e2.autoHide && e2.$emit("hide"), ["esc"]))
  }, [
    createElementVNode("div", {
      class: "v-popper__backdrop",
      onClick: t2[0] || (t2[0] = (a2) => e2.autoHide && e2.$emit("hide"))
    }),
    createElementVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(e2.result ? {
        transformOrigin: e2.result.transformOrigin
      } : void 0)
    }, [
      createElementVNode("div", ut, [
        e2.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("div", null, [
            renderSlot(e2.$slots, "default")
          ]),
          e2.handleResize ? (openBlock(), createBlock(p2, {
            key: 0,
            onNotify: t2[1] || (t2[1] = (a2) => e2.$emit("resize", a2))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createElementVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(e2.result ? {
          left: e2.toPx(e2.result.arrow.x),
          top: e2.toPx(e2.result.arrow.y)
        } : void 0)
      }, mt, 4)
    ], 4)
  ], 46, lt);
}
const Q = /* @__PURE__ */ k(ht, [["render", gt]]), Z = {
  methods: {
    show(...e2) {
      return this.$refs.popper.show(...e2);
    },
    hide(...e2) {
      return this.$refs.popper.hide(...e2);
    },
    dispose(...e2) {
      return this.$refs.popper.dispose(...e2);
    },
    onResize(...e2) {
      return this.$refs.popper.onResize(...e2);
    }
  }
}, $t = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: nt,
    PopperContent: Q
  },
  mixins: [
    Z,
    J("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      return this.theme ?? this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$el.children).filter((e2) => e2 !== this.$refs.popperContent.$el);
    }
  }
});
function _t(e2, t2, o2, i3, s2, r2) {
  const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
  return openBlock(), createBlock(a2, {
    ref: "popper",
    theme: e2.finalTheme,
    "target-nodes": e2.getTargetNodes,
    "popper-node": () => e2.$refs.popperContent.$el,
    class: normalizeClass([
      e2.themeClass
    ])
  }, {
    default: withCtx(({
      popperId: l2,
      isShown: h2,
      shouldMountContent: B2,
      skipTransition: D2,
      autoHide: I2,
      show: R2,
      hide: w2,
      handleResize: F2,
      onResize: V2,
      classes: j2,
      result: Oe
    }) => [
      renderSlot(e2.$slots, "default", {
        shown: h2,
        show: R2,
        hide: w2
      }),
      createVNode(p2, {
        ref: "popperContent",
        "popper-id": l2,
        theme: e2.finalTheme,
        shown: h2,
        mounted: B2,
        "skip-transition": D2,
        "auto-hide": I2,
        "handle-resize": F2,
        classes: j2,
        result: Oe,
        onHide: w2,
        onResize: V2
      }, {
        default: withCtx(() => [
          renderSlot(e2.$slots, "popper", {
            shown: h2,
            hide: w2
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 8, ["theme", "target-nodes", "popper-node", "class"]);
}
const L = /* @__PURE__ */ k($t, [["render", _t]]), _e = {
  ...L,
  name: "VDropdown",
  vPopperTheme: "dropdown"
};
const we = {
  ...L,
  name: "VMenu",
  vPopperTheme: "menu"
}, ve = {
  ...L,
  name: "VTooltip",
  vPopperTheme: "tooltip"
};
const wt = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: K(),
    PopperContent: Q
  },
  mixins: [
    Z
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (e2) => b(e2.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (e2) => b(e2.theme, "loadingContent")
    },
    targetNodes: {
      type: Function,
      required: true
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content == "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick(), this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(e2) {
      if (typeof this.content == "function" && this.$_isShown && (e2 || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null, this.$_loading = true;
        const t2 = ++this.$_fetchId, o2 = this.content(this);
        o2.then ? o2.then((i3) => this.onResult(t2, i3)) : this.onResult(t2, o2);
      }
    },
    onResult(e2, t2) {
      e2 === this.$_fetchId && (this.$_loading = false, this.asyncContent = t2);
    },
    onShow() {
      this.$_isShown = true, this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
}), vt = ["innerHTML"], yt = ["textContent"];
function Pt(e2, t2, o2, i3, s2, r2) {
  const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
  return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e2.$attrs, {
    theme: e2.theme,
    "target-nodes": e2.targetNodes,
    "popper-node": () => e2.$refs.popperContent.$el,
    onApplyShow: e2.onShow,
    onApplyHide: e2.onHide
  }), {
    default: withCtx(({
      popperId: l2,
      isShown: h2,
      shouldMountContent: B2,
      skipTransition: D2,
      autoHide: I2,
      hide: R2,
      handleResize: w2,
      onResize: F2,
      classes: V2,
      result: j2
    }) => [
      createVNode(p2, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": e2.loading
        }),
        "popper-id": l2,
        theme: e2.theme,
        shown: h2,
        mounted: B2,
        "skip-transition": D2,
        "auto-hide": I2,
        "handle-resize": w2,
        classes: V2,
        result: j2,
        onHide: R2,
        onResize: F2
      }, {
        default: withCtx(() => [
          e2.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: e2.finalContent
          }, null, 8, vt)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(e2.finalContent)
          }, null, 8, yt))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
}
const ye = /* @__PURE__ */ k(wt, [["render", Pt]]), Pe = "v-popper--has-tooltip";
function Tt(e2, t2) {
  let o2 = e2.placement;
  if (!o2 && t2)
    for (const i3 of ge)
      t2[i3] && (o2 = i3);
  return o2 || (o2 = b(e2.theme || "tooltip", "placement")), o2;
}
function Te(e2, t2, o2) {
  let i3;
  const s2 = typeof t2;
  return s2 === "string" ? i3 = { content: t2 } : t2 && s2 === "object" ? i3 = t2 : i3 = { content: false }, i3.placement = Tt(i3, o2), i3.targetNodes = () => [e2], i3.referenceNode = () => e2, i3;
}
let q, C, bt = 0;
function Ct() {
  if (q)
    return;
  C = ref([]), q = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives: C
      };
    },
    render() {
      return this.directives.map((t2) => h$5(ye, {
        ...t2.options,
        shown: t2.shown || t2.options.shown,
        key: t2.id
      }));
    },
    devtools: {
      hide: true
    }
  });
  const e2 = document.createElement("div");
  document.body.appendChild(e2), q.mount(e2);
}
function St(e2, t2, o2) {
  Ct();
  const i3 = ref(Te(e2, t2, o2)), s2 = ref(false), r2 = {
    id: bt++,
    options: i3,
    shown: s2
  };
  return C.value.push(r2), e2.classList && e2.classList.add(Pe), e2.$_popper = {
    options: i3,
    item: r2,
    show() {
      s2.value = true;
    },
    hide() {
      s2.value = false;
    }
  };
}
function be(e2) {
  if (e2.$_popper) {
    const t2 = C.value.indexOf(e2.$_popper.item);
    t2 !== -1 && C.value.splice(t2, 1), delete e2.$_popper, delete e2.$_popperOldShown, delete e2.$_popperMountTarget;
  }
  e2.classList && e2.classList.remove(Pe);
}
function he(e2, { value: t2, modifiers: o2 }) {
  const i3 = Te(e2, t2, o2);
  if (!i3.content || b(i3.theme || "tooltip", "disabled"))
    be(e2);
  else {
    let s2;
    e2.$_popper ? (s2 = e2.$_popper, s2.options.value = i3) : s2 = St(e2, t2, o2), typeof t2.shown < "u" && t2.shown !== e2.$_popperOldShown && (e2.$_popperOldShown = t2.shown, t2.shown ? s2.show() : s2.hide());
  }
}
const Ce = {
  beforeMount: he,
  updated: he,
  beforeUnmount(e2) {
    be(e2);
  }
};
function le(e2) {
  e2.addEventListener("click", Se), e2.addEventListener("touchstart", ze, _ ? {
    passive: true
  } : false);
}
function ue(e2) {
  e2.removeEventListener("click", Se), e2.removeEventListener("touchstart", ze), e2.removeEventListener("touchend", Ne), e2.removeEventListener("touchcancel", Ae);
}
function Se(e2) {
  const t2 = e2.currentTarget;
  e2.closePopover = !t2.$_vclosepopover_touch, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
}
function ze(e2) {
  if (e2.changedTouches.length === 1) {
    const t2 = e2.currentTarget;
    t2.$_vclosepopover_touch = true;
    const o2 = e2.changedTouches[0];
    t2.$_vclosepopover_touchPoint = o2, t2.addEventListener("touchend", Ne), t2.addEventListener("touchcancel", Ae);
  }
}
function Ne(e2) {
  const t2 = e2.currentTarget;
  if (t2.$_vclosepopover_touch = false, e2.changedTouches.length === 1) {
    const o2 = e2.changedTouches[0], i3 = t2.$_vclosepopover_touchPoint;
    e2.closePopover = Math.abs(o2.screenY - i3.screenY) < 20 && Math.abs(o2.screenX - i3.screenX) < 20, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
  }
}
function Ae(e2) {
  const t2 = e2.currentTarget;
  t2.$_vclosepopover_touch = false;
}
const He = {
  beforeMount(e2, { value: t2, modifiers: o2 }) {
    e2.$_closePopoverModifiers = o2, (typeof t2 > "u" || t2) && le(e2);
  },
  updated(e2, { value: t2, oldValue: o2, modifiers: i3 }) {
    e2.$_closePopoverModifiers = i3, t2 !== o2 && (typeof t2 > "u" || t2 ? le(e2) : ue(e2));
  },
  beforeUnmount(e2) {
    ue(e2);
  }
};
function zt(e2, t2 = {}) {
  e2.$_vTooltipInstalled || (e2.$_vTooltipInstalled = true, fe(u2, t2), e2.directive("tooltip", Ce), e2.directive("close-popper", He), e2.component("VTooltip", ve), e2.component("VDropdown", _e), e2.component("VMenu", we));
}
const xt = {
  // eslint-disable-next-line no-undef
  version: "2.0.0-beta.24",
  install: zt,
  options: u2
};
const style = "";
const clientConfig19 = defineClientConfig({
  enhance({
    app,
    router,
    siteData: siteData2
  }) {
    app.component("MyBanner", MyBanner);
    app.component("MidBanner", MidBanner);
    app.component("GDialog", GDialog);
    app.use(plugin, {});
    app.use(Tooltip);
    app.use(xt);
    app.config.globalProperties.$api = serverApi;
    app.config.globalProperties.$msg = Message;
    addPhotoRoutes(router);
  },
  layouts: {
    Album: Layout$1,
    Layout,
    Timeline
  },
  setup() {
    const {
      proxy: proxy2
    } = getCurrentInstance();
    const msg = () => proxy2 == null ? void 0 : proxy2.$msg({
      type: "info",
      text: "登录已过期，请重新登录哟(⊙_⊙)~"
    });
    onMounted(() => {
      var _a3;
      window.addEventListener("autologout", msg);
      (_a3 = document.querySelector('.navbar-links a[aria-label="QQ空间"] .xicon-container')) == null ? void 0 : _a3.insertAdjacentHTML("afterbegin", qzoneSvg);
    });
    onUnmounted(() => {
      window.removeEventListener("autologout", msg);
    });
  }
});
const clientConfigs = [clientConfig0, clientConfig1, clientConfig2, clientConfig3, clientConfig4, clientConfig5, clientConfig6, clientConfig7, clientConfig8, clientConfig9, clientConfig10, clientConfig11, clientConfig12, clientConfig13, M$3, clientConfig15, clientConfig16, clientConfig17, clientConfig18, clientConfig19, clientConfig20];
const pagesRoutes = [["v-01560935", "/timeline/", {
  "title": ""
}, []], ["v-e1e3da16", "/posts/", {
  "title": ""
}, []], ["v-53355ebb", "/friendship-link/", {
  "title": ""
}, []], ["v-03d52fd3", "/posts/1/", {
  "title": ""
}, []], ["v-8daa1a0e", "/", {
  "title": ""
}, ["/home.html", "/home.md"]], ["v-33291fb2", "/albums/", {
  "title": "画册"
}, ["/albums/README.md"]], ["v-71cbb60e", "/blogs/blogtest.html", {
  "title": "音乐播放器测试"
}, [":md"]], ["v-4cab04d2", "/blogs/shuoshuotest.html", {
  "title": "9月8日"
}, [":md"]], ["v-926a34b0", "/albums/test_album_1/psb.png.html", {
  "title": "梯田"
}, [":md"]], ["v-1f71f6ee", "/albums/test_album_1/", {
  "title": "测试相册1"
}, ["/albums/test_album_1/README.md"]], ["v-1f71f6b0", "/albums/test_album_2/", {
  "title": "测试相册2"
}, ["/albums/test_album_2/README.md"]], ["v-1d051c9f", "/docs/tech/flowers.html", {
  "title": "前端实现 - 木棉花落"
}, [":md"]], ["v-dc8a1012", "/docs/tech/homebg.html", {
  "title": "前端实现 - 分层背景"
}, [":md"]], ["v-06ec5813", "/docs/test/articletest.html", {
  "title": "文章测试"
}, [":md"]], ["v-23390c64", "/docs/test/mdtest.html", {
  "title": "markdown测试"
}, [":md"]], ["v-3706649a", "/404.html", {
  "title": ""
}, []]];
var Vuepress = defineComponent({
  name: "Vuepress",
  setup() {
    const layout = usePageLayout();
    return () => h$5(layout.value);
  }
});
var createRoutes = () => pagesRoutes.reduce((result, [name2, path, meta, redirects]) => {
  result.push({
    name: name2,
    path,
    component: Vuepress,
    meta
  }, {
    path: path.endsWith("/") ? (
      // redirect from `/index.html` to `/`
      path + "index.html"
    ) : (
      // redirect from `/foo` to `/foo.html`
      path.substring(0, path.length - 5)
    ),
    redirect: path
  }, ...redirects.map((item) => ({
    path: item === ":md" ? (
      // redirect from `/foo.md` to `/foo.html`
      path.substring(0, path.length - 5) + ".md"
    ) : item,
    redirect: path
  })));
  return result;
}, [{
  name: "404",
  path: "/:catchAll(.*)",
  component: Vuepress
}]);
var historyCreator = createWebHistory;
var createVueRouter = () => {
  const router = createRouter({
    // it might be an issue of vue-router that have to remove the ending slash
    history: historyCreator(removeEndingSlash("/")),
    routes: createRoutes(),
    scrollBehavior: (to, from, savedPosition) => {
      if (savedPosition)
        return savedPosition;
      if (to.hash)
        return {
          el: to.hash
        };
      return {
        top: 0
      };
    }
  });
  router.beforeResolve(async (to, from) => {
    var _a3;
    if (to.path !== from.path || from === START_LOCATION) {
      [to.meta._data] = await Promise.all([resolvers.resolvePageData(to.name), (_a3 = pagesComponents[to.name]) == null ? void 0 : _a3.__asyncLoader()]);
    }
  });
  return router;
};
var setupGlobalComponents = (app) => {
  app.component("ClientOnly", ClientOnly);
  app.component("Content", Content);
};
var setupGlobalComputed = (app, router, clientConfigs2) => {
  const routePath = computedEager(() => router.currentRoute.value.path);
  const routeLocale = computedEager(() => resolvers.resolveRouteLocale(siteData$2.value.locales, routePath.value));
  const pageData = computedWithControl(routePath, () => router.currentRoute.value.meta._data);
  const layouts2 = computed(() => resolvers.resolveLayouts(clientConfigs2));
  const siteLocaleData = computed(() => resolvers.resolveSiteLocaleData(siteData$2.value, routeLocale.value));
  const pageFrontmatter = computed(() => resolvers.resolvePageFrontmatter(pageData.value));
  const pageHeadTitle = computed(() => resolvers.resolvePageHeadTitle(pageData.value, siteLocaleData.value));
  const pageHead = computed(() => resolvers.resolvePageHead(pageHeadTitle.value, pageFrontmatter.value, siteLocaleData.value));
  const pageLang = computed(() => resolvers.resolvePageLang(pageData.value, siteLocaleData.value));
  const pageLayout = computed(() => resolvers.resolvePageLayout(pageData.value, layouts2.value));
  app.provide(layoutsSymbol, layouts2);
  app.provide(pageDataSymbol, pageData);
  app.provide(pageFrontmatterSymbol, pageFrontmatter);
  app.provide(pageHeadTitleSymbol, pageHeadTitle);
  app.provide(pageHeadSymbol, pageHead);
  app.provide(pageLangSymbol, pageLang);
  app.provide(pageLayoutSymbol, pageLayout);
  app.provide(routeLocaleSymbol, routeLocale);
  app.provide(siteLocaleDataSymbol, siteLocaleData);
  Object.defineProperties(app.config.globalProperties, {
    $frontmatter: {
      get: () => pageFrontmatter.value
    },
    $head: {
      get: () => pageHead.value
    },
    $headTitle: {
      get: () => pageHeadTitle.value
    },
    $lang: {
      get: () => pageLang.value
    },
    $page: {
      get: () => pageData.value
    },
    $routeLocale: {
      get: () => routeLocale.value
    },
    $site: {
      get: () => siteData$2.value
    },
    $siteLocale: {
      get: () => siteLocaleData.value
    },
    $withBase: {
      get: () => withBase
    }
  });
  return {
    layouts: layouts2,
    pageData,
    pageFrontmatter,
    pageHead,
    pageHeadTitle,
    pageLang,
    pageLayout,
    routeLocale,
    siteData: siteData$2,
    siteLocaleData
  };
};
var setupUpdateHead = () => {
  const head = usePageHead();
  const lang = usePageLang();
  const headTags = ref([]);
  const loadHead = () => {
    head.value.forEach((item) => {
      const tag = queryHeadTag(item);
      if (tag) {
        headTags.value.push(tag);
      }
    });
  };
  const updateHead = () => {
    document.documentElement.lang = lang.value;
    headTags.value.forEach((item) => {
      if (item.parentNode === document.head) {
        document.head.removeChild(item);
      }
    });
    headTags.value.splice(0, headTags.value.length);
    head.value.forEach((item) => {
      const tag = createHeadTag(item);
      if (tag !== null) {
        document.head.appendChild(tag);
        headTags.value.push(tag);
      }
    });
  };
  provide(updateHeadSymbol, updateHead);
  onMounted(() => {
    loadHead();
    updateHead();
    watch(() => head.value, updateHead);
  });
};
var queryHeadTag = ([tagName, attrs, content = ""]) => {
  const attrsSelector = Object.entries(attrs).map(([key, value]) => {
    if (isString$1(value)) {
      return `[${key}=${JSON.stringify(value)}]`;
    }
    if (value === true) {
      return `[${key}]`;
    }
    return "";
  }).join("");
  const selector = `head > ${tagName}${attrsSelector}`;
  const tags = Array.from(document.querySelectorAll(selector));
  const matchedTag = tags.find((item) => item.innerText === content);
  return matchedTag || null;
};
var createHeadTag = ([tagName, attrs, content]) => {
  if (!isString$1(tagName)) {
    return null;
  }
  const tag = document.createElement(tagName);
  if (isPlainObject$1(attrs)) {
    Object.entries(attrs).forEach(([key, value]) => {
      if (isString$1(value)) {
        tag.setAttribute(key, value);
      } else if (value === true) {
        tag.setAttribute(key, "");
      }
    });
  }
  if (isString$1(content)) {
    tag.appendChild(document.createTextNode(content));
  }
  return tag;
};
var appCreator = createSSRApp;
var createVueApp = async () => {
  var _a3;
  const app = appCreator({
    name: "VuepressApp",
    setup() {
      var _a4;
      setupUpdateHead();
      for (const clientConfig of clientConfigs) {
        (_a4 = clientConfig.setup) == null ? void 0 : _a4.call(clientConfig);
      }
      return () => [h$5(RouterView), ...clientConfigs.flatMap(({
        rootComponents = []
      }) => rootComponents.map((component) => h$5(component)))];
    }
  });
  const router = createVueRouter();
  setupGlobalComponents(app);
  const globalComputed = setupGlobalComputed(app, router, clientConfigs);
  {
    const {
      setupDevtools
    } = await __vitePreload(() => import("./setupDevtools-X4YFRK4B-be2eeaae.js"), true ? [] : void 0);
    setupDevtools(app, globalComputed);
  }
  for (const clientConfig of clientConfigs) {
    await ((_a3 = clientConfig.enhance) == null ? void 0 : _a3.call(clientConfig, {
      app,
      router,
      siteData: siteData$2
    }));
  }
  app.use(router);
  return {
    app,
    router
  };
};
{
  createVueApp().then(({
    app,
    router
  }) => {
    router.isReady().then(() => {
      app.mount("#app");
    });
  });
}
export {
  Api as A,
  C$5 as C,
  _export_sfc$1 as _,
  __vitePreload as a,
  commonjsRequire as c,
  createVueApp,
  getAugmentedNamespace as g,
  r$4 as r,
  setupDevtoolsPlugin as s,
  v$5 as v
};
